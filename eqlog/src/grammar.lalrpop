use crate::direct_ast::*;
use crate::indirect_ast;
use crate::signature::Signature;
use std::iter::once;
use crate::analysis::check_semantically;
use crate::unification::TermMap;
use convert_case::{Case, Casing};

grammar;

Id: String = { r"[A-Za-z][A-Za-z0-9'_]*" => <>.to_string(), }

SnakeCaseId: String = {
    <id: Id> => { 
        assert_eq!(id.to_case(Case::Snake), id, "Expected identifier in snake_case");
        id
    },
}

CamelCaseId: String = {
    <id: Id> => { 
        assert_eq!(id.to_case(Case::UpperCamel), id, "Expected identifier in CamelCase");
        id
    },
}

SortDecl: Sort = {
    <l: @L>  "Sort" <name: CamelCaseId> ";" <r: @R> => {
        Sort{name, location: Some(Location(l, r))}
    }
}

PredicateDecl: Predicate = {
    <l: @L> "Pred" <name: CamelCaseId> ":" <head: Id> <tail: ("*" <Id>)*> ";" <r: @R> => {
        Predicate {
            name,
            arity: once(head).chain(tail).collect(),
            location: Some(Location(l, r)),
        }
    },
}

FunctionDecl: Function = {
    <l: @L> "Func" <name: CamelCaseId> ":" <head_dom: (<Id>)?> <tail_dom: ("*" <Id>)*> "->" <cod: Id> ";" <r: @R> => {
        Function {
            name,
            dom: head_dom.into_iter().chain(tail_dom).collect(),
            cod,
            location: Some(Location(l, r)),
        }
    },
}

Application: (String, Vec<Term>) = {
    <operator: Id> "(" <head_arg: (<Term>)?> <tail_args: ("," <Term>)*> ")" => {
        let args: Vec<Term> = head_arg.into_iter().chain(tail_args).collect();
        (operator, args)
    }
}

Term: Term = {
    <l: @L> <var: SnakeCaseId> <r: @R> => Term {
        data: TermData::Variable(var),
        location: Some(Location(l, r)),
    },
    <l: @L> "_" <r: @R> => Term {
        data: TermData::Wildcard,
        location: Some(Location(l, r)),
    },
    <l: @L> <app: Application> <r: @R> => Term {
        data: TermData::Application(app.0, app.1),
        location: Some(Location(l, r)),
    },
}

Atom: Atom = {
    <l: @L> <lhs: Term> "=" <rhs: Term> <r: @R> => Atom {
        data: AtomData::Equal(lhs, rhs),
        location: Some(Location(l, r)),
    },
    <l: @L> <t: Term> "!" <r: @R> => Atom {
        data: AtomData::Defined(t, None),
        location: Some(Location(l, r)),
    },
    <l: @L> <t: Term> "!" ":" <s: Id> <r: @R> => Atom {
        data: AtomData::Defined(t, Some(s)),
        location: Some(Location(l, r)),
    },
    <l: @L> <app: Application> <r: @R> => Atom {
        data: AtomData::Predicate(app.0, app.1),
        location: Some(Location(l, r)),
    },
}

Formula: Formula = {
    <l: @L> <head_atom: (<Atom>)?> <tail_atoms : ("&" <Atom>)*> <r: @R> => {
        Formula {
            atoms: head_atom.into_iter().chain(tail_atoms).collect(),
            location: Some(Location(l, r)),
        }
    }
}

pub Sequent: Sequent = {
    <premise: Formula> "=>" <conclusion: Formula> => Sequent::Implication(premise, conclusion),
    <from_l: @L> <from: Application> <from_r: @R> "~>" <to: Term> => {
        let from = Term {
            data: TermData::Application(from.0, from.1),
            location: Some(Location(from_l, from_r)),
        };
        Sequent::Reduction {
            premise: None,
            from,
            to,
        }
    },
    <premise: Formula> "=>" <from_l: @L> <from: Application> <from_r: @R> "~>" <to: Term> => {
        let from = Term {
            data: TermData::Application(from.0, from.1),
            location: Some(Location(from_l, from_r)),
        };
        Sequent::Reduction {
            premise: Some(premise),
            from,
            to,
        }
    },
}

AxiomDecl: Axiom = {
    <l: @L> "Axiom" <sequent: Sequent> ";" <r: @R> => Axiom {
        sequent,
        location: Some(Location(l, r)),
    },
}

pub Theory: (Signature, Vec<(indirect_ast::Sequent, TermMap<String>)>) = {
    () => (Signature::new(), vec![]),
    <mut theory: Theory> <sort: SortDecl> => {
        let (ref mut sig, _) = &mut theory;
        sig.add_sort(sort);
        theory
    },
    <mut theory: Theory> <pred: PredicateDecl> => {
        let (ref mut sig, _) = &mut theory;
        sig.add_predicate(pred);
        theory
    },
    <mut theory: Theory> <func: FunctionDecl> => {
        let (ref mut sig, _) = &mut theory;
        sig.add_function(func);
        theory
    },
    <mut theory: Theory> <ax: AxiomDecl> => {
        let (ref sig, ref mut axioms) = &mut theory;
        let indirect_seq = indirect_ast::Sequent::new(&ax.sequent);
        let sorts = check_semantically(&sig, &indirect_seq);
        axioms.push((indirect_seq, sorts));
        theory
    },
}
