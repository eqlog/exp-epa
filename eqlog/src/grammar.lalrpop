use crate::direct_ast::*;
use crate::indirect_ast;
use crate::signature::Signature;
use std::iter::once;
use crate::analysis::check_semantically;
use crate::unification::TermMap;

grammar;

Id: String = { r"[A-Za-z][A-Za-z0-9'_]*" => <>.to_string(), }

Sort: Sort = { <name: Id> => Sort(name) }

Predicate: Predicate = {
    <name: Id> ":" <head: Id> <tail: ("*" <Id>)*> => {
        Predicate{name, arity: once(head).chain(tail).collect()}
    },
}

Function: Function = {
    <name: Id> ":" <head_dom: (<Id>)?> <tail_dom: ("*" <Id>)*> "->" <cod: Id> => {
        Function {
            name,
            dom: head_dom.into_iter().chain(tail_dom).collect(),
            cod,
        }
    },
}

Application: (String, Vec<Term>) = {
    <operator: Id> "(" <head_arg: (<Term>)?> <tail_args: ("," <Term>)*> ")" => {
        let args: Vec<Term> = head_arg.into_iter().chain(tail_args).collect();
        (operator, args)
    }
}

Term: Term = {
    <var: Id> => Term::Variable(var),
    "_" => Term::Wildcard,
    <app: Application> => Term::Application(app.0, app.1),
}

Atom: Atom = {
    <lhs: Term> "=" <rhs: Term> => Atom::Equal(lhs, rhs),
    <t: Term> "!" => Atom::Defined(t, None),
    <t: Term> "!" ":" <s: Id> => Atom::Defined(t, Some(s)),
    <app: Application> => Atom::Predicate(app.0, app.1),
}

Formula: Formula = {
    <head_atom: (<Atom>)?> <tail_atoms : ("&" <Atom>)*> =>
        Formula(head_atom.into_iter().chain(tail_atoms).collect()),
}

Sequent: Sequent = {
    <premise: Formula> "=>" <conclusion: Formula> => Sequent::Implication(premise, conclusion),
    <app: Application> "~>" <to: Term> => Sequent::Reduction {
        premise: Formula(Vec::new()),
        from_function: app.0,
        from_args: app.1,
        to,
    },
    <premise: Formula> "=>" <app: Application> "~>" <to: Term> => Sequent::Reduction {
        premise,
        from_function: app.0,
        from_args: app.1,
        to,
    },
}

Declaration: Declaration = {
    "Sort" <sort: Sort> ";" => Declaration::Sort(sort),
    "Pred" <pred: Predicate> ";" => Declaration::Predicate(pred),
    "Func" <func: Function> ";" => Declaration::Function(func),
    "Axiom" <seq: Sequent> ";" => Declaration::Axiom(seq),
}

pub Theory: (Signature, Vec<(indirect_ast::Sequent, TermMap<String>)>) = {
    () => (Signature::new(), vec![]),
    <mut theory: Theory> <decl: Declaration> => {
        let (sig, axioms) = &mut theory;
        match decl {
            Declaration::Sort(sort) => sig.add_sort(sort),
            Declaration::Predicate(pred) => sig.add_predicate(pred),
            Declaration::Function(func) => sig.add_function(func),
            Declaration::Axiom(seq) => { 
                let indirect_seq = indirect_ast::Sequent::new(&seq);
                let sorts = check_semantically(&sig, &indirect_seq);
                axioms.push((indirect_seq, sorts));
            },
        };
        theory
    },
}
