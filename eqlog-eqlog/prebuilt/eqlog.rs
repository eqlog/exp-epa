// src-digest: C1AAEFC0545CEE12D5DD2DA123A9D831264595281FECBDA93D9323046F335CC3
use eqlog_runtime::tabled::{
    object::Segment, Alignment, Extract, Header, Modify, Style, Table, Tabled,
};
#[allow(unused)]
use eqlog_runtime::Unification;
#[allow(unused)]
use std::collections::{BTreeMap, BTreeSet};
use std::fmt;
use std::ops::Bound;

#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Ident(pub u32);
impl Into<u32> for Ident {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for Ident {
    fn from(x: u32) -> Self {
        Ident(x)
    }
}
impl fmt::Display for Ident {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct VirtIdent(pub u32);
impl Into<u32> for VirtIdent {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for VirtIdent {
    fn from(x: u32) -> Self {
        VirtIdent(x)
    }
}
impl fmt::Display for VirtIdent {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct TypeDeclNode(pub u32);
impl Into<u32> for TypeDeclNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for TypeDeclNode {
    fn from(x: u32) -> Self {
        TypeDeclNode(x)
    }
}
impl fmt::Display for TypeDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ArgDeclNode(pub u32);
impl Into<u32> for ArgDeclNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for ArgDeclNode {
    fn from(x: u32) -> Self {
        ArgDeclNode(x)
    }
}
impl fmt::Display for ArgDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ArgDeclListNode(pub u32);
impl Into<u32> for ArgDeclListNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for ArgDeclListNode {
    fn from(x: u32) -> Self {
        ArgDeclListNode(x)
    }
}
impl fmt::Display for ArgDeclListNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct PredDeclNode(pub u32);
impl Into<u32> for PredDeclNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for PredDeclNode {
    fn from(x: u32) -> Self {
        PredDeclNode(x)
    }
}
impl fmt::Display for PredDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct FuncDeclNode(pub u32);
impl Into<u32> for FuncDeclNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for FuncDeclNode {
    fn from(x: u32) -> Self {
        FuncDeclNode(x)
    }
}
impl fmt::Display for FuncDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct CtorDeclNode(pub u32);
impl Into<u32> for CtorDeclNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for CtorDeclNode {
    fn from(x: u32) -> Self {
        CtorDeclNode(x)
    }
}
impl fmt::Display for CtorDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct CtorDeclListNode(pub u32);
impl Into<u32> for CtorDeclListNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for CtorDeclListNode {
    fn from(x: u32) -> Self {
        CtorDeclListNode(x)
    }
}
impl fmt::Display for CtorDeclListNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct EnumDeclNode(pub u32);
impl Into<u32> for EnumDeclNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for EnumDeclNode {
    fn from(x: u32) -> Self {
        EnumDeclNode(x)
    }
}
impl fmt::Display for EnumDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct TermNode(pub u32);
impl Into<u32> for TermNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for TermNode {
    fn from(x: u32) -> Self {
        TermNode(x)
    }
}
impl fmt::Display for TermNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct TermListNode(pub u32);
impl Into<u32> for TermListNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for TermListNode {
    fn from(x: u32) -> Self {
        TermListNode(x)
    }
}
impl fmt::Display for TermListNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct OptTermNode(pub u32);
impl Into<u32> for OptTermNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for OptTermNode {
    fn from(x: u32) -> Self {
        OptTermNode(x)
    }
}
impl fmt::Display for OptTermNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct MatchCaseNode(pub u32);
impl Into<u32> for MatchCaseNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for MatchCaseNode {
    fn from(x: u32) -> Self {
        MatchCaseNode(x)
    }
}
impl fmt::Display for MatchCaseNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct StmtListNode(pub u32);
impl Into<u32> for StmtListNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for StmtListNode {
    fn from(x: u32) -> Self {
        StmtListNode(x)
    }
}
impl fmt::Display for StmtListNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct MatchCaseListNode(pub u32);
impl Into<u32> for MatchCaseListNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for MatchCaseListNode {
    fn from(x: u32) -> Self {
        MatchCaseListNode(x)
    }
}
impl fmt::Display for MatchCaseListNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct IfAtomNode(pub u32);
impl Into<u32> for IfAtomNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for IfAtomNode {
    fn from(x: u32) -> Self {
        IfAtomNode(x)
    }
}
impl fmt::Display for IfAtomNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ThenAtomNode(pub u32);
impl Into<u32> for ThenAtomNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for ThenAtomNode {
    fn from(x: u32) -> Self {
        ThenAtomNode(x)
    }
}
impl fmt::Display for ThenAtomNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct StmtNode(pub u32);
impl Into<u32> for StmtNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for StmtNode {
    fn from(x: u32) -> Self {
        StmtNode(x)
    }
}
impl fmt::Display for StmtNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct StmtBlockListNode(pub u32);
impl Into<u32> for StmtBlockListNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for StmtBlockListNode {
    fn from(x: u32) -> Self {
        StmtBlockListNode(x)
    }
}
impl fmt::Display for StmtBlockListNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct RuleDeclNode(pub u32);
impl Into<u32> for RuleDeclNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for RuleDeclNode {
    fn from(x: u32) -> Self {
        RuleDeclNode(x)
    }
}
impl fmt::Display for RuleDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct DeclNode(pub u32);
impl Into<u32> for DeclNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for DeclNode {
    fn from(x: u32) -> Self {
        DeclNode(x)
    }
}
impl fmt::Display for DeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct DeclListNode(pub u32);
impl Into<u32> for DeclListNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for DeclListNode {
    fn from(x: u32) -> Self {
        DeclListNode(x)
    }
}
impl fmt::Display for DeclListNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ModuleNode(pub u32);
impl Into<u32> for ModuleNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for ModuleNode {
    fn from(x: u32) -> Self {
        ModuleNode(x)
    }
}
impl fmt::Display for ModuleNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Loc(pub u32);
impl Into<u32> for Loc {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for Loc {
    fn from(x: u32) -> Self {
        Loc(x)
    }
}
impl fmt::Display for Loc {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct RuleDescendantNode(pub u32);
impl Into<u32> for RuleDescendantNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for RuleDescendantNode {
    fn from(x: u32) -> Self {
        RuleDescendantNode(x)
    }
}
impl fmt::Display for RuleDescendantNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Scope(pub u32);
impl Into<u32> for Scope {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for Scope {
    fn from(x: u32) -> Self {
        Scope(x)
    }
}
impl fmt::Display for Scope {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Type(pub u32);
impl Into<u32> for Type {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for Type {
    fn from(x: u32) -> Self {
        Type(x)
    }
}
impl fmt::Display for Type {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct TypeList(pub u32);
impl Into<u32> for TypeList {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for TypeList {
    fn from(x: u32) -> Self {
        TypeList(x)
    }
}
impl fmt::Display for TypeList {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Pred(pub u32);
impl Into<u32> for Pred {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for Pred {
    fn from(x: u32) -> Self {
        Pred(x)
    }
}
impl fmt::Display for Pred {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Func(pub u32);
impl Into<u32> for Func {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for Func {
    fn from(x: u32) -> Self {
        Func(x)
    }
}
impl fmt::Display for Func {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Rel(pub u32);
impl Into<u32> for Rel {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for Rel {
    fn from(x: u32) -> Self {
        Rel(x)
    }
}
impl fmt::Display for Rel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Structure(pub u32);
impl Into<u32> for Structure {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for Structure {
    fn from(x: u32) -> Self {
        Structure(x)
    }
}
impl fmt::Display for Structure {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct El(pub u32);
impl Into<u32> for El {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for El {
    fn from(x: u32) -> Self {
        El(x)
    }
}
impl fmt::Display for El {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ElList(pub u32);
impl Into<u32> for ElList {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for ElList {
    fn from(x: u32) -> Self {
        ElList(x)
    }
}
impl fmt::Display for ElList {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ElName(pub u32);
impl Into<u32> for ElName {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for ElName {
    fn from(x: u32) -> Self {
        ElName(x)
    }
}
impl fmt::Display for ElName {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Morphism(pub u32);
impl Into<u32> for Morphism {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for Morphism {
    fn from(x: u32) -> Self {
        Morphism(x)
    }
}
impl fmt::Display for Morphism {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct SymbolKind(pub u32);
impl Into<u32> for SymbolKind {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for SymbolKind {
    fn from(x: u32) -> Self {
        SymbolKind(x)
    }
}
impl fmt::Display for SymbolKind {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Nat(pub u32);
impl Into<u32> for Nat {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for Nat {
    fn from(x: u32) -> Self {
        Nat(x)
    }
}
impl fmt::Display for Nat {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub enum TypeListEnum {
    NilTypeList(),
    ConsTypeList(Type, TypeList),
    SnocTypeList(TypeList, Type),
}

#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub enum RelEnum {
    PredRel(Pred),
    FuncRel(Func),
}

#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub enum ElListEnum {
    NilElList(Structure),
    ConsElList(El, ElList),
    SnocElList(ElList, El),
}

#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Absurd();
#[derive(Clone, Hash, Debug)]
struct AbsurdTable {
    index_all: BTreeSet<()>,
    index_dirty: BTreeSet<()>,
}
impl AbsurdTable {
    #[allow(unused)]
    const WEIGHT: usize = 0;
    fn new() -> Self {
        Self {
            index_all: BTreeSet::new(),
            index_dirty: BTreeSet::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: Absurd) -> bool {
        if self.index_all.insert(Self::permute(t)) {
            self.index_dirty.insert(Self::permute(t));

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: Absurd) -> bool {
        self.index_all.contains(&Self::permute(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty.is_empty()
    }
    #[allow(unused)]
    fn permute(t: Absurd) -> () {
        ()
    }
    #[allow(unused)]
    fn permute_inverse(t: ()) -> Absurd {
        Absurd()
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = Absurd> {
        let min = ();
        let max = ();
        self.index_all
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = Absurd> {
        let min = ();
        let max = ();
        self.index_dirty
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse)
    }
}
impl fmt::Display for AbsurdTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("absurd"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeDecl(pub TypeDeclNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct TypeDeclTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_ident: BTreeMap<Ident, Vec<TypeDecl>>,
    element_index_type_decl_node: BTreeMap<TypeDeclNode, Vec<TypeDecl>>,
}
impl TypeDeclTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_ident: BTreeMap::new(),
            element_index_type_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TypeDecl) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_type_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TypeDecl) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: TypeDecl) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> TypeDecl {
        TypeDecl(TypeDeclNode::from(t.0), Ident::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: TypeDecl) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> TypeDecl {
        TypeDecl(TypeDeclNode::from(t.1), Ident::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TypeDecl> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TypeDecl> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TypeDeclNode) -> impl '_ + Iterator<Item = TypeDecl> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: TypeDeclNode, arg1: Ident) -> impl '_ + Iterator<Item = TypeDecl> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = TypeDecl> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<TypeDecl> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_type_decl_node(&mut self, tm: TypeDeclNode) -> Vec<TypeDecl> {
        let mut ts = match self.element_index_type_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for TypeDeclTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("type_decl"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgDeclNodeName(pub ArgDeclNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct ArgDeclNodeNameTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_arg_decl_node: BTreeMap<ArgDeclNode, Vec<ArgDeclNodeName>>,
    element_index_ident: BTreeMap<Ident, Vec<ArgDeclNodeName>>,
}
impl ArgDeclNodeNameTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_arg_decl_node: BTreeMap::new(),
            element_index_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ArgDeclNodeName) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_arg_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ArgDeclNodeName) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ArgDeclNodeName) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ArgDeclNodeName {
        ArgDeclNodeName(ArgDeclNode::from(t.0), Ident::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ArgDeclNodeName> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ArgDeclNodeName> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: ArgDeclNode,
        arg1: Ident,
    ) -> impl '_ + Iterator<Item = ArgDeclNodeName> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_node(&mut self, tm: ArgDeclNode) -> Vec<ArgDeclNodeName> {
        let mut ts = match self.element_index_arg_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<ArgDeclNodeName> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ArgDeclNodeNameTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("arg_decl_node_name"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgDeclNodeType(pub ArgDeclNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct ArgDeclNodeTypeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_arg_decl_node: BTreeMap<ArgDeclNode, Vec<ArgDeclNodeType>>,
    element_index_ident: BTreeMap<Ident, Vec<ArgDeclNodeType>>,
}
impl ArgDeclNodeTypeTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_arg_decl_node: BTreeMap::new(),
            element_index_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ArgDeclNodeType) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_arg_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ArgDeclNodeType) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ArgDeclNodeType) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ArgDeclNodeType {
        ArgDeclNodeType(ArgDeclNode::from(t.0), Ident::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: ArgDeclNodeType) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> ArgDeclNodeType {
        ArgDeclNodeType(ArgDeclNode::from(t.1), Ident::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ArgDeclNodeType> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ArgDeclNodeType> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ArgDeclNode) -> impl '_ + Iterator<Item = ArgDeclNodeType> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: ArgDeclNode,
        arg1: Ident,
    ) -> impl '_ + Iterator<Item = ArgDeclNodeType> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = ArgDeclNodeType> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_node(&mut self, tm: ArgDeclNode) -> Vec<ArgDeclNodeType> {
        let mut ts = match self.element_index_arg_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<ArgDeclNodeType> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ArgDeclNodeTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("arg_decl_node_type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilArgDeclListNode(pub ArgDeclListNode);
#[derive(Clone, Hash, Debug)]
struct NilArgDeclListNodeTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<NilArgDeclListNode>>,
}
impl NilArgDeclListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_arg_decl_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NilArgDeclListNode) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_arg_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_list_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NilArgDeclListNode) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: NilArgDeclListNode) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> NilArgDeclListNode {
        NilArgDeclListNode(ArgDeclListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NilArgDeclListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NilArgDeclListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ArgDeclListNode) -> impl '_ + Iterator<Item = NilArgDeclListNode> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_list_node(
        &mut self,
        tm: ArgDeclListNode,
    ) -> Vec<NilArgDeclListNode> {
        let mut ts = match self.element_index_arg_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for NilArgDeclListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_arg_decl_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsArgDeclListNode(pub ArgDeclListNode, pub ArgDeclNode, pub ArgDeclListNode);
#[derive(Clone, Hash, Debug)]
struct ConsArgDeclListNodeTable {
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_2_0: BTreeSet<(u32, u32, u32)>,
    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<ConsArgDeclListNode>>,
    element_index_arg_decl_node: BTreeMap<ArgDeclNode, Vec<ConsArgDeclListNode>>,
}
impl ConsArgDeclListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_2_0: BTreeSet::new(),
            element_index_arg_decl_list_node: BTreeMap::new(),
            element_index_arg_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ConsArgDeclListNode) -> bool {
        if self.index_all_1_2_0.insert(Self::permute_1_2_0(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_arg_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_arg_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_arg_decl_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ConsArgDeclListNode) -> bool {
        self.index_all_1_2_0.contains(&Self::permute_1_2_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: ConsArgDeclListNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> ConsArgDeclListNode {
        ConsArgDeclListNode(
            ArgDeclListNode::from(t.0),
            ArgDeclNode::from(t.1),
            ArgDeclListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_2_0(t: ConsArgDeclListNode) -> (u32, u32, u32) {
        (t.1.into(), t.2.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_2_0(t: (u32, u32, u32)) -> ConsArgDeclListNode {
        ConsArgDeclListNode(
            ArgDeclListNode::from(t.2),
            ArgDeclNode::from(t.0),
            ArgDeclListNode::from(t.1),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ConsArgDeclListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ConsArgDeclListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: ArgDeclListNode,
        arg1: ArgDeclNode,
        arg2: ArgDeclListNode,
    ) -> impl '_ + Iterator<Item = ConsArgDeclListNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg2, arg0);
        let max = (arg1, arg2, arg0);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: ArgDeclNode) -> impl '_ + Iterator<Item = ConsArgDeclListNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_1_2(
        &self,
        arg1: ArgDeclNode,
        arg2: ArgDeclListNode,
    ) -> impl '_ + Iterator<Item = ConsArgDeclListNode> {
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg2, u32::MIN);
        let max = (arg1, arg2, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_list_node(
        &mut self,
        tm: ArgDeclListNode,
    ) -> Vec<ConsArgDeclListNode> {
        let mut ts = match self.element_index_arg_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_1_2_0.remove(&Self::permute_1_2_0(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_node(&mut self, tm: ArgDeclNode) -> Vec<ConsArgDeclListNode> {
        let mut ts = match self.element_index_arg_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_1_2_0.remove(&Self::permute_1_2_0(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ConsArgDeclListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_arg_decl_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredDecl(pub PredDeclNode, pub Ident, pub ArgDeclListNode);
#[derive(Clone, Hash, Debug)]
struct PredDeclTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_2_0: BTreeSet<(u32, u32, u32)>,
    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<PredDecl>>,
    element_index_ident: BTreeMap<Ident, Vec<PredDecl>>,
    element_index_pred_decl_node: BTreeMap<PredDeclNode, Vec<PredDecl>>,
}
impl PredDeclTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_2_0: BTreeSet::new(),
            element_index_arg_decl_list_node: BTreeMap::new(),
            element_index_ident: BTreeMap::new(),
            element_index_pred_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: PredDecl) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_2_0.insert(Self::permute_1_2_0(t));

            match self.element_index_pred_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_pred_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            match self.element_index_arg_decl_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: PredDecl) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: PredDecl) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> PredDecl {
        PredDecl(
            PredDeclNode::from(t.0),
            Ident::from(t.1),
            ArgDeclListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_2_0(t: PredDecl) -> (u32, u32, u32) {
        (t.1.into(), t.2.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_2_0(t: (u32, u32, u32)) -> PredDecl {
        PredDecl(
            PredDeclNode::from(t.2),
            Ident::from(t.0),
            ArgDeclListNode::from(t.1),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = PredDecl> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = PredDecl> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: PredDeclNode) -> impl '_ + Iterator<Item = PredDecl> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: PredDeclNode,
        arg1: Ident,
        arg2: ArgDeclListNode,
    ) -> impl '_ + Iterator<Item = PredDecl> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = PredDecl> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_1_2(
        &self,
        arg1: Ident,
        arg2: ArgDeclListNode,
    ) -> impl '_ + Iterator<Item = PredDecl> {
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg2, u32::MIN);
        let max = (arg1, arg2, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_list_node(&mut self, tm: ArgDeclListNode) -> Vec<PredDecl> {
        let mut ts = match self.element_index_arg_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<PredDecl> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_pred_decl_node(&mut self, tm: PredDeclNode) -> Vec<PredDecl> {
        let mut ts = match self.element_index_pred_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for PredDeclTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_decl"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncDecl(pub FuncDeclNode, pub Ident, pub ArgDeclListNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct FuncDeclTable {
    index_all_0_1_2_3: BTreeSet<(u32, u32, u32, u32)>,
    index_dirty_0_1_2_3: BTreeSet<(u32, u32, u32, u32)>,
    index_all_1_2_0_3: BTreeSet<(u32, u32, u32, u32)>,
    index_all_1_3_0_2: BTreeSet<(u32, u32, u32, u32)>,
    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<FuncDecl>>,
    element_index_func_decl_node: BTreeMap<FuncDeclNode, Vec<FuncDecl>>,
    element_index_ident: BTreeMap<Ident, Vec<FuncDecl>>,
}
impl FuncDeclTable {
    #[allow(unused)]
    const WEIGHT: usize = 20;
    fn new() -> Self {
        Self {
            index_all_0_1_2_3: BTreeSet::new(),
            index_dirty_0_1_2_3: BTreeSet::new(),
            index_all_1_2_0_3: BTreeSet::new(),
            index_all_1_3_0_2: BTreeSet::new(),
            element_index_arg_decl_list_node: BTreeMap::new(),
            element_index_func_decl_node: BTreeMap::new(),
            element_index_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: FuncDecl) -> bool {
        if self.index_all_0_1_2_3.insert(Self::permute_0_1_2_3(t)) {
            self.index_dirty_0_1_2_3.insert(Self::permute_0_1_2_3(t));
            self.index_all_1_2_0_3.insert(Self::permute_1_2_0_3(t));
            self.index_all_1_3_0_2.insert(Self::permute_1_3_0_2(t));

            match self.element_index_func_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_func_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            match self.element_index_arg_decl_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_list_node.insert(t.2, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.3) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.3, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: FuncDecl) -> bool {
        self.index_all_0_1_2_3.contains(&Self::permute_0_1_2_3(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2_3.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2_3.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2_3(t: FuncDecl) -> (u32, u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into(), t.3.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2_3(t: (u32, u32, u32, u32)) -> FuncDecl {
        FuncDecl(
            FuncDeclNode::from(t.0),
            Ident::from(t.1),
            ArgDeclListNode::from(t.2),
            Ident::from(t.3),
        )
    }
    #[allow(unused)]
    fn permute_1_2_0_3(t: FuncDecl) -> (u32, u32, u32, u32) {
        (t.1.into(), t.2.into(), t.0.into(), t.3.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_2_0_3(t: (u32, u32, u32, u32)) -> FuncDecl {
        FuncDecl(
            FuncDeclNode::from(t.2),
            Ident::from(t.0),
            ArgDeclListNode::from(t.1),
            Ident::from(t.3),
        )
    }
    #[allow(unused)]
    fn permute_1_3_0_2(t: FuncDecl) -> (u32, u32, u32, u32) {
        (t.1.into(), t.3.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_3_0_2(t: (u32, u32, u32, u32)) -> FuncDecl {
        FuncDecl(
            FuncDeclNode::from(t.2),
            Ident::from(t.0),
            ArgDeclListNode::from(t.3),
            Ident::from(t.1),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = FuncDecl> {
        let min = (u32::MIN, u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2_3
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2_3)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = FuncDecl> {
        let min = (u32::MIN, u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2_3
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2_3)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: FuncDeclNode) -> impl '_ + Iterator<Item = FuncDecl> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2_3
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2_3)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2_3(
        &self,
        arg0: FuncDeclNode,
        arg1: Ident,
        arg2: ArgDeclListNode,
        arg3: Ident,
    ) -> impl '_ + Iterator<Item = FuncDecl> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let arg3 = arg3.0;
        let min = (arg0, arg1, arg2, arg3);
        let max = (arg0, arg1, arg2, arg3);
        self.index_all_0_1_2_3
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2_3)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = FuncDecl> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX, u32::MAX);
        self.index_all_1_2_0_3
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0_3)
    }
    #[allow(dead_code)]
    fn iter_all_1_2(
        &self,
        arg1: Ident,
        arg2: ArgDeclListNode,
    ) -> impl '_ + Iterator<Item = FuncDecl> {
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg2, u32::MIN, u32::MIN);
        let max = (arg1, arg2, u32::MAX, u32::MAX);
        self.index_all_1_2_0_3
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0_3)
    }
    #[allow(dead_code)]
    fn iter_all_1_3(&self, arg1: Ident, arg3: Ident) -> impl '_ + Iterator<Item = FuncDecl> {
        let arg1 = arg1.0;
        let arg3 = arg3.0;
        let min = (arg1, arg3, u32::MIN, u32::MIN);
        let max = (arg1, arg3, u32::MAX, u32::MAX);
        self.index_all_1_3_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_3_0_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_list_node(&mut self, tm: ArgDeclListNode) -> Vec<FuncDecl> {
        let mut ts = match self.element_index_arg_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
                self.index_dirty_0_1_2_3.remove(&Self::permute_0_1_2_3(t));
                self.index_all_1_2_0_3.remove(&Self::permute_1_2_0_3(t));
                self.index_all_1_3_0_2.remove(&Self::permute_1_3_0_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_func_decl_node(&mut self, tm: FuncDeclNode) -> Vec<FuncDecl> {
        let mut ts = match self.element_index_func_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
                self.index_dirty_0_1_2_3.remove(&Self::permute_0_1_2_3(t));
                self.index_all_1_2_0_3.remove(&Self::permute_1_2_0_3(t));
                self.index_all_1_3_0_2.remove(&Self::permute_1_3_0_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<FuncDecl> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
                self.index_dirty_0_1_2_3.remove(&Self::permute_0_1_2_3(t));
                self.index_all_1_2_0_3.remove(&Self::permute_1_2_0_3(t));
                self.index_all_1_3_0_2.remove(&Self::permute_1_3_0_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for FuncDeclTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("func_decl"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorDecl(pub CtorDeclNode, pub Ident, pub ArgDeclListNode);
#[derive(Clone, Hash, Debug)]
struct CtorDeclTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_2_0: BTreeSet<(u32, u32, u32)>,
    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<CtorDecl>>,
    element_index_ctor_decl_node: BTreeMap<CtorDeclNode, Vec<CtorDecl>>,
    element_index_ident: BTreeMap<Ident, Vec<CtorDecl>>,
}
impl CtorDeclTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_2_0: BTreeSet::new(),
            element_index_arg_decl_list_node: BTreeMap::new(),
            element_index_ctor_decl_node: BTreeMap::new(),
            element_index_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: CtorDecl) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_2_0.insert(Self::permute_1_2_0(t));

            match self.element_index_ctor_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ctor_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            match self.element_index_arg_decl_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: CtorDecl) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: CtorDecl) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> CtorDecl {
        CtorDecl(
            CtorDeclNode::from(t.0),
            Ident::from(t.1),
            ArgDeclListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_2_0(t: CtorDecl) -> (u32, u32, u32) {
        (t.1.into(), t.2.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_2_0(t: (u32, u32, u32)) -> CtorDecl {
        CtorDecl(
            CtorDeclNode::from(t.2),
            Ident::from(t.0),
            ArgDeclListNode::from(t.1),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = CtorDecl> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = CtorDecl> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: CtorDeclNode) -> impl '_ + Iterator<Item = CtorDecl> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: CtorDeclNode, arg1: Ident) -> impl '_ + Iterator<Item = CtorDecl> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: CtorDeclNode,
        arg1: Ident,
        arg2: ArgDeclListNode,
    ) -> impl '_ + Iterator<Item = CtorDecl> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = CtorDecl> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_1_2(
        &self,
        arg1: Ident,
        arg2: ArgDeclListNode,
    ) -> impl '_ + Iterator<Item = CtorDecl> {
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg2, u32::MIN);
        let max = (arg1, arg2, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_list_node(&mut self, tm: ArgDeclListNode) -> Vec<CtorDecl> {
        let mut ts = match self.element_index_arg_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_ctor_decl_node(&mut self, tm: CtorDeclNode) -> Vec<CtorDecl> {
        let mut ts = match self.element_index_ctor_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<CtorDecl> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for CtorDeclTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ctor_decl"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilCtorDeclListNode(pub CtorDeclListNode);
#[derive(Clone, Hash, Debug)]
struct NilCtorDeclListNodeTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_ctor_decl_list_node: BTreeMap<CtorDeclListNode, Vec<NilCtorDeclListNode>>,
}
impl NilCtorDeclListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_ctor_decl_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NilCtorDeclListNode) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_ctor_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ctor_decl_list_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NilCtorDeclListNode) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: NilCtorDeclListNode) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> NilCtorDeclListNode {
        NilCtorDeclListNode(CtorDeclListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NilCtorDeclListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NilCtorDeclListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: CtorDeclListNode) -> impl '_ + Iterator<Item = NilCtorDeclListNode> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_ctor_decl_list_node(
        &mut self,
        tm: CtorDeclListNode,
    ) -> Vec<NilCtorDeclListNode> {
        let mut ts = match self.element_index_ctor_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for NilCtorDeclListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_ctor_decl_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsCtorDeclListNode(pub CtorDeclListNode, pub CtorDeclNode, pub CtorDeclListNode);
#[derive(Clone, Hash, Debug)]
struct ConsCtorDeclListNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    element_index_ctor_decl_list_node: BTreeMap<CtorDeclListNode, Vec<ConsCtorDeclListNode>>,
    element_index_ctor_decl_node: BTreeMap<CtorDeclNode, Vec<ConsCtorDeclListNode>>,
}
impl ConsCtorDeclListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            element_index_ctor_decl_list_node: BTreeMap::new(),
            element_index_ctor_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ConsCtorDeclListNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_ctor_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ctor_decl_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ctor_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ctor_decl_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_ctor_decl_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ctor_decl_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ConsCtorDeclListNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: ConsCtorDeclListNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> ConsCtorDeclListNode {
        ConsCtorDeclListNode(
            CtorDeclListNode::from(t.0),
            CtorDeclNode::from(t.1),
            CtorDeclListNode::from(t.2),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ConsCtorDeclListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ConsCtorDeclListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(
        &self,
        arg0: CtorDeclListNode,
    ) -> impl '_ + Iterator<Item = ConsCtorDeclListNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: CtorDeclListNode,
        arg1: CtorDeclNode,
        arg2: CtorDeclListNode,
    ) -> impl '_ + Iterator<Item = ConsCtorDeclListNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_ctor_decl_list_node(
        &mut self,
        tm: CtorDeclListNode,
    ) -> Vec<ConsCtorDeclListNode> {
        let mut ts = match self.element_index_ctor_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_ctor_decl_node(&mut self, tm: CtorDeclNode) -> Vec<ConsCtorDeclListNode> {
        let mut ts = match self.element_index_ctor_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ConsCtorDeclListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_ctor_decl_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EnumDecl(pub EnumDeclNode, pub Ident, pub CtorDeclListNode);
#[derive(Clone, Hash, Debug)]
struct EnumDeclTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    element_index_ctor_decl_list_node: BTreeMap<CtorDeclListNode, Vec<EnumDecl>>,
    element_index_enum_decl_node: BTreeMap<EnumDeclNode, Vec<EnumDecl>>,
    element_index_ident: BTreeMap<Ident, Vec<EnumDecl>>,
}
impl EnumDeclTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            element_index_ctor_decl_list_node: BTreeMap::new(),
            element_index_enum_decl_node: BTreeMap::new(),
            element_index_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: EnumDecl) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_0_2.insert(Self::permute_1_0_2(t));

            match self.element_index_enum_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_enum_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            match self.element_index_ctor_decl_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ctor_decl_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: EnumDecl) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: EnumDecl) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> EnumDecl {
        EnumDecl(
            EnumDeclNode::from(t.0),
            Ident::from(t.1),
            CtorDeclListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_0_2(t: EnumDecl) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> EnumDecl {
        EnumDecl(
            EnumDeclNode::from(t.1),
            Ident::from(t.0),
            CtorDeclListNode::from(t.2),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = EnumDecl> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = EnumDecl> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: EnumDeclNode) -> impl '_ + Iterator<Item = EnumDecl> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: EnumDeclNode, arg1: Ident) -> impl '_ + Iterator<Item = EnumDecl> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: EnumDeclNode,
        arg1: Ident,
        arg2: CtorDeclListNode,
    ) -> impl '_ + Iterator<Item = EnumDecl> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = EnumDecl> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_ctor_decl_list_node(&mut self, tm: CtorDeclListNode) -> Vec<EnumDecl> {
        let mut ts = match self.element_index_ctor_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_enum_decl_node(&mut self, tm: EnumDeclNode) -> Vec<EnumDecl> {
        let mut ts = match self.element_index_enum_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<EnumDecl> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for EnumDeclTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("enum_decl"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilTermListNode(pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct NilTermListNodeTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<NilTermListNode>>,
}
impl NilTermListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_term_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NilTermListNode) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NilTermListNode) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: NilTermListNode) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> NilTermListNode {
        NilTermListNode(TermListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NilTermListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NilTermListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = NilTermListNode> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<NilTermListNode> {
        let mut ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for NilTermListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_term_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsTermListNode(pub TermListNode, pub TermNode, pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct ConsTermListNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_0_2_1: BTreeSet<(u32, u32, u32)>,
    index_all_1_2_0: BTreeSet<(u32, u32, u32)>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<ConsTermListNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<ConsTermListNode>>,
}
impl ConsTermListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_0_2_1: BTreeSet::new(),
            index_all_1_2_0: BTreeSet::new(),
            element_index_term_list_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ConsTermListNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_0_2_1.insert(Self::permute_0_2_1(t));
            self.index_all_1_2_0.insert(Self::permute_1_2_0(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_term_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ConsTermListNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: ConsTermListNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> ConsTermListNode {
        ConsTermListNode(
            TermListNode::from(t.0),
            TermNode::from(t.1),
            TermListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_0_2_1(t: ConsTermListNode) -> (u32, u32, u32) {
        (t.0.into(), t.2.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_2_1(t: (u32, u32, u32)) -> ConsTermListNode {
        ConsTermListNode(
            TermListNode::from(t.0),
            TermNode::from(t.2),
            TermListNode::from(t.1),
        )
    }
    #[allow(unused)]
    fn permute_1_2_0(t: ConsTermListNode) -> (u32, u32, u32) {
        (t.1.into(), t.2.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_2_0(t: (u32, u32, u32)) -> ConsTermListNode {
        ConsTermListNode(
            TermListNode::from(t.2),
            TermNode::from(t.0),
            TermListNode::from(t.1),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ConsTermListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ConsTermListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = ConsTermListNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TermListNode,
        arg1: TermNode,
    ) -> impl '_ + Iterator<Item = ConsTermListNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: TermListNode,
        arg1: TermNode,
        arg2: TermListNode,
    ) -> impl '_ + Iterator<Item = ConsTermListNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_2(
        &self,
        arg0: TermListNode,
        arg2: TermListNode,
    ) -> impl '_ + Iterator<Item = ConsTermListNode> {
        let arg0 = arg0.0;
        let arg2 = arg2.0;
        let min = (arg0, arg2, u32::MIN);
        let max = (arg0, arg2, u32::MAX);
        self.index_all_0_2_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_2_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = ConsTermListNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_1_2(
        &self,
        arg1: TermNode,
        arg2: TermListNode,
    ) -> impl '_ + Iterator<Item = ConsTermListNode> {
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg2, u32::MIN);
        let max = (arg1, arg2, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<ConsTermListNode> {
        let mut ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_0_2_1.remove(&Self::permute_0_2_1(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<ConsTermListNode> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_0_2_1.remove(&Self::permute_0_2_1(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ConsTermListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_term_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NoneTermNode(pub OptTermNode);
#[derive(Clone, Hash, Debug)]
struct NoneTermNodeTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<NoneTermNode>>,
}
impl NoneTermNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_opt_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NoneTermNode) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_opt_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_opt_term_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NoneTermNode) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: NoneTermNode) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> NoneTermNode {
        NoneTermNode(OptTermNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NoneTermNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NoneTermNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: OptTermNode) -> impl '_ + Iterator<Item = NoneTermNode> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_opt_term_node(&mut self, tm: OptTermNode) -> Vec<NoneTermNode> {
        let mut ts = match self.element_index_opt_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for NoneTermNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("none_term_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SomeTermNode(pub OptTermNode, pub TermNode);
#[derive(Clone, Hash, Debug)]
struct SomeTermNodeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<SomeTermNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<SomeTermNode>>,
}
impl SomeTermNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_opt_term_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: SomeTermNode) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_opt_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_opt_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: SomeTermNode) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: SomeTermNode) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> SomeTermNode {
        SomeTermNode(OptTermNode::from(t.0), TermNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: SomeTermNode) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> SomeTermNode {
        SomeTermNode(OptTermNode::from(t.1), TermNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = SomeTermNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = SomeTermNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: OptTermNode) -> impl '_ + Iterator<Item = SomeTermNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: OptTermNode,
        arg1: TermNode,
    ) -> impl '_ + Iterator<Item = SomeTermNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = SomeTermNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_opt_term_node(&mut self, tm: OptTermNode) -> Vec<SomeTermNode> {
        let mut ts = match self.element_index_opt_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<SomeTermNode> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for SomeTermNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("some_term_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarTermNode(pub TermNode, pub VirtIdent);
#[derive(Clone, Hash, Debug)]
struct VarTermNodeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_term_node: BTreeMap<TermNode, Vec<VarTermNode>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<VarTermNode>>,
}
impl VarTermNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_term_node: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VarTermNode) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VarTermNode) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: VarTermNode) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> VarTermNode {
        VarTermNode(TermNode::from(t.0), VirtIdent::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: VarTermNode) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> VarTermNode {
        VarTermNode(TermNode::from(t.1), VirtIdent::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VarTermNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VarTermNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = VarTermNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TermNode,
        arg1: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarTermNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: VirtIdent) -> impl '_ + Iterator<Item = VarTermNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<VarTermNode> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(&mut self, tm: VirtIdent) -> Vec<VarTermNode> {
        let mut ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for VarTermNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_term_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct WildcardTermNode(pub TermNode);
#[derive(Clone, Hash, Debug)]
struct WildcardTermNodeTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_term_node: BTreeMap<TermNode, Vec<WildcardTermNode>>,
}
impl WildcardTermNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: WildcardTermNode) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: WildcardTermNode) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: WildcardTermNode) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> WildcardTermNode {
        WildcardTermNode(TermNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = WildcardTermNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = WildcardTermNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = WildcardTermNode> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<WildcardTermNode> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for WildcardTermNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("wildcard_term_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct AppTermNode(pub TermNode, pub Ident, pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct AppTermNodeTable {
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_0_2_1: BTreeSet<(u32, u32, u32)>,
    index_all_1_2_0: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_ident: BTreeMap<Ident, Vec<AppTermNode>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<AppTermNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<AppTermNode>>,
}
impl AppTermNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_0_2_1: BTreeSet::new(),
            index_all_1_2_0: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_ident: BTreeMap::new(),
            element_index_term_list_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: AppTermNode) -> bool {
        if self.index_all_0_2_1.insert(Self::permute_0_2_1(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_2_0.insert(Self::permute_1_2_0(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            match self.element_index_term_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: AppTermNode) -> bool {
        self.index_all_0_2_1.contains(&Self::permute_0_2_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: AppTermNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> AppTermNode {
        AppTermNode(
            TermNode::from(t.0),
            Ident::from(t.1),
            TermListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_0_2_1(t: AppTermNode) -> (u32, u32, u32) {
        (t.0.into(), t.2.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_2_1(t: (u32, u32, u32)) -> AppTermNode {
        AppTermNode(
            TermNode::from(t.0),
            Ident::from(t.2),
            TermListNode::from(t.1),
        )
    }
    #[allow(unused)]
    fn permute_1_2_0(t: AppTermNode) -> (u32, u32, u32) {
        (t.1.into(), t.2.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_2_0(t: (u32, u32, u32)) -> AppTermNode {
        AppTermNode(
            TermNode::from(t.2),
            Ident::from(t.0),
            TermListNode::from(t.1),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: AppTermNode) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> AppTermNode {
        AppTermNode(
            TermNode::from(t.1),
            Ident::from(t.2),
            TermListNode::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = AppTermNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_2_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_2_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = AppTermNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = AppTermNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_2_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_2_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: TermNode,
        arg1: Ident,
        arg2: TermListNode,
    ) -> impl '_ + Iterator<Item = AppTermNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg2, arg1);
        let max = (arg0, arg2, arg1);
        self.index_all_0_2_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_2_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_2(
        &self,
        arg0: TermNode,
        arg2: TermListNode,
    ) -> impl '_ + Iterator<Item = AppTermNode> {
        let arg0 = arg0.0;
        let arg2 = arg2.0;
        let min = (arg0, arg2, u32::MIN);
        let max = (arg0, arg2, u32::MAX);
        self.index_all_0_2_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_2_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = AppTermNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_1_2(
        &self,
        arg1: Ident,
        arg2: TermListNode,
    ) -> impl '_ + Iterator<Item = AppTermNode> {
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg2, u32::MIN);
        let max = (arg1, arg2, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: TermListNode) -> impl '_ + Iterator<Item = AppTermNode> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<AppTermNode> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_2_1.remove(&Self::permute_0_2_1(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<AppTermNode> {
        let mut ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_2_1.remove(&Self::permute_0_2_1(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<AppTermNode> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_2_1.remove(&Self::permute_0_2_1(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for AppTermNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("app_term_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchCase(pub MatchCaseNode, pub TermNode, pub StmtListNode);
#[derive(Clone, Hash, Debug)]
struct MatchCaseTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    element_index_match_case_node: BTreeMap<MatchCaseNode, Vec<MatchCase>>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<MatchCase>>,
    element_index_term_node: BTreeMap<TermNode, Vec<MatchCase>>,
}
impl MatchCaseTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            element_index_match_case_node: BTreeMap::new(),
            element_index_stmt_list_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: MatchCase) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_0_2.insert(Self::permute_1_0_2(t));

            match self.element_index_match_case_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_match_case_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_stmt_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: MatchCase) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: MatchCase) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> MatchCase {
        MatchCase(
            MatchCaseNode::from(t.0),
            TermNode::from(t.1),
            StmtListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_0_2(t: MatchCase) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> MatchCase {
        MatchCase(
            MatchCaseNode::from(t.1),
            TermNode::from(t.0),
            StmtListNode::from(t.2),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = MatchCase> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = MatchCase> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: MatchCaseNode) -> impl '_ + Iterator<Item = MatchCase> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: MatchCaseNode,
        arg1: TermNode,
    ) -> impl '_ + Iterator<Item = MatchCase> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: MatchCaseNode,
        arg1: TermNode,
        arg2: StmtListNode,
    ) -> impl '_ + Iterator<Item = MatchCase> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = MatchCase> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_match_case_node(&mut self, tm: MatchCaseNode) -> Vec<MatchCase> {
        let mut ts = match self.element_index_match_case_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_list_node(&mut self, tm: StmtListNode) -> Vec<MatchCase> {
        let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<MatchCase> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for MatchCaseTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("match_case"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilMatchCaseListNode(pub MatchCaseListNode);
#[derive(Clone, Hash, Debug)]
struct NilMatchCaseListNodeTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_match_case_list_node: BTreeMap<MatchCaseListNode, Vec<NilMatchCaseListNode>>,
}
impl NilMatchCaseListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_match_case_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NilMatchCaseListNode) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_match_case_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_match_case_list_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NilMatchCaseListNode) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: NilMatchCaseListNode) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> NilMatchCaseListNode {
        NilMatchCaseListNode(MatchCaseListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NilMatchCaseListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NilMatchCaseListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(
        &self,
        arg0: MatchCaseListNode,
    ) -> impl '_ + Iterator<Item = NilMatchCaseListNode> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_match_case_list_node(
        &mut self,
        tm: MatchCaseListNode,
    ) -> Vec<NilMatchCaseListNode> {
        let mut ts = match self.element_index_match_case_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for NilMatchCaseListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_match_case_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsMatchCaseListNode(
    pub MatchCaseListNode,
    pub MatchCaseNode,
    pub MatchCaseListNode,
);
#[derive(Clone, Hash, Debug)]
struct ConsMatchCaseListNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_2_0: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_match_case_list_node: BTreeMap<MatchCaseListNode, Vec<ConsMatchCaseListNode>>,
    element_index_match_case_node: BTreeMap<MatchCaseNode, Vec<ConsMatchCaseListNode>>,
}
impl ConsMatchCaseListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_2_0: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_match_case_list_node: BTreeMap::new(),
            element_index_match_case_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ConsMatchCaseListNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_2_0.insert(Self::permute_1_2_0(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_match_case_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_match_case_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_match_case_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_match_case_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_match_case_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_match_case_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ConsMatchCaseListNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: ConsMatchCaseListNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> ConsMatchCaseListNode {
        ConsMatchCaseListNode(
            MatchCaseListNode::from(t.0),
            MatchCaseNode::from(t.1),
            MatchCaseListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_2_0(t: ConsMatchCaseListNode) -> (u32, u32, u32) {
        (t.1.into(), t.2.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_2_0(t: (u32, u32, u32)) -> ConsMatchCaseListNode {
        ConsMatchCaseListNode(
            MatchCaseListNode::from(t.2),
            MatchCaseNode::from(t.0),
            MatchCaseListNode::from(t.1),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: ConsMatchCaseListNode) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> ConsMatchCaseListNode {
        ConsMatchCaseListNode(
            MatchCaseListNode::from(t.1),
            MatchCaseNode::from(t.2),
            MatchCaseListNode::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ConsMatchCaseListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ConsMatchCaseListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(
        &self,
        arg0: MatchCaseListNode,
    ) -> impl '_ + Iterator<Item = ConsMatchCaseListNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: MatchCaseListNode,
        arg1: MatchCaseNode,
    ) -> impl '_ + Iterator<Item = ConsMatchCaseListNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: MatchCaseListNode,
        arg1: MatchCaseNode,
        arg2: MatchCaseListNode,
    ) -> impl '_ + Iterator<Item = ConsMatchCaseListNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_2(
        &self,
        arg0: MatchCaseListNode,
        arg2: MatchCaseListNode,
    ) -> impl '_ + Iterator<Item = ConsMatchCaseListNode> {
        let arg0 = arg0.0;
        let arg2 = arg2.0;
        let min = (arg2, arg0, u32::MIN);
        let max = (arg2, arg0, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: MatchCaseNode) -> impl '_ + Iterator<Item = ConsMatchCaseListNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_1_2(
        &self,
        arg1: MatchCaseNode,
        arg2: MatchCaseListNode,
    ) -> impl '_ + Iterator<Item = ConsMatchCaseListNode> {
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg2, u32::MIN);
        let max = (arg1, arg2, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_2(
        &self,
        arg2: MatchCaseListNode,
    ) -> impl '_ + Iterator<Item = ConsMatchCaseListNode> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_match_case_list_node(
        &mut self,
        tm: MatchCaseListNode,
    ) -> Vec<ConsMatchCaseListNode> {
        let mut ts = match self.element_index_match_case_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_match_case_node(
        &mut self,
        tm: MatchCaseNode,
    ) -> Vec<ConsMatchCaseListNode> {
        let mut ts = match self.element_index_match_case_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ConsMatchCaseListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_match_case_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EqualIfAtomNode(pub IfAtomNode, pub TermNode, pub TermNode);
#[derive(Clone, Hash, Debug)]
struct EqualIfAtomNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_0_2_1: BTreeSet<(u32, u32, u32)>,
    index_all_1_2_0: BTreeSet<(u32, u32, u32)>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<EqualIfAtomNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<EqualIfAtomNode>>,
}
impl EqualIfAtomNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_0_2_1: BTreeSet::new(),
            index_all_1_2_0: BTreeSet::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: EqualIfAtomNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_0_2_1.insert(Self::permute_0_2_1(t));
            self.index_all_1_2_0.insert(Self::permute_1_2_0(t));

            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: EqualIfAtomNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: EqualIfAtomNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> EqualIfAtomNode {
        EqualIfAtomNode(
            IfAtomNode::from(t.0),
            TermNode::from(t.1),
            TermNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_0_2_1(t: EqualIfAtomNode) -> (u32, u32, u32) {
        (t.0.into(), t.2.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_2_1(t: (u32, u32, u32)) -> EqualIfAtomNode {
        EqualIfAtomNode(
            IfAtomNode::from(t.0),
            TermNode::from(t.2),
            TermNode::from(t.1),
        )
    }
    #[allow(unused)]
    fn permute_1_2_0(t: EqualIfAtomNode) -> (u32, u32, u32) {
        (t.1.into(), t.2.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_2_0(t: (u32, u32, u32)) -> EqualIfAtomNode {
        EqualIfAtomNode(
            IfAtomNode::from(t.2),
            TermNode::from(t.0),
            TermNode::from(t.1),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: IfAtomNode,
        arg1: TermNode,
    ) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: IfAtomNode,
        arg1: TermNode,
        arg2: TermNode,
    ) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_2(
        &self,
        arg0: IfAtomNode,
        arg2: TermNode,
    ) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
        let arg0 = arg0.0;
        let arg2 = arg2.0;
        let min = (arg0, arg2, u32::MIN);
        let max = (arg0, arg2, u32::MAX);
        self.index_all_0_2_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_2_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_1_2(
        &self,
        arg1: TermNode,
        arg2: TermNode,
    ) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg2, u32::MIN);
        let max = (arg1, arg2, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(&mut self, tm: IfAtomNode) -> Vec<EqualIfAtomNode> {
        let mut ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_0_2_1.remove(&Self::permute_0_2_1(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<EqualIfAtomNode> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_0_2_1.remove(&Self::permute_0_2_1(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for EqualIfAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("equal_if_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DefinedIfAtomNode(pub IfAtomNode, pub TermNode);
#[derive(Clone, Hash, Debug)]
struct DefinedIfAtomNodeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<DefinedIfAtomNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<DefinedIfAtomNode>>,
}
impl DefinedIfAtomNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DefinedIfAtomNode) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DefinedIfAtomNode) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DefinedIfAtomNode) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DefinedIfAtomNode {
        DefinedIfAtomNode(IfAtomNode::from(t.0), TermNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: DefinedIfAtomNode) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> DefinedIfAtomNode {
        DefinedIfAtomNode(IfAtomNode::from(t.1), TermNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DefinedIfAtomNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DefinedIfAtomNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = DefinedIfAtomNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: IfAtomNode,
        arg1: TermNode,
    ) -> impl '_ + Iterator<Item = DefinedIfAtomNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = DefinedIfAtomNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(&mut self, tm: IfAtomNode) -> Vec<DefinedIfAtomNode> {
        let mut ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<DefinedIfAtomNode> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for DefinedIfAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("defined_if_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredIfAtomNode(pub IfAtomNode, pub Ident, pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct PredIfAtomNodeTable {
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_0_2_1: BTreeSet<(u32, u32, u32)>,
    index_all_1_2_0: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_ident: BTreeMap<Ident, Vec<PredIfAtomNode>>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<PredIfAtomNode>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<PredIfAtomNode>>,
}
impl PredIfAtomNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_0_2_1: BTreeSet::new(),
            index_all_1_2_0: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_ident: BTreeMap::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_term_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: PredIfAtomNode) -> bool {
        if self.index_all_0_2_1.insert(Self::permute_0_2_1(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_2_0.insert(Self::permute_1_2_0(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            match self.element_index_term_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: PredIfAtomNode) -> bool {
        self.index_all_0_2_1.contains(&Self::permute_0_2_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: PredIfAtomNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> PredIfAtomNode {
        PredIfAtomNode(
            IfAtomNode::from(t.0),
            Ident::from(t.1),
            TermListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_0_2_1(t: PredIfAtomNode) -> (u32, u32, u32) {
        (t.0.into(), t.2.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_2_1(t: (u32, u32, u32)) -> PredIfAtomNode {
        PredIfAtomNode(
            IfAtomNode::from(t.0),
            Ident::from(t.2),
            TermListNode::from(t.1),
        )
    }
    #[allow(unused)]
    fn permute_1_2_0(t: PredIfAtomNode) -> (u32, u32, u32) {
        (t.1.into(), t.2.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_2_0(t: (u32, u32, u32)) -> PredIfAtomNode {
        PredIfAtomNode(
            IfAtomNode::from(t.2),
            Ident::from(t.0),
            TermListNode::from(t.1),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: PredIfAtomNode) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> PredIfAtomNode {
        PredIfAtomNode(
            IfAtomNode::from(t.1),
            Ident::from(t.2),
            TermListNode::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = PredIfAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_2_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_2_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = PredIfAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = PredIfAtomNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_2_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_2_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: IfAtomNode,
        arg1: Ident,
        arg2: TermListNode,
    ) -> impl '_ + Iterator<Item = PredIfAtomNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg2, arg1);
        let max = (arg0, arg2, arg1);
        self.index_all_0_2_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_2_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_2(
        &self,
        arg0: IfAtomNode,
        arg2: TermListNode,
    ) -> impl '_ + Iterator<Item = PredIfAtomNode> {
        let arg0 = arg0.0;
        let arg2 = arg2.0;
        let min = (arg0, arg2, u32::MIN);
        let max = (arg0, arg2, u32::MAX);
        self.index_all_0_2_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_2_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = PredIfAtomNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_1_2(
        &self,
        arg1: Ident,
        arg2: TermListNode,
    ) -> impl '_ + Iterator<Item = PredIfAtomNode> {
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg2, u32::MIN);
        let max = (arg1, arg2, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: TermListNode) -> impl '_ + Iterator<Item = PredIfAtomNode> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<PredIfAtomNode> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_2_1.remove(&Self::permute_0_2_1(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(&mut self, tm: IfAtomNode) -> Vec<PredIfAtomNode> {
        let mut ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_2_1.remove(&Self::permute_0_2_1(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<PredIfAtomNode> {
        let mut ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_2_1.remove(&Self::permute_0_2_1(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for PredIfAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_if_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarIfAtomNode(pub IfAtomNode, pub TermNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct VarIfAtomNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_1_0: BTreeSet<(u32, u32, u32)>,
    element_index_ident: BTreeMap<Ident, Vec<VarIfAtomNode>>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<VarIfAtomNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<VarIfAtomNode>>,
}
impl VarIfAtomNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_2_1_0: BTreeSet::new(),
            element_index_ident: BTreeMap::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VarIfAtomNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_2_1_0.insert(Self::permute_2_1_0(t));

            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VarIfAtomNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: VarIfAtomNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> VarIfAtomNode {
        VarIfAtomNode(IfAtomNode::from(t.0), TermNode::from(t.1), Ident::from(t.2))
    }
    #[allow(unused)]
    fn permute_2_1_0(t: VarIfAtomNode) -> (u32, u32, u32) {
        (t.2.into(), t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_1_0(t: (u32, u32, u32)) -> VarIfAtomNode {
        VarIfAtomNode(IfAtomNode::from(t.2), TermNode::from(t.1), Ident::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VarIfAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VarIfAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = VarIfAtomNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: IfAtomNode,
        arg1: TermNode,
    ) -> impl '_ + Iterator<Item = VarIfAtomNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: IfAtomNode,
        arg1: TermNode,
        arg2: Ident,
    ) -> impl '_ + Iterator<Item = VarIfAtomNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1_2(
        &self,
        arg1: TermNode,
        arg2: Ident,
    ) -> impl '_ + Iterator<Item = VarIfAtomNode> {
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg2, arg1, u32::MIN);
        let max = (arg2, arg1, u32::MAX);
        self.index_all_2_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_1_0)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: Ident) -> impl '_ + Iterator<Item = VarIfAtomNode> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<VarIfAtomNode> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_2_1_0.remove(&Self::permute_2_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(&mut self, tm: IfAtomNode) -> Vec<VarIfAtomNode> {
        let mut ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_2_1_0.remove(&Self::permute_2_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<VarIfAtomNode> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_2_1_0.remove(&Self::permute_2_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for VarIfAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_if_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EqualThenAtomNode(pub ThenAtomNode, pub TermNode, pub TermNode);
#[derive(Clone, Hash, Debug)]
struct EqualThenAtomNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_0_2_1: BTreeSet<(u32, u32, u32)>,
    index_all_1_2_0: BTreeSet<(u32, u32, u32)>,
    element_index_term_node: BTreeMap<TermNode, Vec<EqualThenAtomNode>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<EqualThenAtomNode>>,
}
impl EqualThenAtomNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_0_2_1: BTreeSet::new(),
            index_all_1_2_0: BTreeSet::new(),
            element_index_term_node: BTreeMap::new(),
            element_index_then_atom_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: EqualThenAtomNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_0_2_1.insert(Self::permute_0_2_1(t));
            self.index_all_1_2_0.insert(Self::permute_1_2_0(t));

            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_then_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: EqualThenAtomNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: EqualThenAtomNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> EqualThenAtomNode {
        EqualThenAtomNode(
            ThenAtomNode::from(t.0),
            TermNode::from(t.1),
            TermNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_0_2_1(t: EqualThenAtomNode) -> (u32, u32, u32) {
        (t.0.into(), t.2.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_2_1(t: (u32, u32, u32)) -> EqualThenAtomNode {
        EqualThenAtomNode(
            ThenAtomNode::from(t.0),
            TermNode::from(t.2),
            TermNode::from(t.1),
        )
    }
    #[allow(unused)]
    fn permute_1_2_0(t: EqualThenAtomNode) -> (u32, u32, u32) {
        (t.1.into(), t.2.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_2_0(t: (u32, u32, u32)) -> EqualThenAtomNode {
        EqualThenAtomNode(
            ThenAtomNode::from(t.2),
            TermNode::from(t.0),
            TermNode::from(t.1),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: ThenAtomNode,
        arg1: TermNode,
    ) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: ThenAtomNode,
        arg1: TermNode,
        arg2: TermNode,
    ) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_2(
        &self,
        arg0: ThenAtomNode,
        arg2: TermNode,
    ) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
        let arg0 = arg0.0;
        let arg2 = arg2.0;
        let min = (arg0, arg2, u32::MIN);
        let max = (arg0, arg2, u32::MAX);
        self.index_all_0_2_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_2_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_1_2(
        &self,
        arg1: TermNode,
        arg2: TermNode,
    ) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg2, u32::MIN);
        let max = (arg1, arg2, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<EqualThenAtomNode> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_0_2_1.remove(&Self::permute_0_2_1(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_then_atom_node(&mut self, tm: ThenAtomNode) -> Vec<EqualThenAtomNode> {
        let mut ts = match self.element_index_then_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_0_2_1.remove(&Self::permute_0_2_1(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for EqualThenAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("equal_then_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DefinedThenAtomNode(pub ThenAtomNode, pub OptTermNode, pub TermNode);
#[derive(Clone, Hash, Debug)]
struct DefinedThenAtomNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_2_0: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<DefinedThenAtomNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<DefinedThenAtomNode>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<DefinedThenAtomNode>>,
}
impl DefinedThenAtomNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_2_0: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_opt_term_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
            element_index_then_atom_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DefinedThenAtomNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_2_0.insert(Self::permute_1_2_0(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_then_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_opt_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_opt_term_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DefinedThenAtomNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: DefinedThenAtomNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> DefinedThenAtomNode {
        DefinedThenAtomNode(
            ThenAtomNode::from(t.0),
            OptTermNode::from(t.1),
            TermNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_2_0(t: DefinedThenAtomNode) -> (u32, u32, u32) {
        (t.1.into(), t.2.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_2_0(t: (u32, u32, u32)) -> DefinedThenAtomNode {
        DefinedThenAtomNode(
            ThenAtomNode::from(t.2),
            OptTermNode::from(t.0),
            TermNode::from(t.1),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: DefinedThenAtomNode) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> DefinedThenAtomNode {
        DefinedThenAtomNode(
            ThenAtomNode::from(t.1),
            OptTermNode::from(t.2),
            TermNode::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: ThenAtomNode,
        arg1: OptTermNode,
    ) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: ThenAtomNode,
        arg1: OptTermNode,
        arg2: TermNode,
    ) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_2(
        &self,
        arg0: ThenAtomNode,
        arg2: TermNode,
    ) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
        let arg0 = arg0.0;
        let arg2 = arg2.0;
        let min = (arg2, arg0, u32::MIN);
        let max = (arg2, arg0, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: OptTermNode) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_1_2(
        &self,
        arg1: OptTermNode,
        arg2: TermNode,
    ) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg2, u32::MIN);
        let max = (arg1, arg2, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: TermNode) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_opt_term_node(&mut self, tm: OptTermNode) -> Vec<DefinedThenAtomNode> {
        let mut ts = match self.element_index_opt_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<DefinedThenAtomNode> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_then_atom_node(&mut self, tm: ThenAtomNode) -> Vec<DefinedThenAtomNode> {
        let mut ts = match self.element_index_then_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for DefinedThenAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("defined_then_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredThenAtomNode(pub ThenAtomNode, pub Ident, pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct PredThenAtomNodeTable {
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_0_2_1: BTreeSet<(u32, u32, u32)>,
    index_all_1_2_0: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_ident: BTreeMap<Ident, Vec<PredThenAtomNode>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<PredThenAtomNode>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<PredThenAtomNode>>,
}
impl PredThenAtomNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_0_2_1: BTreeSet::new(),
            index_all_1_2_0: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_ident: BTreeMap::new(),
            element_index_term_list_node: BTreeMap::new(),
            element_index_then_atom_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: PredThenAtomNode) -> bool {
        if self.index_all_0_2_1.insert(Self::permute_0_2_1(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_2_0.insert(Self::permute_1_2_0(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_then_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            match self.element_index_term_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: PredThenAtomNode) -> bool {
        self.index_all_0_2_1.contains(&Self::permute_0_2_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: PredThenAtomNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> PredThenAtomNode {
        PredThenAtomNode(
            ThenAtomNode::from(t.0),
            Ident::from(t.1),
            TermListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_0_2_1(t: PredThenAtomNode) -> (u32, u32, u32) {
        (t.0.into(), t.2.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_2_1(t: (u32, u32, u32)) -> PredThenAtomNode {
        PredThenAtomNode(
            ThenAtomNode::from(t.0),
            Ident::from(t.2),
            TermListNode::from(t.1),
        )
    }
    #[allow(unused)]
    fn permute_1_2_0(t: PredThenAtomNode) -> (u32, u32, u32) {
        (t.1.into(), t.2.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_2_0(t: (u32, u32, u32)) -> PredThenAtomNode {
        PredThenAtomNode(
            ThenAtomNode::from(t.2),
            Ident::from(t.0),
            TermListNode::from(t.1),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: PredThenAtomNode) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> PredThenAtomNode {
        PredThenAtomNode(
            ThenAtomNode::from(t.1),
            Ident::from(t.2),
            TermListNode::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = PredThenAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_2_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_2_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = PredThenAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = PredThenAtomNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_2_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_2_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: ThenAtomNode,
        arg1: Ident,
        arg2: TermListNode,
    ) -> impl '_ + Iterator<Item = PredThenAtomNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg2, arg1);
        let max = (arg0, arg2, arg1);
        self.index_all_0_2_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_2_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_2(
        &self,
        arg0: ThenAtomNode,
        arg2: TermListNode,
    ) -> impl '_ + Iterator<Item = PredThenAtomNode> {
        let arg0 = arg0.0;
        let arg2 = arg2.0;
        let min = (arg0, arg2, u32::MIN);
        let max = (arg0, arg2, u32::MAX);
        self.index_all_0_2_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_2_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = PredThenAtomNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_1_2(
        &self,
        arg1: Ident,
        arg2: TermListNode,
    ) -> impl '_ + Iterator<Item = PredThenAtomNode> {
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg2, u32::MIN);
        let max = (arg1, arg2, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: TermListNode) -> impl '_ + Iterator<Item = PredThenAtomNode> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<PredThenAtomNode> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_2_1.remove(&Self::permute_0_2_1(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<PredThenAtomNode> {
        let mut ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_2_1.remove(&Self::permute_0_2_1(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_then_atom_node(&mut self, tm: ThenAtomNode) -> Vec<PredThenAtomNode> {
        let mut ts = match self.element_index_then_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_2_1.remove(&Self::permute_0_2_1(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for PredThenAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_then_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IfStmtNode(pub StmtNode, pub IfAtomNode);
#[derive(Clone, Hash, Debug)]
struct IfStmtNodeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<IfStmtNode>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<IfStmtNode>>,
}
impl IfStmtNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: IfStmtNode) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_if_atom_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: IfStmtNode) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: IfStmtNode) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> IfStmtNode {
        IfStmtNode(StmtNode::from(t.0), IfAtomNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: IfStmtNode) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> IfStmtNode {
        IfStmtNode(StmtNode::from(t.1), IfAtomNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = IfStmtNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = IfStmtNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = IfStmtNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtNode,
        arg1: IfAtomNode,
    ) -> impl '_ + Iterator<Item = IfStmtNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: IfAtomNode) -> impl '_ + Iterator<Item = IfStmtNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(&mut self, tm: IfAtomNode) -> Vec<IfStmtNode> {
        let mut ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<IfStmtNode> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for IfStmtNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("if_stmt_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ThenStmtNode(pub StmtNode, pub ThenAtomNode);
#[derive(Clone, Hash, Debug)]
struct ThenStmtNodeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<ThenStmtNode>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<ThenStmtNode>>,
}
impl ThenStmtNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_stmt_node: BTreeMap::new(),
            element_index_then_atom_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ThenStmtNode) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_then_atom_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_then_atom_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ThenStmtNode) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ThenStmtNode) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ThenStmtNode {
        ThenStmtNode(StmtNode::from(t.0), ThenAtomNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: ThenStmtNode) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> ThenStmtNode {
        ThenStmtNode(StmtNode::from(t.1), ThenAtomNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ThenStmtNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ThenStmtNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = ThenStmtNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtNode,
        arg1: ThenAtomNode,
    ) -> impl '_ + Iterator<Item = ThenStmtNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: ThenAtomNode) -> impl '_ + Iterator<Item = ThenStmtNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<ThenStmtNode> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_then_atom_node(&mut self, tm: ThenAtomNode) -> Vec<ThenStmtNode> {
        let mut ts = match self.element_index_then_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ThenStmtNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("then_stmt_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct BranchStmtNode(pub StmtNode, pub StmtBlockListNode);
#[derive(Clone, Hash, Debug)]
struct BranchStmtNodeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_stmt_block_list_node: BTreeMap<StmtBlockListNode, Vec<BranchStmtNode>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<BranchStmtNode>>,
}
impl BranchStmtNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_stmt_block_list_node: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: BranchStmtNode) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_stmt_block_list_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_block_list_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: BranchStmtNode) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: BranchStmtNode) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> BranchStmtNode {
        BranchStmtNode(StmtNode::from(t.0), StmtBlockListNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: BranchStmtNode) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> BranchStmtNode {
        BranchStmtNode(StmtNode::from(t.1), StmtBlockListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = BranchStmtNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = BranchStmtNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = BranchStmtNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtNode,
        arg1: StmtBlockListNode,
    ) -> impl '_ + Iterator<Item = BranchStmtNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: StmtBlockListNode) -> impl '_ + Iterator<Item = BranchStmtNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_block_list_node(
        &mut self,
        tm: StmtBlockListNode,
    ) -> Vec<BranchStmtNode> {
        let mut ts = match self.element_index_stmt_block_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<BranchStmtNode> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for BranchStmtNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("branch_stmt_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchStmtNode(pub StmtNode, pub TermNode, pub MatchCaseListNode);
#[derive(Clone, Hash, Debug)]
struct MatchStmtNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_2_0: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_match_case_list_node: BTreeMap<MatchCaseListNode, Vec<MatchStmtNode>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<MatchStmtNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<MatchStmtNode>>,
}
impl MatchStmtNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_2_0: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_match_case_list_node: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: MatchStmtNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_2_0.insert(Self::permute_1_2_0(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_match_case_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_match_case_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: MatchStmtNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: MatchStmtNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> MatchStmtNode {
        MatchStmtNode(
            StmtNode::from(t.0),
            TermNode::from(t.1),
            MatchCaseListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_2_0(t: MatchStmtNode) -> (u32, u32, u32) {
        (t.1.into(), t.2.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_2_0(t: (u32, u32, u32)) -> MatchStmtNode {
        MatchStmtNode(
            StmtNode::from(t.2),
            TermNode::from(t.0),
            MatchCaseListNode::from(t.1),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: MatchStmtNode) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> MatchStmtNode {
        MatchStmtNode(
            StmtNode::from(t.1),
            TermNode::from(t.2),
            MatchCaseListNode::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = MatchStmtNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = MatchStmtNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = MatchStmtNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtNode,
        arg1: TermNode,
    ) -> impl '_ + Iterator<Item = MatchStmtNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: StmtNode,
        arg1: TermNode,
        arg2: MatchCaseListNode,
    ) -> impl '_ + Iterator<Item = MatchStmtNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_2(
        &self,
        arg0: StmtNode,
        arg2: MatchCaseListNode,
    ) -> impl '_ + Iterator<Item = MatchStmtNode> {
        let arg0 = arg0.0;
        let arg2 = arg2.0;
        let min = (arg2, arg0, u32::MIN);
        let max = (arg2, arg0, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = MatchStmtNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_1_2(
        &self,
        arg1: TermNode,
        arg2: MatchCaseListNode,
    ) -> impl '_ + Iterator<Item = MatchStmtNode> {
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg2, u32::MIN);
        let max = (arg1, arg2, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: MatchCaseListNode) -> impl '_ + Iterator<Item = MatchStmtNode> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_match_case_list_node(
        &mut self,
        tm: MatchCaseListNode,
    ) -> Vec<MatchStmtNode> {
        let mut ts = match self.element_index_match_case_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<MatchStmtNode> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<MatchStmtNode> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for MatchStmtNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("match_stmt_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilStmtListNode(pub StmtListNode);
#[derive(Clone, Hash, Debug)]
struct NilStmtListNodeTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<NilStmtListNode>>,
}
impl NilStmtListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_stmt_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NilStmtListNode) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_stmt_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NilStmtListNode) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: NilStmtListNode) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> NilStmtListNode {
        NilStmtListNode(StmtListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NilStmtListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NilStmtListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = NilStmtListNode> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_list_node(&mut self, tm: StmtListNode) -> Vec<NilStmtListNode> {
        let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for NilStmtListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_stmt_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsStmtListNode(pub StmtListNode, pub StmtNode, pub StmtListNode);
#[derive(Clone, Hash, Debug)]
struct ConsStmtListNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<ConsStmtListNode>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<ConsStmtListNode>>,
}
impl ConsStmtListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_stmt_list_node: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ConsStmtListNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_0_2.insert(Self::permute_1_0_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_stmt_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_stmt_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_stmt_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ConsStmtListNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: ConsStmtListNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> ConsStmtListNode {
        ConsStmtListNode(
            StmtListNode::from(t.0),
            StmtNode::from(t.1),
            StmtListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_0_2(t: ConsStmtListNode) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> ConsStmtListNode {
        ConsStmtListNode(
            StmtListNode::from(t.1),
            StmtNode::from(t.0),
            StmtListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: ConsStmtListNode) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> ConsStmtListNode {
        ConsStmtListNode(
            StmtListNode::from(t.1),
            StmtNode::from(t.2),
            StmtListNode::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ConsStmtListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ConsStmtListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = ConsStmtListNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtListNode,
        arg1: StmtNode,
    ) -> impl '_ + Iterator<Item = ConsStmtListNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: StmtListNode,
        arg1: StmtNode,
        arg2: StmtListNode,
    ) -> impl '_ + Iterator<Item = ConsStmtListNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_2(
        &self,
        arg0: StmtListNode,
        arg2: StmtListNode,
    ) -> impl '_ + Iterator<Item = ConsStmtListNode> {
        let arg0 = arg0.0;
        let arg2 = arg2.0;
        let min = (arg2, arg0, u32::MIN);
        let max = (arg2, arg0, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: StmtNode) -> impl '_ + Iterator<Item = ConsStmtListNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: StmtListNode) -> impl '_ + Iterator<Item = ConsStmtListNode> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_list_node(&mut self, tm: StmtListNode) -> Vec<ConsStmtListNode> {
        let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<ConsStmtListNode> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ConsStmtListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_stmt_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilStmtBlockListNode(pub StmtBlockListNode);
#[derive(Clone, Hash, Debug)]
struct NilStmtBlockListNodeTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_stmt_block_list_node: BTreeMap<StmtBlockListNode, Vec<NilStmtBlockListNode>>,
}
impl NilStmtBlockListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_stmt_block_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NilStmtBlockListNode) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_stmt_block_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_block_list_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NilStmtBlockListNode) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: NilStmtBlockListNode) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> NilStmtBlockListNode {
        NilStmtBlockListNode(StmtBlockListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NilStmtBlockListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NilStmtBlockListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(
        &self,
        arg0: StmtBlockListNode,
    ) -> impl '_ + Iterator<Item = NilStmtBlockListNode> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_block_list_node(
        &mut self,
        tm: StmtBlockListNode,
    ) -> Vec<NilStmtBlockListNode> {
        let mut ts = match self.element_index_stmt_block_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for NilStmtBlockListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_stmt_block_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsStmtBlockListNode(
    pub StmtBlockListNode,
    pub StmtListNode,
    pub StmtBlockListNode,
);
#[derive(Clone, Hash, Debug)]
struct ConsStmtBlockListNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_0_2_1: BTreeSet<(u32, u32, u32)>,
    element_index_stmt_block_list_node: BTreeMap<StmtBlockListNode, Vec<ConsStmtBlockListNode>>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<ConsStmtBlockListNode>>,
}
impl ConsStmtBlockListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_0_2_1: BTreeSet::new(),
            element_index_stmt_block_list_node: BTreeMap::new(),
            element_index_stmt_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ConsStmtBlockListNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_0_2_1.insert(Self::permute_0_2_1(t));

            match self.element_index_stmt_block_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_block_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_stmt_list_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_stmt_block_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_block_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ConsStmtBlockListNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: ConsStmtBlockListNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> ConsStmtBlockListNode {
        ConsStmtBlockListNode(
            StmtBlockListNode::from(t.0),
            StmtListNode::from(t.1),
            StmtBlockListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_0_2_1(t: ConsStmtBlockListNode) -> (u32, u32, u32) {
        (t.0.into(), t.2.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_2_1(t: (u32, u32, u32)) -> ConsStmtBlockListNode {
        ConsStmtBlockListNode(
            StmtBlockListNode::from(t.0),
            StmtListNode::from(t.2),
            StmtBlockListNode::from(t.1),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ConsStmtBlockListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ConsStmtBlockListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(
        &self,
        arg0: StmtBlockListNode,
    ) -> impl '_ + Iterator<Item = ConsStmtBlockListNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtBlockListNode,
        arg1: StmtListNode,
    ) -> impl '_ + Iterator<Item = ConsStmtBlockListNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: StmtBlockListNode,
        arg1: StmtListNode,
        arg2: StmtBlockListNode,
    ) -> impl '_ + Iterator<Item = ConsStmtBlockListNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_2(
        &self,
        arg0: StmtBlockListNode,
        arg2: StmtBlockListNode,
    ) -> impl '_ + Iterator<Item = ConsStmtBlockListNode> {
        let arg0 = arg0.0;
        let arg2 = arg2.0;
        let min = (arg0, arg2, u32::MIN);
        let max = (arg0, arg2, u32::MAX);
        self.index_all_0_2_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_2_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_block_list_node(
        &mut self,
        tm: StmtBlockListNode,
    ) -> Vec<ConsStmtBlockListNode> {
        let mut ts = match self.element_index_stmt_block_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_0_2_1.remove(&Self::permute_0_2_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_list_node(
        &mut self,
        tm: StmtListNode,
    ) -> Vec<ConsStmtBlockListNode> {
        let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_0_2_1.remove(&Self::permute_0_2_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ConsStmtBlockListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_stmt_block_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDecl(pub RuleDeclNode, pub StmtListNode);
#[derive(Clone, Hash, Debug)]
struct RuleDeclTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<RuleDecl>>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<RuleDecl>>,
}
impl RuleDeclTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_rule_decl_node: BTreeMap::new(),
            element_index_stmt_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleDecl) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_rule_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_stmt_list_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleDecl) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleDecl) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleDecl {
        RuleDecl(RuleDeclNode::from(t.0), StmtListNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: RuleDecl) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> RuleDecl {
        RuleDecl(RuleDeclNode::from(t.1), StmtListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleDecl> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleDecl> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = RuleDecl> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: RuleDeclNode,
        arg1: StmtListNode,
    ) -> impl '_ + Iterator<Item = RuleDecl> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: StmtListNode) -> impl '_ + Iterator<Item = RuleDecl> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_decl_node(&mut self, tm: RuleDeclNode) -> Vec<RuleDecl> {
        let mut ts = match self.element_index_rule_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_list_node(&mut self, tm: StmtListNode) -> Vec<RuleDecl> {
        let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for RuleDeclTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_decl"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodeType(pub DeclNode, pub TypeDeclNode);
#[derive(Clone, Hash, Debug)]
struct DeclNodeTypeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_decl_node: BTreeMap<DeclNode, Vec<DeclNodeType>>,
    element_index_type_decl_node: BTreeMap<TypeDeclNode, Vec<DeclNodeType>>,
}
impl DeclNodeTypeTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_decl_node: BTreeMap::new(),
            element_index_type_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DeclNodeType) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_decl_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DeclNodeType) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DeclNodeType) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DeclNodeType {
        DeclNodeType(DeclNode::from(t.0), TypeDeclNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DeclNodeType> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DeclNodeType> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: DeclNode,
        arg1: TypeDeclNode,
    ) -> impl '_ + Iterator<Item = DeclNodeType> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_node(&mut self, tm: DeclNode) -> Vec<DeclNodeType> {
        let mut ts = match self.element_index_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_type_decl_node(&mut self, tm: TypeDeclNode) -> Vec<DeclNodeType> {
        let mut ts = match self.element_index_type_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for DeclNodeTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_node_type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodePred(pub DeclNode, pub PredDeclNode);
#[derive(Clone, Hash, Debug)]
struct DeclNodePredTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_decl_node: BTreeMap<DeclNode, Vec<DeclNodePred>>,
    element_index_pred_decl_node: BTreeMap<PredDeclNode, Vec<DeclNodePred>>,
}
impl DeclNodePredTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_decl_node: BTreeMap::new(),
            element_index_pred_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DeclNodePred) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_pred_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_pred_decl_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DeclNodePred) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DeclNodePred) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DeclNodePred {
        DeclNodePred(DeclNode::from(t.0), PredDeclNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DeclNodePred> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DeclNodePred> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: DeclNode,
        arg1: PredDeclNode,
    ) -> impl '_ + Iterator<Item = DeclNodePred> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_node(&mut self, tm: DeclNode) -> Vec<DeclNodePred> {
        let mut ts = match self.element_index_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_pred_decl_node(&mut self, tm: PredDeclNode) -> Vec<DeclNodePred> {
        let mut ts = match self.element_index_pred_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for DeclNodePredTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_node_pred"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodeFunc(pub DeclNode, pub FuncDeclNode);
#[derive(Clone, Hash, Debug)]
struct DeclNodeFuncTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_decl_node: BTreeMap<DeclNode, Vec<DeclNodeFunc>>,
    element_index_func_decl_node: BTreeMap<FuncDeclNode, Vec<DeclNodeFunc>>,
}
impl DeclNodeFuncTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_decl_node: BTreeMap::new(),
            element_index_func_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DeclNodeFunc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_func_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_func_decl_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DeclNodeFunc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DeclNodeFunc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DeclNodeFunc {
        DeclNodeFunc(DeclNode::from(t.0), FuncDeclNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DeclNodeFunc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DeclNodeFunc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: DeclNode,
        arg1: FuncDeclNode,
    ) -> impl '_ + Iterator<Item = DeclNodeFunc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_node(&mut self, tm: DeclNode) -> Vec<DeclNodeFunc> {
        let mut ts = match self.element_index_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_func_decl_node(&mut self, tm: FuncDeclNode) -> Vec<DeclNodeFunc> {
        let mut ts = match self.element_index_func_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for DeclNodeFuncTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_node_func"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodeRule(pub DeclNode, pub RuleDeclNode);
#[derive(Clone, Hash, Debug)]
struct DeclNodeRuleTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_decl_node: BTreeMap<DeclNode, Vec<DeclNodeRule>>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<DeclNodeRule>>,
}
impl DeclNodeRuleTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_decl_node: BTreeMap::new(),
            element_index_rule_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DeclNodeRule) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_decl_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DeclNodeRule) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DeclNodeRule) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DeclNodeRule {
        DeclNodeRule(DeclNode::from(t.0), RuleDeclNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DeclNodeRule> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DeclNodeRule> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: DeclNode,
        arg1: RuleDeclNode,
    ) -> impl '_ + Iterator<Item = DeclNodeRule> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_node(&mut self, tm: DeclNode) -> Vec<DeclNodeRule> {
        let mut ts = match self.element_index_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_decl_node(&mut self, tm: RuleDeclNode) -> Vec<DeclNodeRule> {
        let mut ts = match self.element_index_rule_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for DeclNodeRuleTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_node_rule"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodeEnum(pub DeclNode, pub EnumDeclNode);
#[derive(Clone, Hash, Debug)]
struct DeclNodeEnumTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_decl_node: BTreeMap<DeclNode, Vec<DeclNodeEnum>>,
    element_index_enum_decl_node: BTreeMap<EnumDeclNode, Vec<DeclNodeEnum>>,
}
impl DeclNodeEnumTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_decl_node: BTreeMap::new(),
            element_index_enum_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DeclNodeEnum) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_enum_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_enum_decl_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DeclNodeEnum) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DeclNodeEnum) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DeclNodeEnum {
        DeclNodeEnum(DeclNode::from(t.0), EnumDeclNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DeclNodeEnum> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DeclNodeEnum> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: DeclNode,
        arg1: EnumDeclNode,
    ) -> impl '_ + Iterator<Item = DeclNodeEnum> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_node(&mut self, tm: DeclNode) -> Vec<DeclNodeEnum> {
        let mut ts = match self.element_index_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_enum_decl_node(&mut self, tm: EnumDeclNode) -> Vec<DeclNodeEnum> {
        let mut ts = match self.element_index_enum_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for DeclNodeEnumTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_node_enum"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilDeclListNode(pub DeclListNode);
#[derive(Clone, Hash, Debug)]
struct NilDeclListNodeTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_decl_list_node: BTreeMap<DeclListNode, Vec<NilDeclListNode>>,
}
impl NilDeclListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_decl_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NilDeclListNode) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_list_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NilDeclListNode) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: NilDeclListNode) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> NilDeclListNode {
        NilDeclListNode(DeclListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NilDeclListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NilDeclListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: DeclListNode) -> impl '_ + Iterator<Item = NilDeclListNode> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_list_node(&mut self, tm: DeclListNode) -> Vec<NilDeclListNode> {
        let mut ts = match self.element_index_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for NilDeclListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_decl_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsDeclListNode(pub DeclListNode, pub DeclNode, pub DeclListNode);
#[derive(Clone, Hash, Debug)]
struct ConsDeclListNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    element_index_decl_list_node: BTreeMap<DeclListNode, Vec<ConsDeclListNode>>,
    element_index_decl_node: BTreeMap<DeclNode, Vec<ConsDeclListNode>>,
}
impl ConsDeclListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            element_index_decl_list_node: BTreeMap::new(),
            element_index_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ConsDeclListNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_decl_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ConsDeclListNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: ConsDeclListNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> ConsDeclListNode {
        ConsDeclListNode(
            DeclListNode::from(t.0),
            DeclNode::from(t.1),
            DeclListNode::from(t.2),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ConsDeclListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ConsDeclListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: DeclListNode,
        arg1: DeclNode,
        arg2: DeclListNode,
    ) -> impl '_ + Iterator<Item = ConsDeclListNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_list_node(&mut self, tm: DeclListNode) -> Vec<ConsDeclListNode> {
        let mut ts = match self.element_index_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_node(&mut self, tm: DeclNode) -> Vec<ConsDeclListNode> {
        let mut ts = match self.element_index_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ConsDeclListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_decl_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclsModuleNode(pub ModuleNode, pub DeclListNode);
#[derive(Clone, Hash, Debug)]
struct DeclsModuleNodeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_decl_list_node: BTreeMap<DeclListNode, Vec<DeclsModuleNode>>,
    element_index_module_node: BTreeMap<ModuleNode, Vec<DeclsModuleNode>>,
}
impl DeclsModuleNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_decl_list_node: BTreeMap::new(),
            element_index_module_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DeclsModuleNode) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_module_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_module_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_decl_list_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_list_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DeclsModuleNode) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DeclsModuleNode) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DeclsModuleNode {
        DeclsModuleNode(ModuleNode::from(t.0), DeclListNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DeclsModuleNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DeclsModuleNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: ModuleNode,
        arg1: DeclListNode,
    ) -> impl '_ + Iterator<Item = DeclsModuleNode> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_list_node(&mut self, tm: DeclListNode) -> Vec<DeclsModuleNode> {
        let mut ts = match self.element_index_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_module_node(&mut self, tm: ModuleNode) -> Vec<DeclsModuleNode> {
        let mut ts = match self.element_index_module_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for DeclsModuleNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decls_module_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarInScope(pub VirtIdent, pub Scope);
#[derive(Clone, Hash, Debug)]
struct VarInScopeTable {
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_scope: BTreeMap<Scope, Vec<VarInScope>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<VarInScope>>,
}
impl VarInScopeTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_scope: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VarInScope) -> bool {
        if self.index_all_1_0.insert(Self::permute_1_0(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_virt_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.0, vec![t]);
                }
            };

            match self.element_index_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_scope.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VarInScope) -> bool {
        self.index_all_1_0.contains(&Self::permute_1_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: VarInScope) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> VarInScope {
        VarInScope(VirtIdent::from(t.0), Scope::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: VarInScope) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> VarInScope {
        VarInScope(VirtIdent::from(t.1), Scope::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VarInScope> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VarInScope> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: VirtIdent, arg1: Scope) -> impl '_ + Iterator<Item = VarInScope> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg1, arg0);
        let max = (arg1, arg0);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Scope) -> impl '_ + Iterator<Item = VarInScope> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_scope(&mut self, tm: Scope) -> Vec<VarInScope> {
        let mut ts = match self.element_index_scope.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_1_0.remove(&Self::permute_1_0(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(&mut self, tm: VirtIdent) -> Vec<VarInScope> {
        let mut ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_1_0.remove(&Self::permute_1_0(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for VarInScopeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_in_scope"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ScopeExtension(pub Scope, pub Scope);
#[derive(Clone, Hash, Debug)]
struct ScopeExtensionTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_scope: BTreeMap<Scope, Vec<ScopeExtension>>,
}
impl ScopeExtensionTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_scope: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ScopeExtension) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_scope.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_scope.insert(t.0, vec![t]);
                }
            };

            match self.element_index_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_scope.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ScopeExtension) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ScopeExtension) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ScopeExtension {
        ScopeExtension(Scope::from(t.0), Scope::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: ScopeExtension) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> ScopeExtension {
        ScopeExtension(Scope::from(t.1), Scope::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ScopeExtension> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ScopeExtension> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Scope) -> impl '_ + Iterator<Item = ScopeExtension> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Scope, arg1: Scope) -> impl '_ + Iterator<Item = ScopeExtension> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Scope) -> impl '_ + Iterator<Item = ScopeExtension> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_scope(&mut self, tm: Scope) -> Vec<ScopeExtension> {
        let mut ts = match self.element_index_scope.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ScopeExtensionTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("scope_extension"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ScopeSingleChild(pub RuleDescendantNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct ScopeSingleChildTable {
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<ScopeSingleChild>>,
}
impl ScopeSingleChildTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_rule_descendant_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ScopeSingleChild) -> bool {
        if self.index_all_1_0.insert(Self::permute_1_0(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_rule_descendant_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_descendant_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_descendant_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ScopeSingleChild) -> bool {
        self.index_all_1_0.contains(&Self::permute_1_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ScopeSingleChild) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ScopeSingleChild {
        ScopeSingleChild(RuleDescendantNode::from(t.0), RuleDescendantNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: ScopeSingleChild) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> ScopeSingleChild {
        ScopeSingleChild(RuleDescendantNode::from(t.1), RuleDescendantNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ScopeSingleChild> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ScopeSingleChild> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: RuleDescendantNode,
        arg1: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = ScopeSingleChild> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg1, arg0);
        let max = (arg1, arg0);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = ScopeSingleChild> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_descendant_node(
        &mut self,
        tm: RuleDescendantNode,
    ) -> Vec<ScopeSingleChild> {
        let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_1_0.remove(&Self::permute_1_0(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ScopeSingleChildTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("scope_single_child"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ScopeExtensionSiblings(
    pub RuleDescendantNode,
    pub RuleDescendantNode,
    pub RuleDescendantNode,
);
#[derive(Clone, Hash, Debug)]
struct ScopeExtensionSiblingsTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<ScopeExtensionSiblings>>,
}
impl ScopeExtensionSiblingsTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_rule_descendant_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ScopeExtensionSiblings) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_0_2.insert(Self::permute_1_0_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_rule_descendant_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_descendant_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_descendant_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_rule_descendant_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_descendant_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ScopeExtensionSiblings) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: ScopeExtensionSiblings) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> ScopeExtensionSiblings {
        ScopeExtensionSiblings(
            RuleDescendantNode::from(t.0),
            RuleDescendantNode::from(t.1),
            RuleDescendantNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_0_2(t: ScopeExtensionSiblings) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> ScopeExtensionSiblings {
        ScopeExtensionSiblings(
            RuleDescendantNode::from(t.1),
            RuleDescendantNode::from(t.0),
            RuleDescendantNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: ScopeExtensionSiblings) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> ScopeExtensionSiblings {
        ScopeExtensionSiblings(
            RuleDescendantNode::from(t.1),
            RuleDescendantNode::from(t.2),
            RuleDescendantNode::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ScopeExtensionSiblings> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ScopeExtensionSiblings> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(
        &self,
        arg0: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = ScopeExtensionSiblings> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: RuleDescendantNode,
        arg1: RuleDescendantNode,
        arg2: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = ScopeExtensionSiblings> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(
        &self,
        arg1: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = ScopeExtensionSiblings> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(
        &self,
        arg2: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = ScopeExtensionSiblings> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_descendant_node(
        &mut self,
        tm: RuleDescendantNode,
    ) -> Vec<ScopeExtensionSiblings> {
        let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ScopeExtensionSiblingsTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("scope_extension_siblings"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RelApp(pub Rel, pub ElList);
#[derive(Clone, Hash, Debug)]
struct RelAppTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_el_list: BTreeMap<ElList, Vec<RelApp>>,
    element_index_rel: BTreeMap<Rel, Vec<RelApp>>,
}
impl RelAppTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_el_list: BTreeMap::new(),
            element_index_rel: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RelApp) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_rel.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rel.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RelApp) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RelApp) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RelApp {
        RelApp(Rel::from(t.0), ElList::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: RelApp) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> RelApp {
        RelApp(Rel::from(t.1), ElList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RelApp> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RelApp> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Rel) -> impl '_ + Iterator<Item = RelApp> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Rel, arg1: ElList) -> impl '_ + Iterator<Item = RelApp> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: ElList) -> impl '_ + Iterator<Item = RelApp> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<RelApp> {
        let mut ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_rel(&mut self, tm: Rel) -> Vec<RelApp> {
        let mut ts = match self.element_index_rel.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for RelAppTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rel_app"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElType(pub El, pub Type);
#[derive(Clone, Hash, Debug)]
struct ElTypeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_el: BTreeMap<El, Vec<ElType>>,
    element_index_type: BTreeMap<Type, Vec<ElType>>,
}
impl ElTypeTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_el: BTreeMap::new(),
            element_index_type: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ElType) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ElType) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ElType) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ElType {
        ElType(El::from(t.0), Type::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: ElType) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> ElType {
        ElType(El::from(t.1), Type::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ElType> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ElType> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: El) -> impl '_ + Iterator<Item = ElType> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: El, arg1: Type) -> impl '_ + Iterator<Item = ElType> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Type) -> impl '_ + Iterator<Item = ElType> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> Vec<ElType> {
        let mut ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_type(&mut self, tm: Type) -> Vec<ElType> {
        let mut ts = match self.element_index_type.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ElTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("el_type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElTypes(pub ElList, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct ElTypesTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_el_list: BTreeMap<ElList, Vec<ElTypes>>,
    element_index_type_list: BTreeMap<TypeList, Vec<ElTypes>>,
}
impl ElTypesTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_el_list: BTreeMap::new(),
            element_index_type_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ElTypes) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_el_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_list.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ElTypes) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ElTypes) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ElTypes {
        ElTypes(ElList::from(t.0), TypeList::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: ElTypes) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> ElTypes {
        ElTypes(ElList::from(t.1), TypeList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ElTypes> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ElTypes> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ElList) -> impl '_ + Iterator<Item = ElTypes> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: ElList, arg1: TypeList) -> impl '_ + Iterator<Item = ElTypes> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TypeList) -> impl '_ + Iterator<Item = ElTypes> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<ElTypes> {
        let mut ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<ElTypes> {
        let mut ts = match self.element_index_type_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ElTypesTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("el_types"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConstrainedEl(pub El);
#[derive(Clone, Hash, Debug)]
struct ConstrainedElTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_el: BTreeMap<El, Vec<ConstrainedEl>>,
}
impl ConstrainedElTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_el: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ConstrainedEl) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ConstrainedEl) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: ConstrainedEl) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> ConstrainedEl {
        ConstrainedEl(El::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ConstrainedEl> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ConstrainedEl> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: El) -> impl '_ + Iterator<Item = ConstrainedEl> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> Vec<ConstrainedEl> {
        let mut ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ConstrainedElTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("constrained_el"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConstrainedEls(pub ElList);
#[derive(Clone, Hash, Debug)]
struct ConstrainedElsTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_el_list: BTreeMap<ElList, Vec<ConstrainedEls>>,
}
impl ConstrainedElsTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_el_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ConstrainedEls) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_el_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ConstrainedEls) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: ConstrainedEls) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> ConstrainedEls {
        ConstrainedEls(ElList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ConstrainedEls> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ConstrainedEls> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ElList) -> impl '_ + Iterator<Item = ConstrainedEls> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<ConstrainedEls> {
        let mut ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ConstrainedElsTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("constrained_els"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct InKer(pub Morphism, pub El, pub El);
#[derive(Clone, Hash, Debug)]
struct InKerTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    element_index_el: BTreeMap<El, Vec<InKer>>,
    element_index_morphism: BTreeMap<Morphism, Vec<InKer>>,
}
impl InKerTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            element_index_el: BTreeMap::new(),
            element_index_morphism: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: InKer) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.1, vec![t]);
                }
            };

            match self.element_index_el.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: InKer) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: InKer) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> InKer {
        InKer(Morphism::from(t.0), El::from(t.1), El::from(t.2))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = InKer> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = InKer> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Morphism,
        arg1: El,
        arg2: El,
    ) -> impl '_ + Iterator<Item = InKer> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> Vec<InKer> {
        let mut ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<InKer> {
        let mut ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for InKerTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("in_ker"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElInImg(pub Morphism, pub El);
#[derive(Clone, Hash, Debug)]
struct ElInImgTable {
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_el: BTreeMap<El, Vec<ElInImg>>,
    element_index_morphism: BTreeMap<Morphism, Vec<ElInImg>>,
}
impl ElInImgTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_el: BTreeMap::new(),
            element_index_morphism: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ElInImg) -> bool {
        if self.index_all_1_0.insert(Self::permute_1_0(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ElInImg) -> bool {
        self.index_all_1_0.contains(&Self::permute_1_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ElInImg) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ElInImg {
        ElInImg(Morphism::from(t.0), El::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: ElInImg) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> ElInImg {
        ElInImg(Morphism::from(t.1), El::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ElInImg> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ElInImg> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Morphism, arg1: El) -> impl '_ + Iterator<Item = ElInImg> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg1, arg0);
        let max = (arg1, arg0);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: El) -> impl '_ + Iterator<Item = ElInImg> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> Vec<ElInImg> {
        let mut ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_1_0.remove(&Self::permute_1_0(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<ElInImg> {
        let mut ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_1_0.remove(&Self::permute_1_0(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ElInImgTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("el_in_img"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RelTupleInImg(pub Morphism, pub Rel, pub ElList);
#[derive(Clone, Hash, Debug)]
struct RelTupleInImgTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    element_index_el_list: BTreeMap<ElList, Vec<RelTupleInImg>>,
    element_index_morphism: BTreeMap<Morphism, Vec<RelTupleInImg>>,
    element_index_rel: BTreeMap<Rel, Vec<RelTupleInImg>>,
}
impl RelTupleInImgTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            element_index_el_list: BTreeMap::new(),
            element_index_morphism: BTreeMap::new(),
            element_index_rel: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RelTupleInImg) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rel.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rel.insert(t.1, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RelTupleInImg) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: RelTupleInImg) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> RelTupleInImg {
        RelTupleInImg(Morphism::from(t.0), Rel::from(t.1), ElList::from(t.2))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RelTupleInImg> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RelTupleInImg> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Morphism,
        arg1: Rel,
        arg2: ElList,
    ) -> impl '_ + Iterator<Item = RelTupleInImg> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<RelTupleInImg> {
        let mut ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<RelTupleInImg> {
        let mut ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_rel(&mut self, tm: Rel) -> Vec<RelTupleInImg> {
        let mut ts = match self.element_index_rel.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for RelTupleInImgTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rel_tuple_in_img"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DefinedSymbol(pub Ident, pub SymbolKind, pub Loc);
#[derive(Clone, Hash, Debug)]
struct DefinedSymbolTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    element_index_ident: BTreeMap<Ident, Vec<DefinedSymbol>>,
    element_index_loc: BTreeMap<Loc, Vec<DefinedSymbol>>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<DefinedSymbol>>,
}
impl DefinedSymbolTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            element_index_ident: BTreeMap::new(),
            element_index_loc: BTreeMap::new(),
            element_index_symbol_kind: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DefinedSymbol) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.0, vec![t]);
                }
            };

            match self.element_index_symbol_kind.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_symbol_kind.insert(t.1, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DefinedSymbol) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: DefinedSymbol) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> DefinedSymbol {
        DefinedSymbol(Ident::from(t.0), SymbolKind::from(t.1), Loc::from(t.2))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DefinedSymbol> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DefinedSymbol> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Ident,
        arg1: SymbolKind,
        arg2: Loc,
    ) -> impl '_ + Iterator<Item = DefinedSymbol> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<DefinedSymbol> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<DefinedSymbol> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<DefinedSymbol> {
        let mut ts = match self.element_index_symbol_kind.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for DefinedSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("defined_symbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ShouldBeSymbol(pub Ident, pub SymbolKind, pub Loc);
#[derive(Clone, Hash, Debug)]
struct ShouldBeSymbolTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    element_index_ident: BTreeMap<Ident, Vec<ShouldBeSymbol>>,
    element_index_loc: BTreeMap<Loc, Vec<ShouldBeSymbol>>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<ShouldBeSymbol>>,
}
impl ShouldBeSymbolTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            element_index_ident: BTreeMap::new(),
            element_index_loc: BTreeMap::new(),
            element_index_symbol_kind: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ShouldBeSymbol) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.0, vec![t]);
                }
            };

            match self.element_index_symbol_kind.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_symbol_kind.insert(t.1, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ShouldBeSymbol) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: ShouldBeSymbol) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> ShouldBeSymbol {
        ShouldBeSymbol(Ident::from(t.0), SymbolKind::from(t.1), Loc::from(t.2))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ShouldBeSymbol> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ShouldBeSymbol> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Ident,
        arg1: SymbolKind,
        arg2: Loc,
    ) -> impl '_ + Iterator<Item = ShouldBeSymbol> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<ShouldBeSymbol> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<ShouldBeSymbol> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<ShouldBeSymbol> {
        let mut ts = match self.element_index_symbol_kind.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ShouldBeSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("should_be_symbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ShouldBeSymbol2(pub Ident, pub SymbolKind, pub SymbolKind, pub Loc);
#[derive(Clone, Hash, Debug)]
struct ShouldBeSymbol2Table {
    index_all_0_1_2_3: BTreeSet<(u32, u32, u32, u32)>,
    index_dirty_0_1_2_3: BTreeSet<(u32, u32, u32, u32)>,
    element_index_ident: BTreeMap<Ident, Vec<ShouldBeSymbol2>>,
    element_index_loc: BTreeMap<Loc, Vec<ShouldBeSymbol2>>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<ShouldBeSymbol2>>,
}
impl ShouldBeSymbol2Table {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_all_0_1_2_3: BTreeSet::new(),
            index_dirty_0_1_2_3: BTreeSet::new(),
            element_index_ident: BTreeMap::new(),
            element_index_loc: BTreeMap::new(),
            element_index_symbol_kind: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ShouldBeSymbol2) -> bool {
        if self.index_all_0_1_2_3.insert(Self::permute_0_1_2_3(t)) {
            self.index_dirty_0_1_2_3.insert(Self::permute_0_1_2_3(t));

            match self.element_index_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.0, vec![t]);
                }
            };

            match self.element_index_symbol_kind.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_symbol_kind.insert(t.1, vec![t]);
                }
            };

            match self.element_index_symbol_kind.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_symbol_kind.insert(t.2, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.3) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.3, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ShouldBeSymbol2) -> bool {
        self.index_all_0_1_2_3.contains(&Self::permute_0_1_2_3(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2_3.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2_3.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2_3(t: ShouldBeSymbol2) -> (u32, u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into(), t.3.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2_3(t: (u32, u32, u32, u32)) -> ShouldBeSymbol2 {
        ShouldBeSymbol2(
            Ident::from(t.0),
            SymbolKind::from(t.1),
            SymbolKind::from(t.2),
            Loc::from(t.3),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ShouldBeSymbol2> {
        let min = (u32::MIN, u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2_3
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2_3)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ShouldBeSymbol2> {
        let min = (u32::MIN, u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2_3
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2_3)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2_3(
        &self,
        arg0: Ident,
        arg1: SymbolKind,
        arg2: SymbolKind,
        arg3: Loc,
    ) -> impl '_ + Iterator<Item = ShouldBeSymbol2> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let arg3 = arg3.0;
        let min = (arg0, arg1, arg2, arg3);
        let max = (arg0, arg1, arg2, arg3);
        self.index_all_0_1_2_3
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2_3)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<ShouldBeSymbol2> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
                self.index_dirty_0_1_2_3.remove(&Self::permute_0_1_2_3(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<ShouldBeSymbol2> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
                self.index_dirty_0_1_2_3.remove(&Self::permute_0_1_2_3(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<ShouldBeSymbol2> {
        let mut ts = match self.element_index_symbol_kind.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
                self.index_dirty_0_1_2_3.remove(&Self::permute_0_1_2_3(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ShouldBeSymbol2Table {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("should_be_symbol_2"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredArgNumShouldMatch(pub Nat, pub Nat, pub Loc);
#[derive(Clone, Hash, Debug)]
struct PredArgNumShouldMatchTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    element_index_loc: BTreeMap<Loc, Vec<PredArgNumShouldMatch>>,
    element_index_nat: BTreeMap<Nat, Vec<PredArgNumShouldMatch>>,
}
impl PredArgNumShouldMatchTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            element_index_loc: BTreeMap::new(),
            element_index_nat: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: PredArgNumShouldMatch) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_nat.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_nat.insert(t.0, vec![t]);
                }
            };

            match self.element_index_nat.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_nat.insert(t.1, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: PredArgNumShouldMatch) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: PredArgNumShouldMatch) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> PredArgNumShouldMatch {
        PredArgNumShouldMatch(Nat::from(t.0), Nat::from(t.1), Loc::from(t.2))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = PredArgNumShouldMatch> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = PredArgNumShouldMatch> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Nat,
        arg1: Nat,
        arg2: Loc,
    ) -> impl '_ + Iterator<Item = PredArgNumShouldMatch> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<PredArgNumShouldMatch> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_nat(&mut self, tm: Nat) -> Vec<PredArgNumShouldMatch> {
        let mut ts = match self.element_index_nat.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for PredArgNumShouldMatchTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_arg_num_should_match"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncArgNumShouldMatch(pub Nat, pub Nat, pub Loc);
#[derive(Clone, Hash, Debug)]
struct FuncArgNumShouldMatchTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    element_index_loc: BTreeMap<Loc, Vec<FuncArgNumShouldMatch>>,
    element_index_nat: BTreeMap<Nat, Vec<FuncArgNumShouldMatch>>,
}
impl FuncArgNumShouldMatchTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            element_index_loc: BTreeMap::new(),
            element_index_nat: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: FuncArgNumShouldMatch) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_nat.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_nat.insert(t.0, vec![t]);
                }
            };

            match self.element_index_nat.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_nat.insert(t.1, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: FuncArgNumShouldMatch) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: FuncArgNumShouldMatch) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> FuncArgNumShouldMatch {
        FuncArgNumShouldMatch(Nat::from(t.0), Nat::from(t.1), Loc::from(t.2))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = FuncArgNumShouldMatch> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = FuncArgNumShouldMatch> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Nat,
        arg1: Nat,
        arg2: Loc,
    ) -> impl '_ + Iterator<Item = FuncArgNumShouldMatch> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<FuncArgNumShouldMatch> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_nat(&mut self, tm: Nat) -> Vec<FuncArgNumShouldMatch> {
        let mut ts = match self.element_index_nat.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for FuncArgNumShouldMatchTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("func_arg_num_should_match"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CfgEdge(pub StmtNode, pub StmtNode);
#[derive(Clone, Hash, Debug)]
struct CfgEdgeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<CfgEdge>>,
}
impl CfgEdgeTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: CfgEdge) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_stmt_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: CfgEdge) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: CfgEdge) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> CfgEdge {
        CfgEdge(StmtNode::from(t.0), StmtNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = CfgEdge> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = CfgEdge> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = CfgEdge> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: StmtNode, arg1: StmtNode) -> impl '_ + Iterator<Item = CfgEdge> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<CfgEdge> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for CfgEdgeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cfg_edge"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CfgEdgeStmtsStmt(pub StmtListNode, pub StmtNode);
#[derive(Clone, Hash, Debug)]
struct CfgEdgeStmtsStmtTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<CfgEdgeStmtsStmt>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<CfgEdgeStmtsStmt>>,
}
impl CfgEdgeStmtsStmtTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_stmt_list_node: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: CfgEdgeStmtsStmt) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_stmt_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_stmt_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: CfgEdgeStmtsStmt) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: CfgEdgeStmtsStmt) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> CfgEdgeStmtsStmt {
        CfgEdgeStmtsStmt(StmtListNode::from(t.0), StmtNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = CfgEdgeStmtsStmt> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = CfgEdgeStmtsStmt> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = CfgEdgeStmtsStmt> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtListNode,
        arg1: StmtNode,
    ) -> impl '_ + Iterator<Item = CfgEdgeStmtsStmt> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_list_node(&mut self, tm: StmtListNode) -> Vec<CfgEdgeStmtsStmt> {
        let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<CfgEdgeStmtsStmt> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for CfgEdgeStmtsStmtTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cfg_edge_stmts_stmt"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CfgEdgeStmtStmts(pub StmtNode, pub StmtListNode);
#[derive(Clone, Hash, Debug)]
struct CfgEdgeStmtStmtsTable {
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<CfgEdgeStmtStmts>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<CfgEdgeStmtStmts>>,
}
impl CfgEdgeStmtStmtsTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_stmt_list_node: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: CfgEdgeStmtStmts) -> bool {
        if self.index_all_1_0.insert(Self::permute_1_0(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_stmt_list_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: CfgEdgeStmtStmts) -> bool {
        self.index_all_1_0.contains(&Self::permute_1_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: CfgEdgeStmtStmts) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> CfgEdgeStmtStmts {
        CfgEdgeStmtStmts(StmtNode::from(t.0), StmtListNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: CfgEdgeStmtStmts) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> CfgEdgeStmtStmts {
        CfgEdgeStmtStmts(StmtNode::from(t.1), StmtListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = CfgEdgeStmtStmts> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = CfgEdgeStmtStmts> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtNode,
        arg1: StmtListNode,
    ) -> impl '_ + Iterator<Item = CfgEdgeStmtStmts> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg1, arg0);
        let max = (arg1, arg0);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: StmtListNode) -> impl '_ + Iterator<Item = CfgEdgeStmtStmts> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_list_node(&mut self, tm: StmtListNode) -> Vec<CfgEdgeStmtStmts> {
        let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_1_0.remove(&Self::permute_1_0(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<CfgEdgeStmtStmts> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_1_0.remove(&Self::permute_1_0(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for CfgEdgeStmtStmtsTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cfg_edge_stmt_stmts"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CfgEdgeFork(pub StmtNode, pub StmtBlockListNode);
#[derive(Clone, Hash, Debug)]
struct CfgEdgeForkTable {
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_stmt_block_list_node: BTreeMap<StmtBlockListNode, Vec<CfgEdgeFork>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<CfgEdgeFork>>,
}
impl CfgEdgeForkTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_stmt_block_list_node: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: CfgEdgeFork) -> bool {
        if self.index_all_1_0.insert(Self::permute_1_0(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_stmt_block_list_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_block_list_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: CfgEdgeFork) -> bool {
        self.index_all_1_0.contains(&Self::permute_1_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: CfgEdgeFork) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> CfgEdgeFork {
        CfgEdgeFork(StmtNode::from(t.0), StmtBlockListNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: CfgEdgeFork) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> CfgEdgeFork {
        CfgEdgeFork(StmtNode::from(t.1), StmtBlockListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = CfgEdgeFork> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = CfgEdgeFork> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtNode,
        arg1: StmtBlockListNode,
    ) -> impl '_ + Iterator<Item = CfgEdgeFork> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg1, arg0);
        let max = (arg1, arg0);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: StmtBlockListNode) -> impl '_ + Iterator<Item = CfgEdgeFork> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_block_list_node(
        &mut self,
        tm: StmtBlockListNode,
    ) -> Vec<CfgEdgeFork> {
        let mut ts = match self.element_index_stmt_block_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_1_0.remove(&Self::permute_1_0(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<CfgEdgeFork> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_1_0.remove(&Self::permute_1_0(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for CfgEdgeForkTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cfg_edge_fork"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CfgEdgeJoin(pub StmtBlockListNode, pub StmtNode);
#[derive(Clone, Hash, Debug)]
struct CfgEdgeJoinTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_stmt_block_list_node: BTreeMap<StmtBlockListNode, Vec<CfgEdgeJoin>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<CfgEdgeJoin>>,
}
impl CfgEdgeJoinTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_stmt_block_list_node: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: CfgEdgeJoin) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_stmt_block_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_block_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_stmt_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: CfgEdgeJoin) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: CfgEdgeJoin) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> CfgEdgeJoin {
        CfgEdgeJoin(StmtBlockListNode::from(t.0), StmtNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = CfgEdgeJoin> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = CfgEdgeJoin> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtBlockListNode) -> impl '_ + Iterator<Item = CfgEdgeJoin> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtBlockListNode,
        arg1: StmtNode,
    ) -> impl '_ + Iterator<Item = CfgEdgeJoin> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_block_list_node(
        &mut self,
        tm: StmtBlockListNode,
    ) -> Vec<CfgEdgeJoin> {
        let mut ts = match self.element_index_stmt_block_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<CfgEdgeJoin> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for CfgEdgeJoinTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cfg_edge_join"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct BeforeStmtStructure(pub StmtNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct BeforeStmtStructureTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<BeforeStmtStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<BeforeStmtStructure>>,
}
impl BeforeStmtStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_stmt_node: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: BeforeStmtStructure) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: BeforeStmtStructure) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: BeforeStmtStructure) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> BeforeStmtStructure {
        BeforeStmtStructure(StmtNode::from(t.0), Structure::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: BeforeStmtStructure) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> BeforeStmtStructure {
        BeforeStmtStructure(StmtNode::from(t.1), Structure::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = BeforeStmtStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = BeforeStmtStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = BeforeStmtStructure> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = BeforeStmtStructure> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = BeforeStmtStructure> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<BeforeStmtStructure> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<BeforeStmtStructure> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for BeforeStmtStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("before_stmt_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct StmtMorphism(pub StmtNode, pub Morphism);
#[derive(Clone, Hash, Debug)]
struct StmtMorphismTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_morphism: BTreeMap<Morphism, Vec<StmtMorphism>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<StmtMorphism>>,
}
impl StmtMorphismTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_morphism: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: StmtMorphism) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_morphism.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: StmtMorphism) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: StmtMorphism) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> StmtMorphism {
        StmtMorphism(StmtNode::from(t.0), Morphism::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: StmtMorphism) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> StmtMorphism {
        StmtMorphism(StmtNode::from(t.1), Morphism::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = StmtMorphism> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = StmtMorphism> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = StmtMorphism> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtNode,
        arg1: Morphism,
    ) -> impl '_ + Iterator<Item = StmtMorphism> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Morphism) -> impl '_ + Iterator<Item = StmtMorphism> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<StmtMorphism> {
        let mut ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<StmtMorphism> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for StmtMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("stmt_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IfMorphism(pub Morphism);
#[derive(Clone, Hash, Debug)]
struct IfMorphismTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_morphism: BTreeMap<Morphism, Vec<IfMorphism>>,
}
impl IfMorphismTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_morphism: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: IfMorphism) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: IfMorphism) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: IfMorphism) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> IfMorphism {
        IfMorphism(Morphism::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = IfMorphism> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = IfMorphism> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = IfMorphism> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<IfMorphism> {
        let mut ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for IfMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("if_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SurjThenMorphism(pub Morphism);
#[derive(Clone, Hash, Debug)]
struct SurjThenMorphismTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_morphism: BTreeMap<Morphism, Vec<SurjThenMorphism>>,
}
impl SurjThenMorphismTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_morphism: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: SurjThenMorphism) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: SurjThenMorphism) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: SurjThenMorphism) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> SurjThenMorphism {
        SurjThenMorphism(Morphism::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = SurjThenMorphism> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = SurjThenMorphism> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = SurjThenMorphism> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<SurjThenMorphism> {
        let mut ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for SurjThenMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("surj_then_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NonSurjThenMorphism(pub Morphism);
#[derive(Clone, Hash, Debug)]
struct NonSurjThenMorphismTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_morphism: BTreeMap<Morphism, Vec<NonSurjThenMorphism>>,
}
impl NonSurjThenMorphismTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_morphism: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NonSurjThenMorphism) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NonSurjThenMorphism) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: NonSurjThenMorphism) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> NonSurjThenMorphism {
        NonSurjThenMorphism(Morphism::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NonSurjThenMorphism> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NonSurjThenMorphism> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = NonSurjThenMorphism> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<NonSurjThenMorphism> {
        let mut ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for NonSurjThenMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("non_surj_then_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NoopMorphism(pub Morphism);
#[derive(Clone, Hash, Debug)]
struct NoopMorphismTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_morphism: BTreeMap<Morphism, Vec<NoopMorphism>>,
}
impl NoopMorphismTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_morphism: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NoopMorphism) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NoopMorphism) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: NoopMorphism) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> NoopMorphism {
        NoopMorphism(Morphism::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NoopMorphism> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NoopMorphism> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = NoopMorphism> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<NoopMorphism> {
        let mut ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for NoopMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("noop_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct StmtStructure(pub StmtNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct StmtStructureTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<StmtStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<StmtStructure>>,
}
impl StmtStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_stmt_node: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: StmtStructure) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: StmtStructure) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: StmtStructure) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> StmtStructure {
        StmtStructure(StmtNode::from(t.0), Structure::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = StmtStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = StmtStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = StmtStructure> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = StmtStructure> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<StmtStructure> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<StmtStructure> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for StmtStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("stmt_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IfAtomStructure(pub IfAtomNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct IfAtomStructureTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<IfAtomStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<IfAtomStructure>>,
}
impl IfAtomStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: IfAtomStructure) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: IfAtomStructure) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: IfAtomStructure) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> IfAtomStructure {
        IfAtomStructure(IfAtomNode::from(t.0), Structure::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = IfAtomStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = IfAtomStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = IfAtomStructure> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: IfAtomNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = IfAtomStructure> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(&mut self, tm: IfAtomNode) -> Vec<IfAtomStructure> {
        let mut ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<IfAtomStructure> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for IfAtomStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("if_atom_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ThenAtomStructure(pub ThenAtomNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct ThenAtomStructureTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_structure: BTreeMap<Structure, Vec<ThenAtomStructure>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<ThenAtomStructure>>,
}
impl ThenAtomStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_structure: BTreeMap::new(),
            element_index_then_atom_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ThenAtomStructure) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_then_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ThenAtomStructure) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ThenAtomStructure) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ThenAtomStructure {
        ThenAtomStructure(ThenAtomNode::from(t.0), Structure::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ThenAtomStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ThenAtomStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = ThenAtomStructure> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: ThenAtomNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = ThenAtomStructure> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<ThenAtomStructure> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_then_atom_node(&mut self, tm: ThenAtomNode) -> Vec<ThenAtomStructure> {
        let mut ts = match self.element_index_then_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ThenAtomStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("then_atom_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermStructure(pub TermNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct TermStructureTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_structure: BTreeMap<Structure, Vec<TermStructure>>,
    element_index_term_node: BTreeMap<TermNode, Vec<TermStructure>>,
}
impl TermStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_structure: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TermStructure) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TermStructure) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: TermStructure) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> TermStructure {
        TermStructure(TermNode::from(t.0), Structure::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TermStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TermStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = TermStructure> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TermNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = TermStructure> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<TermStructure> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<TermStructure> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for TermStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("term_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermsStructure(pub TermListNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct TermsStructureTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_structure: BTreeMap<Structure, Vec<TermsStructure>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<TermsStructure>>,
}
impl TermsStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_structure: BTreeMap::new(),
            element_index_term_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TermsStructure) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TermsStructure) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: TermsStructure) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> TermsStructure {
        TermsStructure(TermListNode::from(t.0), Structure::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: TermsStructure) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> TermsStructure {
        TermsStructure(TermListNode::from(t.1), Structure::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TermsStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TermsStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = TermsStructure> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TermListNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = TermsStructure> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = TermsStructure> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<TermsStructure> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<TermsStructure> {
        let mut ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for TermsStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("terms_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct OptTermStructure(pub OptTermNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct OptTermStructureTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<OptTermStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<OptTermStructure>>,
}
impl OptTermStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_opt_term_node: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: OptTermStructure) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_opt_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_opt_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: OptTermStructure) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: OptTermStructure) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> OptTermStructure {
        OptTermStructure(OptTermNode::from(t.0), Structure::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = OptTermStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = OptTermStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: OptTermNode) -> impl '_ + Iterator<Item = OptTermStructure> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: OptTermNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = OptTermStructure> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_opt_term_node(&mut self, tm: OptTermNode) -> Vec<OptTermStructure> {
        let mut ts = match self.element_index_opt_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<OptTermStructure> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for OptTermStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("opt_term_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermShouldBeEpicOk(pub TermNode);
#[derive(Clone, Hash, Debug)]
struct TermShouldBeEpicOkTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_term_node: BTreeMap<TermNode, Vec<TermShouldBeEpicOk>>,
}
impl TermShouldBeEpicOkTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TermShouldBeEpicOk) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TermShouldBeEpicOk) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: TermShouldBeEpicOk) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> TermShouldBeEpicOk {
        TermShouldBeEpicOk(TermNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TermShouldBeEpicOk> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TermShouldBeEpicOk> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = TermShouldBeEpicOk> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<TermShouldBeEpicOk> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for TermShouldBeEpicOkTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("term_should_be_epic_ok"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermsShouldBeEpicOk(pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct TermsShouldBeEpicOkTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<TermsShouldBeEpicOk>>,
}
impl TermsShouldBeEpicOkTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_term_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TermsShouldBeEpicOk) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TermsShouldBeEpicOk) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: TermsShouldBeEpicOk) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> TermsShouldBeEpicOk {
        TermsShouldBeEpicOk(TermListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TermsShouldBeEpicOk> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TermsShouldBeEpicOk> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = TermsShouldBeEpicOk> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<TermsShouldBeEpicOk> {
        let mut ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for TermsShouldBeEpicOkTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("terms_should_be_epic_ok"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElShouldBeSurjectiveOk(pub El);
#[derive(Clone, Hash, Debug)]
struct ElShouldBeSurjectiveOkTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_el: BTreeMap<El, Vec<ElShouldBeSurjectiveOk>>,
}
impl ElShouldBeSurjectiveOkTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_el: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ElShouldBeSurjectiveOk) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ElShouldBeSurjectiveOk) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: ElShouldBeSurjectiveOk) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> ElShouldBeSurjectiveOk {
        ElShouldBeSurjectiveOk(El::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ElShouldBeSurjectiveOk> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ElShouldBeSurjectiveOk> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: El) -> impl '_ + Iterator<Item = ElShouldBeSurjectiveOk> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> Vec<ElShouldBeSurjectiveOk> {
        let mut ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ElShouldBeSurjectiveOkTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("el_should_be_surjective_ok"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElIsSurjectiveOk(pub El);
#[derive(Clone, Hash, Debug)]
struct ElIsSurjectiveOkTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_el: BTreeMap<El, Vec<ElIsSurjectiveOk>>,
}
impl ElIsSurjectiveOkTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_el: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ElIsSurjectiveOk) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ElIsSurjectiveOk) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: ElIsSurjectiveOk) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> ElIsSurjectiveOk {
        ElIsSurjectiveOk(El::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ElIsSurjectiveOk> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ElIsSurjectiveOk> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: El) -> impl '_ + Iterator<Item = ElIsSurjectiveOk> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> Vec<ElIsSurjectiveOk> {
        let mut ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ElIsSurjectiveOkTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("el_is_surjective_ok"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ShouldBeObtainedByCtor(pub TermNode, pub EnumDeclNode);
#[derive(Clone, Hash, Debug)]
struct ShouldBeObtainedByCtorTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_enum_decl_node: BTreeMap<EnumDeclNode, Vec<ShouldBeObtainedByCtor>>,
    element_index_term_node: BTreeMap<TermNode, Vec<ShouldBeObtainedByCtor>>,
}
impl ShouldBeObtainedByCtorTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_enum_decl_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ShouldBeObtainedByCtor) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_enum_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_enum_decl_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ShouldBeObtainedByCtor) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ShouldBeObtainedByCtor) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ShouldBeObtainedByCtor {
        ShouldBeObtainedByCtor(TermNode::from(t.0), EnumDeclNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ShouldBeObtainedByCtor> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ShouldBeObtainedByCtor> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TermNode,
        arg1: EnumDeclNode,
    ) -> impl '_ + Iterator<Item = ShouldBeObtainedByCtor> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_enum_decl_node(
        &mut self,
        tm: EnumDeclNode,
    ) -> Vec<ShouldBeObtainedByCtor> {
        let mut ts = match self.element_index_enum_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<ShouldBeObtainedByCtor> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ShouldBeObtainedByCtorTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("should_be_obtained_by_ctor"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IsGivenByCtor(pub TermNode, pub EnumDeclNode);
#[derive(Clone, Hash, Debug)]
struct IsGivenByCtorTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_enum_decl_node: BTreeMap<EnumDeclNode, Vec<IsGivenByCtor>>,
    element_index_term_node: BTreeMap<TermNode, Vec<IsGivenByCtor>>,
}
impl IsGivenByCtorTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_enum_decl_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: IsGivenByCtor) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_enum_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_enum_decl_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: IsGivenByCtor) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: IsGivenByCtor) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> IsGivenByCtor {
        IsGivenByCtor(TermNode::from(t.0), EnumDeclNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = IsGivenByCtor> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = IsGivenByCtor> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TermNode,
        arg1: EnumDeclNode,
    ) -> impl '_ + Iterator<Item = IsGivenByCtor> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_enum_decl_node(&mut self, tm: EnumDeclNode) -> Vec<IsGivenByCtor> {
        let mut ts = match self.element_index_enum_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<IsGivenByCtor> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for IsGivenByCtorTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("is_given_by_ctor"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FunctionCanBeMadeDefined(pub Func);
#[derive(Clone, Hash, Debug)]
struct FunctionCanBeMadeDefinedTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_func: BTreeMap<Func, Vec<FunctionCanBeMadeDefined>>,
}
impl FunctionCanBeMadeDefinedTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_func: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: FunctionCanBeMadeDefined) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_func.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_func.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: FunctionCanBeMadeDefined) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: FunctionCanBeMadeDefined) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> FunctionCanBeMadeDefined {
        FunctionCanBeMadeDefined(Func::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = FunctionCanBeMadeDefined> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = FunctionCanBeMadeDefined> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Func) -> impl '_ + Iterator<Item = FunctionCanBeMadeDefined> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_func(&mut self, tm: Func) -> Vec<FunctionCanBeMadeDefined> {
        let mut ts = match self.element_index_func.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for FunctionCanBeMadeDefinedTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("function_can_be_made_defined"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CasePatternIsVariable(pub Loc);
#[derive(Clone, Hash, Debug)]
struct CasePatternIsVariableTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_loc: BTreeMap<Loc, Vec<CasePatternIsVariable>>,
}
impl CasePatternIsVariableTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_loc: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: CasePatternIsVariable) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_loc.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: CasePatternIsVariable) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: CasePatternIsVariable) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> CasePatternIsVariable {
        CasePatternIsVariable(Loc::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = CasePatternIsVariable> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = CasePatternIsVariable> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Loc) -> impl '_ + Iterator<Item = CasePatternIsVariable> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<CasePatternIsVariable> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for CasePatternIsVariableTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("case_pattern_is_variable"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CasePatternIsWildcard(pub Loc);
#[derive(Clone, Hash, Debug)]
struct CasePatternIsWildcardTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_loc: BTreeMap<Loc, Vec<CasePatternIsWildcard>>,
}
impl CasePatternIsWildcardTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_loc: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: CasePatternIsWildcard) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_loc.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: CasePatternIsWildcard) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: CasePatternIsWildcard) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> CasePatternIsWildcard {
        CasePatternIsWildcard(Loc::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = CasePatternIsWildcard> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = CasePatternIsWildcard> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Loc) -> impl '_ + Iterator<Item = CasePatternIsWildcard> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<CasePatternIsWildcard> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for CasePatternIsWildcardTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("case_pattern_is_wildcard"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IsPatternCtorArg(pub TermNode);
#[derive(Clone, Hash, Debug)]
struct IsPatternCtorArgTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_term_node: BTreeMap<TermNode, Vec<IsPatternCtorArg>>,
}
impl IsPatternCtorArgTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: IsPatternCtorArg) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: IsPatternCtorArg) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: IsPatternCtorArg) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> IsPatternCtorArg {
        IsPatternCtorArg(TermNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = IsPatternCtorArg> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = IsPatternCtorArg> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = IsPatternCtorArg> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<IsPatternCtorArg> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for IsPatternCtorArgTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("is_pattern_ctor_arg"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArePatternCtorArgs(pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct ArePatternCtorArgsTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<ArePatternCtorArgs>>,
}
impl ArePatternCtorArgsTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_term_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ArePatternCtorArgs) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ArePatternCtorArgs) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: ArePatternCtorArgs) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> ArePatternCtorArgs {
        ArePatternCtorArgs(TermListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ArePatternCtorArgs> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ArePatternCtorArgs> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = ArePatternCtorArgs> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<ArePatternCtorArgs> {
        let mut ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ArePatternCtorArgsTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("are_pattern_ctor_args"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PatternCtorArgIsApp(pub Loc);
#[derive(Clone, Hash, Debug)]
struct PatternCtorArgIsAppTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_loc: BTreeMap<Loc, Vec<PatternCtorArgIsApp>>,
}
impl PatternCtorArgIsAppTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_loc: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: PatternCtorArgIsApp) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_loc.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: PatternCtorArgIsApp) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: PatternCtorArgIsApp) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> PatternCtorArgIsApp {
        PatternCtorArgIsApp(Loc::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = PatternCtorArgIsApp> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = PatternCtorArgIsApp> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Loc) -> impl '_ + Iterator<Item = PatternCtorArgIsApp> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<PatternCtorArgIsApp> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for PatternCtorArgIsAppTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pattern_ctor_arg_is_app"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PatternCtorArgVarIsNotFresh(pub Loc);
#[derive(Clone, Hash, Debug)]
struct PatternCtorArgVarIsNotFreshTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_loc: BTreeMap<Loc, Vec<PatternCtorArgVarIsNotFresh>>,
}
impl PatternCtorArgVarIsNotFreshTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_loc: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: PatternCtorArgVarIsNotFresh) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_loc.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: PatternCtorArgVarIsNotFresh) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: PatternCtorArgVarIsNotFresh) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> PatternCtorArgVarIsNotFresh {
        PatternCtorArgVarIsNotFresh(Loc::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = PatternCtorArgVarIsNotFresh> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = PatternCtorArgVarIsNotFresh> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Loc) -> impl '_ + Iterator<Item = PatternCtorArgVarIsNotFresh> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<PatternCtorArgVarIsNotFresh> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for PatternCtorArgVarIsNotFreshTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pattern_ctor_arg_var_is_not_fresh"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CasesContainCtor(pub MatchCaseListNode, pub CtorDeclNode);
#[derive(Clone, Hash, Debug)]
struct CasesContainCtorTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_ctor_decl_node: BTreeMap<CtorDeclNode, Vec<CasesContainCtor>>,
    element_index_match_case_list_node: BTreeMap<MatchCaseListNode, Vec<CasesContainCtor>>,
}
impl CasesContainCtorTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_ctor_decl_node: BTreeMap::new(),
            element_index_match_case_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: CasesContainCtor) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_match_case_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_match_case_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ctor_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ctor_decl_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: CasesContainCtor) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: CasesContainCtor) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> CasesContainCtor {
        CasesContainCtor(MatchCaseListNode::from(t.0), CtorDeclNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: CasesContainCtor) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> CasesContainCtor {
        CasesContainCtor(MatchCaseListNode::from(t.1), CtorDeclNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = CasesContainCtor> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = CasesContainCtor> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: MatchCaseListNode) -> impl '_ + Iterator<Item = CasesContainCtor> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: MatchCaseListNode,
        arg1: CtorDeclNode,
    ) -> impl '_ + Iterator<Item = CasesContainCtor> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: CtorDeclNode) -> impl '_ + Iterator<Item = CasesContainCtor> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_ctor_decl_node(&mut self, tm: CtorDeclNode) -> Vec<CasesContainCtor> {
        let mut ts = match self.element_index_ctor_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_match_case_list_node(
        &mut self,
        tm: MatchCaseListNode,
    ) -> Vec<CasesContainCtor> {
        let mut ts = match self.element_index_match_case_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for CasesContainCtorTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cases_contain_ctor"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchStmtContainsCtorOfEnum(pub StmtNode, pub CtorDeclNode, pub EnumDeclNode);
#[derive(Clone, Hash, Debug)]
struct MatchStmtContainsCtorOfEnumTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    element_index_ctor_decl_node: BTreeMap<CtorDeclNode, Vec<MatchStmtContainsCtorOfEnum>>,
    element_index_enum_decl_node: BTreeMap<EnumDeclNode, Vec<MatchStmtContainsCtorOfEnum>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<MatchStmtContainsCtorOfEnum>>,
}
impl MatchStmtContainsCtorOfEnumTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            element_index_ctor_decl_node: BTreeMap::new(),
            element_index_enum_decl_node: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: MatchStmtContainsCtorOfEnum) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ctor_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ctor_decl_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_enum_decl_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_enum_decl_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: MatchStmtContainsCtorOfEnum) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: MatchStmtContainsCtorOfEnum) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> MatchStmtContainsCtorOfEnum {
        MatchStmtContainsCtorOfEnum(
            StmtNode::from(t.0),
            CtorDeclNode::from(t.1),
            EnumDeclNode::from(t.2),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = MatchStmtContainsCtorOfEnum> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = MatchStmtContainsCtorOfEnum> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: StmtNode,
        arg1: CtorDeclNode,
        arg2: EnumDeclNode,
    ) -> impl '_ + Iterator<Item = MatchStmtContainsCtorOfEnum> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_ctor_decl_node(
        &mut self,
        tm: CtorDeclNode,
    ) -> Vec<MatchStmtContainsCtorOfEnum> {
        let mut ts = match self.element_index_ctor_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_enum_decl_node(
        &mut self,
        tm: EnumDeclNode,
    ) -> Vec<MatchStmtContainsCtorOfEnum> {
        let mut ts = match self.element_index_enum_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<MatchStmtContainsCtorOfEnum> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for MatchStmtContainsCtorOfEnumTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("match_stmt_contains_ctor_of_enum"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchStmtShouldContainCtor(pub StmtNode, pub CtorDeclNode);
#[derive(Clone, Hash, Debug)]
struct MatchStmtShouldContainCtorTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_ctor_decl_node: BTreeMap<CtorDeclNode, Vec<MatchStmtShouldContainCtor>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<MatchStmtShouldContainCtor>>,
}
impl MatchStmtShouldContainCtorTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_ctor_decl_node: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: MatchStmtShouldContainCtor) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ctor_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ctor_decl_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: MatchStmtShouldContainCtor) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: MatchStmtShouldContainCtor) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> MatchStmtShouldContainCtor {
        MatchStmtShouldContainCtor(StmtNode::from(t.0), CtorDeclNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = MatchStmtShouldContainCtor> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = MatchStmtShouldContainCtor> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtNode,
        arg1: CtorDeclNode,
    ) -> impl '_ + Iterator<Item = MatchStmtShouldContainCtor> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_ctor_decl_node(
        &mut self,
        tm: CtorDeclNode,
    ) -> Vec<MatchStmtShouldContainCtor> {
        let mut ts = match self.element_index_ctor_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<MatchStmtShouldContainCtor> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for MatchStmtShouldContainCtorTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("match_stmt_should_contain_ctor"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchStmtContainsCtor(pub StmtNode, pub CtorDeclNode);
#[derive(Clone, Hash, Debug)]
struct MatchStmtContainsCtorTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_ctor_decl_node: BTreeMap<CtorDeclNode, Vec<MatchStmtContainsCtor>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<MatchStmtContainsCtor>>,
}
impl MatchStmtContainsCtorTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_ctor_decl_node: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: MatchStmtContainsCtor) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ctor_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ctor_decl_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: MatchStmtContainsCtor) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: MatchStmtContainsCtor) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> MatchStmtContainsCtor {
        MatchStmtContainsCtor(StmtNode::from(t.0), CtorDeclNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = MatchStmtContainsCtor> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = MatchStmtContainsCtor> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtNode,
        arg1: CtorDeclNode,
    ) -> impl '_ + Iterator<Item = MatchStmtContainsCtor> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_ctor_decl_node(
        &mut self,
        tm: CtorDeclNode,
    ) -> Vec<MatchStmtContainsCtor> {
        let mut ts = match self.element_index_ctor_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<MatchStmtContainsCtor> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for MatchStmtContainsCtorTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("match_stmt_contains_ctor"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RealVirtIdent(pub Ident, pub VirtIdent);
#[derive(Clone, Hash, Debug)]
struct RealVirtIdentTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_ident: BTreeMap<Ident, Vec<RealVirtIdent>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<RealVirtIdent>>,
}
impl RealVirtIdentTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_ident: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RealVirtIdent) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.0, vec![t]);
                }
            };

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RealVirtIdent) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RealVirtIdent) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RealVirtIdent {
        RealVirtIdent(Ident::from(t.0), VirtIdent::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RealVirtIdent> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RealVirtIdent> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Ident) -> impl '_ + Iterator<Item = RealVirtIdent> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: Ident,
        arg1: VirtIdent,
    ) -> impl '_ + Iterator<Item = RealVirtIdent> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<RealVirtIdent> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(&mut self, tm: VirtIdent) -> Vec<RealVirtIdent> {
        let mut ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for RealVirtIdentTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("real_virt_ident"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VirtRealIdent(pub VirtIdent, pub Ident);
#[derive(Clone, Hash, Debug)]
struct VirtRealIdentTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_ident: BTreeMap<Ident, Vec<VirtRealIdent>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<VirtRealIdent>>,
}
impl VirtRealIdentTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_ident: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VirtRealIdent) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_virt_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VirtRealIdent) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: VirtRealIdent) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> VirtRealIdent {
        VirtRealIdent(VirtIdent::from(t.0), Ident::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VirtRealIdent> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VirtRealIdent> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: VirtIdent) -> impl '_ + Iterator<Item = VirtRealIdent> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: VirtIdent,
        arg1: Ident,
    ) -> impl '_ + Iterator<Item = VirtRealIdent> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<VirtRealIdent> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(&mut self, tm: VirtIdent) -> Vec<VirtRealIdent> {
        let mut ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for VirtRealIdentTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("virt_real_ident"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Var(pub Structure, pub ElName, pub El);
#[derive(Clone, Hash, Debug)]
struct VarTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_el: BTreeMap<El, Vec<Var>>,
    element_index_el_name: BTreeMap<ElName, Vec<Var>>,
    element_index_structure: BTreeMap<Structure, Vec<Var>>,
}
impl VarTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_el: BTreeMap::new(),
            element_index_el_name: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: Var) -> bool {
        if self.index_all_2_0_1.insert(Self::permute_2_0_1(t)) {
            self.index_all_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_structure.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el_name.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_name.insert(t.1, vec![t]);
                }
            };

            match self.element_index_el.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: Var) -> bool {
        self.index_all_2_0_1.contains(&Self::permute_2_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: Var) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> Var {
        Var(Structure::from(t.0), ElName::from(t.1), El::from(t.2))
    }
    #[allow(unused)]
    fn permute_2_0_1(t: Var) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> Var {
        Var(Structure::from(t.1), ElName::from(t.2), El::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = Var> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = Var> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Structure, arg1: ElName) -> impl '_ + Iterator<Item = Var> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Structure,
        arg1: ElName,
        arg2: El,
    ) -> impl '_ + Iterator<Item = Var> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg2, arg0, arg1);
        let max = (arg2, arg0, arg1);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: El) -> impl '_ + Iterator<Item = Var> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> Vec<Var> {
        let mut ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_2_0_1.remove(&Self::permute_2_0_1(t)) {
                self.index_all_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_el_name(&mut self, tm: ElName) -> Vec<Var> {
        let mut ts = match self.element_index_el_name.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_2_0_1.remove(&Self::permute_2_0_1(t)) {
                self.index_all_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<Var> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_2_0_1.remove(&Self::permute_2_0_1(t)) {
                self.index_all_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for VarTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleName(pub RuleDeclNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct RuleNameTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_ident: BTreeMap<Ident, Vec<RuleName>>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<RuleName>>,
}
impl RuleNameTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_ident: BTreeMap::new(),
            element_index_rule_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleName) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_rule_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleName) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleName) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleName {
        RuleName(RuleDeclNode::from(t.0), Ident::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleName> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleName> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = RuleName> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: RuleDeclNode, arg1: Ident) -> impl '_ + Iterator<Item = RuleName> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<RuleName> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_decl_node(&mut self, tm: RuleDeclNode) -> Vec<RuleName> {
        let mut ts = match self.element_index_rule_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for RuleNameTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_name"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeDeclNodeLoc(pub TypeDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct TypeDeclNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_loc: BTreeMap<Loc, Vec<TypeDeclNodeLoc>>,
    element_index_type_decl_node: BTreeMap<TypeDeclNode, Vec<TypeDeclNodeLoc>>,
}
impl TypeDeclNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_loc: BTreeMap::new(),
            element_index_type_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TypeDeclNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_type_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TypeDeclNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: TypeDeclNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> TypeDeclNodeLoc {
        TypeDeclNodeLoc(TypeDeclNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TypeDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TypeDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TypeDeclNode) -> impl '_ + Iterator<Item = TypeDeclNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TypeDeclNode,
        arg1: Loc,
    ) -> impl '_ + Iterator<Item = TypeDeclNodeLoc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<TypeDeclNodeLoc> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_type_decl_node(&mut self, tm: TypeDeclNode) -> Vec<TypeDeclNodeLoc> {
        let mut ts = match self.element_index_type_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for TypeDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("type_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgDeclNodeLoc(pub ArgDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct ArgDeclNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_arg_decl_node: BTreeMap<ArgDeclNode, Vec<ArgDeclNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<ArgDeclNodeLoc>>,
}
impl ArgDeclNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_arg_decl_node: BTreeMap::new(),
            element_index_loc: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ArgDeclNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_arg_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ArgDeclNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ArgDeclNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ArgDeclNodeLoc {
        ArgDeclNodeLoc(ArgDeclNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ArgDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ArgDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ArgDeclNode) -> impl '_ + Iterator<Item = ArgDeclNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: ArgDeclNode,
        arg1: Loc,
    ) -> impl '_ + Iterator<Item = ArgDeclNodeLoc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_node(&mut self, tm: ArgDeclNode) -> Vec<ArgDeclNodeLoc> {
        let mut ts = match self.element_index_arg_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<ArgDeclNodeLoc> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ArgDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("arg_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgDeclListNodeLoc(pub ArgDeclListNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct ArgDeclListNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<ArgDeclListNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<ArgDeclListNodeLoc>>,
}
impl ArgDeclListNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_arg_decl_list_node: BTreeMap::new(),
            element_index_loc: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ArgDeclListNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_arg_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ArgDeclListNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ArgDeclListNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ArgDeclListNodeLoc {
        ArgDeclListNodeLoc(ArgDeclListNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ArgDeclListNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ArgDeclListNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ArgDeclListNode) -> impl '_ + Iterator<Item = ArgDeclListNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: ArgDeclListNode,
        arg1: Loc,
    ) -> impl '_ + Iterator<Item = ArgDeclListNodeLoc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_list_node(
        &mut self,
        tm: ArgDeclListNode,
    ) -> Vec<ArgDeclListNodeLoc> {
        let mut ts = match self.element_index_arg_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<ArgDeclListNodeLoc> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ArgDeclListNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("arg_decl_list_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredDeclNodeLoc(pub PredDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct PredDeclNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_loc: BTreeMap<Loc, Vec<PredDeclNodeLoc>>,
    element_index_pred_decl_node: BTreeMap<PredDeclNode, Vec<PredDeclNodeLoc>>,
}
impl PredDeclNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_loc: BTreeMap::new(),
            element_index_pred_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: PredDeclNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_pred_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_pred_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: PredDeclNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: PredDeclNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> PredDeclNodeLoc {
        PredDeclNodeLoc(PredDeclNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = PredDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = PredDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: PredDeclNode) -> impl '_ + Iterator<Item = PredDeclNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: PredDeclNode,
        arg1: Loc,
    ) -> impl '_ + Iterator<Item = PredDeclNodeLoc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<PredDeclNodeLoc> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_pred_decl_node(&mut self, tm: PredDeclNode) -> Vec<PredDeclNodeLoc> {
        let mut ts = match self.element_index_pred_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for PredDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncDeclNodeLoc(pub FuncDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct FuncDeclNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_func_decl_node: BTreeMap<FuncDeclNode, Vec<FuncDeclNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<FuncDeclNodeLoc>>,
}
impl FuncDeclNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_func_decl_node: BTreeMap::new(),
            element_index_loc: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: FuncDeclNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_func_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_func_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: FuncDeclNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: FuncDeclNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> FuncDeclNodeLoc {
        FuncDeclNodeLoc(FuncDeclNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = FuncDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = FuncDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: FuncDeclNode) -> impl '_ + Iterator<Item = FuncDeclNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: FuncDeclNode,
        arg1: Loc,
    ) -> impl '_ + Iterator<Item = FuncDeclNodeLoc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_func_decl_node(&mut self, tm: FuncDeclNode) -> Vec<FuncDeclNodeLoc> {
        let mut ts = match self.element_index_func_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<FuncDeclNodeLoc> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for FuncDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("func_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorDeclNodeLoc(pub CtorDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct CtorDeclNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_ctor_decl_node: BTreeMap<CtorDeclNode, Vec<CtorDeclNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<CtorDeclNodeLoc>>,
}
impl CtorDeclNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_ctor_decl_node: BTreeMap::new(),
            element_index_loc: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: CtorDeclNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_ctor_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ctor_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: CtorDeclNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: CtorDeclNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> CtorDeclNodeLoc {
        CtorDeclNodeLoc(CtorDeclNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = CtorDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = CtorDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: CtorDeclNode) -> impl '_ + Iterator<Item = CtorDeclNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: CtorDeclNode,
        arg1: Loc,
    ) -> impl '_ + Iterator<Item = CtorDeclNodeLoc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_ctor_decl_node(&mut self, tm: CtorDeclNode) -> Vec<CtorDeclNodeLoc> {
        let mut ts = match self.element_index_ctor_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<CtorDeclNodeLoc> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for CtorDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ctor_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EnumDeclNodeLoc(pub EnumDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct EnumDeclNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_enum_decl_node: BTreeMap<EnumDeclNode, Vec<EnumDeclNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<EnumDeclNodeLoc>>,
}
impl EnumDeclNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_enum_decl_node: BTreeMap::new(),
            element_index_loc: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: EnumDeclNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_enum_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_enum_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: EnumDeclNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: EnumDeclNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> EnumDeclNodeLoc {
        EnumDeclNodeLoc(EnumDeclNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = EnumDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = EnumDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: EnumDeclNode) -> impl '_ + Iterator<Item = EnumDeclNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: EnumDeclNode,
        arg1: Loc,
    ) -> impl '_ + Iterator<Item = EnumDeclNodeLoc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_enum_decl_node(&mut self, tm: EnumDeclNode) -> Vec<EnumDeclNodeLoc> {
        let mut ts = match self.element_index_enum_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<EnumDeclNodeLoc> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for EnumDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("enum_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermNodeLoc(pub TermNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct TermNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_loc: BTreeMap<Loc, Vec<TermNodeLoc>>,
    element_index_term_node: BTreeMap<TermNode, Vec<TermNodeLoc>>,
}
impl TermNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_loc: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TermNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TermNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: TermNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> TermNodeLoc {
        TermNodeLoc(TermNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TermNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TermNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = TermNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: TermNode, arg1: Loc) -> impl '_ + Iterator<Item = TermNodeLoc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<TermNodeLoc> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<TermNodeLoc> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for TermNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("term_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermListNodeLoc(pub TermListNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct TermListNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_loc: BTreeMap<Loc, Vec<TermListNodeLoc>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<TermListNodeLoc>>,
}
impl TermListNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_loc: BTreeMap::new(),
            element_index_term_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TermListNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TermListNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: TermListNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> TermListNodeLoc {
        TermListNodeLoc(TermListNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TermListNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TermListNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = TermListNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TermListNode,
        arg1: Loc,
    ) -> impl '_ + Iterator<Item = TermListNodeLoc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<TermListNodeLoc> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<TermListNodeLoc> {
        let mut ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for TermListNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("term_list_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchCaseNodeLoc(pub MatchCaseNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct MatchCaseNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_loc: BTreeMap<Loc, Vec<MatchCaseNodeLoc>>,
    element_index_match_case_node: BTreeMap<MatchCaseNode, Vec<MatchCaseNodeLoc>>,
}
impl MatchCaseNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_loc: BTreeMap::new(),
            element_index_match_case_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: MatchCaseNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_match_case_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_match_case_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: MatchCaseNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: MatchCaseNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> MatchCaseNodeLoc {
        MatchCaseNodeLoc(MatchCaseNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = MatchCaseNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = MatchCaseNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: MatchCaseNode) -> impl '_ + Iterator<Item = MatchCaseNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: MatchCaseNode,
        arg1: Loc,
    ) -> impl '_ + Iterator<Item = MatchCaseNodeLoc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<MatchCaseNodeLoc> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_match_case_node(&mut self, tm: MatchCaseNode) -> Vec<MatchCaseNodeLoc> {
        let mut ts = match self.element_index_match_case_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for MatchCaseNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("match_case_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct OptTermNodeLoc(pub OptTermNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct OptTermNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_loc: BTreeMap<Loc, Vec<OptTermNodeLoc>>,
    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<OptTermNodeLoc>>,
}
impl OptTermNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_loc: BTreeMap::new(),
            element_index_opt_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: OptTermNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_opt_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_opt_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: OptTermNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: OptTermNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> OptTermNodeLoc {
        OptTermNodeLoc(OptTermNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = OptTermNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = OptTermNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: OptTermNode) -> impl '_ + Iterator<Item = OptTermNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: OptTermNode,
        arg1: Loc,
    ) -> impl '_ + Iterator<Item = OptTermNodeLoc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<OptTermNodeLoc> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_opt_term_node(&mut self, tm: OptTermNode) -> Vec<OptTermNodeLoc> {
        let mut ts = match self.element_index_opt_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for OptTermNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("opt_term_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IfAtomNodeLoc(pub IfAtomNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct IfAtomNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<IfAtomNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<IfAtomNodeLoc>>,
}
impl IfAtomNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_loc: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: IfAtomNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: IfAtomNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: IfAtomNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> IfAtomNodeLoc {
        IfAtomNodeLoc(IfAtomNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = IfAtomNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = IfAtomNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = IfAtomNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: IfAtomNode,
        arg1: Loc,
    ) -> impl '_ + Iterator<Item = IfAtomNodeLoc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(&mut self, tm: IfAtomNode) -> Vec<IfAtomNodeLoc> {
        let mut ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<IfAtomNodeLoc> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for IfAtomNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("if_atom_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ThenAtomNodeLoc(pub ThenAtomNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct ThenAtomNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_loc: BTreeMap<Loc, Vec<ThenAtomNodeLoc>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<ThenAtomNodeLoc>>,
}
impl ThenAtomNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_loc: BTreeMap::new(),
            element_index_then_atom_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ThenAtomNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_then_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ThenAtomNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ThenAtomNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ThenAtomNodeLoc {
        ThenAtomNodeLoc(ThenAtomNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ThenAtomNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ThenAtomNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = ThenAtomNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: ThenAtomNode,
        arg1: Loc,
    ) -> impl '_ + Iterator<Item = ThenAtomNodeLoc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<ThenAtomNodeLoc> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_then_atom_node(&mut self, tm: ThenAtomNode) -> Vec<ThenAtomNodeLoc> {
        let mut ts = match self.element_index_then_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ThenAtomNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("then_atom_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct StmtNodeLoc(pub StmtNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct StmtNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_loc: BTreeMap<Loc, Vec<StmtNodeLoc>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<StmtNodeLoc>>,
}
impl StmtNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_loc: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: StmtNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: StmtNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: StmtNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> StmtNodeLoc {
        StmtNodeLoc(StmtNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = StmtNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = StmtNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = StmtNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: StmtNode, arg1: Loc) -> impl '_ + Iterator<Item = StmtNodeLoc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<StmtNodeLoc> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<StmtNodeLoc> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for StmtNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("stmt_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct StmtListNodeLoc(pub StmtListNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct StmtListNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_loc: BTreeMap<Loc, Vec<StmtListNodeLoc>>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<StmtListNodeLoc>>,
}
impl StmtListNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_loc: BTreeMap::new(),
            element_index_stmt_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: StmtListNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_stmt_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: StmtListNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: StmtListNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> StmtListNodeLoc {
        StmtListNodeLoc(StmtListNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = StmtListNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = StmtListNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = StmtListNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtListNode,
        arg1: Loc,
    ) -> impl '_ + Iterator<Item = StmtListNodeLoc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<StmtListNodeLoc> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_list_node(&mut self, tm: StmtListNode) -> Vec<StmtListNodeLoc> {
        let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for StmtListNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("stmt_list_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDeclNodeLoc(pub RuleDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct RuleDeclNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_loc: BTreeMap<Loc, Vec<RuleDeclNodeLoc>>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<RuleDeclNodeLoc>>,
}
impl RuleDeclNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_loc: BTreeMap::new(),
            element_index_rule_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleDeclNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_rule_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleDeclNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleDeclNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleDeclNodeLoc {
        RuleDeclNodeLoc(RuleDeclNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = RuleDeclNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: RuleDeclNode,
        arg1: Loc,
    ) -> impl '_ + Iterator<Item = RuleDeclNodeLoc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<RuleDeclNodeLoc> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_decl_node(&mut self, tm: RuleDeclNode) -> Vec<RuleDeclNodeLoc> {
        let mut ts = match self.element_index_rule_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for RuleDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodeLoc(pub DeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct DeclNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_decl_node: BTreeMap<DeclNode, Vec<DeclNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<DeclNodeLoc>>,
}
impl DeclNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_decl_node: BTreeMap::new(),
            element_index_loc: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DeclNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DeclNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DeclNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DeclNodeLoc {
        DeclNodeLoc(DeclNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: DeclNode) -> impl '_ + Iterator<Item = DeclNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: DeclNode, arg1: Loc) -> impl '_ + Iterator<Item = DeclNodeLoc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_node(&mut self, tm: DeclNode) -> Vec<DeclNodeLoc> {
        let mut ts = match self.element_index_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<DeclNodeLoc> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for DeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclListNodeLoc(pub DeclListNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct DeclListNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_decl_list_node: BTreeMap<DeclListNode, Vec<DeclListNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<DeclListNodeLoc>>,
}
impl DeclListNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_decl_list_node: BTreeMap::new(),
            element_index_loc: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DeclListNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DeclListNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DeclListNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DeclListNodeLoc {
        DeclListNodeLoc(DeclListNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DeclListNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DeclListNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: DeclListNode) -> impl '_ + Iterator<Item = DeclListNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: DeclListNode,
        arg1: Loc,
    ) -> impl '_ + Iterator<Item = DeclListNodeLoc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_list_node(&mut self, tm: DeclListNode) -> Vec<DeclListNodeLoc> {
        let mut ts = match self.element_index_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<DeclListNodeLoc> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for DeclListNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_list_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ModuleNodeLoc(pub ModuleNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct ModuleNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_loc: BTreeMap<Loc, Vec<ModuleNodeLoc>>,
    element_index_module_node: BTreeMap<ModuleNode, Vec<ModuleNodeLoc>>,
}
impl ModuleNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_loc: BTreeMap::new(),
            element_index_module_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ModuleNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_module_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_module_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ModuleNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ModuleNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ModuleNodeLoc {
        ModuleNodeLoc(ModuleNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ModuleNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ModuleNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ModuleNode) -> impl '_ + Iterator<Item = ModuleNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: ModuleNode,
        arg1: Loc,
    ) -> impl '_ + Iterator<Item = ModuleNodeLoc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<ModuleNodeLoc> {
        let mut ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_module_node(&mut self, tm: ModuleNode) -> Vec<ModuleNodeLoc> {
        let mut ts = match self.element_index_module_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ModuleNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("module_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantRule(pub RuleDeclNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantRuleTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<RuleDescendantRule>>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantRule>>,
}
impl RuleDescendantRuleTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_rule_decl_node: BTreeMap::new(),
            element_index_rule_descendant_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleDescendantRule) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_rule_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_descendant_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleDescendantRule) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleDescendantRule) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleDescendantRule {
        RuleDescendantRule(RuleDeclNode::from(t.0), RuleDescendantNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleDescendantRule> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleDescendantRule> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = RuleDescendantRule> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: RuleDeclNode,
        arg1: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = RuleDescendantRule> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_decl_node(&mut self, tm: RuleDeclNode) -> Vec<RuleDescendantRule> {
        let mut ts = match self.element_index_rule_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_descendant_node(
        &mut self,
        tm: RuleDescendantNode,
    ) -> Vec<RuleDescendantRule> {
        let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for RuleDescendantRuleTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_rule"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantTerm(pub TermNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantTermTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantTerm>>,
    element_index_term_node: BTreeMap<TermNode, Vec<RuleDescendantTerm>>,
}
impl RuleDescendantTermTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_rule_descendant_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleDescendantTerm) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_descendant_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleDescendantTerm) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleDescendantTerm) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleDescendantTerm {
        RuleDescendantTerm(TermNode::from(t.0), RuleDescendantNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: RuleDescendantTerm) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> RuleDescendantTerm {
        RuleDescendantTerm(TermNode::from(t.1), RuleDescendantNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleDescendantTerm> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleDescendantTerm> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = RuleDescendantTerm> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TermNode,
        arg1: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = RuleDescendantTerm> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(
        &self,
        arg1: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = RuleDescendantTerm> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_descendant_node(
        &mut self,
        tm: RuleDescendantNode,
    ) -> Vec<RuleDescendantTerm> {
        let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<RuleDescendantTerm> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for RuleDescendantTermTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_term"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantTermList(pub TermListNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantTermListTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantTermList>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<RuleDescendantTermList>>,
}
impl RuleDescendantTermListTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_rule_descendant_node: BTreeMap::new(),
            element_index_term_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleDescendantTermList) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_descendant_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleDescendantTermList) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleDescendantTermList) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleDescendantTermList {
        RuleDescendantTermList(TermListNode::from(t.0), RuleDescendantNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleDescendantTermList> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleDescendantTermList> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = RuleDescendantTermList> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TermListNode,
        arg1: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = RuleDescendantTermList> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_descendant_node(
        &mut self,
        tm: RuleDescendantNode,
    ) -> Vec<RuleDescendantTermList> {
        let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(
        &mut self,
        tm: TermListNode,
    ) -> Vec<RuleDescendantTermList> {
        let mut ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for RuleDescendantTermListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_term_list"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantOptTerm(pub OptTermNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantOptTermTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<RuleDescendantOptTerm>>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantOptTerm>>,
}
impl RuleDescendantOptTermTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_opt_term_node: BTreeMap::new(),
            element_index_rule_descendant_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleDescendantOptTerm) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_opt_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_opt_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_descendant_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleDescendantOptTerm) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleDescendantOptTerm) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleDescendantOptTerm {
        RuleDescendantOptTerm(OptTermNode::from(t.0), RuleDescendantNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleDescendantOptTerm> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleDescendantOptTerm> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: OptTermNode) -> impl '_ + Iterator<Item = RuleDescendantOptTerm> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: OptTermNode,
        arg1: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = RuleDescendantOptTerm> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_opt_term_node(&mut self, tm: OptTermNode) -> Vec<RuleDescendantOptTerm> {
        let mut ts = match self.element_index_opt_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_descendant_node(
        &mut self,
        tm: RuleDescendantNode,
    ) -> Vec<RuleDescendantOptTerm> {
        let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for RuleDescendantOptTermTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_opt_term"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantIfAtom(pub IfAtomNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantIfAtomTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<RuleDescendantIfAtom>>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantIfAtom>>,
}
impl RuleDescendantIfAtomTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_rule_descendant_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleDescendantIfAtom) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_descendant_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleDescendantIfAtom) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleDescendantIfAtom) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleDescendantIfAtom {
        RuleDescendantIfAtom(IfAtomNode::from(t.0), RuleDescendantNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleDescendantIfAtom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleDescendantIfAtom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = RuleDescendantIfAtom> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: IfAtomNode,
        arg1: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = RuleDescendantIfAtom> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(&mut self, tm: IfAtomNode) -> Vec<RuleDescendantIfAtom> {
        let mut ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_descendant_node(
        &mut self,
        tm: RuleDescendantNode,
    ) -> Vec<RuleDescendantIfAtom> {
        let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for RuleDescendantIfAtomTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_if_atom"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantThenAtom(pub ThenAtomNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantThenAtomTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantThenAtom>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<RuleDescendantThenAtom>>,
}
impl RuleDescendantThenAtomTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_rule_descendant_node: BTreeMap::new(),
            element_index_then_atom_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleDescendantThenAtom) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_then_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_descendant_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleDescendantThenAtom) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleDescendantThenAtom) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleDescendantThenAtom {
        RuleDescendantThenAtom(ThenAtomNode::from(t.0), RuleDescendantNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleDescendantThenAtom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleDescendantThenAtom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = RuleDescendantThenAtom> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: ThenAtomNode,
        arg1: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = RuleDescendantThenAtom> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_descendant_node(
        &mut self,
        tm: RuleDescendantNode,
    ) -> Vec<RuleDescendantThenAtom> {
        let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_then_atom_node(
        &mut self,
        tm: ThenAtomNode,
    ) -> Vec<RuleDescendantThenAtom> {
        let mut ts = match self.element_index_then_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for RuleDescendantThenAtomTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_then_atom"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantMatchCase(pub MatchCaseNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantMatchCaseTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_match_case_node: BTreeMap<MatchCaseNode, Vec<RuleDescendantMatchCase>>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantMatchCase>>,
}
impl RuleDescendantMatchCaseTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_match_case_node: BTreeMap::new(),
            element_index_rule_descendant_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleDescendantMatchCase) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_match_case_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_match_case_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_descendant_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleDescendantMatchCase) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleDescendantMatchCase) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleDescendantMatchCase {
        RuleDescendantMatchCase(MatchCaseNode::from(t.0), RuleDescendantNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: RuleDescendantMatchCase) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> RuleDescendantMatchCase {
        RuleDescendantMatchCase(MatchCaseNode::from(t.1), RuleDescendantNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleDescendantMatchCase> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleDescendantMatchCase> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(
        &self,
        arg0: MatchCaseNode,
    ) -> impl '_ + Iterator<Item = RuleDescendantMatchCase> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: MatchCaseNode,
        arg1: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = RuleDescendantMatchCase> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(
        &self,
        arg1: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = RuleDescendantMatchCase> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_match_case_node(
        &mut self,
        tm: MatchCaseNode,
    ) -> Vec<RuleDescendantMatchCase> {
        let mut ts = match self.element_index_match_case_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_descendant_node(
        &mut self,
        tm: RuleDescendantNode,
    ) -> Vec<RuleDescendantMatchCase> {
        let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for RuleDescendantMatchCaseTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_match_case"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantMatchCaseList(pub MatchCaseListNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantMatchCaseListTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_match_case_list_node:
        BTreeMap<MatchCaseListNode, Vec<RuleDescendantMatchCaseList>>,
    element_index_rule_descendant_node:
        BTreeMap<RuleDescendantNode, Vec<RuleDescendantMatchCaseList>>,
}
impl RuleDescendantMatchCaseListTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_match_case_list_node: BTreeMap::new(),
            element_index_rule_descendant_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleDescendantMatchCaseList) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_match_case_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_match_case_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_descendant_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleDescendantMatchCaseList) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleDescendantMatchCaseList) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleDescendantMatchCaseList {
        RuleDescendantMatchCaseList(MatchCaseListNode::from(t.0), RuleDescendantNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: RuleDescendantMatchCaseList) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> RuleDescendantMatchCaseList {
        RuleDescendantMatchCaseList(MatchCaseListNode::from(t.1), RuleDescendantNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleDescendantMatchCaseList> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleDescendantMatchCaseList> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(
        &self,
        arg0: MatchCaseListNode,
    ) -> impl '_ + Iterator<Item = RuleDescendantMatchCaseList> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: MatchCaseListNode,
        arg1: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = RuleDescendantMatchCaseList> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(
        &self,
        arg1: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = RuleDescendantMatchCaseList> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_match_case_list_node(
        &mut self,
        tm: MatchCaseListNode,
    ) -> Vec<RuleDescendantMatchCaseList> {
        let mut ts = match self.element_index_match_case_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_descendant_node(
        &mut self,
        tm: RuleDescendantNode,
    ) -> Vec<RuleDescendantMatchCaseList> {
        let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for RuleDescendantMatchCaseListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_match_case_list"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantStmt(pub StmtNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantStmtTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantStmt>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<RuleDescendantStmt>>,
}
impl RuleDescendantStmtTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_rule_descendant_node: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleDescendantStmt) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_descendant_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleDescendantStmt) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleDescendantStmt) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleDescendantStmt {
        RuleDescendantStmt(StmtNode::from(t.0), RuleDescendantNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleDescendantStmt> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleDescendantStmt> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = RuleDescendantStmt> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtNode,
        arg1: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = RuleDescendantStmt> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_descendant_node(
        &mut self,
        tm: RuleDescendantNode,
    ) -> Vec<RuleDescendantStmt> {
        let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<RuleDescendantStmt> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for RuleDescendantStmtTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_stmt"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantStmtList(pub StmtListNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantStmtListTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantStmtList>>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<RuleDescendantStmtList>>,
}
impl RuleDescendantStmtListTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_rule_descendant_node: BTreeMap::new(),
            element_index_stmt_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleDescendantStmtList) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_stmt_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_descendant_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleDescendantStmtList) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleDescendantStmtList) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleDescendantStmtList {
        RuleDescendantStmtList(StmtListNode::from(t.0), RuleDescendantNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleDescendantStmtList> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleDescendantStmtList> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = RuleDescendantStmtList> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtListNode,
        arg1: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = RuleDescendantStmtList> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_descendant_node(
        &mut self,
        tm: RuleDescendantNode,
    ) -> Vec<RuleDescendantStmtList> {
        let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_list_node(
        &mut self,
        tm: StmtListNode,
    ) -> Vec<RuleDescendantStmtList> {
        let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for RuleDescendantStmtListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_stmt_list"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantStmtBlockList(pub StmtBlockListNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantStmtBlockListTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_rule_descendant_node:
        BTreeMap<RuleDescendantNode, Vec<RuleDescendantStmtBlockList>>,
    element_index_stmt_block_list_node:
        BTreeMap<StmtBlockListNode, Vec<RuleDescendantStmtBlockList>>,
}
impl RuleDescendantStmtBlockListTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_rule_descendant_node: BTreeMap::new(),
            element_index_stmt_block_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleDescendantStmtBlockList) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_stmt_block_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_block_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_descendant_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleDescendantStmtBlockList) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleDescendantStmtBlockList) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleDescendantStmtBlockList {
        RuleDescendantStmtBlockList(StmtBlockListNode::from(t.0), RuleDescendantNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: RuleDescendantStmtBlockList) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> RuleDescendantStmtBlockList {
        RuleDescendantStmtBlockList(StmtBlockListNode::from(t.1), RuleDescendantNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleDescendantStmtBlockList> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleDescendantStmtBlockList> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(
        &self,
        arg0: StmtBlockListNode,
    ) -> impl '_ + Iterator<Item = RuleDescendantStmtBlockList> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtBlockListNode,
        arg1: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = RuleDescendantStmtBlockList> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(
        &self,
        arg1: RuleDescendantNode,
    ) -> impl '_ + Iterator<Item = RuleDescendantStmtBlockList> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_descendant_node(
        &mut self,
        tm: RuleDescendantNode,
    ) -> Vec<RuleDescendantStmtBlockList> {
        let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_block_list_node(
        &mut self,
        tm: StmtBlockListNode,
    ) -> Vec<RuleDescendantStmtBlockList> {
        let mut ts = match self.element_index_stmt_block_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for RuleDescendantStmtBlockListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_stmt_block_list"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EntryScope(pub RuleDescendantNode, pub Scope);
#[derive(Clone, Hash, Debug)]
struct EntryScopeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<EntryScope>>,
    element_index_scope: BTreeMap<Scope, Vec<EntryScope>>,
}
impl EntryScopeTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_rule_descendant_node: BTreeMap::new(),
            element_index_scope: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: EntryScope) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_rule_descendant_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_descendant_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_scope.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: EntryScope) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: EntryScope) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> EntryScope {
        EntryScope(RuleDescendantNode::from(t.0), Scope::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: EntryScope) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> EntryScope {
        EntryScope(RuleDescendantNode::from(t.1), Scope::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = EntryScope> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = EntryScope> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: RuleDescendantNode) -> impl '_ + Iterator<Item = EntryScope> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: RuleDescendantNode,
        arg1: Scope,
    ) -> impl '_ + Iterator<Item = EntryScope> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Scope) -> impl '_ + Iterator<Item = EntryScope> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_descendant_node(
        &mut self,
        tm: RuleDescendantNode,
    ) -> Vec<EntryScope> {
        let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_scope(&mut self, tm: Scope) -> Vec<EntryScope> {
        let mut ts = match self.element_index_scope.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for EntryScopeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("entry_scope"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ExitScope(pub RuleDescendantNode, pub Scope);
#[derive(Clone, Hash, Debug)]
struct ExitScopeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<ExitScope>>,
    element_index_scope: BTreeMap<Scope, Vec<ExitScope>>,
}
impl ExitScopeTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_rule_descendant_node: BTreeMap::new(),
            element_index_scope: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ExitScope) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_rule_descendant_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_descendant_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_scope.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ExitScope) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ExitScope) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ExitScope {
        ExitScope(RuleDescendantNode::from(t.0), Scope::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: ExitScope) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> ExitScope {
        ExitScope(RuleDescendantNode::from(t.1), Scope::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ExitScope> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ExitScope> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: RuleDescendantNode) -> impl '_ + Iterator<Item = ExitScope> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: RuleDescendantNode,
        arg1: Scope,
    ) -> impl '_ + Iterator<Item = ExitScope> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Scope) -> impl '_ + Iterator<Item = ExitScope> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_descendant_node(
        &mut self,
        tm: RuleDescendantNode,
    ) -> Vec<ExitScope> {
        let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_scope(&mut self, tm: Scope) -> Vec<ExitScope> {
        let mut ts = match self.element_index_scope.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ExitScopeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("exit_scope"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorEnum(pub CtorDeclNode, pub EnumDeclNode);
#[derive(Clone, Hash, Debug)]
struct CtorEnumTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_ctor_decl_node: BTreeMap<CtorDeclNode, Vec<CtorEnum>>,
    element_index_enum_decl_node: BTreeMap<EnumDeclNode, Vec<CtorEnum>>,
}
impl CtorEnumTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_ctor_decl_node: BTreeMap::new(),
            element_index_enum_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: CtorEnum) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_ctor_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ctor_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_enum_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_enum_decl_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: CtorEnum) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: CtorEnum) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> CtorEnum {
        CtorEnum(CtorDeclNode::from(t.0), EnumDeclNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: CtorEnum) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> CtorEnum {
        CtorEnum(CtorDeclNode::from(t.1), EnumDeclNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = CtorEnum> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = CtorEnum> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: CtorDeclNode) -> impl '_ + Iterator<Item = CtorEnum> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: CtorDeclNode,
        arg1: EnumDeclNode,
    ) -> impl '_ + Iterator<Item = CtorEnum> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: EnumDeclNode) -> impl '_ + Iterator<Item = CtorEnum> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_ctor_decl_node(&mut self, tm: CtorDeclNode) -> Vec<CtorEnum> {
        let mut ts = match self.element_index_ctor_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_enum_decl_node(&mut self, tm: EnumDeclNode) -> Vec<CtorEnum> {
        let mut ts = match self.element_index_enum_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for CtorEnumTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ctor_enum"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorsEnum(pub CtorDeclListNode, pub EnumDeclNode);
#[derive(Clone, Hash, Debug)]
struct CtorsEnumTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_ctor_decl_list_node: BTreeMap<CtorDeclListNode, Vec<CtorsEnum>>,
    element_index_enum_decl_node: BTreeMap<EnumDeclNode, Vec<CtorsEnum>>,
}
impl CtorsEnumTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_ctor_decl_list_node: BTreeMap::new(),
            element_index_enum_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: CtorsEnum) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_ctor_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ctor_decl_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_enum_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_enum_decl_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: CtorsEnum) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: CtorsEnum) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> CtorsEnum {
        CtorsEnum(CtorDeclListNode::from(t.0), EnumDeclNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = CtorsEnum> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = CtorsEnum> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: CtorDeclListNode) -> impl '_ + Iterator<Item = CtorsEnum> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: CtorDeclListNode,
        arg1: EnumDeclNode,
    ) -> impl '_ + Iterator<Item = CtorsEnum> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_ctor_decl_list_node(&mut self, tm: CtorDeclListNode) -> Vec<CtorsEnum> {
        let mut ts = match self.element_index_ctor_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_enum_decl_node(&mut self, tm: EnumDeclNode) -> Vec<CtorsEnum> {
        let mut ts = match self.element_index_enum_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for CtorsEnumTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ctors_enum"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CasesDiscriminee(pub MatchCaseListNode, pub TermNode);
#[derive(Clone, Hash, Debug)]
struct CasesDiscrimineeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_match_case_list_node: BTreeMap<MatchCaseListNode, Vec<CasesDiscriminee>>,
    element_index_term_node: BTreeMap<TermNode, Vec<CasesDiscriminee>>,
}
impl CasesDiscrimineeTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_match_case_list_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: CasesDiscriminee) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_match_case_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_match_case_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: CasesDiscriminee) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: CasesDiscriminee) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> CasesDiscriminee {
        CasesDiscriminee(MatchCaseListNode::from(t.0), TermNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = CasesDiscriminee> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = CasesDiscriminee> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: MatchCaseListNode) -> impl '_ + Iterator<Item = CasesDiscriminee> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: MatchCaseListNode,
        arg1: TermNode,
    ) -> impl '_ + Iterator<Item = CasesDiscriminee> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_match_case_list_node(
        &mut self,
        tm: MatchCaseListNode,
    ) -> Vec<CasesDiscriminee> {
        let mut ts = match self.element_index_match_case_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<CasesDiscriminee> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for CasesDiscrimineeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cases_discriminee"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CaseDiscriminee(pub MatchCaseNode, pub TermNode);
#[derive(Clone, Hash, Debug)]
struct CaseDiscrimineeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_match_case_node: BTreeMap<MatchCaseNode, Vec<CaseDiscriminee>>,
    element_index_term_node: BTreeMap<TermNode, Vec<CaseDiscriminee>>,
}
impl CaseDiscrimineeTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_match_case_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: CaseDiscriminee) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_match_case_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_match_case_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: CaseDiscriminee) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: CaseDiscriminee) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> CaseDiscriminee {
        CaseDiscriminee(MatchCaseNode::from(t.0), TermNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = CaseDiscriminee> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = CaseDiscriminee> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: MatchCaseNode) -> impl '_ + Iterator<Item = CaseDiscriminee> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: MatchCaseNode,
        arg1: TermNode,
    ) -> impl '_ + Iterator<Item = CaseDiscriminee> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_match_case_node(&mut self, tm: MatchCaseNode) -> Vec<CaseDiscriminee> {
        let mut ts = match self.element_index_match_case_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<CaseDiscriminee> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for CaseDiscrimineeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("case_discriminee"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DesugaredCaseEqualityAtom(pub MatchCaseNode, pub IfAtomNode);
#[derive(Clone, Hash, Debug)]
struct DesugaredCaseEqualityAtomTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<DesugaredCaseEqualityAtom>>,
    element_index_match_case_node: BTreeMap<MatchCaseNode, Vec<DesugaredCaseEqualityAtom>>,
}
impl DesugaredCaseEqualityAtomTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_match_case_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DesugaredCaseEqualityAtom) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_match_case_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_match_case_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_if_atom_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DesugaredCaseEqualityAtom) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DesugaredCaseEqualityAtom) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DesugaredCaseEqualityAtom {
        DesugaredCaseEqualityAtom(MatchCaseNode::from(t.0), IfAtomNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DesugaredCaseEqualityAtom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DesugaredCaseEqualityAtom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(
        &self,
        arg0: MatchCaseNode,
    ) -> impl '_ + Iterator<Item = DesugaredCaseEqualityAtom> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: MatchCaseNode,
        arg1: IfAtomNode,
    ) -> impl '_ + Iterator<Item = DesugaredCaseEqualityAtom> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(
        &mut self,
        tm: IfAtomNode,
    ) -> Vec<DesugaredCaseEqualityAtom> {
        let mut ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_match_case_node(
        &mut self,
        tm: MatchCaseNode,
    ) -> Vec<DesugaredCaseEqualityAtom> {
        let mut ts = match self.element_index_match_case_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for DesugaredCaseEqualityAtomTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("desugared_case_equality_atom"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DesugaredCaseEqualityStmt(pub MatchCaseNode, pub StmtNode);
#[derive(Clone, Hash, Debug)]
struct DesugaredCaseEqualityStmtTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_match_case_node: BTreeMap<MatchCaseNode, Vec<DesugaredCaseEqualityStmt>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<DesugaredCaseEqualityStmt>>,
}
impl DesugaredCaseEqualityStmtTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_match_case_node: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DesugaredCaseEqualityStmt) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_match_case_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_match_case_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_stmt_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DesugaredCaseEqualityStmt) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DesugaredCaseEqualityStmt) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DesugaredCaseEqualityStmt {
        DesugaredCaseEqualityStmt(MatchCaseNode::from(t.0), StmtNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DesugaredCaseEqualityStmt> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DesugaredCaseEqualityStmt> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(
        &self,
        arg0: MatchCaseNode,
    ) -> impl '_ + Iterator<Item = DesugaredCaseEqualityStmt> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: MatchCaseNode,
        arg1: StmtNode,
    ) -> impl '_ + Iterator<Item = DesugaredCaseEqualityStmt> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_match_case_node(
        &mut self,
        tm: MatchCaseNode,
    ) -> Vec<DesugaredCaseEqualityStmt> {
        let mut ts = match self.element_index_match_case_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<DesugaredCaseEqualityStmt> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for DesugaredCaseEqualityStmtTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("desugared_case_equality_stmt"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DesugaredCaseBlock(pub MatchCaseNode, pub StmtListNode);
#[derive(Clone, Hash, Debug)]
struct DesugaredCaseBlockTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_match_case_node: BTreeMap<MatchCaseNode, Vec<DesugaredCaseBlock>>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<DesugaredCaseBlock>>,
}
impl DesugaredCaseBlockTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_match_case_node: BTreeMap::new(),
            element_index_stmt_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DesugaredCaseBlock) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_match_case_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_match_case_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_stmt_list_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DesugaredCaseBlock) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DesugaredCaseBlock) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DesugaredCaseBlock {
        DesugaredCaseBlock(MatchCaseNode::from(t.0), StmtListNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: DesugaredCaseBlock) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> DesugaredCaseBlock {
        DesugaredCaseBlock(MatchCaseNode::from(t.1), StmtListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DesugaredCaseBlock> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DesugaredCaseBlock> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: MatchCaseNode) -> impl '_ + Iterator<Item = DesugaredCaseBlock> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: MatchCaseNode,
        arg1: StmtListNode,
    ) -> impl '_ + Iterator<Item = DesugaredCaseBlock> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: StmtListNode) -> impl '_ + Iterator<Item = DesugaredCaseBlock> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_match_case_node(&mut self, tm: MatchCaseNode) -> Vec<DesugaredCaseBlock> {
        let mut ts = match self.element_index_match_case_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_list_node(&mut self, tm: StmtListNode) -> Vec<DesugaredCaseBlock> {
        let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for DesugaredCaseBlockTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("desugared_case_block"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DesugaredCaseBlockList(pub MatchCaseListNode, pub StmtBlockListNode);
#[derive(Clone, Hash, Debug)]
struct DesugaredCaseBlockListTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_match_case_list_node: BTreeMap<MatchCaseListNode, Vec<DesugaredCaseBlockList>>,
    element_index_stmt_block_list_node: BTreeMap<StmtBlockListNode, Vec<DesugaredCaseBlockList>>,
}
impl DesugaredCaseBlockListTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_match_case_list_node: BTreeMap::new(),
            element_index_stmt_block_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DesugaredCaseBlockList) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_match_case_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_match_case_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_stmt_block_list_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_block_list_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DesugaredCaseBlockList) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DesugaredCaseBlockList) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DesugaredCaseBlockList {
        DesugaredCaseBlockList(MatchCaseListNode::from(t.0), StmtBlockListNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: DesugaredCaseBlockList) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> DesugaredCaseBlockList {
        DesugaredCaseBlockList(MatchCaseListNode::from(t.1), StmtBlockListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DesugaredCaseBlockList> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DesugaredCaseBlockList> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(
        &self,
        arg0: MatchCaseListNode,
    ) -> impl '_ + Iterator<Item = DesugaredCaseBlockList> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: MatchCaseListNode,
        arg1: StmtBlockListNode,
    ) -> impl '_ + Iterator<Item = DesugaredCaseBlockList> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(
        &self,
        arg1: StmtBlockListNode,
    ) -> impl '_ + Iterator<Item = DesugaredCaseBlockList> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_match_case_list_node(
        &mut self,
        tm: MatchCaseListNode,
    ) -> Vec<DesugaredCaseBlockList> {
        let mut ts = match self.element_index_match_case_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_block_list_node(
        &mut self,
        tm: StmtBlockListNode,
    ) -> Vec<DesugaredCaseBlockList> {
        let mut ts = match self.element_index_stmt_block_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for DesugaredCaseBlockListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("desugared_case_block_list"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilTypeList(pub TypeList);
#[derive(Clone, Hash, Debug)]
struct NilTypeListTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_type_list: BTreeMap<TypeList, Vec<NilTypeList>>,
}
impl NilTypeListTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_type_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NilTypeList) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_type_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_list.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NilTypeList) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: NilTypeList) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> NilTypeList {
        NilTypeList(TypeList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NilTypeList> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NilTypeList> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TypeList) -> impl '_ + Iterator<Item = NilTypeList> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<NilTypeList> {
        let mut ts = match self.element_index_type_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for NilTypeListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("NilTypeList"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsTypeList(pub Type, pub TypeList, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct ConsTypeListTable {
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_type: BTreeMap<Type, Vec<ConsTypeList>>,
    element_index_type_list: BTreeMap<TypeList, Vec<ConsTypeList>>,
}
impl ConsTypeListTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_type: BTreeMap::new(),
            element_index_type_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ConsTypeList) -> bool {
        if self.index_all_1_0_2.insert(Self::permute_1_0_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_type.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_list.insert(t.1, vec![t]);
                }
            };

            match self.element_index_type_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_list.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ConsTypeList) -> bool {
        self.index_all_1_0_2.contains(&Self::permute_1_0_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: ConsTypeList) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> ConsTypeList {
        ConsTypeList(Type::from(t.0), TypeList::from(t.1), TypeList::from(t.2))
    }
    #[allow(unused)]
    fn permute_1_0_2(t: ConsTypeList) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> ConsTypeList {
        ConsTypeList(Type::from(t.1), TypeList::from(t.0), TypeList::from(t.2))
    }
    #[allow(unused)]
    fn permute_2_0_1(t: ConsTypeList) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> ConsTypeList {
        ConsTypeList(Type::from(t.1), TypeList::from(t.2), TypeList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ConsTypeList> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ConsTypeList> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Type, arg1: TypeList) -> impl '_ + Iterator<Item = ConsTypeList> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg1, arg0, u32::MIN);
        let max = (arg1, arg0, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Type,
        arg1: TypeList,
        arg2: TypeList,
    ) -> impl '_ + Iterator<Item = ConsTypeList> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg0, arg2);
        let max = (arg1, arg0, arg2);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TypeList) -> impl '_ + Iterator<Item = ConsTypeList> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: TypeList) -> impl '_ + Iterator<Item = ConsTypeList> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_type(&mut self, tm: Type) -> Vec<ConsTypeList> {
        let mut ts = match self.element_index_type.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_1_0_2.remove(&Self::permute_1_0_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<ConsTypeList> {
        let mut ts = match self.element_index_type_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_1_0_2.remove(&Self::permute_1_0_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ConsTypeListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ConsTypeList"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SnocTypeList(pub TypeList, pub Type, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct SnocTypeListTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_type: BTreeMap<Type, Vec<SnocTypeList>>,
    element_index_type_list: BTreeMap<TypeList, Vec<SnocTypeList>>,
}
impl SnocTypeListTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_type: BTreeMap::new(),
            element_index_type_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: SnocTypeList) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_type_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_list.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type.insert(t.1, vec![t]);
                }
            };

            match self.element_index_type_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_list.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: SnocTypeList) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: SnocTypeList) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> SnocTypeList {
        SnocTypeList(TypeList::from(t.0), Type::from(t.1), TypeList::from(t.2))
    }
    #[allow(unused)]
    fn permute_2_0_1(t: SnocTypeList) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> SnocTypeList {
        SnocTypeList(TypeList::from(t.1), Type::from(t.2), TypeList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = SnocTypeList> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = SnocTypeList> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TypeList) -> impl '_ + Iterator<Item = SnocTypeList> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: TypeList, arg1: Type) -> impl '_ + Iterator<Item = SnocTypeList> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: TypeList,
        arg1: Type,
        arg2: TypeList,
    ) -> impl '_ + Iterator<Item = SnocTypeList> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: TypeList) -> impl '_ + Iterator<Item = SnocTypeList> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_type(&mut self, tm: Type) -> Vec<SnocTypeList> {
        let mut ts = match self.element_index_type.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<SnocTypeList> {
        let mut ts = match self.element_index_type_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for SnocTypeListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("SnocTypeList"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticType(pub Ident, pub Type);
#[derive(Clone, Hash, Debug)]
struct SemanticTypeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_ident: BTreeMap<Ident, Vec<SemanticType>>,
    element_index_type: BTreeMap<Type, Vec<SemanticType>>,
}
impl SemanticTypeTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_ident: BTreeMap::new(),
            element_index_type: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: SemanticType) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: SemanticType) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: SemanticType) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> SemanticType {
        SemanticType(Ident::from(t.0), Type::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: SemanticType) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> SemanticType {
        SemanticType(Ident::from(t.1), Type::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = SemanticType> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = SemanticType> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Ident) -> impl '_ + Iterator<Item = SemanticType> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Ident, arg1: Type) -> impl '_ + Iterator<Item = SemanticType> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Type) -> impl '_ + Iterator<Item = SemanticType> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<SemanticType> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_type(&mut self, tm: Type) -> Vec<SemanticType> {
        let mut ts = match self.element_index_type.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for SemanticTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticArgTypes(pub ArgDeclListNode, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct SemanticArgTypesTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<SemanticArgTypes>>,
    element_index_type_list: BTreeMap<TypeList, Vec<SemanticArgTypes>>,
}
impl SemanticArgTypesTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_arg_decl_list_node: BTreeMap::new(),
            element_index_type_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: SemanticArgTypes) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_arg_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_list.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: SemanticArgTypes) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: SemanticArgTypes) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> SemanticArgTypes {
        SemanticArgTypes(ArgDeclListNode::from(t.0), TypeList::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: SemanticArgTypes) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> SemanticArgTypes {
        SemanticArgTypes(ArgDeclListNode::from(t.1), TypeList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = SemanticArgTypes> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = SemanticArgTypes> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ArgDeclListNode) -> impl '_ + Iterator<Item = SemanticArgTypes> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: ArgDeclListNode,
        arg1: TypeList,
    ) -> impl '_ + Iterator<Item = SemanticArgTypes> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TypeList) -> impl '_ + Iterator<Item = SemanticArgTypes> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_list_node(
        &mut self,
        tm: ArgDeclListNode,
    ) -> Vec<SemanticArgTypes> {
        let mut ts = match self.element_index_arg_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<SemanticArgTypes> {
        let mut ts = match self.element_index_type_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for SemanticArgTypesTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_arg_types"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticPred(pub Ident, pub Pred);
#[derive(Clone, Hash, Debug)]
struct SemanticPredTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_ident: BTreeMap<Ident, Vec<SemanticPred>>,
    element_index_pred: BTreeMap<Pred, Vec<SemanticPred>>,
}
impl SemanticPredTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_ident: BTreeMap::new(),
            element_index_pred: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: SemanticPred) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.0, vec![t]);
                }
            };

            match self.element_index_pred.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_pred.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: SemanticPred) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: SemanticPred) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> SemanticPred {
        SemanticPred(Ident::from(t.0), Pred::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: SemanticPred) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> SemanticPred {
        SemanticPred(Ident::from(t.1), Pred::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = SemanticPred> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = SemanticPred> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Ident) -> impl '_ + Iterator<Item = SemanticPred> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Ident, arg1: Pred) -> impl '_ + Iterator<Item = SemanticPred> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Pred) -> impl '_ + Iterator<Item = SemanticPred> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<SemanticPred> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_pred(&mut self, tm: Pred) -> Vec<SemanticPred> {
        let mut ts = match self.element_index_pred.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for SemanticPredTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_pred"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredArity(pub Pred, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct PredArityTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_pred: BTreeMap<Pred, Vec<PredArity>>,
    element_index_type_list: BTreeMap<TypeList, Vec<PredArity>>,
}
impl PredArityTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_pred: BTreeMap::new(),
            element_index_type_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: PredArity) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_pred.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_pred.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_list.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: PredArity) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: PredArity) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> PredArity {
        PredArity(Pred::from(t.0), TypeList::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: PredArity) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> PredArity {
        PredArity(Pred::from(t.1), TypeList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = PredArity> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = PredArity> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Pred) -> impl '_ + Iterator<Item = PredArity> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Pred, arg1: TypeList) -> impl '_ + Iterator<Item = PredArity> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TypeList) -> impl '_ + Iterator<Item = PredArity> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_pred(&mut self, tm: Pred) -> Vec<PredArity> {
        let mut ts = match self.element_index_pred.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<PredArity> {
        let mut ts = match self.element_index_type_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for PredArityTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_arity"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticFunc(pub Ident, pub Func);
#[derive(Clone, Hash, Debug)]
struct SemanticFuncTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_func: BTreeMap<Func, Vec<SemanticFunc>>,
    element_index_ident: BTreeMap<Ident, Vec<SemanticFunc>>,
}
impl SemanticFuncTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_func: BTreeMap::new(),
            element_index_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: SemanticFunc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.0, vec![t]);
                }
            };

            match self.element_index_func.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_func.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: SemanticFunc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: SemanticFunc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> SemanticFunc {
        SemanticFunc(Ident::from(t.0), Func::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: SemanticFunc) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> SemanticFunc {
        SemanticFunc(Ident::from(t.1), Func::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = SemanticFunc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = SemanticFunc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Ident) -> impl '_ + Iterator<Item = SemanticFunc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Ident, arg1: Func) -> impl '_ + Iterator<Item = SemanticFunc> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Func) -> impl '_ + Iterator<Item = SemanticFunc> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_func(&mut self, tm: Func) -> Vec<SemanticFunc> {
        let mut ts = match self.element_index_func.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<SemanticFunc> {
        let mut ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for SemanticFuncTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_func"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Domain(pub Func, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct DomainTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_func: BTreeMap<Func, Vec<Domain>>,
    element_index_type_list: BTreeMap<TypeList, Vec<Domain>>,
}
impl DomainTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_func: BTreeMap::new(),
            element_index_type_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: Domain) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_func.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_func.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_list.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: Domain) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: Domain) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> Domain {
        Domain(Func::from(t.0), TypeList::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: Domain) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> Domain {
        Domain(Func::from(t.1), TypeList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = Domain> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = Domain> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Func) -> impl '_ + Iterator<Item = Domain> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Func, arg1: TypeList) -> impl '_ + Iterator<Item = Domain> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TypeList) -> impl '_ + Iterator<Item = Domain> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_func(&mut self, tm: Func) -> Vec<Domain> {
        let mut ts = match self.element_index_func.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<Domain> {
        let mut ts = match self.element_index_type_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for DomainTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("domain"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Codomain(pub Func, pub Type);
#[derive(Clone, Hash, Debug)]
struct CodomainTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_func: BTreeMap<Func, Vec<Codomain>>,
    element_index_type: BTreeMap<Type, Vec<Codomain>>,
}
impl CodomainTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_func: BTreeMap::new(),
            element_index_type: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: Codomain) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_func.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_func.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: Codomain) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: Codomain) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> Codomain {
        Codomain(Func::from(t.0), Type::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: Codomain) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> Codomain {
        Codomain(Func::from(t.1), Type::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = Codomain> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = Codomain> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Func) -> impl '_ + Iterator<Item = Codomain> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Func, arg1: Type) -> impl '_ + Iterator<Item = Codomain> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Type) -> impl '_ + Iterator<Item = Codomain> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_func(&mut self, tm: Func) -> Vec<Codomain> {
        let mut ts = match self.element_index_func.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_type(&mut self, tm: Type) -> Vec<Codomain> {
        let mut ts = match self.element_index_type.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for CodomainTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("codomain"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredRel(pub Pred, pub Rel);
#[derive(Clone, Hash, Debug)]
struct PredRelTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_pred: BTreeMap<Pred, Vec<PredRel>>,
    element_index_rel: BTreeMap<Rel, Vec<PredRel>>,
}
impl PredRelTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_pred: BTreeMap::new(),
            element_index_rel: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: PredRel) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_pred.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_pred.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rel.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rel.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: PredRel) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: PredRel) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> PredRel {
        PredRel(Pred::from(t.0), Rel::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: PredRel) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> PredRel {
        PredRel(Pred::from(t.1), Rel::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = PredRel> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = PredRel> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Pred) -> impl '_ + Iterator<Item = PredRel> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Pred, arg1: Rel) -> impl '_ + Iterator<Item = PredRel> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Rel) -> impl '_ + Iterator<Item = PredRel> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_pred(&mut self, tm: Pred) -> Vec<PredRel> {
        let mut ts = match self.element_index_pred.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_rel(&mut self, tm: Rel) -> Vec<PredRel> {
        let mut ts = match self.element_index_rel.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for PredRelTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("PredRel"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncRel(pub Func, pub Rel);
#[derive(Clone, Hash, Debug)]
struct FuncRelTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_func: BTreeMap<Func, Vec<FuncRel>>,
    element_index_rel: BTreeMap<Rel, Vec<FuncRel>>,
}
impl FuncRelTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_func: BTreeMap::new(),
            element_index_rel: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: FuncRel) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_func.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_func.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rel.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rel.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: FuncRel) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: FuncRel) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> FuncRel {
        FuncRel(Func::from(t.0), Rel::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: FuncRel) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> FuncRel {
        FuncRel(Func::from(t.1), Rel::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = FuncRel> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = FuncRel> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Func) -> impl '_ + Iterator<Item = FuncRel> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Func, arg1: Rel) -> impl '_ + Iterator<Item = FuncRel> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Rel) -> impl '_ + Iterator<Item = FuncRel> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_func(&mut self, tm: Func) -> Vec<FuncRel> {
        let mut ts = match self.element_index_func.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_rel(&mut self, tm: Rel) -> Vec<FuncRel> {
        let mut ts = match self.element_index_rel.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for FuncRelTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("FuncRel"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Arity(pub Rel, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct ArityTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_rel: BTreeMap<Rel, Vec<Arity>>,
    element_index_type_list: BTreeMap<TypeList, Vec<Arity>>,
}
impl ArityTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_rel: BTreeMap::new(),
            element_index_type_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: Arity) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_rel.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rel.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_list.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: Arity) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: Arity) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> Arity {
        Arity(Rel::from(t.0), TypeList::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = Arity> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = Arity> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Rel) -> impl '_ + Iterator<Item = Arity> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Rel, arg1: TypeList) -> impl '_ + Iterator<Item = Arity> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_rel(&mut self, tm: Rel) -> Vec<Arity> {
        let mut ts = match self.element_index_rel.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<Arity> {
        let mut ts = match self.element_index_type_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ArityTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("arity"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Dom(pub Morphism, pub Structure);
#[derive(Clone, Hash, Debug)]
struct DomTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_morphism: BTreeMap<Morphism, Vec<Dom>>,
    element_index_structure: BTreeMap<Structure, Vec<Dom>>,
}
impl DomTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_morphism: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: Dom) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: Dom) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: Dom) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> Dom {
        Dom(Morphism::from(t.0), Structure::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: Dom) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> Dom {
        Dom(Morphism::from(t.1), Structure::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = Dom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = Dom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = Dom> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Morphism, arg1: Structure) -> impl '_ + Iterator<Item = Dom> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = Dom> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<Dom> {
        let mut ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<Dom> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for DomTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("dom"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Cod(pub Morphism, pub Structure);
#[derive(Clone, Hash, Debug)]
struct CodTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_morphism: BTreeMap<Morphism, Vec<Cod>>,
    element_index_structure: BTreeMap<Structure, Vec<Cod>>,
}
impl CodTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_morphism: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: Cod) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: Cod) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: Cod) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> Cod {
        Cod(Morphism::from(t.0), Structure::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: Cod) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> Cod {
        Cod(Morphism::from(t.1), Structure::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = Cod> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = Cod> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = Cod> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Morphism, arg1: Structure) -> impl '_ + Iterator<Item = Cod> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = Cod> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<Cod> {
        let mut ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<Cod> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for CodTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cod"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilElList(pub Structure, pub ElList);
#[derive(Clone, Hash, Debug)]
struct NilElListTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_el_list: BTreeMap<ElList, Vec<NilElList>>,
    element_index_structure: BTreeMap<Structure, Vec<NilElList>>,
}
impl NilElListTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_el_list: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NilElList) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_structure.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NilElList) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: NilElList) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> NilElList {
        NilElList(Structure::from(t.0), ElList::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: NilElList) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> NilElList {
        NilElList(Structure::from(t.1), ElList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NilElList> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NilElList> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Structure) -> impl '_ + Iterator<Item = NilElList> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Structure, arg1: ElList) -> impl '_ + Iterator<Item = NilElList> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: ElList) -> impl '_ + Iterator<Item = NilElList> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<NilElList> {
        let mut ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<NilElList> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for NilElListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("NilElList"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsElList(pub El, pub ElList, pub ElList);
#[derive(Clone, Hash, Debug)]
struct ConsElListTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_2_0: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_el: BTreeMap<El, Vec<ConsElList>>,
    element_index_el_list: BTreeMap<ElList, Vec<ConsElList>>,
}
impl ConsElListTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_2_0: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_el: BTreeMap::new(),
            element_index_el_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ConsElList) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_2_0.insert(Self::permute_1_2_0(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.1, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ConsElList) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: ConsElList) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> ConsElList {
        ConsElList(El::from(t.0), ElList::from(t.1), ElList::from(t.2))
    }
    #[allow(unused)]
    fn permute_1_2_0(t: ConsElList) -> (u32, u32, u32) {
        (t.1.into(), t.2.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_2_0(t: (u32, u32, u32)) -> ConsElList {
        ConsElList(El::from(t.2), ElList::from(t.0), ElList::from(t.1))
    }
    #[allow(unused)]
    fn permute_2_0_1(t: ConsElList) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> ConsElList {
        ConsElList(El::from(t.1), ElList::from(t.2), ElList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ConsElList> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ConsElList> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: El) -> impl '_ + Iterator<Item = ConsElList> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: El, arg1: ElList) -> impl '_ + Iterator<Item = ConsElList> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: El,
        arg1: ElList,
        arg2: ElList,
    ) -> impl '_ + Iterator<Item = ConsElList> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_2(&self, arg0: El, arg2: ElList) -> impl '_ + Iterator<Item = ConsElList> {
        let arg0 = arg0.0;
        let arg2 = arg2.0;
        let min = (arg2, arg0, u32::MIN);
        let max = (arg2, arg0, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: ElList) -> impl '_ + Iterator<Item = ConsElList> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_1_2(&self, arg1: ElList, arg2: ElList) -> impl '_ + Iterator<Item = ConsElList> {
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg2, u32::MIN);
        let max = (arg1, arg2, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: ElList) -> impl '_ + Iterator<Item = ConsElList> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> Vec<ConsElList> {
        let mut ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<ConsElList> {
        let mut ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ConsElListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ConsElList"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SnocElList(pub ElList, pub El, pub ElList);
#[derive(Clone, Hash, Debug)]
struct SnocElListTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_2_0: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_el: BTreeMap<El, Vec<SnocElList>>,
    element_index_el_list: BTreeMap<ElList, Vec<SnocElList>>,
}
impl SnocElListTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_2_0: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_el: BTreeMap::new(),
            element_index_el_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: SnocElList) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_2_0.insert(Self::permute_1_2_0(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_el_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.1, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: SnocElList) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: SnocElList) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> SnocElList {
        SnocElList(ElList::from(t.0), El::from(t.1), ElList::from(t.2))
    }
    #[allow(unused)]
    fn permute_1_2_0(t: SnocElList) -> (u32, u32, u32) {
        (t.1.into(), t.2.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_2_0(t: (u32, u32, u32)) -> SnocElList {
        SnocElList(ElList::from(t.2), El::from(t.0), ElList::from(t.1))
    }
    #[allow(unused)]
    fn permute_2_0_1(t: SnocElList) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> SnocElList {
        SnocElList(ElList::from(t.1), El::from(t.2), ElList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = SnocElList> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = SnocElList> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ElList) -> impl '_ + Iterator<Item = SnocElList> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: ElList, arg1: El) -> impl '_ + Iterator<Item = SnocElList> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: ElList,
        arg1: El,
        arg2: ElList,
    ) -> impl '_ + Iterator<Item = SnocElList> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_2(&self, arg0: ElList, arg2: ElList) -> impl '_ + Iterator<Item = SnocElList> {
        let arg0 = arg0.0;
        let arg2 = arg2.0;
        let min = (arg2, arg0, u32::MIN);
        let max = (arg2, arg0, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: El) -> impl '_ + Iterator<Item = SnocElList> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_1_2(&self, arg1: El, arg2: ElList) -> impl '_ + Iterator<Item = SnocElList> {
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg2, u32::MIN);
        let max = (arg1, arg2, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: ElList) -> impl '_ + Iterator<Item = SnocElList> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> Vec<SnocElList> {
        let mut ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<SnocElList> {
        let mut ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for SnocElListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("SnocElList"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElStructure(pub El, pub Structure);
#[derive(Clone, Hash, Debug)]
struct ElStructureTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_el: BTreeMap<El, Vec<ElStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<ElStructure>>,
}
impl ElStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_el: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ElStructure) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ElStructure) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ElStructure) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ElStructure {
        ElStructure(El::from(t.0), Structure::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: ElStructure) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> ElStructure {
        ElStructure(El::from(t.1), Structure::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ElStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ElStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: El) -> impl '_ + Iterator<Item = ElStructure> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: El, arg1: Structure) -> impl '_ + Iterator<Item = ElStructure> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = ElStructure> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> Vec<ElStructure> {
        let mut ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<ElStructure> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ElStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("el_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElsStructure(pub ElList, pub Structure);
#[derive(Clone, Hash, Debug)]
struct ElsStructureTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_el_list: BTreeMap<ElList, Vec<ElsStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<ElsStructure>>,
}
impl ElsStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_el_list: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ElsStructure) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_el_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ElsStructure) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ElsStructure) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ElsStructure {
        ElsStructure(ElList::from(t.0), Structure::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: ElsStructure) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> ElsStructure {
        ElsStructure(ElList::from(t.1), Structure::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ElsStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ElsStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ElList) -> impl '_ + Iterator<Item = ElsStructure> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: ElList,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = ElsStructure> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = ElsStructure> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<ElsStructure> {
        let mut ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<ElsStructure> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ElsStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("els_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncApp(pub Func, pub ElList, pub El);
#[derive(Clone, Hash, Debug)]
struct FuncAppTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    element_index_el: BTreeMap<El, Vec<FuncApp>>,
    element_index_el_list: BTreeMap<ElList, Vec<FuncApp>>,
    element_index_func: BTreeMap<Func, Vec<FuncApp>>,
}
impl FuncAppTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            element_index_el: BTreeMap::new(),
            element_index_el_list: BTreeMap::new(),
            element_index_func: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: FuncApp) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_func.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_func.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.1, vec![t]);
                }
            };

            match self.element_index_el.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: FuncApp) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: FuncApp) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> FuncApp {
        FuncApp(Func::from(t.0), ElList::from(t.1), El::from(t.2))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = FuncApp> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = FuncApp> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Func, arg1: ElList) -> impl '_ + Iterator<Item = FuncApp> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Func,
        arg1: ElList,
        arg2: El,
    ) -> impl '_ + Iterator<Item = FuncApp> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> Vec<FuncApp> {
        let mut ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<FuncApp> {
        let mut ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_func(&mut self, tm: Func) -> Vec<FuncApp> {
        let mut ts = match self.element_index_func.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for FuncAppTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("func_app"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MapEl(pub Morphism, pub El, pub El);
#[derive(Clone, Hash, Debug)]
struct MapElTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_el: BTreeMap<El, Vec<MapEl>>,
    element_index_morphism: BTreeMap<Morphism, Vec<MapEl>>,
}
impl MapElTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_el: BTreeMap::new(),
            element_index_morphism: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: MapEl) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_0_2.insert(Self::permute_1_0_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.1, vec![t]);
                }
            };

            match self.element_index_el.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: MapEl) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: MapEl) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> MapEl {
        MapEl(Morphism::from(t.0), El::from(t.1), El::from(t.2))
    }
    #[allow(unused)]
    fn permute_1_0_2(t: MapEl) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> MapEl {
        MapEl(Morphism::from(t.1), El::from(t.0), El::from(t.2))
    }
    #[allow(unused)]
    fn permute_2_0_1(t: MapEl) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> MapEl {
        MapEl(Morphism::from(t.1), El::from(t.2), El::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = MapEl> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = MapEl> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = MapEl> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Morphism, arg1: El) -> impl '_ + Iterator<Item = MapEl> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Morphism,
        arg1: El,
        arg2: El,
    ) -> impl '_ + Iterator<Item = MapEl> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_2(&self, arg0: Morphism, arg2: El) -> impl '_ + Iterator<Item = MapEl> {
        let arg0 = arg0.0;
        let arg2 = arg2.0;
        let min = (arg2, arg0, u32::MIN);
        let max = (arg2, arg0, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: El) -> impl '_ + Iterator<Item = MapEl> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: El) -> impl '_ + Iterator<Item = MapEl> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> Vec<MapEl> {
        let mut ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<MapEl> {
        let mut ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for MapElTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("map_el"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MapEls(pub Morphism, pub ElList, pub ElList);
#[derive(Clone, Hash, Debug)]
struct MapElsTable {
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_el_list: BTreeMap<ElList, Vec<MapEls>>,
    element_index_morphism: BTreeMap<Morphism, Vec<MapEls>>,
}
impl MapElsTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_el_list: BTreeMap::new(),
            element_index_morphism: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: MapEls) -> bool {
        if self.index_all_1_0_2.insert(Self::permute_1_0_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.1, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: MapEls) -> bool {
        self.index_all_1_0_2.contains(&Self::permute_1_0_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: MapEls) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> MapEls {
        MapEls(Morphism::from(t.0), ElList::from(t.1), ElList::from(t.2))
    }
    #[allow(unused)]
    fn permute_1_0_2(t: MapEls) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> MapEls {
        MapEls(Morphism::from(t.1), ElList::from(t.0), ElList::from(t.2))
    }
    #[allow(unused)]
    fn permute_2_0_1(t: MapEls) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> MapEls {
        MapEls(Morphism::from(t.1), ElList::from(t.2), ElList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = MapEls> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = MapEls> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Morphism, arg1: ElList) -> impl '_ + Iterator<Item = MapEls> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg1, arg0, u32::MIN);
        let max = (arg1, arg0, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Morphism,
        arg1: ElList,
        arg2: ElList,
    ) -> impl '_ + Iterator<Item = MapEls> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg0, arg2);
        let max = (arg1, arg0, arg2);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: ElList) -> impl '_ + Iterator<Item = MapEls> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: ElList) -> impl '_ + Iterator<Item = MapEls> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<MapEls> {
        let mut ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_1_0_2.remove(&Self::permute_1_0_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<MapEls> {
        let mut ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_1_0_2.remove(&Self::permute_1_0_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for MapElsTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("map_els"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeSymbol(pub SymbolKind);
#[derive(Clone, Hash, Debug)]
struct TypeSymbolTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<TypeSymbol>>,
}
impl TypeSymbolTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_symbol_kind: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TypeSymbol) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_symbol_kind.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_symbol_kind.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TypeSymbol) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: TypeSymbol) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> TypeSymbol {
        TypeSymbol(SymbolKind::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TypeSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TypeSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: SymbolKind) -> impl '_ + Iterator<Item = TypeSymbol> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<TypeSymbol> {
        let mut ts = match self.element_index_symbol_kind.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for TypeSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("type_symbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredSymbol(pub SymbolKind);
#[derive(Clone, Hash, Debug)]
struct PredSymbolTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<PredSymbol>>,
}
impl PredSymbolTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_symbol_kind: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: PredSymbol) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_symbol_kind.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_symbol_kind.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: PredSymbol) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: PredSymbol) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> PredSymbol {
        PredSymbol(SymbolKind::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = PredSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = PredSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: SymbolKind) -> impl '_ + Iterator<Item = PredSymbol> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<PredSymbol> {
        let mut ts = match self.element_index_symbol_kind.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for PredSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_symbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncSymbol(pub SymbolKind);
#[derive(Clone, Hash, Debug)]
struct FuncSymbolTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<FuncSymbol>>,
}
impl FuncSymbolTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_symbol_kind: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: FuncSymbol) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_symbol_kind.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_symbol_kind.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: FuncSymbol) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: FuncSymbol) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> FuncSymbol {
        FuncSymbol(SymbolKind::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = FuncSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = FuncSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: SymbolKind) -> impl '_ + Iterator<Item = FuncSymbol> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<FuncSymbol> {
        let mut ts = match self.element_index_symbol_kind.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for FuncSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("func_symbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleSymbol(pub SymbolKind);
#[derive(Clone, Hash, Debug)]
struct RuleSymbolTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<RuleSymbol>>,
}
impl RuleSymbolTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_symbol_kind: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleSymbol) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_symbol_kind.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_symbol_kind.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleSymbol) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: RuleSymbol) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> RuleSymbol {
        RuleSymbol(SymbolKind::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: SymbolKind) -> impl '_ + Iterator<Item = RuleSymbol> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<RuleSymbol> {
        let mut ts = match self.element_index_symbol_kind.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for RuleSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_symbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EnumSymbol(pub SymbolKind);
#[derive(Clone, Hash, Debug)]
struct EnumSymbolTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<EnumSymbol>>,
}
impl EnumSymbolTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_symbol_kind: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: EnumSymbol) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_symbol_kind.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_symbol_kind.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: EnumSymbol) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: EnumSymbol) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> EnumSymbol {
        EnumSymbol(SymbolKind::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = EnumSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = EnumSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: SymbolKind) -> impl '_ + Iterator<Item = EnumSymbol> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<EnumSymbol> {
        let mut ts = match self.element_index_symbol_kind.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for EnumSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("enum_symbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorSymbol(pub SymbolKind);
#[derive(Clone, Hash, Debug)]
struct CtorSymbolTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<CtorSymbol>>,
}
impl CtorSymbolTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_symbol_kind: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: CtorSymbol) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_symbol_kind.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_symbol_kind.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: CtorSymbol) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: CtorSymbol) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> CtorSymbol {
        CtorSymbol(SymbolKind::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = CtorSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = CtorSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: SymbolKind) -> impl '_ + Iterator<Item = CtorSymbol> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<CtorSymbol> {
        let mut ts = match self.element_index_symbol_kind.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for CtorSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ctor_symbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Zero(pub Nat);
#[derive(Clone, Hash, Debug)]
struct ZeroTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,
    element_index_nat: BTreeMap<Nat, Vec<Zero>>,
}
impl ZeroTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            element_index_nat: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: Zero) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_nat.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_nat.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: Zero) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: Zero) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> Zero {
        Zero(Nat::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = Zero> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = Zero> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Nat) -> impl '_ + Iterator<Item = Zero> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_nat(&mut self, tm: Nat) -> Vec<Zero> {
        let mut ts = match self.element_index_nat.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0.remove(&Self::permute_0(t)) {
                self.index_dirty_0.remove(&Self::permute_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ZeroTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("zero"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Succ(pub Nat, pub Nat);
#[derive(Clone, Hash, Debug)]
struct SuccTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_nat: BTreeMap<Nat, Vec<Succ>>,
}
impl SuccTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_nat: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: Succ) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_nat.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_nat.insert(t.0, vec![t]);
                }
            };

            match self.element_index_nat.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_nat.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: Succ) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: Succ) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> Succ {
        Succ(Nat::from(t.0), Nat::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = Succ> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = Succ> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Nat) -> impl '_ + Iterator<Item = Succ> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Nat, arg1: Nat) -> impl '_ + Iterator<Item = Succ> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_nat(&mut self, tm: Nat) -> Vec<Succ> {
        let mut ts = match self.element_index_nat.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for SuccTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("succ"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeListLen(pub TypeList, pub Nat);
#[derive(Clone, Hash, Debug)]
struct TypeListLenTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_nat: BTreeMap<Nat, Vec<TypeListLen>>,
    element_index_type_list: BTreeMap<TypeList, Vec<TypeListLen>>,
}
impl TypeListLenTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_nat: BTreeMap::new(),
            element_index_type_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TypeListLen) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_type_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_list.insert(t.0, vec![t]);
                }
            };

            match self.element_index_nat.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_nat.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TypeListLen) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: TypeListLen) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> TypeListLen {
        TypeListLen(TypeList::from(t.0), Nat::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TypeListLen> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TypeListLen> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TypeList) -> impl '_ + Iterator<Item = TypeListLen> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: TypeList, arg1: Nat) -> impl '_ + Iterator<Item = TypeListLen> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_nat(&mut self, tm: Nat) -> Vec<TypeListLen> {
        let mut ts = match self.element_index_nat.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<TypeListLen> {
        let mut ts = match self.element_index_type_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for TypeListLenTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("type_list_len"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermListLen(pub TermListNode, pub Nat);
#[derive(Clone, Hash, Debug)]
struct TermListLenTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_nat: BTreeMap<Nat, Vec<TermListLen>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<TermListLen>>,
}
impl TermListLenTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_nat: BTreeMap::new(),
            element_index_term_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TermListLen) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_nat.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_nat.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TermListLen) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: TermListLen) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> TermListLen {
        TermListLen(TermListNode::from(t.0), Nat::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TermListLen> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TermListLen> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = TermListLen> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TermListNode,
        arg1: Nat,
    ) -> impl '_ + Iterator<Item = TermListLen> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_nat(&mut self, tm: Nat) -> Vec<TermListLen> {
        let mut ts = match self.element_index_nat.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<TermListLen> {
        let mut ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for TermListLenTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("term_list_len"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct BeforeRuleStructure(pub RuleDeclNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct BeforeRuleStructureTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<BeforeRuleStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<BeforeRuleStructure>>,
}
impl BeforeRuleStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_rule_decl_node: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: BeforeRuleStructure) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_rule_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: BeforeRuleStructure) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: BeforeRuleStructure) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> BeforeRuleStructure {
        BeforeRuleStructure(RuleDeclNode::from(t.0), Structure::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = BeforeRuleStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = BeforeRuleStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = BeforeRuleStructure> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: RuleDeclNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = BeforeRuleStructure> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_decl_node(&mut self, tm: RuleDeclNode) -> Vec<BeforeRuleStructure> {
        let mut ts = match self.element_index_rule_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<BeforeRuleStructure> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for BeforeRuleStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("before_rule_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IfAtomMorphism(pub IfAtomNode, pub Structure, pub Morphism);
#[derive(Clone, Hash, Debug)]
struct IfAtomMorphismTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<IfAtomMorphism>>,
    element_index_morphism: BTreeMap<Morphism, Vec<IfAtomMorphism>>,
    element_index_structure: BTreeMap<Structure, Vec<IfAtomMorphism>>,
}
impl IfAtomMorphismTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_morphism: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: IfAtomMorphism) -> bool {
        if self.index_all_2_0_1.insert(Self::permute_2_0_1(t)) {
            self.index_all_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            match self.element_index_morphism.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: IfAtomMorphism) -> bool {
        self.index_all_2_0_1.contains(&Self::permute_2_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: IfAtomMorphism) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> IfAtomMorphism {
        IfAtomMorphism(
            IfAtomNode::from(t.0),
            Structure::from(t.1),
            Morphism::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: IfAtomMorphism) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> IfAtomMorphism {
        IfAtomMorphism(
            IfAtomNode::from(t.1),
            Structure::from(t.2),
            Morphism::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = IfAtomMorphism> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = IfAtomMorphism> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: IfAtomNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = IfAtomMorphism> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: IfAtomNode,
        arg1: Structure,
        arg2: Morphism,
    ) -> impl '_ + Iterator<Item = IfAtomMorphism> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg2, arg0, arg1);
        let max = (arg2, arg0, arg1);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: Morphism) -> impl '_ + Iterator<Item = IfAtomMorphism> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(&mut self, tm: IfAtomNode) -> Vec<IfAtomMorphism> {
        let mut ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_2_0_1.remove(&Self::permute_2_0_1(t)) {
                self.index_all_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<IfAtomMorphism> {
        let mut ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_2_0_1.remove(&Self::permute_2_0_1(t)) {
                self.index_all_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<IfAtomMorphism> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_2_0_1.remove(&Self::permute_2_0_1(t)) {
                self.index_all_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for IfAtomMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("if_atom_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ThenAtomMorphism(pub ThenAtomNode, pub Structure, pub Morphism);
#[derive(Clone, Hash, Debug)]
struct ThenAtomMorphismTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_morphism: BTreeMap<Morphism, Vec<ThenAtomMorphism>>,
    element_index_structure: BTreeMap<Structure, Vec<ThenAtomMorphism>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<ThenAtomMorphism>>,
}
impl ThenAtomMorphismTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_morphism: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
            element_index_then_atom_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ThenAtomMorphism) -> bool {
        if self.index_all_2_0_1.insert(Self::permute_2_0_1(t)) {
            self.index_all_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_then_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            match self.element_index_morphism.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ThenAtomMorphism) -> bool {
        self.index_all_2_0_1.contains(&Self::permute_2_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: ThenAtomMorphism) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> ThenAtomMorphism {
        ThenAtomMorphism(
            ThenAtomNode::from(t.0),
            Structure::from(t.1),
            Morphism::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: ThenAtomMorphism) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> ThenAtomMorphism {
        ThenAtomMorphism(
            ThenAtomNode::from(t.1),
            Structure::from(t.2),
            Morphism::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ThenAtomMorphism> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ThenAtomMorphism> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: ThenAtomNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = ThenAtomMorphism> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: ThenAtomNode,
        arg1: Structure,
        arg2: Morphism,
    ) -> impl '_ + Iterator<Item = ThenAtomMorphism> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg2, arg0, arg1);
        let max = (arg2, arg0, arg1);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: Morphism) -> impl '_ + Iterator<Item = ThenAtomMorphism> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<ThenAtomMorphism> {
        let mut ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_2_0_1.remove(&Self::permute_2_0_1(t)) {
                self.index_all_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<ThenAtomMorphism> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_2_0_1.remove(&Self::permute_2_0_1(t)) {
                self.index_all_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_then_atom_node(&mut self, tm: ThenAtomNode) -> Vec<ThenAtomMorphism> {
        let mut ts = match self.element_index_then_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_2_0_1.remove(&Self::permute_2_0_1(t)) {
                self.index_all_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for ThenAtomMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("then_atom_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct BranchStmtMorphism(pub StmtNode, pub Structure, pub Morphism);
#[derive(Clone, Hash, Debug)]
struct BranchStmtMorphismTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_morphism: BTreeMap<Morphism, Vec<BranchStmtMorphism>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<BranchStmtMorphism>>,
    element_index_structure: BTreeMap<Structure, Vec<BranchStmtMorphism>>,
}
impl BranchStmtMorphismTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_morphism: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: BranchStmtMorphism) -> bool {
        if self.index_all_2_0_1.insert(Self::permute_2_0_1(t)) {
            self.index_all_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            match self.element_index_morphism.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: BranchStmtMorphism) -> bool {
        self.index_all_2_0_1.contains(&Self::permute_2_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: BranchStmtMorphism) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> BranchStmtMorphism {
        BranchStmtMorphism(
            StmtNode::from(t.0),
            Structure::from(t.1),
            Morphism::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: BranchStmtMorphism) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> BranchStmtMorphism {
        BranchStmtMorphism(
            StmtNode::from(t.1),
            Structure::from(t.2),
            Morphism::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = BranchStmtMorphism> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = BranchStmtMorphism> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = BranchStmtMorphism> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: StmtNode,
        arg1: Structure,
        arg2: Morphism,
    ) -> impl '_ + Iterator<Item = BranchStmtMorphism> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg2, arg0, arg1);
        let max = (arg2, arg0, arg1);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: Morphism) -> impl '_ + Iterator<Item = BranchStmtMorphism> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<BranchStmtMorphism> {
        let mut ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_2_0_1.remove(&Self::permute_2_0_1(t)) {
                self.index_all_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<BranchStmtMorphism> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_2_0_1.remove(&Self::permute_2_0_1(t)) {
                self.index_all_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<BranchStmtMorphism> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_2_0_1.remove(&Self::permute_2_0_1(t)) {
                self.index_all_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for BranchStmtMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("branch_stmt_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchStmtMorphism(pub StmtNode, pub Structure, pub Morphism);
#[derive(Clone, Hash, Debug)]
struct MatchStmtMorphismTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_morphism: BTreeMap<Morphism, Vec<MatchStmtMorphism>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<MatchStmtMorphism>>,
    element_index_structure: BTreeMap<Structure, Vec<MatchStmtMorphism>>,
}
impl MatchStmtMorphismTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_morphism: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: MatchStmtMorphism) -> bool {
        if self.index_all_2_0_1.insert(Self::permute_2_0_1(t)) {
            self.index_all_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            match self.element_index_morphism.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: MatchStmtMorphism) -> bool {
        self.index_all_2_0_1.contains(&Self::permute_2_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: MatchStmtMorphism) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> MatchStmtMorphism {
        MatchStmtMorphism(
            StmtNode::from(t.0),
            Structure::from(t.1),
            Morphism::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: MatchStmtMorphism) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> MatchStmtMorphism {
        MatchStmtMorphism(
            StmtNode::from(t.1),
            Structure::from(t.2),
            Morphism::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = MatchStmtMorphism> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = MatchStmtMorphism> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = MatchStmtMorphism> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: StmtNode,
        arg1: Structure,
        arg2: Morphism,
    ) -> impl '_ + Iterator<Item = MatchStmtMorphism> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg2, arg0, arg1);
        let max = (arg2, arg0, arg1);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: Morphism) -> impl '_ + Iterator<Item = MatchStmtMorphism> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<MatchStmtMorphism> {
        let mut ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_2_0_1.remove(&Self::permute_2_0_1(t)) {
                self.index_all_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<MatchStmtMorphism> {
        let mut ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_2_0_1.remove(&Self::permute_2_0_1(t)) {
                self.index_all_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<MatchStmtMorphism> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_2_0_1.remove(&Self::permute_2_0_1(t)) {
                self.index_all_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for MatchStmtMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("match_stmt_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticName(pub VirtIdent, pub Scope, pub ElName);
#[derive(Clone, Hash, Debug)]
struct SemanticNameTable {
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    element_index_el_name: BTreeMap<ElName, Vec<SemanticName>>,
    element_index_scope: BTreeMap<Scope, Vec<SemanticName>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<SemanticName>>,
}
impl SemanticNameTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            element_index_el_name: BTreeMap::new(),
            element_index_scope: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: SemanticName) -> bool {
        if self.index_all_1_0_2.insert(Self::permute_1_0_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_virt_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.0, vec![t]);
                }
            };

            match self.element_index_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_scope.insert(t.1, vec![t]);
                }
            };

            match self.element_index_el_name.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_name.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: SemanticName) -> bool {
        self.index_all_1_0_2.contains(&Self::permute_1_0_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: SemanticName) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> SemanticName {
        SemanticName(VirtIdent::from(t.0), Scope::from(t.1), ElName::from(t.2))
    }
    #[allow(unused)]
    fn permute_1_0_2(t: SemanticName) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> SemanticName {
        SemanticName(VirtIdent::from(t.1), Scope::from(t.0), ElName::from(t.2))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = SemanticName> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = SemanticName> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: VirtIdent,
        arg1: Scope,
    ) -> impl '_ + Iterator<Item = SemanticName> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg1, arg0, u32::MIN);
        let max = (arg1, arg0, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: VirtIdent,
        arg1: Scope,
        arg2: ElName,
    ) -> impl '_ + Iterator<Item = SemanticName> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg0, arg2);
        let max = (arg1, arg0, arg2);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Scope) -> impl '_ + Iterator<Item = SemanticName> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_el_name(&mut self, tm: ElName) -> Vec<SemanticName> {
        let mut ts = match self.element_index_el_name.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_1_0_2.remove(&Self::permute_1_0_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_scope(&mut self, tm: Scope) -> Vec<SemanticName> {
        let mut ts = match self.element_index_scope.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_1_0_2.remove(&Self::permute_1_0_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(&mut self, tm: VirtIdent) -> Vec<SemanticName> {
        let mut ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_1_0_2.remove(&Self::permute_1_0_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for SemanticNameTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_name"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticEl(pub TermNode, pub Structure, pub El);
#[derive(Clone, Hash, Debug)]
struct SemanticElTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_2_0: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_el: BTreeMap<El, Vec<SemanticEl>>,
    element_index_structure: BTreeMap<Structure, Vec<SemanticEl>>,
    element_index_term_node: BTreeMap<TermNode, Vec<SemanticEl>>,
}
impl SemanticElTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_2_0: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_el: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: SemanticEl) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_2_0.insert(Self::permute_1_2_0(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            match self.element_index_el.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: SemanticEl) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: SemanticEl) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> SemanticEl {
        SemanticEl(TermNode::from(t.0), Structure::from(t.1), El::from(t.2))
    }
    #[allow(unused)]
    fn permute_1_2_0(t: SemanticEl) -> (u32, u32, u32) {
        (t.1.into(), t.2.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_2_0(t: (u32, u32, u32)) -> SemanticEl {
        SemanticEl(TermNode::from(t.2), Structure::from(t.0), El::from(t.1))
    }
    #[allow(unused)]
    fn permute_2_0_1(t: SemanticEl) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> SemanticEl {
        SemanticEl(TermNode::from(t.1), Structure::from(t.2), El::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = SemanticEl> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = SemanticEl> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = SemanticEl> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TermNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = SemanticEl> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: TermNode,
        arg1: Structure,
        arg2: El,
    ) -> impl '_ + Iterator<Item = SemanticEl> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_2(&self, arg0: TermNode, arg2: El) -> impl '_ + Iterator<Item = SemanticEl> {
        let arg0 = arg0.0;
        let arg2 = arg2.0;
        let min = (arg2, arg0, u32::MIN);
        let max = (arg2, arg0, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = SemanticEl> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_1_2(&self, arg1: Structure, arg2: El) -> impl '_ + Iterator<Item = SemanticEl> {
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg2, u32::MIN);
        let max = (arg1, arg2, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: El) -> impl '_ + Iterator<Item = SemanticEl> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> Vec<SemanticEl> {
        let mut ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<SemanticEl> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<SemanticEl> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for SemanticElTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_el"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticEls(pub TermListNode, pub Structure, pub ElList);
#[derive(Clone, Hash, Debug)]
struct SemanticElsTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,
    element_index_el_list: BTreeMap<ElList, Vec<SemanticEls>>,
    element_index_structure: BTreeMap<Structure, Vec<SemanticEls>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<SemanticEls>>,
}
impl SemanticElsTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            element_index_el_list: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
            element_index_term_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: SemanticEls) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: SemanticEls) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: SemanticEls) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> SemanticEls {
        SemanticEls(
            TermListNode::from(t.0),
            Structure::from(t.1),
            ElList::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: SemanticEls) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> SemanticEls {
        SemanticEls(
            TermListNode::from(t.1),
            Structure::from(t.2),
            ElList::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = SemanticEls> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = SemanticEls> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = SemanticEls> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TermListNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = SemanticEls> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: TermListNode,
        arg1: Structure,
        arg2: ElList,
    ) -> impl '_ + Iterator<Item = SemanticEls> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: ElList) -> impl '_ + Iterator<Item = SemanticEls> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<SemanticEls> {
        let mut ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<SemanticEls> {
        let mut ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<SemanticEls> {
        let mut ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for SemanticElsTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_els"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct WildcardName(pub TermNode, pub ElName);
#[derive(Clone, Hash, Debug)]
struct WildcardNameTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    element_index_el_name: BTreeMap<ElName, Vec<WildcardName>>,
    element_index_term_node: BTreeMap<TermNode, Vec<WildcardName>>,
}
impl WildcardNameTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            element_index_el_name: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: WildcardName) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el_name.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_name.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: WildcardName) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: WildcardName) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> WildcardName {
        WildcardName(TermNode::from(t.0), ElName::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = WildcardName> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = WildcardName> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = WildcardName> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TermNode,
        arg1: ElName,
    ) -> impl '_ + Iterator<Item = WildcardName> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_el_name(&mut self, tm: ElName) -> Vec<WildcardName> {
        let mut ts = match self.element_index_el_name.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<WildcardName> {
        let mut ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for WildcardNameTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("wildcard_name"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchCasePatternCtor(pub MatchCaseNode, pub CtorDeclNode);
#[derive(Clone, Hash, Debug)]
struct MatchCasePatternCtorTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_ctor_decl_node: BTreeMap<CtorDeclNode, Vec<MatchCasePatternCtor>>,
    element_index_match_case_node: BTreeMap<MatchCaseNode, Vec<MatchCasePatternCtor>>,
}
impl MatchCasePatternCtorTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_ctor_decl_node: BTreeMap::new(),
            element_index_match_case_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: MatchCasePatternCtor) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_match_case_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_match_case_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ctor_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ctor_decl_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: MatchCasePatternCtor) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: MatchCasePatternCtor) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> MatchCasePatternCtor {
        MatchCasePatternCtor(MatchCaseNode::from(t.0), CtorDeclNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: MatchCasePatternCtor) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> MatchCasePatternCtor {
        MatchCasePatternCtor(MatchCaseNode::from(t.1), CtorDeclNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = MatchCasePatternCtor> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = MatchCasePatternCtor> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: MatchCaseNode) -> impl '_ + Iterator<Item = MatchCasePatternCtor> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: MatchCaseNode,
        arg1: CtorDeclNode,
    ) -> impl '_ + Iterator<Item = MatchCasePatternCtor> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: CtorDeclNode) -> impl '_ + Iterator<Item = MatchCasePatternCtor> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_ctor_decl_node(&mut self, tm: CtorDeclNode) -> Vec<MatchCasePatternCtor> {
        let mut ts = match self.element_index_ctor_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_match_case_node(
        &mut self,
        tm: MatchCaseNode,
    ) -> Vec<MatchCasePatternCtor> {
        let mut ts = match self.element_index_match_case_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for MatchCasePatternCtorTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("match_case_pattern_ctor"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CasesDeterminedEnum(pub MatchCaseListNode, pub EnumDeclNode);
#[derive(Clone, Hash, Debug)]
struct CasesDeterminedEnumTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,
    element_index_enum_decl_node: BTreeMap<EnumDeclNode, Vec<CasesDeterminedEnum>>,
    element_index_match_case_list_node: BTreeMap<MatchCaseListNode, Vec<CasesDeterminedEnum>>,
}
impl CasesDeterminedEnumTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            element_index_enum_decl_node: BTreeMap::new(),
            element_index_match_case_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: CasesDeterminedEnum) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_match_case_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_match_case_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_enum_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_enum_decl_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: CasesDeterminedEnum) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: CasesDeterminedEnum) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> CasesDeterminedEnum {
        CasesDeterminedEnum(MatchCaseListNode::from(t.0), EnumDeclNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: CasesDeterminedEnum) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> CasesDeterminedEnum {
        CasesDeterminedEnum(MatchCaseListNode::from(t.1), EnumDeclNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = CasesDeterminedEnum> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = CasesDeterminedEnum> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(
        &self,
        arg0: MatchCaseListNode,
    ) -> impl '_ + Iterator<Item = CasesDeterminedEnum> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: MatchCaseListNode,
        arg1: EnumDeclNode,
    ) -> impl '_ + Iterator<Item = CasesDeterminedEnum> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: EnumDeclNode) -> impl '_ + Iterator<Item = CasesDeterminedEnum> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_enum_decl_node(&mut self, tm: EnumDeclNode) -> Vec<CasesDeterminedEnum> {
        let mut ts = match self.element_index_enum_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
    #[allow(dead_code)]
    fn drain_with_element_match_case_list_node(
        &mut self,
        tm: MatchCaseListNode,
    ) -> Vec<CasesDeterminedEnum> {
        let mut ts = match self.element_index_match_case_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        let mut i = 0;
        while i < ts.len() {
            let t = ts[i];
            if self.index_all_0_1.remove(&Self::permute_0_1(t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(t));
                self.index_all_1_0.remove(&Self::permute_1_0(t));
                i += 1;
            } else {
                ts.swap_remove(i);
            }
        }

        ts
    }
}
impl fmt::Display for CasesDeterminedEnumTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cases_determined_enum"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RealVirtIdentArgs(pub Ident);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VirtRealIdentArgs(pub VirtIdent);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarArgs(pub Structure, pub ElName);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleNameArgs(pub RuleDeclNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeDeclNodeLocArgs(pub TypeDeclNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgDeclNodeLocArgs(pub ArgDeclNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgDeclListNodeLocArgs(pub ArgDeclListNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredDeclNodeLocArgs(pub PredDeclNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncDeclNodeLocArgs(pub FuncDeclNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorDeclNodeLocArgs(pub CtorDeclNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EnumDeclNodeLocArgs(pub EnumDeclNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermNodeLocArgs(pub TermNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermListNodeLocArgs(pub TermListNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchCaseNodeLocArgs(pub MatchCaseNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct OptTermNodeLocArgs(pub OptTermNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IfAtomNodeLocArgs(pub IfAtomNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ThenAtomNodeLocArgs(pub ThenAtomNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct StmtNodeLocArgs(pub StmtNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct StmtListNodeLocArgs(pub StmtListNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDeclNodeLocArgs(pub RuleDeclNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodeLocArgs(pub DeclNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclListNodeLocArgs(pub DeclListNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ModuleNodeLocArgs(pub ModuleNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantRuleArgs(pub RuleDeclNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantTermArgs(pub TermNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantTermListArgs(pub TermListNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantOptTermArgs(pub OptTermNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantIfAtomArgs(pub IfAtomNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantThenAtomArgs(pub ThenAtomNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantMatchCaseArgs(pub MatchCaseNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantMatchCaseListArgs(pub MatchCaseListNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantStmtArgs(pub StmtNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantStmtListArgs(pub StmtListNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantStmtBlockListArgs(pub StmtBlockListNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EntryScopeArgs(pub RuleDescendantNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ExitScopeArgs(pub RuleDescendantNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorEnumArgs(pub CtorDeclNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorsEnumArgs(pub CtorDeclListNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CasesDiscrimineeArgs(pub MatchCaseListNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CaseDiscrimineeArgs(pub MatchCaseNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DesugaredCaseEqualityAtomArgs(pub MatchCaseNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DesugaredCaseEqualityStmtArgs(pub MatchCaseNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DesugaredCaseBlockArgs(pub MatchCaseNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DesugaredCaseBlockListArgs(pub MatchCaseListNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilTypeListArgs();
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsTypeListArgs(pub Type, pub TypeList);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SnocTypeListArgs(pub TypeList, pub Type);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticTypeArgs(pub Ident);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticArgTypesArgs(pub ArgDeclListNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticPredArgs(pub Ident);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredArityArgs(pub Pred);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticFuncArgs(pub Ident);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DomainArgs(pub Func);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CodomainArgs(pub Func);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredRelArgs(pub Pred);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncRelArgs(pub Func);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArityArgs(pub Rel);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DomArgs(pub Morphism);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CodArgs(pub Morphism);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilElListArgs(pub Structure);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsElListArgs(pub El, pub ElList);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SnocElListArgs(pub ElList, pub El);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElStructureArgs(pub El);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElsStructureArgs(pub ElList);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncAppArgs(pub Func, pub ElList);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MapElArgs(pub Morphism, pub El);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MapElsArgs(pub Morphism, pub ElList);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeSymbolArgs();
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredSymbolArgs();
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncSymbolArgs();
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleSymbolArgs();
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EnumSymbolArgs();
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorSymbolArgs();
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ZeroArgs();
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SuccArgs(pub Nat);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeListLenArgs(pub TypeList);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermListLenArgs(pub TermListNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct BeforeRuleStructureArgs(pub RuleDeclNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IfAtomMorphismArgs(pub IfAtomNode, pub Structure);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ThenAtomMorphismArgs(pub ThenAtomNode, pub Structure);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct BranchStmtMorphismArgs(pub StmtNode, pub Structure);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchStmtMorphismArgs(pub StmtNode, pub Structure);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticNameArgs(pub VirtIdent, pub Scope);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticElArgs(pub TermNode, pub Structure);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticElsArgs(pub TermListNode, pub Structure);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct WildcardNameArgs(pub TermNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchCasePatternCtorArgs(pub MatchCaseNode);
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CasesDeterminedEnumArgs(pub MatchCaseListNode);

#[derive(Debug, Clone)]
struct ModelDelta {
    new_absurd: Vec<Absurd>,
    new_type_decl: Vec<TypeDecl>,
    new_arg_decl_node_name: Vec<ArgDeclNodeName>,
    new_arg_decl_node_type: Vec<ArgDeclNodeType>,
    new_nil_arg_decl_list_node: Vec<NilArgDeclListNode>,
    new_cons_arg_decl_list_node: Vec<ConsArgDeclListNode>,
    new_pred_decl: Vec<PredDecl>,
    new_func_decl: Vec<FuncDecl>,
    new_ctor_decl: Vec<CtorDecl>,
    new_nil_ctor_decl_list_node: Vec<NilCtorDeclListNode>,
    new_cons_ctor_decl_list_node: Vec<ConsCtorDeclListNode>,
    new_enum_decl: Vec<EnumDecl>,
    new_nil_term_list_node: Vec<NilTermListNode>,
    new_cons_term_list_node: Vec<ConsTermListNode>,
    new_none_term_node: Vec<NoneTermNode>,
    new_some_term_node: Vec<SomeTermNode>,
    new_var_term_node: Vec<VarTermNode>,
    new_wildcard_term_node: Vec<WildcardTermNode>,
    new_app_term_node: Vec<AppTermNode>,
    new_match_case: Vec<MatchCase>,
    new_nil_match_case_list_node: Vec<NilMatchCaseListNode>,
    new_cons_match_case_list_node: Vec<ConsMatchCaseListNode>,
    new_equal_if_atom_node: Vec<EqualIfAtomNode>,
    new_defined_if_atom_node: Vec<DefinedIfAtomNode>,
    new_pred_if_atom_node: Vec<PredIfAtomNode>,
    new_var_if_atom_node: Vec<VarIfAtomNode>,
    new_equal_then_atom_node: Vec<EqualThenAtomNode>,
    new_defined_then_atom_node: Vec<DefinedThenAtomNode>,
    new_pred_then_atom_node: Vec<PredThenAtomNode>,
    new_if_stmt_node: Vec<IfStmtNode>,
    new_then_stmt_node: Vec<ThenStmtNode>,
    new_branch_stmt_node: Vec<BranchStmtNode>,
    new_match_stmt_node: Vec<MatchStmtNode>,
    new_nil_stmt_list_node: Vec<NilStmtListNode>,
    new_cons_stmt_list_node: Vec<ConsStmtListNode>,
    new_nil_stmt_block_list_node: Vec<NilStmtBlockListNode>,
    new_cons_stmt_block_list_node: Vec<ConsStmtBlockListNode>,
    new_rule_decl: Vec<RuleDecl>,
    new_decl_node_type: Vec<DeclNodeType>,
    new_decl_node_pred: Vec<DeclNodePred>,
    new_decl_node_func: Vec<DeclNodeFunc>,
    new_decl_node_rule: Vec<DeclNodeRule>,
    new_decl_node_enum: Vec<DeclNodeEnum>,
    new_nil_decl_list_node: Vec<NilDeclListNode>,
    new_cons_decl_list_node: Vec<ConsDeclListNode>,
    new_decls_module_node: Vec<DeclsModuleNode>,
    new_var_in_scope: Vec<VarInScope>,
    new_scope_extension: Vec<ScopeExtension>,
    new_scope_single_child: Vec<ScopeSingleChild>,
    new_scope_extension_siblings: Vec<ScopeExtensionSiblings>,
    new_rel_app: Vec<RelApp>,
    new_el_type: Vec<ElType>,
    new_el_types: Vec<ElTypes>,
    new_constrained_el: Vec<ConstrainedEl>,
    new_constrained_els: Vec<ConstrainedEls>,
    new_in_ker: Vec<InKer>,
    new_el_in_img: Vec<ElInImg>,
    new_rel_tuple_in_img: Vec<RelTupleInImg>,
    new_defined_symbol: Vec<DefinedSymbol>,
    new_should_be_symbol: Vec<ShouldBeSymbol>,
    new_should_be_symbol_2: Vec<ShouldBeSymbol2>,
    new_pred_arg_num_should_match: Vec<PredArgNumShouldMatch>,
    new_func_arg_num_should_match: Vec<FuncArgNumShouldMatch>,
    new_cfg_edge: Vec<CfgEdge>,
    new_cfg_edge_stmts_stmt: Vec<CfgEdgeStmtsStmt>,
    new_cfg_edge_stmt_stmts: Vec<CfgEdgeStmtStmts>,
    new_cfg_edge_fork: Vec<CfgEdgeFork>,
    new_cfg_edge_join: Vec<CfgEdgeJoin>,
    new_before_stmt_structure: Vec<BeforeStmtStructure>,
    new_stmt_morphism: Vec<StmtMorphism>,
    new_if_morphism: Vec<IfMorphism>,
    new_surj_then_morphism: Vec<SurjThenMorphism>,
    new_non_surj_then_morphism: Vec<NonSurjThenMorphism>,
    new_noop_morphism: Vec<NoopMorphism>,
    new_stmt_structure: Vec<StmtStructure>,
    new_if_atom_structure: Vec<IfAtomStructure>,
    new_then_atom_structure: Vec<ThenAtomStructure>,
    new_term_structure: Vec<TermStructure>,
    new_terms_structure: Vec<TermsStructure>,
    new_opt_term_structure: Vec<OptTermStructure>,
    new_term_should_be_epic_ok: Vec<TermShouldBeEpicOk>,
    new_terms_should_be_epic_ok: Vec<TermsShouldBeEpicOk>,
    new_el_should_be_surjective_ok: Vec<ElShouldBeSurjectiveOk>,
    new_el_is_surjective_ok: Vec<ElIsSurjectiveOk>,
    new_should_be_obtained_by_ctor: Vec<ShouldBeObtainedByCtor>,
    new_is_given_by_ctor: Vec<IsGivenByCtor>,
    new_function_can_be_made_defined: Vec<FunctionCanBeMadeDefined>,
    new_case_pattern_is_variable: Vec<CasePatternIsVariable>,
    new_case_pattern_is_wildcard: Vec<CasePatternIsWildcard>,
    new_is_pattern_ctor_arg: Vec<IsPatternCtorArg>,
    new_are_pattern_ctor_args: Vec<ArePatternCtorArgs>,
    new_pattern_ctor_arg_is_app: Vec<PatternCtorArgIsApp>,
    new_pattern_ctor_arg_var_is_not_fresh: Vec<PatternCtorArgVarIsNotFresh>,
    new_cases_contain_ctor: Vec<CasesContainCtor>,
    new_match_stmt_contains_ctor_of_enum: Vec<MatchStmtContainsCtorOfEnum>,
    new_match_stmt_should_contain_ctor: Vec<MatchStmtShouldContainCtor>,
    new_match_stmt_contains_ctor: Vec<MatchStmtContainsCtor>,
    new_real_virt_ident: Vec<RealVirtIdent>,
    new_virt_real_ident: Vec<VirtRealIdent>,
    new_var: Vec<Var>,
    new_rule_name: Vec<RuleName>,
    new_type_decl_node_loc: Vec<TypeDeclNodeLoc>,
    new_arg_decl_node_loc: Vec<ArgDeclNodeLoc>,
    new_arg_decl_list_node_loc: Vec<ArgDeclListNodeLoc>,
    new_pred_decl_node_loc: Vec<PredDeclNodeLoc>,
    new_func_decl_node_loc: Vec<FuncDeclNodeLoc>,
    new_ctor_decl_node_loc: Vec<CtorDeclNodeLoc>,
    new_enum_decl_node_loc: Vec<EnumDeclNodeLoc>,
    new_term_node_loc: Vec<TermNodeLoc>,
    new_term_list_node_loc: Vec<TermListNodeLoc>,
    new_match_case_node_loc: Vec<MatchCaseNodeLoc>,
    new_opt_term_node_loc: Vec<OptTermNodeLoc>,
    new_if_atom_node_loc: Vec<IfAtomNodeLoc>,
    new_then_atom_node_loc: Vec<ThenAtomNodeLoc>,
    new_stmt_node_loc: Vec<StmtNodeLoc>,
    new_stmt_list_node_loc: Vec<StmtListNodeLoc>,
    new_rule_decl_node_loc: Vec<RuleDeclNodeLoc>,
    new_decl_node_loc: Vec<DeclNodeLoc>,
    new_decl_list_node_loc: Vec<DeclListNodeLoc>,
    new_module_node_loc: Vec<ModuleNodeLoc>,
    new_rule_descendant_rule: Vec<RuleDescendantRule>,
    new_rule_descendant_term: Vec<RuleDescendantTerm>,
    new_rule_descendant_term_list: Vec<RuleDescendantTermList>,
    new_rule_descendant_opt_term: Vec<RuleDescendantOptTerm>,
    new_rule_descendant_if_atom: Vec<RuleDescendantIfAtom>,
    new_rule_descendant_then_atom: Vec<RuleDescendantThenAtom>,
    new_rule_descendant_match_case: Vec<RuleDescendantMatchCase>,
    new_rule_descendant_match_case_list: Vec<RuleDescendantMatchCaseList>,
    new_rule_descendant_stmt: Vec<RuleDescendantStmt>,
    new_rule_descendant_stmt_list: Vec<RuleDescendantStmtList>,
    new_rule_descendant_stmt_block_list: Vec<RuleDescendantStmtBlockList>,
    new_entry_scope: Vec<EntryScope>,
    new_exit_scope: Vec<ExitScope>,
    new_ctor_enum: Vec<CtorEnum>,
    new_ctors_enum: Vec<CtorsEnum>,
    new_cases_discriminee: Vec<CasesDiscriminee>,
    new_case_discriminee: Vec<CaseDiscriminee>,
    new_desugared_case_equality_atom: Vec<DesugaredCaseEqualityAtom>,
    new_desugared_case_equality_stmt: Vec<DesugaredCaseEqualityStmt>,
    new_desugared_case_block: Vec<DesugaredCaseBlock>,
    new_desugared_case_block_list: Vec<DesugaredCaseBlockList>,
    new_nil_type_list: Vec<NilTypeList>,
    new_cons_type_list: Vec<ConsTypeList>,
    new_snoc_type_list: Vec<SnocTypeList>,
    new_semantic_type: Vec<SemanticType>,
    new_semantic_arg_types: Vec<SemanticArgTypes>,
    new_semantic_pred: Vec<SemanticPred>,
    new_pred_arity: Vec<PredArity>,
    new_semantic_func: Vec<SemanticFunc>,
    new_domain: Vec<Domain>,
    new_codomain: Vec<Codomain>,
    new_pred_rel: Vec<PredRel>,
    new_func_rel: Vec<FuncRel>,
    new_arity: Vec<Arity>,
    new_dom: Vec<Dom>,
    new_cod: Vec<Cod>,
    new_nil_el_list: Vec<NilElList>,
    new_cons_el_list: Vec<ConsElList>,
    new_snoc_el_list: Vec<SnocElList>,
    new_el_structure: Vec<ElStructure>,
    new_els_structure: Vec<ElsStructure>,
    new_func_app: Vec<FuncApp>,
    new_map_el: Vec<MapEl>,
    new_map_els: Vec<MapEls>,
    new_type_symbol: Vec<TypeSymbol>,
    new_pred_symbol: Vec<PredSymbol>,
    new_func_symbol: Vec<FuncSymbol>,
    new_rule_symbol: Vec<RuleSymbol>,
    new_enum_symbol: Vec<EnumSymbol>,
    new_ctor_symbol: Vec<CtorSymbol>,
    new_zero: Vec<Zero>,
    new_succ: Vec<Succ>,
    new_type_list_len: Vec<TypeListLen>,
    new_term_list_len: Vec<TermListLen>,
    new_before_rule_structure: Vec<BeforeRuleStructure>,
    new_if_atom_morphism: Vec<IfAtomMorphism>,
    new_then_atom_morphism: Vec<ThenAtomMorphism>,
    new_branch_stmt_morphism: Vec<BranchStmtMorphism>,
    new_match_stmt_morphism: Vec<MatchStmtMorphism>,
    new_semantic_name: Vec<SemanticName>,
    new_semantic_el: Vec<SemanticEl>,
    new_semantic_els: Vec<SemanticEls>,
    new_wildcard_name: Vec<WildcardName>,
    new_match_case_pattern_ctor: Vec<MatchCasePatternCtor>,
    new_cases_determined_enum: Vec<CasesDeterminedEnum>,
    new_ident_equalities: Vec<(Ident, Ident)>,
    new_virt_ident_equalities: Vec<(VirtIdent, VirtIdent)>,
    new_type_decl_node_equalities: Vec<(TypeDeclNode, TypeDeclNode)>,
    new_arg_decl_node_equalities: Vec<(ArgDeclNode, ArgDeclNode)>,
    new_arg_decl_list_node_equalities: Vec<(ArgDeclListNode, ArgDeclListNode)>,
    new_pred_decl_node_equalities: Vec<(PredDeclNode, PredDeclNode)>,
    new_func_decl_node_equalities: Vec<(FuncDeclNode, FuncDeclNode)>,
    new_ctor_decl_node_equalities: Vec<(CtorDeclNode, CtorDeclNode)>,
    new_ctor_decl_list_node_equalities: Vec<(CtorDeclListNode, CtorDeclListNode)>,
    new_enum_decl_node_equalities: Vec<(EnumDeclNode, EnumDeclNode)>,
    new_term_node_equalities: Vec<(TermNode, TermNode)>,
    new_term_list_node_equalities: Vec<(TermListNode, TermListNode)>,
    new_opt_term_node_equalities: Vec<(OptTermNode, OptTermNode)>,
    new_match_case_node_equalities: Vec<(MatchCaseNode, MatchCaseNode)>,
    new_stmt_list_node_equalities: Vec<(StmtListNode, StmtListNode)>,
    new_match_case_list_node_equalities: Vec<(MatchCaseListNode, MatchCaseListNode)>,
    new_if_atom_node_equalities: Vec<(IfAtomNode, IfAtomNode)>,
    new_then_atom_node_equalities: Vec<(ThenAtomNode, ThenAtomNode)>,
    new_stmt_node_equalities: Vec<(StmtNode, StmtNode)>,
    new_stmt_block_list_node_equalities: Vec<(StmtBlockListNode, StmtBlockListNode)>,
    new_rule_decl_node_equalities: Vec<(RuleDeclNode, RuleDeclNode)>,
    new_decl_node_equalities: Vec<(DeclNode, DeclNode)>,
    new_decl_list_node_equalities: Vec<(DeclListNode, DeclListNode)>,
    new_module_node_equalities: Vec<(ModuleNode, ModuleNode)>,
    new_loc_equalities: Vec<(Loc, Loc)>,
    new_rule_descendant_node_equalities: Vec<(RuleDescendantNode, RuleDescendantNode)>,
    new_scope_equalities: Vec<(Scope, Scope)>,
    new_type_equalities: Vec<(Type, Type)>,
    new_type_list_equalities: Vec<(TypeList, TypeList)>,
    new_pred_equalities: Vec<(Pred, Pred)>,
    new_func_equalities: Vec<(Func, Func)>,
    new_rel_equalities: Vec<(Rel, Rel)>,
    new_structure_equalities: Vec<(Structure, Structure)>,
    new_el_equalities: Vec<(El, El)>,
    new_el_list_equalities: Vec<(ElList, ElList)>,
    new_el_name_equalities: Vec<(ElName, ElName)>,
    new_morphism_equalities: Vec<(Morphism, Morphism)>,
    new_symbol_kind_equalities: Vec<(SymbolKind, SymbolKind)>,
    new_nat_equalities: Vec<(Nat, Nat)>,
    new_real_virt_ident_def: Vec<RealVirtIdentArgs>,
    new_virt_real_ident_def: Vec<VirtRealIdentArgs>,
    new_var_def: Vec<VarArgs>,
    new_rule_name_def: Vec<RuleNameArgs>,
    new_type_decl_node_loc_def: Vec<TypeDeclNodeLocArgs>,
    new_arg_decl_node_loc_def: Vec<ArgDeclNodeLocArgs>,
    new_arg_decl_list_node_loc_def: Vec<ArgDeclListNodeLocArgs>,
    new_pred_decl_node_loc_def: Vec<PredDeclNodeLocArgs>,
    new_func_decl_node_loc_def: Vec<FuncDeclNodeLocArgs>,
    new_ctor_decl_node_loc_def: Vec<CtorDeclNodeLocArgs>,
    new_enum_decl_node_loc_def: Vec<EnumDeclNodeLocArgs>,
    new_term_node_loc_def: Vec<TermNodeLocArgs>,
    new_term_list_node_loc_def: Vec<TermListNodeLocArgs>,
    new_match_case_node_loc_def: Vec<MatchCaseNodeLocArgs>,
    new_opt_term_node_loc_def: Vec<OptTermNodeLocArgs>,
    new_if_atom_node_loc_def: Vec<IfAtomNodeLocArgs>,
    new_then_atom_node_loc_def: Vec<ThenAtomNodeLocArgs>,
    new_stmt_node_loc_def: Vec<StmtNodeLocArgs>,
    new_stmt_list_node_loc_def: Vec<StmtListNodeLocArgs>,
    new_rule_decl_node_loc_def: Vec<RuleDeclNodeLocArgs>,
    new_decl_node_loc_def: Vec<DeclNodeLocArgs>,
    new_decl_list_node_loc_def: Vec<DeclListNodeLocArgs>,
    new_module_node_loc_def: Vec<ModuleNodeLocArgs>,
    new_rule_descendant_rule_def: Vec<RuleDescendantRuleArgs>,
    new_rule_descendant_term_def: Vec<RuleDescendantTermArgs>,
    new_rule_descendant_term_list_def: Vec<RuleDescendantTermListArgs>,
    new_rule_descendant_opt_term_def: Vec<RuleDescendantOptTermArgs>,
    new_rule_descendant_if_atom_def: Vec<RuleDescendantIfAtomArgs>,
    new_rule_descendant_then_atom_def: Vec<RuleDescendantThenAtomArgs>,
    new_rule_descendant_match_case_def: Vec<RuleDescendantMatchCaseArgs>,
    new_rule_descendant_match_case_list_def: Vec<RuleDescendantMatchCaseListArgs>,
    new_rule_descendant_stmt_def: Vec<RuleDescendantStmtArgs>,
    new_rule_descendant_stmt_list_def: Vec<RuleDescendantStmtListArgs>,
    new_rule_descendant_stmt_block_list_def: Vec<RuleDescendantStmtBlockListArgs>,
    new_entry_scope_def: Vec<EntryScopeArgs>,
    new_exit_scope_def: Vec<ExitScopeArgs>,
    new_ctor_enum_def: Vec<CtorEnumArgs>,
    new_ctors_enum_def: Vec<CtorsEnumArgs>,
    new_cases_discriminee_def: Vec<CasesDiscrimineeArgs>,
    new_case_discriminee_def: Vec<CaseDiscrimineeArgs>,
    new_desugared_case_equality_atom_def: Vec<DesugaredCaseEqualityAtomArgs>,
    new_desugared_case_equality_stmt_def: Vec<DesugaredCaseEqualityStmtArgs>,
    new_desugared_case_block_def: Vec<DesugaredCaseBlockArgs>,
    new_desugared_case_block_list_def: Vec<DesugaredCaseBlockListArgs>,
    new_nil_type_list_def: Vec<NilTypeListArgs>,
    new_cons_type_list_def: Vec<ConsTypeListArgs>,
    new_snoc_type_list_def: Vec<SnocTypeListArgs>,
    new_semantic_type_def: Vec<SemanticTypeArgs>,
    new_semantic_pred_def: Vec<SemanticPredArgs>,
    new_semantic_func_def: Vec<SemanticFuncArgs>,
    new_codomain_def: Vec<CodomainArgs>,
    new_pred_rel_def: Vec<PredRelArgs>,
    new_func_rel_def: Vec<FuncRelArgs>,
    new_dom_def: Vec<DomArgs>,
    new_cod_def: Vec<CodArgs>,
    new_nil_el_list_def: Vec<NilElListArgs>,
    new_cons_el_list_def: Vec<ConsElListArgs>,
    new_snoc_el_list_def: Vec<SnocElListArgs>,
    new_el_structure_def: Vec<ElStructureArgs>,
    new_els_structure_def: Vec<ElsStructureArgs>,
    new_func_app_def: Vec<FuncAppArgs>,
    new_map_el_def: Vec<MapElArgs>,
    new_type_symbol_def: Vec<TypeSymbolArgs>,
    new_pred_symbol_def: Vec<PredSymbolArgs>,
    new_func_symbol_def: Vec<FuncSymbolArgs>,
    new_rule_symbol_def: Vec<RuleSymbolArgs>,
    new_enum_symbol_def: Vec<EnumSymbolArgs>,
    new_ctor_symbol_def: Vec<CtorSymbolArgs>,
    new_zero_def: Vec<ZeroArgs>,
    new_succ_def: Vec<SuccArgs>,
    new_type_list_len_def: Vec<TypeListLenArgs>,
    new_term_list_len_def: Vec<TermListLenArgs>,
    new_before_rule_structure_def: Vec<BeforeRuleStructureArgs>,
    new_if_atom_morphism_def: Vec<IfAtomMorphismArgs>,
    new_then_atom_morphism_def: Vec<ThenAtomMorphismArgs>,
    new_branch_stmt_morphism_def: Vec<BranchStmtMorphismArgs>,
    new_match_stmt_morphism_def: Vec<MatchStmtMorphismArgs>,
    new_semantic_name_def: Vec<SemanticNameArgs>,
    new_semantic_el_def: Vec<SemanticElArgs>,
    new_wildcard_name_def: Vec<WildcardNameArgs>,
    new_match_case_pattern_ctor_def: Vec<MatchCasePatternCtorArgs>,
    new_cases_determined_enum_def: Vec<CasesDeterminedEnumArgs>,
}
/// A model of the `Eqlog` theory.
#[derive(Debug, Clone)]
pub struct Eqlog {
    ident_equalities: Unification<Ident>,
    ident_all: BTreeSet<Ident>,
    ident_dirty: BTreeSet<Ident>,
    ident_weights: Vec<usize>,
    ident_uprooted: Vec<Ident>,

    virt_ident_equalities: Unification<VirtIdent>,
    virt_ident_all: BTreeSet<VirtIdent>,
    virt_ident_dirty: BTreeSet<VirtIdent>,
    virt_ident_weights: Vec<usize>,
    virt_ident_uprooted: Vec<VirtIdent>,

    type_decl_node_equalities: Unification<TypeDeclNode>,
    type_decl_node_all: BTreeSet<TypeDeclNode>,
    type_decl_node_dirty: BTreeSet<TypeDeclNode>,
    type_decl_node_weights: Vec<usize>,
    type_decl_node_uprooted: Vec<TypeDeclNode>,

    arg_decl_node_equalities: Unification<ArgDeclNode>,
    arg_decl_node_all: BTreeSet<ArgDeclNode>,
    arg_decl_node_dirty: BTreeSet<ArgDeclNode>,
    arg_decl_node_weights: Vec<usize>,
    arg_decl_node_uprooted: Vec<ArgDeclNode>,

    arg_decl_list_node_equalities: Unification<ArgDeclListNode>,
    arg_decl_list_node_all: BTreeSet<ArgDeclListNode>,
    arg_decl_list_node_dirty: BTreeSet<ArgDeclListNode>,
    arg_decl_list_node_weights: Vec<usize>,
    arg_decl_list_node_uprooted: Vec<ArgDeclListNode>,

    pred_decl_node_equalities: Unification<PredDeclNode>,
    pred_decl_node_all: BTreeSet<PredDeclNode>,
    pred_decl_node_dirty: BTreeSet<PredDeclNode>,
    pred_decl_node_weights: Vec<usize>,
    pred_decl_node_uprooted: Vec<PredDeclNode>,

    func_decl_node_equalities: Unification<FuncDeclNode>,
    func_decl_node_all: BTreeSet<FuncDeclNode>,
    func_decl_node_dirty: BTreeSet<FuncDeclNode>,
    func_decl_node_weights: Vec<usize>,
    func_decl_node_uprooted: Vec<FuncDeclNode>,

    ctor_decl_node_equalities: Unification<CtorDeclNode>,
    ctor_decl_node_all: BTreeSet<CtorDeclNode>,
    ctor_decl_node_dirty: BTreeSet<CtorDeclNode>,
    ctor_decl_node_weights: Vec<usize>,
    ctor_decl_node_uprooted: Vec<CtorDeclNode>,

    ctor_decl_list_node_equalities: Unification<CtorDeclListNode>,
    ctor_decl_list_node_all: BTreeSet<CtorDeclListNode>,
    ctor_decl_list_node_dirty: BTreeSet<CtorDeclListNode>,
    ctor_decl_list_node_weights: Vec<usize>,
    ctor_decl_list_node_uprooted: Vec<CtorDeclListNode>,

    enum_decl_node_equalities: Unification<EnumDeclNode>,
    enum_decl_node_all: BTreeSet<EnumDeclNode>,
    enum_decl_node_dirty: BTreeSet<EnumDeclNode>,
    enum_decl_node_weights: Vec<usize>,
    enum_decl_node_uprooted: Vec<EnumDeclNode>,

    term_node_equalities: Unification<TermNode>,
    term_node_all: BTreeSet<TermNode>,
    term_node_dirty: BTreeSet<TermNode>,
    term_node_weights: Vec<usize>,
    term_node_uprooted: Vec<TermNode>,

    term_list_node_equalities: Unification<TermListNode>,
    term_list_node_all: BTreeSet<TermListNode>,
    term_list_node_dirty: BTreeSet<TermListNode>,
    term_list_node_weights: Vec<usize>,
    term_list_node_uprooted: Vec<TermListNode>,

    opt_term_node_equalities: Unification<OptTermNode>,
    opt_term_node_all: BTreeSet<OptTermNode>,
    opt_term_node_dirty: BTreeSet<OptTermNode>,
    opt_term_node_weights: Vec<usize>,
    opt_term_node_uprooted: Vec<OptTermNode>,

    match_case_node_equalities: Unification<MatchCaseNode>,
    match_case_node_all: BTreeSet<MatchCaseNode>,
    match_case_node_dirty: BTreeSet<MatchCaseNode>,
    match_case_node_weights: Vec<usize>,
    match_case_node_uprooted: Vec<MatchCaseNode>,

    stmt_list_node_equalities: Unification<StmtListNode>,
    stmt_list_node_all: BTreeSet<StmtListNode>,
    stmt_list_node_dirty: BTreeSet<StmtListNode>,
    stmt_list_node_weights: Vec<usize>,
    stmt_list_node_uprooted: Vec<StmtListNode>,

    match_case_list_node_equalities: Unification<MatchCaseListNode>,
    match_case_list_node_all: BTreeSet<MatchCaseListNode>,
    match_case_list_node_dirty: BTreeSet<MatchCaseListNode>,
    match_case_list_node_weights: Vec<usize>,
    match_case_list_node_uprooted: Vec<MatchCaseListNode>,

    if_atom_node_equalities: Unification<IfAtomNode>,
    if_atom_node_all: BTreeSet<IfAtomNode>,
    if_atom_node_dirty: BTreeSet<IfAtomNode>,
    if_atom_node_weights: Vec<usize>,
    if_atom_node_uprooted: Vec<IfAtomNode>,

    then_atom_node_equalities: Unification<ThenAtomNode>,
    then_atom_node_all: BTreeSet<ThenAtomNode>,
    then_atom_node_dirty: BTreeSet<ThenAtomNode>,
    then_atom_node_weights: Vec<usize>,
    then_atom_node_uprooted: Vec<ThenAtomNode>,

    stmt_node_equalities: Unification<StmtNode>,
    stmt_node_all: BTreeSet<StmtNode>,
    stmt_node_dirty: BTreeSet<StmtNode>,
    stmt_node_weights: Vec<usize>,
    stmt_node_uprooted: Vec<StmtNode>,

    stmt_block_list_node_equalities: Unification<StmtBlockListNode>,
    stmt_block_list_node_all: BTreeSet<StmtBlockListNode>,
    stmt_block_list_node_dirty: BTreeSet<StmtBlockListNode>,
    stmt_block_list_node_weights: Vec<usize>,
    stmt_block_list_node_uprooted: Vec<StmtBlockListNode>,

    rule_decl_node_equalities: Unification<RuleDeclNode>,
    rule_decl_node_all: BTreeSet<RuleDeclNode>,
    rule_decl_node_dirty: BTreeSet<RuleDeclNode>,
    rule_decl_node_weights: Vec<usize>,
    rule_decl_node_uprooted: Vec<RuleDeclNode>,

    decl_node_equalities: Unification<DeclNode>,
    decl_node_all: BTreeSet<DeclNode>,
    decl_node_dirty: BTreeSet<DeclNode>,
    decl_node_weights: Vec<usize>,
    decl_node_uprooted: Vec<DeclNode>,

    decl_list_node_equalities: Unification<DeclListNode>,
    decl_list_node_all: BTreeSet<DeclListNode>,
    decl_list_node_dirty: BTreeSet<DeclListNode>,
    decl_list_node_weights: Vec<usize>,
    decl_list_node_uprooted: Vec<DeclListNode>,

    module_node_equalities: Unification<ModuleNode>,
    module_node_all: BTreeSet<ModuleNode>,
    module_node_dirty: BTreeSet<ModuleNode>,
    module_node_weights: Vec<usize>,
    module_node_uprooted: Vec<ModuleNode>,

    loc_equalities: Unification<Loc>,
    loc_all: BTreeSet<Loc>,
    loc_dirty: BTreeSet<Loc>,
    loc_weights: Vec<usize>,
    loc_uprooted: Vec<Loc>,

    rule_descendant_node_equalities: Unification<RuleDescendantNode>,
    rule_descendant_node_all: BTreeSet<RuleDescendantNode>,
    rule_descendant_node_dirty: BTreeSet<RuleDescendantNode>,
    rule_descendant_node_weights: Vec<usize>,
    rule_descendant_node_uprooted: Vec<RuleDescendantNode>,

    scope_equalities: Unification<Scope>,
    scope_all: BTreeSet<Scope>,
    scope_dirty: BTreeSet<Scope>,
    scope_weights: Vec<usize>,
    scope_uprooted: Vec<Scope>,

    type_equalities: Unification<Type>,
    type_all: BTreeSet<Type>,
    type_dirty: BTreeSet<Type>,
    type_weights: Vec<usize>,
    type_uprooted: Vec<Type>,

    type_list_equalities: Unification<TypeList>,
    type_list_all: BTreeSet<TypeList>,
    type_list_dirty: BTreeSet<TypeList>,
    type_list_weights: Vec<usize>,
    type_list_uprooted: Vec<TypeList>,

    pred_equalities: Unification<Pred>,
    pred_all: BTreeSet<Pred>,
    pred_dirty: BTreeSet<Pred>,
    pred_weights: Vec<usize>,
    pred_uprooted: Vec<Pred>,

    func_equalities: Unification<Func>,
    func_all: BTreeSet<Func>,
    func_dirty: BTreeSet<Func>,
    func_weights: Vec<usize>,
    func_uprooted: Vec<Func>,

    rel_equalities: Unification<Rel>,
    rel_all: BTreeSet<Rel>,
    rel_dirty: BTreeSet<Rel>,
    rel_weights: Vec<usize>,
    rel_uprooted: Vec<Rel>,

    structure_equalities: Unification<Structure>,
    structure_all: BTreeSet<Structure>,
    structure_dirty: BTreeSet<Structure>,
    structure_weights: Vec<usize>,
    structure_uprooted: Vec<Structure>,

    el_equalities: Unification<El>,
    el_all: BTreeSet<El>,
    el_dirty: BTreeSet<El>,
    el_weights: Vec<usize>,
    el_uprooted: Vec<El>,

    el_list_equalities: Unification<ElList>,
    el_list_all: BTreeSet<ElList>,
    el_list_dirty: BTreeSet<ElList>,
    el_list_weights: Vec<usize>,
    el_list_uprooted: Vec<ElList>,

    el_name_equalities: Unification<ElName>,
    el_name_all: BTreeSet<ElName>,
    el_name_dirty: BTreeSet<ElName>,
    el_name_weights: Vec<usize>,
    el_name_uprooted: Vec<ElName>,

    morphism_equalities: Unification<Morphism>,
    morphism_all: BTreeSet<Morphism>,
    morphism_dirty: BTreeSet<Morphism>,
    morphism_weights: Vec<usize>,
    morphism_uprooted: Vec<Morphism>,

    symbol_kind_equalities: Unification<SymbolKind>,
    symbol_kind_all: BTreeSet<SymbolKind>,
    symbol_kind_dirty: BTreeSet<SymbolKind>,
    symbol_kind_weights: Vec<usize>,
    symbol_kind_uprooted: Vec<SymbolKind>,

    nat_equalities: Unification<Nat>,
    nat_all: BTreeSet<Nat>,
    nat_dirty: BTreeSet<Nat>,
    nat_weights: Vec<usize>,
    nat_uprooted: Vec<Nat>,

    absurd: AbsurdTable,
    type_decl: TypeDeclTable,
    arg_decl_node_name: ArgDeclNodeNameTable,
    arg_decl_node_type: ArgDeclNodeTypeTable,
    nil_arg_decl_list_node: NilArgDeclListNodeTable,
    cons_arg_decl_list_node: ConsArgDeclListNodeTable,
    pred_decl: PredDeclTable,
    func_decl: FuncDeclTable,
    ctor_decl: CtorDeclTable,
    nil_ctor_decl_list_node: NilCtorDeclListNodeTable,
    cons_ctor_decl_list_node: ConsCtorDeclListNodeTable,
    enum_decl: EnumDeclTable,
    nil_term_list_node: NilTermListNodeTable,
    cons_term_list_node: ConsTermListNodeTable,
    none_term_node: NoneTermNodeTable,
    some_term_node: SomeTermNodeTable,
    var_term_node: VarTermNodeTable,
    wildcard_term_node: WildcardTermNodeTable,
    app_term_node: AppTermNodeTable,
    match_case: MatchCaseTable,
    nil_match_case_list_node: NilMatchCaseListNodeTable,
    cons_match_case_list_node: ConsMatchCaseListNodeTable,
    equal_if_atom_node: EqualIfAtomNodeTable,
    defined_if_atom_node: DefinedIfAtomNodeTable,
    pred_if_atom_node: PredIfAtomNodeTable,
    var_if_atom_node: VarIfAtomNodeTable,
    equal_then_atom_node: EqualThenAtomNodeTable,
    defined_then_atom_node: DefinedThenAtomNodeTable,
    pred_then_atom_node: PredThenAtomNodeTable,
    if_stmt_node: IfStmtNodeTable,
    then_stmt_node: ThenStmtNodeTable,
    branch_stmt_node: BranchStmtNodeTable,
    match_stmt_node: MatchStmtNodeTable,
    nil_stmt_list_node: NilStmtListNodeTable,
    cons_stmt_list_node: ConsStmtListNodeTable,
    nil_stmt_block_list_node: NilStmtBlockListNodeTable,
    cons_stmt_block_list_node: ConsStmtBlockListNodeTable,
    rule_decl: RuleDeclTable,
    decl_node_type: DeclNodeTypeTable,
    decl_node_pred: DeclNodePredTable,
    decl_node_func: DeclNodeFuncTable,
    decl_node_rule: DeclNodeRuleTable,
    decl_node_enum: DeclNodeEnumTable,
    nil_decl_list_node: NilDeclListNodeTable,
    cons_decl_list_node: ConsDeclListNodeTable,
    decls_module_node: DeclsModuleNodeTable,
    var_in_scope: VarInScopeTable,
    scope_extension: ScopeExtensionTable,
    scope_single_child: ScopeSingleChildTable,
    scope_extension_siblings: ScopeExtensionSiblingsTable,
    rel_app: RelAppTable,
    el_type: ElTypeTable,
    el_types: ElTypesTable,
    constrained_el: ConstrainedElTable,
    constrained_els: ConstrainedElsTable,
    in_ker: InKerTable,
    el_in_img: ElInImgTable,
    rel_tuple_in_img: RelTupleInImgTable,
    defined_symbol: DefinedSymbolTable,
    should_be_symbol: ShouldBeSymbolTable,
    should_be_symbol_2: ShouldBeSymbol2Table,
    pred_arg_num_should_match: PredArgNumShouldMatchTable,
    func_arg_num_should_match: FuncArgNumShouldMatchTable,
    cfg_edge: CfgEdgeTable,
    cfg_edge_stmts_stmt: CfgEdgeStmtsStmtTable,
    cfg_edge_stmt_stmts: CfgEdgeStmtStmtsTable,
    cfg_edge_fork: CfgEdgeForkTable,
    cfg_edge_join: CfgEdgeJoinTable,
    before_stmt_structure: BeforeStmtStructureTable,
    stmt_morphism: StmtMorphismTable,
    if_morphism: IfMorphismTable,
    surj_then_morphism: SurjThenMorphismTable,
    non_surj_then_morphism: NonSurjThenMorphismTable,
    noop_morphism: NoopMorphismTable,
    stmt_structure: StmtStructureTable,
    if_atom_structure: IfAtomStructureTable,
    then_atom_structure: ThenAtomStructureTable,
    term_structure: TermStructureTable,
    terms_structure: TermsStructureTable,
    opt_term_structure: OptTermStructureTable,
    term_should_be_epic_ok: TermShouldBeEpicOkTable,
    terms_should_be_epic_ok: TermsShouldBeEpicOkTable,
    el_should_be_surjective_ok: ElShouldBeSurjectiveOkTable,
    el_is_surjective_ok: ElIsSurjectiveOkTable,
    should_be_obtained_by_ctor: ShouldBeObtainedByCtorTable,
    is_given_by_ctor: IsGivenByCtorTable,
    function_can_be_made_defined: FunctionCanBeMadeDefinedTable,
    case_pattern_is_variable: CasePatternIsVariableTable,
    case_pattern_is_wildcard: CasePatternIsWildcardTable,
    is_pattern_ctor_arg: IsPatternCtorArgTable,
    are_pattern_ctor_args: ArePatternCtorArgsTable,
    pattern_ctor_arg_is_app: PatternCtorArgIsAppTable,
    pattern_ctor_arg_var_is_not_fresh: PatternCtorArgVarIsNotFreshTable,
    cases_contain_ctor: CasesContainCtorTable,
    match_stmt_contains_ctor_of_enum: MatchStmtContainsCtorOfEnumTable,
    match_stmt_should_contain_ctor: MatchStmtShouldContainCtorTable,
    match_stmt_contains_ctor: MatchStmtContainsCtorTable,
    real_virt_ident: RealVirtIdentTable,
    virt_real_ident: VirtRealIdentTable,
    var: VarTable,
    rule_name: RuleNameTable,
    type_decl_node_loc: TypeDeclNodeLocTable,
    arg_decl_node_loc: ArgDeclNodeLocTable,
    arg_decl_list_node_loc: ArgDeclListNodeLocTable,
    pred_decl_node_loc: PredDeclNodeLocTable,
    func_decl_node_loc: FuncDeclNodeLocTable,
    ctor_decl_node_loc: CtorDeclNodeLocTable,
    enum_decl_node_loc: EnumDeclNodeLocTable,
    term_node_loc: TermNodeLocTable,
    term_list_node_loc: TermListNodeLocTable,
    match_case_node_loc: MatchCaseNodeLocTable,
    opt_term_node_loc: OptTermNodeLocTable,
    if_atom_node_loc: IfAtomNodeLocTable,
    then_atom_node_loc: ThenAtomNodeLocTable,
    stmt_node_loc: StmtNodeLocTable,
    stmt_list_node_loc: StmtListNodeLocTable,
    rule_decl_node_loc: RuleDeclNodeLocTable,
    decl_node_loc: DeclNodeLocTable,
    decl_list_node_loc: DeclListNodeLocTable,
    module_node_loc: ModuleNodeLocTable,
    rule_descendant_rule: RuleDescendantRuleTable,
    rule_descendant_term: RuleDescendantTermTable,
    rule_descendant_term_list: RuleDescendantTermListTable,
    rule_descendant_opt_term: RuleDescendantOptTermTable,
    rule_descendant_if_atom: RuleDescendantIfAtomTable,
    rule_descendant_then_atom: RuleDescendantThenAtomTable,
    rule_descendant_match_case: RuleDescendantMatchCaseTable,
    rule_descendant_match_case_list: RuleDescendantMatchCaseListTable,
    rule_descendant_stmt: RuleDescendantStmtTable,
    rule_descendant_stmt_list: RuleDescendantStmtListTable,
    rule_descendant_stmt_block_list: RuleDescendantStmtBlockListTable,
    entry_scope: EntryScopeTable,
    exit_scope: ExitScopeTable,
    ctor_enum: CtorEnumTable,
    ctors_enum: CtorsEnumTable,
    cases_discriminee: CasesDiscrimineeTable,
    case_discriminee: CaseDiscrimineeTable,
    desugared_case_equality_atom: DesugaredCaseEqualityAtomTable,
    desugared_case_equality_stmt: DesugaredCaseEqualityStmtTable,
    desugared_case_block: DesugaredCaseBlockTable,
    desugared_case_block_list: DesugaredCaseBlockListTable,
    nil_type_list: NilTypeListTable,
    cons_type_list: ConsTypeListTable,
    snoc_type_list: SnocTypeListTable,
    semantic_type: SemanticTypeTable,
    semantic_arg_types: SemanticArgTypesTable,
    semantic_pred: SemanticPredTable,
    pred_arity: PredArityTable,
    semantic_func: SemanticFuncTable,
    domain: DomainTable,
    codomain: CodomainTable,
    pred_rel: PredRelTable,
    func_rel: FuncRelTable,
    arity: ArityTable,
    dom: DomTable,
    cod: CodTable,
    nil_el_list: NilElListTable,
    cons_el_list: ConsElListTable,
    snoc_el_list: SnocElListTable,
    el_structure: ElStructureTable,
    els_structure: ElsStructureTable,
    func_app: FuncAppTable,
    map_el: MapElTable,
    map_els: MapElsTable,
    type_symbol: TypeSymbolTable,
    pred_symbol: PredSymbolTable,
    func_symbol: FuncSymbolTable,
    rule_symbol: RuleSymbolTable,
    enum_symbol: EnumSymbolTable,
    ctor_symbol: CtorSymbolTable,
    zero: ZeroTable,
    succ: SuccTable,
    type_list_len: TypeListLenTable,
    term_list_len: TermListLenTable,
    before_rule_structure: BeforeRuleStructureTable,
    if_atom_morphism: IfAtomMorphismTable,
    then_atom_morphism: ThenAtomMorphismTable,
    branch_stmt_morphism: BranchStmtMorphismTable,
    match_stmt_morphism: MatchStmtMorphismTable,
    semantic_name: SemanticNameTable,
    semantic_el: SemanticElTable,
    semantic_els: SemanticElsTable,
    wildcard_name: WildcardNameTable,
    match_case_pattern_ctor: MatchCasePatternCtorTable,
    cases_determined_enum: CasesDeterminedEnumTable,
    empty_join_is_dirty: bool,
}
type Model = Eqlog;
impl ModelDelta {
    fn new() -> ModelDelta {
        ModelDelta {
            new_absurd: Vec::new(),
            new_type_decl: Vec::new(),
            new_arg_decl_node_name: Vec::new(),
            new_arg_decl_node_type: Vec::new(),
            new_nil_arg_decl_list_node: Vec::new(),
            new_cons_arg_decl_list_node: Vec::new(),
            new_pred_decl: Vec::new(),
            new_func_decl: Vec::new(),
            new_ctor_decl: Vec::new(),
            new_nil_ctor_decl_list_node: Vec::new(),
            new_cons_ctor_decl_list_node: Vec::new(),
            new_enum_decl: Vec::new(),
            new_nil_term_list_node: Vec::new(),
            new_cons_term_list_node: Vec::new(),
            new_none_term_node: Vec::new(),
            new_some_term_node: Vec::new(),
            new_var_term_node: Vec::new(),
            new_wildcard_term_node: Vec::new(),
            new_app_term_node: Vec::new(),
            new_match_case: Vec::new(),
            new_nil_match_case_list_node: Vec::new(),
            new_cons_match_case_list_node: Vec::new(),
            new_equal_if_atom_node: Vec::new(),
            new_defined_if_atom_node: Vec::new(),
            new_pred_if_atom_node: Vec::new(),
            new_var_if_atom_node: Vec::new(),
            new_equal_then_atom_node: Vec::new(),
            new_defined_then_atom_node: Vec::new(),
            new_pred_then_atom_node: Vec::new(),
            new_if_stmt_node: Vec::new(),
            new_then_stmt_node: Vec::new(),
            new_branch_stmt_node: Vec::new(),
            new_match_stmt_node: Vec::new(),
            new_nil_stmt_list_node: Vec::new(),
            new_cons_stmt_list_node: Vec::new(),
            new_nil_stmt_block_list_node: Vec::new(),
            new_cons_stmt_block_list_node: Vec::new(),
            new_rule_decl: Vec::new(),
            new_decl_node_type: Vec::new(),
            new_decl_node_pred: Vec::new(),
            new_decl_node_func: Vec::new(),
            new_decl_node_rule: Vec::new(),
            new_decl_node_enum: Vec::new(),
            new_nil_decl_list_node: Vec::new(),
            new_cons_decl_list_node: Vec::new(),
            new_decls_module_node: Vec::new(),
            new_var_in_scope: Vec::new(),
            new_scope_extension: Vec::new(),
            new_scope_single_child: Vec::new(),
            new_scope_extension_siblings: Vec::new(),
            new_rel_app: Vec::new(),
            new_el_type: Vec::new(),
            new_el_types: Vec::new(),
            new_constrained_el: Vec::new(),
            new_constrained_els: Vec::new(),
            new_in_ker: Vec::new(),
            new_el_in_img: Vec::new(),
            new_rel_tuple_in_img: Vec::new(),
            new_defined_symbol: Vec::new(),
            new_should_be_symbol: Vec::new(),
            new_should_be_symbol_2: Vec::new(),
            new_pred_arg_num_should_match: Vec::new(),
            new_func_arg_num_should_match: Vec::new(),
            new_cfg_edge: Vec::new(),
            new_cfg_edge_stmts_stmt: Vec::new(),
            new_cfg_edge_stmt_stmts: Vec::new(),
            new_cfg_edge_fork: Vec::new(),
            new_cfg_edge_join: Vec::new(),
            new_before_stmt_structure: Vec::new(),
            new_stmt_morphism: Vec::new(),
            new_if_morphism: Vec::new(),
            new_surj_then_morphism: Vec::new(),
            new_non_surj_then_morphism: Vec::new(),
            new_noop_morphism: Vec::new(),
            new_stmt_structure: Vec::new(),
            new_if_atom_structure: Vec::new(),
            new_then_atom_structure: Vec::new(),
            new_term_structure: Vec::new(),
            new_terms_structure: Vec::new(),
            new_opt_term_structure: Vec::new(),
            new_term_should_be_epic_ok: Vec::new(),
            new_terms_should_be_epic_ok: Vec::new(),
            new_el_should_be_surjective_ok: Vec::new(),
            new_el_is_surjective_ok: Vec::new(),
            new_should_be_obtained_by_ctor: Vec::new(),
            new_is_given_by_ctor: Vec::new(),
            new_function_can_be_made_defined: Vec::new(),
            new_case_pattern_is_variable: Vec::new(),
            new_case_pattern_is_wildcard: Vec::new(),
            new_is_pattern_ctor_arg: Vec::new(),
            new_are_pattern_ctor_args: Vec::new(),
            new_pattern_ctor_arg_is_app: Vec::new(),
            new_pattern_ctor_arg_var_is_not_fresh: Vec::new(),
            new_cases_contain_ctor: Vec::new(),
            new_match_stmt_contains_ctor_of_enum: Vec::new(),
            new_match_stmt_should_contain_ctor: Vec::new(),
            new_match_stmt_contains_ctor: Vec::new(),
            new_real_virt_ident: Vec::new(),
            new_virt_real_ident: Vec::new(),
            new_var: Vec::new(),
            new_rule_name: Vec::new(),
            new_type_decl_node_loc: Vec::new(),
            new_arg_decl_node_loc: Vec::new(),
            new_arg_decl_list_node_loc: Vec::new(),
            new_pred_decl_node_loc: Vec::new(),
            new_func_decl_node_loc: Vec::new(),
            new_ctor_decl_node_loc: Vec::new(),
            new_enum_decl_node_loc: Vec::new(),
            new_term_node_loc: Vec::new(),
            new_term_list_node_loc: Vec::new(),
            new_match_case_node_loc: Vec::new(),
            new_opt_term_node_loc: Vec::new(),
            new_if_atom_node_loc: Vec::new(),
            new_then_atom_node_loc: Vec::new(),
            new_stmt_node_loc: Vec::new(),
            new_stmt_list_node_loc: Vec::new(),
            new_rule_decl_node_loc: Vec::new(),
            new_decl_node_loc: Vec::new(),
            new_decl_list_node_loc: Vec::new(),
            new_module_node_loc: Vec::new(),
            new_rule_descendant_rule: Vec::new(),
            new_rule_descendant_term: Vec::new(),
            new_rule_descendant_term_list: Vec::new(),
            new_rule_descendant_opt_term: Vec::new(),
            new_rule_descendant_if_atom: Vec::new(),
            new_rule_descendant_then_atom: Vec::new(),
            new_rule_descendant_match_case: Vec::new(),
            new_rule_descendant_match_case_list: Vec::new(),
            new_rule_descendant_stmt: Vec::new(),
            new_rule_descendant_stmt_list: Vec::new(),
            new_rule_descendant_stmt_block_list: Vec::new(),
            new_entry_scope: Vec::new(),
            new_exit_scope: Vec::new(),
            new_ctor_enum: Vec::new(),
            new_ctors_enum: Vec::new(),
            new_cases_discriminee: Vec::new(),
            new_case_discriminee: Vec::new(),
            new_desugared_case_equality_atom: Vec::new(),
            new_desugared_case_equality_stmt: Vec::new(),
            new_desugared_case_block: Vec::new(),
            new_desugared_case_block_list: Vec::new(),
            new_nil_type_list: Vec::new(),
            new_cons_type_list: Vec::new(),
            new_snoc_type_list: Vec::new(),
            new_semantic_type: Vec::new(),
            new_semantic_arg_types: Vec::new(),
            new_semantic_pred: Vec::new(),
            new_pred_arity: Vec::new(),
            new_semantic_func: Vec::new(),
            new_domain: Vec::new(),
            new_codomain: Vec::new(),
            new_pred_rel: Vec::new(),
            new_func_rel: Vec::new(),
            new_arity: Vec::new(),
            new_dom: Vec::new(),
            new_cod: Vec::new(),
            new_nil_el_list: Vec::new(),
            new_cons_el_list: Vec::new(),
            new_snoc_el_list: Vec::new(),
            new_el_structure: Vec::new(),
            new_els_structure: Vec::new(),
            new_func_app: Vec::new(),
            new_map_el: Vec::new(),
            new_map_els: Vec::new(),
            new_type_symbol: Vec::new(),
            new_pred_symbol: Vec::new(),
            new_func_symbol: Vec::new(),
            new_rule_symbol: Vec::new(),
            new_enum_symbol: Vec::new(),
            new_ctor_symbol: Vec::new(),
            new_zero: Vec::new(),
            new_succ: Vec::new(),
            new_type_list_len: Vec::new(),
            new_term_list_len: Vec::new(),
            new_before_rule_structure: Vec::new(),
            new_if_atom_morphism: Vec::new(),
            new_then_atom_morphism: Vec::new(),
            new_branch_stmt_morphism: Vec::new(),
            new_match_stmt_morphism: Vec::new(),
            new_semantic_name: Vec::new(),
            new_semantic_el: Vec::new(),
            new_semantic_els: Vec::new(),
            new_wildcard_name: Vec::new(),
            new_match_case_pattern_ctor: Vec::new(),
            new_cases_determined_enum: Vec::new(),
            new_ident_equalities: Vec::new(),
            new_virt_ident_equalities: Vec::new(),
            new_type_decl_node_equalities: Vec::new(),
            new_arg_decl_node_equalities: Vec::new(),
            new_arg_decl_list_node_equalities: Vec::new(),
            new_pred_decl_node_equalities: Vec::new(),
            new_func_decl_node_equalities: Vec::new(),
            new_ctor_decl_node_equalities: Vec::new(),
            new_ctor_decl_list_node_equalities: Vec::new(),
            new_enum_decl_node_equalities: Vec::new(),
            new_term_node_equalities: Vec::new(),
            new_term_list_node_equalities: Vec::new(),
            new_opt_term_node_equalities: Vec::new(),
            new_match_case_node_equalities: Vec::new(),
            new_stmt_list_node_equalities: Vec::new(),
            new_match_case_list_node_equalities: Vec::new(),
            new_if_atom_node_equalities: Vec::new(),
            new_then_atom_node_equalities: Vec::new(),
            new_stmt_node_equalities: Vec::new(),
            new_stmt_block_list_node_equalities: Vec::new(),
            new_rule_decl_node_equalities: Vec::new(),
            new_decl_node_equalities: Vec::new(),
            new_decl_list_node_equalities: Vec::new(),
            new_module_node_equalities: Vec::new(),
            new_loc_equalities: Vec::new(),
            new_rule_descendant_node_equalities: Vec::new(),
            new_scope_equalities: Vec::new(),
            new_type_equalities: Vec::new(),
            new_type_list_equalities: Vec::new(),
            new_pred_equalities: Vec::new(),
            new_func_equalities: Vec::new(),
            new_rel_equalities: Vec::new(),
            new_structure_equalities: Vec::new(),
            new_el_equalities: Vec::new(),
            new_el_list_equalities: Vec::new(),
            new_el_name_equalities: Vec::new(),
            new_morphism_equalities: Vec::new(),
            new_symbol_kind_equalities: Vec::new(),
            new_nat_equalities: Vec::new(),
            new_real_virt_ident_def: Vec::new(),

            new_virt_real_ident_def: Vec::new(),

            new_var_def: Vec::new(),

            new_rule_name_def: Vec::new(),

            new_type_decl_node_loc_def: Vec::new(),

            new_arg_decl_node_loc_def: Vec::new(),

            new_arg_decl_list_node_loc_def: Vec::new(),

            new_pred_decl_node_loc_def: Vec::new(),

            new_func_decl_node_loc_def: Vec::new(),

            new_ctor_decl_node_loc_def: Vec::new(),

            new_enum_decl_node_loc_def: Vec::new(),

            new_term_node_loc_def: Vec::new(),

            new_term_list_node_loc_def: Vec::new(),

            new_match_case_node_loc_def: Vec::new(),

            new_opt_term_node_loc_def: Vec::new(),

            new_if_atom_node_loc_def: Vec::new(),

            new_then_atom_node_loc_def: Vec::new(),

            new_stmt_node_loc_def: Vec::new(),

            new_stmt_list_node_loc_def: Vec::new(),

            new_rule_decl_node_loc_def: Vec::new(),

            new_decl_node_loc_def: Vec::new(),

            new_decl_list_node_loc_def: Vec::new(),

            new_module_node_loc_def: Vec::new(),

            new_rule_descendant_rule_def: Vec::new(),

            new_rule_descendant_term_def: Vec::new(),

            new_rule_descendant_term_list_def: Vec::new(),

            new_rule_descendant_opt_term_def: Vec::new(),

            new_rule_descendant_if_atom_def: Vec::new(),

            new_rule_descendant_then_atom_def: Vec::new(),

            new_rule_descendant_match_case_def: Vec::new(),

            new_rule_descendant_match_case_list_def: Vec::new(),

            new_rule_descendant_stmt_def: Vec::new(),

            new_rule_descendant_stmt_list_def: Vec::new(),

            new_rule_descendant_stmt_block_list_def: Vec::new(),

            new_entry_scope_def: Vec::new(),

            new_exit_scope_def: Vec::new(),

            new_ctor_enum_def: Vec::new(),

            new_ctors_enum_def: Vec::new(),

            new_cases_discriminee_def: Vec::new(),

            new_case_discriminee_def: Vec::new(),

            new_desugared_case_equality_atom_def: Vec::new(),

            new_desugared_case_equality_stmt_def: Vec::new(),

            new_desugared_case_block_def: Vec::new(),

            new_desugared_case_block_list_def: Vec::new(),

            new_nil_type_list_def: Vec::new(),

            new_cons_type_list_def: Vec::new(),

            new_snoc_type_list_def: Vec::new(),

            new_semantic_type_def: Vec::new(),

            new_semantic_pred_def: Vec::new(),

            new_semantic_func_def: Vec::new(),

            new_codomain_def: Vec::new(),

            new_pred_rel_def: Vec::new(),

            new_func_rel_def: Vec::new(),

            new_dom_def: Vec::new(),

            new_cod_def: Vec::new(),

            new_nil_el_list_def: Vec::new(),

            new_cons_el_list_def: Vec::new(),

            new_snoc_el_list_def: Vec::new(),

            new_el_structure_def: Vec::new(),

            new_els_structure_def: Vec::new(),

            new_func_app_def: Vec::new(),

            new_map_el_def: Vec::new(),

            new_type_symbol_def: Vec::new(),

            new_pred_symbol_def: Vec::new(),

            new_func_symbol_def: Vec::new(),

            new_rule_symbol_def: Vec::new(),

            new_enum_symbol_def: Vec::new(),

            new_ctor_symbol_def: Vec::new(),

            new_zero_def: Vec::new(),

            new_succ_def: Vec::new(),

            new_type_list_len_def: Vec::new(),

            new_term_list_len_def: Vec::new(),

            new_before_rule_structure_def: Vec::new(),

            new_if_atom_morphism_def: Vec::new(),

            new_then_atom_morphism_def: Vec::new(),

            new_branch_stmt_morphism_def: Vec::new(),

            new_match_stmt_morphism_def: Vec::new(),

            new_semantic_name_def: Vec::new(),

            new_semantic_el_def: Vec::new(),

            new_wildcard_name_def: Vec::new(),

            new_match_case_pattern_ctor_def: Vec::new(),

            new_cases_determined_enum_def: Vec::new(),
        }
    }
    fn apply_surjective(&mut self, model: &mut Model) {
        self.apply_equalities(model);
        self.apply_tuples(model);
    }
    fn apply_non_surjective(&mut self, model: &mut Model) {
        self.apply_func_defs(model);
    }
    #[allow(unused)]
    fn apply_equalities(&mut self, model: &mut Model) {
        for (lhs, rhs) in self.new_ident_equalities.iter().copied() {
            model.equate_ident(lhs, rhs);
        }

        for (lhs, rhs) in self.new_virt_ident_equalities.iter().copied() {
            model.equate_virt_ident(lhs, rhs);
        }

        for (lhs, rhs) in self.new_type_decl_node_equalities.iter().copied() {
            model.equate_type_decl_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_arg_decl_node_equalities.iter().copied() {
            model.equate_arg_decl_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_arg_decl_list_node_equalities.iter().copied() {
            model.equate_arg_decl_list_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_pred_decl_node_equalities.iter().copied() {
            model.equate_pred_decl_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_func_decl_node_equalities.iter().copied() {
            model.equate_func_decl_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_ctor_decl_node_equalities.iter().copied() {
            model.equate_ctor_decl_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_ctor_decl_list_node_equalities.iter().copied() {
            model.equate_ctor_decl_list_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_enum_decl_node_equalities.iter().copied() {
            model.equate_enum_decl_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_term_node_equalities.iter().copied() {
            model.equate_term_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_term_list_node_equalities.iter().copied() {
            model.equate_term_list_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_opt_term_node_equalities.iter().copied() {
            model.equate_opt_term_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_match_case_node_equalities.iter().copied() {
            model.equate_match_case_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_match_case_list_node_equalities.iter().copied() {
            model.equate_match_case_list_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_if_atom_node_equalities.iter().copied() {
            model.equate_if_atom_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_then_atom_node_equalities.iter().copied() {
            model.equate_then_atom_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_stmt_node_equalities.iter().copied() {
            model.equate_stmt_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_stmt_list_node_equalities.iter().copied() {
            model.equate_stmt_list_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_stmt_block_list_node_equalities.iter().copied() {
            model.equate_stmt_block_list_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_rule_decl_node_equalities.iter().copied() {
            model.equate_rule_decl_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_decl_node_equalities.iter().copied() {
            model.equate_decl_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_decl_list_node_equalities.iter().copied() {
            model.equate_decl_list_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_module_node_equalities.iter().copied() {
            model.equate_module_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_loc_equalities.iter().copied() {
            model.equate_loc(lhs, rhs);
        }

        for (lhs, rhs) in self.new_rule_descendant_node_equalities.iter().copied() {
            model.equate_rule_descendant_node(lhs, rhs);
        }

        for (lhs, rhs) in self.new_scope_equalities.iter().copied() {
            model.equate_scope(lhs, rhs);
        }

        for (lhs, rhs) in self.new_type_equalities.iter().copied() {
            model.equate_type(lhs, rhs);
        }

        for (lhs, rhs) in self.new_pred_equalities.iter().copied() {
            model.equate_pred(lhs, rhs);
        }

        for (lhs, rhs) in self.new_func_equalities.iter().copied() {
            model.equate_func(lhs, rhs);
        }

        for (lhs, rhs) in self.new_structure_equalities.iter().copied() {
            model.equate_structure(lhs, rhs);
        }

        for (lhs, rhs) in self.new_el_equalities.iter().copied() {
            model.equate_el(lhs, rhs);
        }

        for (lhs, rhs) in self.new_el_name_equalities.iter().copied() {
            model.equate_el_name(lhs, rhs);
        }

        for (lhs, rhs) in self.new_morphism_equalities.iter().copied() {
            model.equate_morphism(lhs, rhs);
        }

        for (lhs, rhs) in self.new_symbol_kind_equalities.iter().copied() {
            model.equate_symbol_kind(lhs, rhs);
        }

        for (lhs, rhs) in self.new_nat_equalities.iter().copied() {
            model.equate_nat(lhs, rhs);
        }

        for (lhs, rhs) in self.new_type_list_equalities.iter().copied() {
            model.equate_type_list(lhs, rhs);
        }

        for (lhs, rhs) in self.new_rel_equalities.iter().copied() {
            model.equate_rel(lhs, rhs);
        }

        for (lhs, rhs) in self.new_el_list_equalities.iter().copied() {
            model.equate_el_list(lhs, rhs);
        }
    }
    fn apply_tuples(&mut self, model: &mut Model) {
        for Absurd() in self.new_absurd.drain(..) {
            model.insert_absurd();
        }

        for TypeDecl(tm0, tm1) in self.new_type_decl.drain(..) {
            model.insert_type_decl(tm0, tm1);
        }

        for ArgDeclNodeName(tm0, tm1) in self.new_arg_decl_node_name.drain(..) {
            model.insert_arg_decl_node_name(tm0, tm1);
        }

        for ArgDeclNodeType(tm0, tm1) in self.new_arg_decl_node_type.drain(..) {
            model.insert_arg_decl_node_type(tm0, tm1);
        }

        for NilArgDeclListNode(tm0) in self.new_nil_arg_decl_list_node.drain(..) {
            model.insert_nil_arg_decl_list_node(tm0);
        }

        for ConsArgDeclListNode(tm0, tm1, tm2) in self.new_cons_arg_decl_list_node.drain(..) {
            model.insert_cons_arg_decl_list_node(tm0, tm1, tm2);
        }

        for PredDecl(tm0, tm1, tm2) in self.new_pred_decl.drain(..) {
            model.insert_pred_decl(tm0, tm1, tm2);
        }

        for FuncDecl(tm0, tm1, tm2, tm3) in self.new_func_decl.drain(..) {
            model.insert_func_decl(tm0, tm1, tm2, tm3);
        }

        for CtorDecl(tm0, tm1, tm2) in self.new_ctor_decl.drain(..) {
            model.insert_ctor_decl(tm0, tm1, tm2);
        }

        for NilCtorDeclListNode(tm0) in self.new_nil_ctor_decl_list_node.drain(..) {
            model.insert_nil_ctor_decl_list_node(tm0);
        }

        for ConsCtorDeclListNode(tm0, tm1, tm2) in self.new_cons_ctor_decl_list_node.drain(..) {
            model.insert_cons_ctor_decl_list_node(tm0, tm1, tm2);
        }

        for EnumDecl(tm0, tm1, tm2) in self.new_enum_decl.drain(..) {
            model.insert_enum_decl(tm0, tm1, tm2);
        }

        for NilTermListNode(tm0) in self.new_nil_term_list_node.drain(..) {
            model.insert_nil_term_list_node(tm0);
        }

        for ConsTermListNode(tm0, tm1, tm2) in self.new_cons_term_list_node.drain(..) {
            model.insert_cons_term_list_node(tm0, tm1, tm2);
        }

        for NoneTermNode(tm0) in self.new_none_term_node.drain(..) {
            model.insert_none_term_node(tm0);
        }

        for SomeTermNode(tm0, tm1) in self.new_some_term_node.drain(..) {
            model.insert_some_term_node(tm0, tm1);
        }

        for VarTermNode(tm0, tm1) in self.new_var_term_node.drain(..) {
            model.insert_var_term_node(tm0, tm1);
        }

        for WildcardTermNode(tm0) in self.new_wildcard_term_node.drain(..) {
            model.insert_wildcard_term_node(tm0);
        }

        for AppTermNode(tm0, tm1, tm2) in self.new_app_term_node.drain(..) {
            model.insert_app_term_node(tm0, tm1, tm2);
        }

        for MatchCase(tm0, tm1, tm2) in self.new_match_case.drain(..) {
            model.insert_match_case(tm0, tm1, tm2);
        }

        for NilMatchCaseListNode(tm0) in self.new_nil_match_case_list_node.drain(..) {
            model.insert_nil_match_case_list_node(tm0);
        }

        for ConsMatchCaseListNode(tm0, tm1, tm2) in self.new_cons_match_case_list_node.drain(..) {
            model.insert_cons_match_case_list_node(tm0, tm1, tm2);
        }

        for EqualIfAtomNode(tm0, tm1, tm2) in self.new_equal_if_atom_node.drain(..) {
            model.insert_equal_if_atom_node(tm0, tm1, tm2);
        }

        for DefinedIfAtomNode(tm0, tm1) in self.new_defined_if_atom_node.drain(..) {
            model.insert_defined_if_atom_node(tm0, tm1);
        }

        for PredIfAtomNode(tm0, tm1, tm2) in self.new_pred_if_atom_node.drain(..) {
            model.insert_pred_if_atom_node(tm0, tm1, tm2);
        }

        for VarIfAtomNode(tm0, tm1, tm2) in self.new_var_if_atom_node.drain(..) {
            model.insert_var_if_atom_node(tm0, tm1, tm2);
        }

        for EqualThenAtomNode(tm0, tm1, tm2) in self.new_equal_then_atom_node.drain(..) {
            model.insert_equal_then_atom_node(tm0, tm1, tm2);
        }

        for DefinedThenAtomNode(tm0, tm1, tm2) in self.new_defined_then_atom_node.drain(..) {
            model.insert_defined_then_atom_node(tm0, tm1, tm2);
        }

        for PredThenAtomNode(tm0, tm1, tm2) in self.new_pred_then_atom_node.drain(..) {
            model.insert_pred_then_atom_node(tm0, tm1, tm2);
        }

        for IfStmtNode(tm0, tm1) in self.new_if_stmt_node.drain(..) {
            model.insert_if_stmt_node(tm0, tm1);
        }

        for ThenStmtNode(tm0, tm1) in self.new_then_stmt_node.drain(..) {
            model.insert_then_stmt_node(tm0, tm1);
        }

        for BranchStmtNode(tm0, tm1) in self.new_branch_stmt_node.drain(..) {
            model.insert_branch_stmt_node(tm0, tm1);
        }

        for MatchStmtNode(tm0, tm1, tm2) in self.new_match_stmt_node.drain(..) {
            model.insert_match_stmt_node(tm0, tm1, tm2);
        }

        for NilStmtListNode(tm0) in self.new_nil_stmt_list_node.drain(..) {
            model.insert_nil_stmt_list_node(tm0);
        }

        for ConsStmtListNode(tm0, tm1, tm2) in self.new_cons_stmt_list_node.drain(..) {
            model.insert_cons_stmt_list_node(tm0, tm1, tm2);
        }

        for NilStmtBlockListNode(tm0) in self.new_nil_stmt_block_list_node.drain(..) {
            model.insert_nil_stmt_block_list_node(tm0);
        }

        for ConsStmtBlockListNode(tm0, tm1, tm2) in self.new_cons_stmt_block_list_node.drain(..) {
            model.insert_cons_stmt_block_list_node(tm0, tm1, tm2);
        }

        for RuleDecl(tm0, tm1) in self.new_rule_decl.drain(..) {
            model.insert_rule_decl(tm0, tm1);
        }

        for DeclNodeType(tm0, tm1) in self.new_decl_node_type.drain(..) {
            model.insert_decl_node_type(tm0, tm1);
        }

        for DeclNodePred(tm0, tm1) in self.new_decl_node_pred.drain(..) {
            model.insert_decl_node_pred(tm0, tm1);
        }

        for DeclNodeFunc(tm0, tm1) in self.new_decl_node_func.drain(..) {
            model.insert_decl_node_func(tm0, tm1);
        }

        for DeclNodeRule(tm0, tm1) in self.new_decl_node_rule.drain(..) {
            model.insert_decl_node_rule(tm0, tm1);
        }

        for DeclNodeEnum(tm0, tm1) in self.new_decl_node_enum.drain(..) {
            model.insert_decl_node_enum(tm0, tm1);
        }

        for NilDeclListNode(tm0) in self.new_nil_decl_list_node.drain(..) {
            model.insert_nil_decl_list_node(tm0);
        }

        for ConsDeclListNode(tm0, tm1, tm2) in self.new_cons_decl_list_node.drain(..) {
            model.insert_cons_decl_list_node(tm0, tm1, tm2);
        }

        for DeclsModuleNode(tm0, tm1) in self.new_decls_module_node.drain(..) {
            model.insert_decls_module_node(tm0, tm1);
        }

        for VarInScope(tm0, tm1) in self.new_var_in_scope.drain(..) {
            model.insert_var_in_scope(tm0, tm1);
        }

        for ScopeExtension(tm0, tm1) in self.new_scope_extension.drain(..) {
            model.insert_scope_extension(tm0, tm1);
        }

        for ScopeSingleChild(tm0, tm1) in self.new_scope_single_child.drain(..) {
            model.insert_scope_single_child(tm0, tm1);
        }

        for ScopeExtensionSiblings(tm0, tm1, tm2) in self.new_scope_extension_siblings.drain(..) {
            model.insert_scope_extension_siblings(tm0, tm1, tm2);
        }

        for RelApp(tm0, tm1) in self.new_rel_app.drain(..) {
            model.insert_rel_app(tm0, tm1);
        }

        for ElType(tm0, tm1) in self.new_el_type.drain(..) {
            model.insert_el_type(tm0, tm1);
        }

        for ElTypes(tm0, tm1) in self.new_el_types.drain(..) {
            model.insert_el_types(tm0, tm1);
        }

        for ConstrainedEl(tm0) in self.new_constrained_el.drain(..) {
            model.insert_constrained_el(tm0);
        }

        for ConstrainedEls(tm0) in self.new_constrained_els.drain(..) {
            model.insert_constrained_els(tm0);
        }

        for InKer(tm0, tm1, tm2) in self.new_in_ker.drain(..) {
            model.insert_in_ker(tm0, tm1, tm2);
        }

        for ElInImg(tm0, tm1) in self.new_el_in_img.drain(..) {
            model.insert_el_in_img(tm0, tm1);
        }

        for RelTupleInImg(tm0, tm1, tm2) in self.new_rel_tuple_in_img.drain(..) {
            model.insert_rel_tuple_in_img(tm0, tm1, tm2);
        }

        for DefinedSymbol(tm0, tm1, tm2) in self.new_defined_symbol.drain(..) {
            model.insert_defined_symbol(tm0, tm1, tm2);
        }

        for ShouldBeSymbol(tm0, tm1, tm2) in self.new_should_be_symbol.drain(..) {
            model.insert_should_be_symbol(tm0, tm1, tm2);
        }

        for ShouldBeSymbol2(tm0, tm1, tm2, tm3) in self.new_should_be_symbol_2.drain(..) {
            model.insert_should_be_symbol_2(tm0, tm1, tm2, tm3);
        }

        for PredArgNumShouldMatch(tm0, tm1, tm2) in self.new_pred_arg_num_should_match.drain(..) {
            model.insert_pred_arg_num_should_match(tm0, tm1, tm2);
        }

        for FuncArgNumShouldMatch(tm0, tm1, tm2) in self.new_func_arg_num_should_match.drain(..) {
            model.insert_func_arg_num_should_match(tm0, tm1, tm2);
        }

        for CfgEdge(tm0, tm1) in self.new_cfg_edge.drain(..) {
            model.insert_cfg_edge(tm0, tm1);
        }

        for CfgEdgeStmtsStmt(tm0, tm1) in self.new_cfg_edge_stmts_stmt.drain(..) {
            model.insert_cfg_edge_stmts_stmt(tm0, tm1);
        }

        for CfgEdgeStmtStmts(tm0, tm1) in self.new_cfg_edge_stmt_stmts.drain(..) {
            model.insert_cfg_edge_stmt_stmts(tm0, tm1);
        }

        for CfgEdgeFork(tm0, tm1) in self.new_cfg_edge_fork.drain(..) {
            model.insert_cfg_edge_fork(tm0, tm1);
        }

        for CfgEdgeJoin(tm0, tm1) in self.new_cfg_edge_join.drain(..) {
            model.insert_cfg_edge_join(tm0, tm1);
        }

        for BeforeStmtStructure(tm0, tm1) in self.new_before_stmt_structure.drain(..) {
            model.insert_before_stmt_structure(tm0, tm1);
        }

        for StmtMorphism(tm0, tm1) in self.new_stmt_morphism.drain(..) {
            model.insert_stmt_morphism(tm0, tm1);
        }

        for IfMorphism(tm0) in self.new_if_morphism.drain(..) {
            model.insert_if_morphism(tm0);
        }

        for SurjThenMorphism(tm0) in self.new_surj_then_morphism.drain(..) {
            model.insert_surj_then_morphism(tm0);
        }

        for NonSurjThenMorphism(tm0) in self.new_non_surj_then_morphism.drain(..) {
            model.insert_non_surj_then_morphism(tm0);
        }

        for NoopMorphism(tm0) in self.new_noop_morphism.drain(..) {
            model.insert_noop_morphism(tm0);
        }

        for StmtStructure(tm0, tm1) in self.new_stmt_structure.drain(..) {
            model.insert_stmt_structure(tm0, tm1);
        }

        for IfAtomStructure(tm0, tm1) in self.new_if_atom_structure.drain(..) {
            model.insert_if_atom_structure(tm0, tm1);
        }

        for ThenAtomStructure(tm0, tm1) in self.new_then_atom_structure.drain(..) {
            model.insert_then_atom_structure(tm0, tm1);
        }

        for TermStructure(tm0, tm1) in self.new_term_structure.drain(..) {
            model.insert_term_structure(tm0, tm1);
        }

        for TermsStructure(tm0, tm1) in self.new_terms_structure.drain(..) {
            model.insert_terms_structure(tm0, tm1);
        }

        for OptTermStructure(tm0, tm1) in self.new_opt_term_structure.drain(..) {
            model.insert_opt_term_structure(tm0, tm1);
        }

        for TermShouldBeEpicOk(tm0) in self.new_term_should_be_epic_ok.drain(..) {
            model.insert_term_should_be_epic_ok(tm0);
        }

        for TermsShouldBeEpicOk(tm0) in self.new_terms_should_be_epic_ok.drain(..) {
            model.insert_terms_should_be_epic_ok(tm0);
        }

        for ElShouldBeSurjectiveOk(tm0) in self.new_el_should_be_surjective_ok.drain(..) {
            model.insert_el_should_be_surjective_ok(tm0);
        }

        for ElIsSurjectiveOk(tm0) in self.new_el_is_surjective_ok.drain(..) {
            model.insert_el_is_surjective_ok(tm0);
        }

        for ShouldBeObtainedByCtor(tm0, tm1) in self.new_should_be_obtained_by_ctor.drain(..) {
            model.insert_should_be_obtained_by_ctor(tm0, tm1);
        }

        for IsGivenByCtor(tm0, tm1) in self.new_is_given_by_ctor.drain(..) {
            model.insert_is_given_by_ctor(tm0, tm1);
        }

        for FunctionCanBeMadeDefined(tm0) in self.new_function_can_be_made_defined.drain(..) {
            model.insert_function_can_be_made_defined(tm0);
        }

        for CasePatternIsVariable(tm0) in self.new_case_pattern_is_variable.drain(..) {
            model.insert_case_pattern_is_variable(tm0);
        }

        for CasePatternIsWildcard(tm0) in self.new_case_pattern_is_wildcard.drain(..) {
            model.insert_case_pattern_is_wildcard(tm0);
        }

        for IsPatternCtorArg(tm0) in self.new_is_pattern_ctor_arg.drain(..) {
            model.insert_is_pattern_ctor_arg(tm0);
        }

        for ArePatternCtorArgs(tm0) in self.new_are_pattern_ctor_args.drain(..) {
            model.insert_are_pattern_ctor_args(tm0);
        }

        for PatternCtorArgIsApp(tm0) in self.new_pattern_ctor_arg_is_app.drain(..) {
            model.insert_pattern_ctor_arg_is_app(tm0);
        }

        for PatternCtorArgVarIsNotFresh(tm0) in self.new_pattern_ctor_arg_var_is_not_fresh.drain(..)
        {
            model.insert_pattern_ctor_arg_var_is_not_fresh(tm0);
        }

        for CasesContainCtor(tm0, tm1) in self.new_cases_contain_ctor.drain(..) {
            model.insert_cases_contain_ctor(tm0, tm1);
        }

        for MatchStmtContainsCtorOfEnum(tm0, tm1, tm2) in
            self.new_match_stmt_contains_ctor_of_enum.drain(..)
        {
            model.insert_match_stmt_contains_ctor_of_enum(tm0, tm1, tm2);
        }

        for MatchStmtShouldContainCtor(tm0, tm1) in
            self.new_match_stmt_should_contain_ctor.drain(..)
        {
            model.insert_match_stmt_should_contain_ctor(tm0, tm1);
        }

        for MatchStmtContainsCtor(tm0, tm1) in self.new_match_stmt_contains_ctor.drain(..) {
            model.insert_match_stmt_contains_ctor(tm0, tm1);
        }

        for RealVirtIdent(tm0, tm1) in self.new_real_virt_ident.drain(..) {
            model.insert_real_virt_ident(tm0, tm1);
        }

        for VirtRealIdent(tm0, tm1) in self.new_virt_real_ident.drain(..) {
            model.insert_virt_real_ident(tm0, tm1);
        }

        for Var(tm0, tm1, tm2) in self.new_var.drain(..) {
            model.insert_var(tm0, tm1, tm2);
        }

        for RuleName(tm0, tm1) in self.new_rule_name.drain(..) {
            model.insert_rule_name(tm0, tm1);
        }

        for TypeDeclNodeLoc(tm0, tm1) in self.new_type_decl_node_loc.drain(..) {
            model.insert_type_decl_node_loc(tm0, tm1);
        }

        for ArgDeclNodeLoc(tm0, tm1) in self.new_arg_decl_node_loc.drain(..) {
            model.insert_arg_decl_node_loc(tm0, tm1);
        }

        for ArgDeclListNodeLoc(tm0, tm1) in self.new_arg_decl_list_node_loc.drain(..) {
            model.insert_arg_decl_list_node_loc(tm0, tm1);
        }

        for PredDeclNodeLoc(tm0, tm1) in self.new_pred_decl_node_loc.drain(..) {
            model.insert_pred_decl_node_loc(tm0, tm1);
        }

        for FuncDeclNodeLoc(tm0, tm1) in self.new_func_decl_node_loc.drain(..) {
            model.insert_func_decl_node_loc(tm0, tm1);
        }

        for CtorDeclNodeLoc(tm0, tm1) in self.new_ctor_decl_node_loc.drain(..) {
            model.insert_ctor_decl_node_loc(tm0, tm1);
        }

        for EnumDeclNodeLoc(tm0, tm1) in self.new_enum_decl_node_loc.drain(..) {
            model.insert_enum_decl_node_loc(tm0, tm1);
        }

        for TermNodeLoc(tm0, tm1) in self.new_term_node_loc.drain(..) {
            model.insert_term_node_loc(tm0, tm1);
        }

        for TermListNodeLoc(tm0, tm1) in self.new_term_list_node_loc.drain(..) {
            model.insert_term_list_node_loc(tm0, tm1);
        }

        for MatchCaseNodeLoc(tm0, tm1) in self.new_match_case_node_loc.drain(..) {
            model.insert_match_case_node_loc(tm0, tm1);
        }

        for OptTermNodeLoc(tm0, tm1) in self.new_opt_term_node_loc.drain(..) {
            model.insert_opt_term_node_loc(tm0, tm1);
        }

        for IfAtomNodeLoc(tm0, tm1) in self.new_if_atom_node_loc.drain(..) {
            model.insert_if_atom_node_loc(tm0, tm1);
        }

        for ThenAtomNodeLoc(tm0, tm1) in self.new_then_atom_node_loc.drain(..) {
            model.insert_then_atom_node_loc(tm0, tm1);
        }

        for StmtNodeLoc(tm0, tm1) in self.new_stmt_node_loc.drain(..) {
            model.insert_stmt_node_loc(tm0, tm1);
        }

        for StmtListNodeLoc(tm0, tm1) in self.new_stmt_list_node_loc.drain(..) {
            model.insert_stmt_list_node_loc(tm0, tm1);
        }

        for RuleDeclNodeLoc(tm0, tm1) in self.new_rule_decl_node_loc.drain(..) {
            model.insert_rule_decl_node_loc(tm0, tm1);
        }

        for DeclNodeLoc(tm0, tm1) in self.new_decl_node_loc.drain(..) {
            model.insert_decl_node_loc(tm0, tm1);
        }

        for DeclListNodeLoc(tm0, tm1) in self.new_decl_list_node_loc.drain(..) {
            model.insert_decl_list_node_loc(tm0, tm1);
        }

        for ModuleNodeLoc(tm0, tm1) in self.new_module_node_loc.drain(..) {
            model.insert_module_node_loc(tm0, tm1);
        }

        for RuleDescendantRule(tm0, tm1) in self.new_rule_descendant_rule.drain(..) {
            model.insert_rule_descendant_rule(tm0, tm1);
        }

        for RuleDescendantTerm(tm0, tm1) in self.new_rule_descendant_term.drain(..) {
            model.insert_rule_descendant_term(tm0, tm1);
        }

        for RuleDescendantTermList(tm0, tm1) in self.new_rule_descendant_term_list.drain(..) {
            model.insert_rule_descendant_term_list(tm0, tm1);
        }

        for RuleDescendantOptTerm(tm0, tm1) in self.new_rule_descendant_opt_term.drain(..) {
            model.insert_rule_descendant_opt_term(tm0, tm1);
        }

        for RuleDescendantIfAtom(tm0, tm1) in self.new_rule_descendant_if_atom.drain(..) {
            model.insert_rule_descendant_if_atom(tm0, tm1);
        }

        for RuleDescendantThenAtom(tm0, tm1) in self.new_rule_descendant_then_atom.drain(..) {
            model.insert_rule_descendant_then_atom(tm0, tm1);
        }

        for RuleDescendantMatchCase(tm0, tm1) in self.new_rule_descendant_match_case.drain(..) {
            model.insert_rule_descendant_match_case(tm0, tm1);
        }

        for RuleDescendantMatchCaseList(tm0, tm1) in
            self.new_rule_descendant_match_case_list.drain(..)
        {
            model.insert_rule_descendant_match_case_list(tm0, tm1);
        }

        for RuleDescendantStmt(tm0, tm1) in self.new_rule_descendant_stmt.drain(..) {
            model.insert_rule_descendant_stmt(tm0, tm1);
        }

        for RuleDescendantStmtList(tm0, tm1) in self.new_rule_descendant_stmt_list.drain(..) {
            model.insert_rule_descendant_stmt_list(tm0, tm1);
        }

        for RuleDescendantStmtBlockList(tm0, tm1) in
            self.new_rule_descendant_stmt_block_list.drain(..)
        {
            model.insert_rule_descendant_stmt_block_list(tm0, tm1);
        }

        for EntryScope(tm0, tm1) in self.new_entry_scope.drain(..) {
            model.insert_entry_scope(tm0, tm1);
        }

        for ExitScope(tm0, tm1) in self.new_exit_scope.drain(..) {
            model.insert_exit_scope(tm0, tm1);
        }

        for CtorEnum(tm0, tm1) in self.new_ctor_enum.drain(..) {
            model.insert_ctor_enum(tm0, tm1);
        }

        for CtorsEnum(tm0, tm1) in self.new_ctors_enum.drain(..) {
            model.insert_ctors_enum(tm0, tm1);
        }

        for CasesDiscriminee(tm0, tm1) in self.new_cases_discriminee.drain(..) {
            model.insert_cases_discriminee(tm0, tm1);
        }

        for CaseDiscriminee(tm0, tm1) in self.new_case_discriminee.drain(..) {
            model.insert_case_discriminee(tm0, tm1);
        }

        for DesugaredCaseEqualityAtom(tm0, tm1) in self.new_desugared_case_equality_atom.drain(..) {
            model.insert_desugared_case_equality_atom(tm0, tm1);
        }

        for DesugaredCaseEqualityStmt(tm0, tm1) in self.new_desugared_case_equality_stmt.drain(..) {
            model.insert_desugared_case_equality_stmt(tm0, tm1);
        }

        for DesugaredCaseBlock(tm0, tm1) in self.new_desugared_case_block.drain(..) {
            model.insert_desugared_case_block(tm0, tm1);
        }

        for DesugaredCaseBlockList(tm0, tm1) in self.new_desugared_case_block_list.drain(..) {
            model.insert_desugared_case_block_list(tm0, tm1);
        }

        for NilTypeList(tm0) in self.new_nil_type_list.drain(..) {
            model.insert_nil_type_list(tm0);
        }

        for ConsTypeList(tm0, tm1, tm2) in self.new_cons_type_list.drain(..) {
            model.insert_cons_type_list(tm0, tm1, tm2);
        }

        for SnocTypeList(tm0, tm1, tm2) in self.new_snoc_type_list.drain(..) {
            model.insert_snoc_type_list(tm0, tm1, tm2);
        }

        for SemanticType(tm0, tm1) in self.new_semantic_type.drain(..) {
            model.insert_semantic_type(tm0, tm1);
        }

        for SemanticArgTypes(tm0, tm1) in self.new_semantic_arg_types.drain(..) {
            model.insert_semantic_arg_types(tm0, tm1);
        }

        for SemanticPred(tm0, tm1) in self.new_semantic_pred.drain(..) {
            model.insert_semantic_pred(tm0, tm1);
        }

        for PredArity(tm0, tm1) in self.new_pred_arity.drain(..) {
            model.insert_pred_arity(tm0, tm1);
        }

        for SemanticFunc(tm0, tm1) in self.new_semantic_func.drain(..) {
            model.insert_semantic_func(tm0, tm1);
        }

        for Domain(tm0, tm1) in self.new_domain.drain(..) {
            model.insert_domain(tm0, tm1);
        }

        for Codomain(tm0, tm1) in self.new_codomain.drain(..) {
            model.insert_codomain(tm0, tm1);
        }

        for PredRel(tm0, tm1) in self.new_pred_rel.drain(..) {
            model.insert_pred_rel(tm0, tm1);
        }

        for FuncRel(tm0, tm1) in self.new_func_rel.drain(..) {
            model.insert_func_rel(tm0, tm1);
        }

        for Arity(tm0, tm1) in self.new_arity.drain(..) {
            model.insert_arity(tm0, tm1);
        }

        for Dom(tm0, tm1) in self.new_dom.drain(..) {
            model.insert_dom(tm0, tm1);
        }

        for Cod(tm0, tm1) in self.new_cod.drain(..) {
            model.insert_cod(tm0, tm1);
        }

        for NilElList(tm0, tm1) in self.new_nil_el_list.drain(..) {
            model.insert_nil_el_list(tm0, tm1);
        }

        for ConsElList(tm0, tm1, tm2) in self.new_cons_el_list.drain(..) {
            model.insert_cons_el_list(tm0, tm1, tm2);
        }

        for SnocElList(tm0, tm1, tm2) in self.new_snoc_el_list.drain(..) {
            model.insert_snoc_el_list(tm0, tm1, tm2);
        }

        for ElStructure(tm0, tm1) in self.new_el_structure.drain(..) {
            model.insert_el_structure(tm0, tm1);
        }

        for ElsStructure(tm0, tm1) in self.new_els_structure.drain(..) {
            model.insert_els_structure(tm0, tm1);
        }

        for FuncApp(tm0, tm1, tm2) in self.new_func_app.drain(..) {
            model.insert_func_app(tm0, tm1, tm2);
        }

        for MapEl(tm0, tm1, tm2) in self.new_map_el.drain(..) {
            model.insert_map_el(tm0, tm1, tm2);
        }

        for MapEls(tm0, tm1, tm2) in self.new_map_els.drain(..) {
            model.insert_map_els(tm0, tm1, tm2);
        }

        for TypeSymbol(tm0) in self.new_type_symbol.drain(..) {
            model.insert_type_symbol(tm0);
        }

        for PredSymbol(tm0) in self.new_pred_symbol.drain(..) {
            model.insert_pred_symbol(tm0);
        }

        for FuncSymbol(tm0) in self.new_func_symbol.drain(..) {
            model.insert_func_symbol(tm0);
        }

        for RuleSymbol(tm0) in self.new_rule_symbol.drain(..) {
            model.insert_rule_symbol(tm0);
        }

        for EnumSymbol(tm0) in self.new_enum_symbol.drain(..) {
            model.insert_enum_symbol(tm0);
        }

        for CtorSymbol(tm0) in self.new_ctor_symbol.drain(..) {
            model.insert_ctor_symbol(tm0);
        }

        for Zero(tm0) in self.new_zero.drain(..) {
            model.insert_zero(tm0);
        }

        for Succ(tm0, tm1) in self.new_succ.drain(..) {
            model.insert_succ(tm0, tm1);
        }

        for TypeListLen(tm0, tm1) in self.new_type_list_len.drain(..) {
            model.insert_type_list_len(tm0, tm1);
        }

        for TermListLen(tm0, tm1) in self.new_term_list_len.drain(..) {
            model.insert_term_list_len(tm0, tm1);
        }

        for BeforeRuleStructure(tm0, tm1) in self.new_before_rule_structure.drain(..) {
            model.insert_before_rule_structure(tm0, tm1);
        }

        for IfAtomMorphism(tm0, tm1, tm2) in self.new_if_atom_morphism.drain(..) {
            model.insert_if_atom_morphism(tm0, tm1, tm2);
        }

        for ThenAtomMorphism(tm0, tm1, tm2) in self.new_then_atom_morphism.drain(..) {
            model.insert_then_atom_morphism(tm0, tm1, tm2);
        }

        for BranchStmtMorphism(tm0, tm1, tm2) in self.new_branch_stmt_morphism.drain(..) {
            model.insert_branch_stmt_morphism(tm0, tm1, tm2);
        }

        for MatchStmtMorphism(tm0, tm1, tm2) in self.new_match_stmt_morphism.drain(..) {
            model.insert_match_stmt_morphism(tm0, tm1, tm2);
        }

        for SemanticName(tm0, tm1, tm2) in self.new_semantic_name.drain(..) {
            model.insert_semantic_name(tm0, tm1, tm2);
        }

        for SemanticEl(tm0, tm1, tm2) in self.new_semantic_el.drain(..) {
            model.insert_semantic_el(tm0, tm1, tm2);
        }

        for SemanticEls(tm0, tm1, tm2) in self.new_semantic_els.drain(..) {
            model.insert_semantic_els(tm0, tm1, tm2);
        }

        for WildcardName(tm0, tm1) in self.new_wildcard_name.drain(..) {
            model.insert_wildcard_name(tm0, tm1);
        }

        for MatchCasePatternCtor(tm0, tm1) in self.new_match_case_pattern_ctor.drain(..) {
            model.insert_match_case_pattern_ctor(tm0, tm1);
        }

        for CasesDeterminedEnum(tm0, tm1) in self.new_cases_determined_enum.drain(..) {
            model.insert_cases_determined_enum(tm0, tm1);
        }
    }
    #[allow(unused_variables)]
    fn apply_func_defs(&mut self, model: &mut Model) {
        for RealVirtIdentArgs(tm0) in self.new_real_virt_ident_def.drain(..) {
            model.define_real_virt_ident(tm0);
        }

        for VirtRealIdentArgs(tm0) in self.new_virt_real_ident_def.drain(..) {
            model.define_virt_real_ident(tm0);
        }

        for VarArgs(tm0, tm1) in self.new_var_def.drain(..) {
            model.define_var(tm0, tm1);
        }

        for RuleNameArgs(tm0) in self.new_rule_name_def.drain(..) {
            model.define_rule_name(tm0);
        }

        for TypeDeclNodeLocArgs(tm0) in self.new_type_decl_node_loc_def.drain(..) {
            model.define_type_decl_node_loc(tm0);
        }

        for ArgDeclNodeLocArgs(tm0) in self.new_arg_decl_node_loc_def.drain(..) {
            model.define_arg_decl_node_loc(tm0);
        }

        for ArgDeclListNodeLocArgs(tm0) in self.new_arg_decl_list_node_loc_def.drain(..) {
            model.define_arg_decl_list_node_loc(tm0);
        }

        for PredDeclNodeLocArgs(tm0) in self.new_pred_decl_node_loc_def.drain(..) {
            model.define_pred_decl_node_loc(tm0);
        }

        for FuncDeclNodeLocArgs(tm0) in self.new_func_decl_node_loc_def.drain(..) {
            model.define_func_decl_node_loc(tm0);
        }

        for CtorDeclNodeLocArgs(tm0) in self.new_ctor_decl_node_loc_def.drain(..) {
            model.define_ctor_decl_node_loc(tm0);
        }

        for EnumDeclNodeLocArgs(tm0) in self.new_enum_decl_node_loc_def.drain(..) {
            model.define_enum_decl_node_loc(tm0);
        }

        for TermNodeLocArgs(tm0) in self.new_term_node_loc_def.drain(..) {
            model.define_term_node_loc(tm0);
        }

        for TermListNodeLocArgs(tm0) in self.new_term_list_node_loc_def.drain(..) {
            model.define_term_list_node_loc(tm0);
        }

        for MatchCaseNodeLocArgs(tm0) in self.new_match_case_node_loc_def.drain(..) {
            model.define_match_case_node_loc(tm0);
        }

        for OptTermNodeLocArgs(tm0) in self.new_opt_term_node_loc_def.drain(..) {
            model.define_opt_term_node_loc(tm0);
        }

        for IfAtomNodeLocArgs(tm0) in self.new_if_atom_node_loc_def.drain(..) {
            model.define_if_atom_node_loc(tm0);
        }

        for ThenAtomNodeLocArgs(tm0) in self.new_then_atom_node_loc_def.drain(..) {
            model.define_then_atom_node_loc(tm0);
        }

        for StmtNodeLocArgs(tm0) in self.new_stmt_node_loc_def.drain(..) {
            model.define_stmt_node_loc(tm0);
        }

        for StmtListNodeLocArgs(tm0) in self.new_stmt_list_node_loc_def.drain(..) {
            model.define_stmt_list_node_loc(tm0);
        }

        for RuleDeclNodeLocArgs(tm0) in self.new_rule_decl_node_loc_def.drain(..) {
            model.define_rule_decl_node_loc(tm0);
        }

        for DeclNodeLocArgs(tm0) in self.new_decl_node_loc_def.drain(..) {
            model.define_decl_node_loc(tm0);
        }

        for DeclListNodeLocArgs(tm0) in self.new_decl_list_node_loc_def.drain(..) {
            model.define_decl_list_node_loc(tm0);
        }

        for ModuleNodeLocArgs(tm0) in self.new_module_node_loc_def.drain(..) {
            model.define_module_node_loc(tm0);
        }

        for RuleDescendantRuleArgs(tm0) in self.new_rule_descendant_rule_def.drain(..) {
            model.define_rule_descendant_rule(tm0);
        }

        for RuleDescendantTermArgs(tm0) in self.new_rule_descendant_term_def.drain(..) {
            model.define_rule_descendant_term(tm0);
        }

        for RuleDescendantTermListArgs(tm0) in self.new_rule_descendant_term_list_def.drain(..) {
            model.define_rule_descendant_term_list(tm0);
        }

        for RuleDescendantOptTermArgs(tm0) in self.new_rule_descendant_opt_term_def.drain(..) {
            model.define_rule_descendant_opt_term(tm0);
        }

        for RuleDescendantIfAtomArgs(tm0) in self.new_rule_descendant_if_atom_def.drain(..) {
            model.define_rule_descendant_if_atom(tm0);
        }

        for RuleDescendantThenAtomArgs(tm0) in self.new_rule_descendant_then_atom_def.drain(..) {
            model.define_rule_descendant_then_atom(tm0);
        }

        for RuleDescendantMatchCaseArgs(tm0) in self.new_rule_descendant_match_case_def.drain(..) {
            model.define_rule_descendant_match_case(tm0);
        }

        for RuleDescendantMatchCaseListArgs(tm0) in
            self.new_rule_descendant_match_case_list_def.drain(..)
        {
            model.define_rule_descendant_match_case_list(tm0);
        }

        for RuleDescendantStmtArgs(tm0) in self.new_rule_descendant_stmt_def.drain(..) {
            model.define_rule_descendant_stmt(tm0);
        }

        for RuleDescendantStmtListArgs(tm0) in self.new_rule_descendant_stmt_list_def.drain(..) {
            model.define_rule_descendant_stmt_list(tm0);
        }

        for RuleDescendantStmtBlockListArgs(tm0) in
            self.new_rule_descendant_stmt_block_list_def.drain(..)
        {
            model.define_rule_descendant_stmt_block_list(tm0);
        }

        for EntryScopeArgs(tm0) in self.new_entry_scope_def.drain(..) {
            model.define_entry_scope(tm0);
        }

        for ExitScopeArgs(tm0) in self.new_exit_scope_def.drain(..) {
            model.define_exit_scope(tm0);
        }

        for CtorEnumArgs(tm0) in self.new_ctor_enum_def.drain(..) {
            model.define_ctor_enum(tm0);
        }

        for CtorsEnumArgs(tm0) in self.new_ctors_enum_def.drain(..) {
            model.define_ctors_enum(tm0);
        }

        for CasesDiscrimineeArgs(tm0) in self.new_cases_discriminee_def.drain(..) {
            model.define_cases_discriminee(tm0);
        }

        for CaseDiscrimineeArgs(tm0) in self.new_case_discriminee_def.drain(..) {
            model.define_case_discriminee(tm0);
        }

        for DesugaredCaseEqualityAtomArgs(tm0) in
            self.new_desugared_case_equality_atom_def.drain(..)
        {
            model.define_desugared_case_equality_atom(tm0);
        }

        for DesugaredCaseEqualityStmtArgs(tm0) in
            self.new_desugared_case_equality_stmt_def.drain(..)
        {
            model.define_desugared_case_equality_stmt(tm0);
        }

        for DesugaredCaseBlockArgs(tm0) in self.new_desugared_case_block_def.drain(..) {
            model.define_desugared_case_block(tm0);
        }

        for DesugaredCaseBlockListArgs(tm0) in self.new_desugared_case_block_list_def.drain(..) {
            model.define_desugared_case_block_list(tm0);
        }

        for NilTypeListArgs() in self.new_nil_type_list_def.drain(..) {
            model.define_nil_type_list();
        }

        for ConsTypeListArgs(tm0, tm1) in self.new_cons_type_list_def.drain(..) {
            model.define_cons_type_list(tm0, tm1);
        }

        for SnocTypeListArgs(tm0, tm1) in self.new_snoc_type_list_def.drain(..) {
            model.define_snoc_type_list(tm0, tm1);
        }

        for SemanticTypeArgs(tm0) in self.new_semantic_type_def.drain(..) {
            model.define_semantic_type(tm0);
        }

        for SemanticPredArgs(tm0) in self.new_semantic_pred_def.drain(..) {
            model.define_semantic_pred(tm0);
        }

        for SemanticFuncArgs(tm0) in self.new_semantic_func_def.drain(..) {
            model.define_semantic_func(tm0);
        }

        for CodomainArgs(tm0) in self.new_codomain_def.drain(..) {
            model.define_codomain(tm0);
        }

        for PredRelArgs(tm0) in self.new_pred_rel_def.drain(..) {
            model.define_pred_rel(tm0);
        }

        for FuncRelArgs(tm0) in self.new_func_rel_def.drain(..) {
            model.define_func_rel(tm0);
        }

        for DomArgs(tm0) in self.new_dom_def.drain(..) {
            model.define_dom(tm0);
        }

        for CodArgs(tm0) in self.new_cod_def.drain(..) {
            model.define_cod(tm0);
        }

        for NilElListArgs(tm0) in self.new_nil_el_list_def.drain(..) {
            model.define_nil_el_list(tm0);
        }

        for ConsElListArgs(tm0, tm1) in self.new_cons_el_list_def.drain(..) {
            model.define_cons_el_list(tm0, tm1);
        }

        for SnocElListArgs(tm0, tm1) in self.new_snoc_el_list_def.drain(..) {
            model.define_snoc_el_list(tm0, tm1);
        }

        for ElStructureArgs(tm0) in self.new_el_structure_def.drain(..) {
            model.define_el_structure(tm0);
        }

        for ElsStructureArgs(tm0) in self.new_els_structure_def.drain(..) {
            model.define_els_structure(tm0);
        }

        for FuncAppArgs(tm0, tm1) in self.new_func_app_def.drain(..) {
            model.define_func_app(tm0, tm1);
        }

        for MapElArgs(tm0, tm1) in self.new_map_el_def.drain(..) {
            model.define_map_el(tm0, tm1);
        }

        for TypeSymbolArgs() in self.new_type_symbol_def.drain(..) {
            model.define_type_symbol();
        }

        for PredSymbolArgs() in self.new_pred_symbol_def.drain(..) {
            model.define_pred_symbol();
        }

        for FuncSymbolArgs() in self.new_func_symbol_def.drain(..) {
            model.define_func_symbol();
        }

        for RuleSymbolArgs() in self.new_rule_symbol_def.drain(..) {
            model.define_rule_symbol();
        }

        for EnumSymbolArgs() in self.new_enum_symbol_def.drain(..) {
            model.define_enum_symbol();
        }

        for CtorSymbolArgs() in self.new_ctor_symbol_def.drain(..) {
            model.define_ctor_symbol();
        }

        for ZeroArgs() in self.new_zero_def.drain(..) {
            model.define_zero();
        }

        for SuccArgs(tm0) in self.new_succ_def.drain(..) {
            model.define_succ(tm0);
        }

        for TypeListLenArgs(tm0) in self.new_type_list_len_def.drain(..) {
            model.define_type_list_len(tm0);
        }

        for TermListLenArgs(tm0) in self.new_term_list_len_def.drain(..) {
            model.define_term_list_len(tm0);
        }

        for BeforeRuleStructureArgs(tm0) in self.new_before_rule_structure_def.drain(..) {
            model.define_before_rule_structure(tm0);
        }

        for IfAtomMorphismArgs(tm0, tm1) in self.new_if_atom_morphism_def.drain(..) {
            model.define_if_atom_morphism(tm0, tm1);
        }

        for ThenAtomMorphismArgs(tm0, tm1) in self.new_then_atom_morphism_def.drain(..) {
            model.define_then_atom_morphism(tm0, tm1);
        }

        for BranchStmtMorphismArgs(tm0, tm1) in self.new_branch_stmt_morphism_def.drain(..) {
            model.define_branch_stmt_morphism(tm0, tm1);
        }

        for MatchStmtMorphismArgs(tm0, tm1) in self.new_match_stmt_morphism_def.drain(..) {
            model.define_match_stmt_morphism(tm0, tm1);
        }

        for SemanticNameArgs(tm0, tm1) in self.new_semantic_name_def.drain(..) {
            model.define_semantic_name(tm0, tm1);
        }

        for SemanticElArgs(tm0, tm1) in self.new_semantic_el_def.drain(..) {
            model.define_semantic_el(tm0, tm1);
        }

        for WildcardNameArgs(tm0) in self.new_wildcard_name_def.drain(..) {
            model.define_wildcard_name(tm0);
        }

        for MatchCasePatternCtorArgs(tm0) in self.new_match_case_pattern_ctor_def.drain(..) {
            model.define_match_case_pattern_ctor(tm0);
        }

        for CasesDeterminedEnumArgs(tm0) in self.new_cases_determined_enum_def.drain(..) {
            model.define_cases_determined_enum(tm0);
        }
    }
}

impl Eqlog {
    /// Creates an empty model.
    #[allow(dead_code)]
    pub fn new() -> Self {
        Self {
            ident_equalities: Unification::new(),
            ident_dirty: BTreeSet::new(),
            ident_weights: Vec::new(),
            ident_all: BTreeSet::new(),
            ident_uprooted: Vec::new(),
            virt_ident_equalities: Unification::new(),
            virt_ident_dirty: BTreeSet::new(),
            virt_ident_weights: Vec::new(),
            virt_ident_all: BTreeSet::new(),
            virt_ident_uprooted: Vec::new(),
            type_decl_node_equalities: Unification::new(),
            type_decl_node_dirty: BTreeSet::new(),
            type_decl_node_weights: Vec::new(),
            type_decl_node_all: BTreeSet::new(),
            type_decl_node_uprooted: Vec::new(),
            arg_decl_node_equalities: Unification::new(),
            arg_decl_node_dirty: BTreeSet::new(),
            arg_decl_node_weights: Vec::new(),
            arg_decl_node_all: BTreeSet::new(),
            arg_decl_node_uprooted: Vec::new(),
            arg_decl_list_node_equalities: Unification::new(),
            arg_decl_list_node_dirty: BTreeSet::new(),
            arg_decl_list_node_weights: Vec::new(),
            arg_decl_list_node_all: BTreeSet::new(),
            arg_decl_list_node_uprooted: Vec::new(),
            pred_decl_node_equalities: Unification::new(),
            pred_decl_node_dirty: BTreeSet::new(),
            pred_decl_node_weights: Vec::new(),
            pred_decl_node_all: BTreeSet::new(),
            pred_decl_node_uprooted: Vec::new(),
            func_decl_node_equalities: Unification::new(),
            func_decl_node_dirty: BTreeSet::new(),
            func_decl_node_weights: Vec::new(),
            func_decl_node_all: BTreeSet::new(),
            func_decl_node_uprooted: Vec::new(),
            ctor_decl_node_equalities: Unification::new(),
            ctor_decl_node_dirty: BTreeSet::new(),
            ctor_decl_node_weights: Vec::new(),
            ctor_decl_node_all: BTreeSet::new(),
            ctor_decl_node_uprooted: Vec::new(),
            ctor_decl_list_node_equalities: Unification::new(),
            ctor_decl_list_node_dirty: BTreeSet::new(),
            ctor_decl_list_node_weights: Vec::new(),
            ctor_decl_list_node_all: BTreeSet::new(),
            ctor_decl_list_node_uprooted: Vec::new(),
            enum_decl_node_equalities: Unification::new(),
            enum_decl_node_dirty: BTreeSet::new(),
            enum_decl_node_weights: Vec::new(),
            enum_decl_node_all: BTreeSet::new(),
            enum_decl_node_uprooted: Vec::new(),
            term_node_equalities: Unification::new(),
            term_node_dirty: BTreeSet::new(),
            term_node_weights: Vec::new(),
            term_node_all: BTreeSet::new(),
            term_node_uprooted: Vec::new(),
            term_list_node_equalities: Unification::new(),
            term_list_node_dirty: BTreeSet::new(),
            term_list_node_weights: Vec::new(),
            term_list_node_all: BTreeSet::new(),
            term_list_node_uprooted: Vec::new(),
            opt_term_node_equalities: Unification::new(),
            opt_term_node_dirty: BTreeSet::new(),
            opt_term_node_weights: Vec::new(),
            opt_term_node_all: BTreeSet::new(),
            opt_term_node_uprooted: Vec::new(),
            match_case_node_equalities: Unification::new(),
            match_case_node_dirty: BTreeSet::new(),
            match_case_node_weights: Vec::new(),
            match_case_node_all: BTreeSet::new(),
            match_case_node_uprooted: Vec::new(),
            stmt_list_node_equalities: Unification::new(),
            stmt_list_node_dirty: BTreeSet::new(),
            stmt_list_node_weights: Vec::new(),
            stmt_list_node_all: BTreeSet::new(),
            stmt_list_node_uprooted: Vec::new(),
            match_case_list_node_equalities: Unification::new(),
            match_case_list_node_dirty: BTreeSet::new(),
            match_case_list_node_weights: Vec::new(),
            match_case_list_node_all: BTreeSet::new(),
            match_case_list_node_uprooted: Vec::new(),
            if_atom_node_equalities: Unification::new(),
            if_atom_node_dirty: BTreeSet::new(),
            if_atom_node_weights: Vec::new(),
            if_atom_node_all: BTreeSet::new(),
            if_atom_node_uprooted: Vec::new(),
            then_atom_node_equalities: Unification::new(),
            then_atom_node_dirty: BTreeSet::new(),
            then_atom_node_weights: Vec::new(),
            then_atom_node_all: BTreeSet::new(),
            then_atom_node_uprooted: Vec::new(),
            stmt_node_equalities: Unification::new(),
            stmt_node_dirty: BTreeSet::new(),
            stmt_node_weights: Vec::new(),
            stmt_node_all: BTreeSet::new(),
            stmt_node_uprooted: Vec::new(),
            stmt_block_list_node_equalities: Unification::new(),
            stmt_block_list_node_dirty: BTreeSet::new(),
            stmt_block_list_node_weights: Vec::new(),
            stmt_block_list_node_all: BTreeSet::new(),
            stmt_block_list_node_uprooted: Vec::new(),
            rule_decl_node_equalities: Unification::new(),
            rule_decl_node_dirty: BTreeSet::new(),
            rule_decl_node_weights: Vec::new(),
            rule_decl_node_all: BTreeSet::new(),
            rule_decl_node_uprooted: Vec::new(),
            decl_node_equalities: Unification::new(),
            decl_node_dirty: BTreeSet::new(),
            decl_node_weights: Vec::new(),
            decl_node_all: BTreeSet::new(),
            decl_node_uprooted: Vec::new(),
            decl_list_node_equalities: Unification::new(),
            decl_list_node_dirty: BTreeSet::new(),
            decl_list_node_weights: Vec::new(),
            decl_list_node_all: BTreeSet::new(),
            decl_list_node_uprooted: Vec::new(),
            module_node_equalities: Unification::new(),
            module_node_dirty: BTreeSet::new(),
            module_node_weights: Vec::new(),
            module_node_all: BTreeSet::new(),
            module_node_uprooted: Vec::new(),
            loc_equalities: Unification::new(),
            loc_dirty: BTreeSet::new(),
            loc_weights: Vec::new(),
            loc_all: BTreeSet::new(),
            loc_uprooted: Vec::new(),
            rule_descendant_node_equalities: Unification::new(),
            rule_descendant_node_dirty: BTreeSet::new(),
            rule_descendant_node_weights: Vec::new(),
            rule_descendant_node_all: BTreeSet::new(),
            rule_descendant_node_uprooted: Vec::new(),
            scope_equalities: Unification::new(),
            scope_dirty: BTreeSet::new(),
            scope_weights: Vec::new(),
            scope_all: BTreeSet::new(),
            scope_uprooted: Vec::new(),
            type_equalities: Unification::new(),
            type_dirty: BTreeSet::new(),
            type_weights: Vec::new(),
            type_all: BTreeSet::new(),
            type_uprooted: Vec::new(),
            type_list_equalities: Unification::new(),
            type_list_dirty: BTreeSet::new(),
            type_list_weights: Vec::new(),
            type_list_all: BTreeSet::new(),
            type_list_uprooted: Vec::new(),
            pred_equalities: Unification::new(),
            pred_dirty: BTreeSet::new(),
            pred_weights: Vec::new(),
            pred_all: BTreeSet::new(),
            pred_uprooted: Vec::new(),
            func_equalities: Unification::new(),
            func_dirty: BTreeSet::new(),
            func_weights: Vec::new(),
            func_all: BTreeSet::new(),
            func_uprooted: Vec::new(),
            rel_equalities: Unification::new(),
            rel_dirty: BTreeSet::new(),
            rel_weights: Vec::new(),
            rel_all: BTreeSet::new(),
            rel_uprooted: Vec::new(),
            structure_equalities: Unification::new(),
            structure_dirty: BTreeSet::new(),
            structure_weights: Vec::new(),
            structure_all: BTreeSet::new(),
            structure_uprooted: Vec::new(),
            el_equalities: Unification::new(),
            el_dirty: BTreeSet::new(),
            el_weights: Vec::new(),
            el_all: BTreeSet::new(),
            el_uprooted: Vec::new(),
            el_list_equalities: Unification::new(),
            el_list_dirty: BTreeSet::new(),
            el_list_weights: Vec::new(),
            el_list_all: BTreeSet::new(),
            el_list_uprooted: Vec::new(),
            el_name_equalities: Unification::new(),
            el_name_dirty: BTreeSet::new(),
            el_name_weights: Vec::new(),
            el_name_all: BTreeSet::new(),
            el_name_uprooted: Vec::new(),
            morphism_equalities: Unification::new(),
            morphism_dirty: BTreeSet::new(),
            morphism_weights: Vec::new(),
            morphism_all: BTreeSet::new(),
            morphism_uprooted: Vec::new(),
            symbol_kind_equalities: Unification::new(),
            symbol_kind_dirty: BTreeSet::new(),
            symbol_kind_weights: Vec::new(),
            symbol_kind_all: BTreeSet::new(),
            symbol_kind_uprooted: Vec::new(),
            nat_equalities: Unification::new(),
            nat_dirty: BTreeSet::new(),
            nat_weights: Vec::new(),
            nat_all: BTreeSet::new(),
            nat_uprooted: Vec::new(),
            absurd: AbsurdTable::new(),
            type_decl: TypeDeclTable::new(),
            arg_decl_node_name: ArgDeclNodeNameTable::new(),
            arg_decl_node_type: ArgDeclNodeTypeTable::new(),
            nil_arg_decl_list_node: NilArgDeclListNodeTable::new(),
            cons_arg_decl_list_node: ConsArgDeclListNodeTable::new(),
            pred_decl: PredDeclTable::new(),
            func_decl: FuncDeclTable::new(),
            ctor_decl: CtorDeclTable::new(),
            nil_ctor_decl_list_node: NilCtorDeclListNodeTable::new(),
            cons_ctor_decl_list_node: ConsCtorDeclListNodeTable::new(),
            enum_decl: EnumDeclTable::new(),
            nil_term_list_node: NilTermListNodeTable::new(),
            cons_term_list_node: ConsTermListNodeTable::new(),
            none_term_node: NoneTermNodeTable::new(),
            some_term_node: SomeTermNodeTable::new(),
            var_term_node: VarTermNodeTable::new(),
            wildcard_term_node: WildcardTermNodeTable::new(),
            app_term_node: AppTermNodeTable::new(),
            match_case: MatchCaseTable::new(),
            nil_match_case_list_node: NilMatchCaseListNodeTable::new(),
            cons_match_case_list_node: ConsMatchCaseListNodeTable::new(),
            equal_if_atom_node: EqualIfAtomNodeTable::new(),
            defined_if_atom_node: DefinedIfAtomNodeTable::new(),
            pred_if_atom_node: PredIfAtomNodeTable::new(),
            var_if_atom_node: VarIfAtomNodeTable::new(),
            equal_then_atom_node: EqualThenAtomNodeTable::new(),
            defined_then_atom_node: DefinedThenAtomNodeTable::new(),
            pred_then_atom_node: PredThenAtomNodeTable::new(),
            if_stmt_node: IfStmtNodeTable::new(),
            then_stmt_node: ThenStmtNodeTable::new(),
            branch_stmt_node: BranchStmtNodeTable::new(),
            match_stmt_node: MatchStmtNodeTable::new(),
            nil_stmt_list_node: NilStmtListNodeTable::new(),
            cons_stmt_list_node: ConsStmtListNodeTable::new(),
            nil_stmt_block_list_node: NilStmtBlockListNodeTable::new(),
            cons_stmt_block_list_node: ConsStmtBlockListNodeTable::new(),
            rule_decl: RuleDeclTable::new(),
            decl_node_type: DeclNodeTypeTable::new(),
            decl_node_pred: DeclNodePredTable::new(),
            decl_node_func: DeclNodeFuncTable::new(),
            decl_node_rule: DeclNodeRuleTable::new(),
            decl_node_enum: DeclNodeEnumTable::new(),
            nil_decl_list_node: NilDeclListNodeTable::new(),
            cons_decl_list_node: ConsDeclListNodeTable::new(),
            decls_module_node: DeclsModuleNodeTable::new(),
            var_in_scope: VarInScopeTable::new(),
            scope_extension: ScopeExtensionTable::new(),
            scope_single_child: ScopeSingleChildTable::new(),
            scope_extension_siblings: ScopeExtensionSiblingsTable::new(),
            rel_app: RelAppTable::new(),
            el_type: ElTypeTable::new(),
            el_types: ElTypesTable::new(),
            constrained_el: ConstrainedElTable::new(),
            constrained_els: ConstrainedElsTable::new(),
            in_ker: InKerTable::new(),
            el_in_img: ElInImgTable::new(),
            rel_tuple_in_img: RelTupleInImgTable::new(),
            defined_symbol: DefinedSymbolTable::new(),
            should_be_symbol: ShouldBeSymbolTable::new(),
            should_be_symbol_2: ShouldBeSymbol2Table::new(),
            pred_arg_num_should_match: PredArgNumShouldMatchTable::new(),
            func_arg_num_should_match: FuncArgNumShouldMatchTable::new(),
            cfg_edge: CfgEdgeTable::new(),
            cfg_edge_stmts_stmt: CfgEdgeStmtsStmtTable::new(),
            cfg_edge_stmt_stmts: CfgEdgeStmtStmtsTable::new(),
            cfg_edge_fork: CfgEdgeForkTable::new(),
            cfg_edge_join: CfgEdgeJoinTable::new(),
            before_stmt_structure: BeforeStmtStructureTable::new(),
            stmt_morphism: StmtMorphismTable::new(),
            if_morphism: IfMorphismTable::new(),
            surj_then_morphism: SurjThenMorphismTable::new(),
            non_surj_then_morphism: NonSurjThenMorphismTable::new(),
            noop_morphism: NoopMorphismTable::new(),
            stmt_structure: StmtStructureTable::new(),
            if_atom_structure: IfAtomStructureTable::new(),
            then_atom_structure: ThenAtomStructureTable::new(),
            term_structure: TermStructureTable::new(),
            terms_structure: TermsStructureTable::new(),
            opt_term_structure: OptTermStructureTable::new(),
            term_should_be_epic_ok: TermShouldBeEpicOkTable::new(),
            terms_should_be_epic_ok: TermsShouldBeEpicOkTable::new(),
            el_should_be_surjective_ok: ElShouldBeSurjectiveOkTable::new(),
            el_is_surjective_ok: ElIsSurjectiveOkTable::new(),
            should_be_obtained_by_ctor: ShouldBeObtainedByCtorTable::new(),
            is_given_by_ctor: IsGivenByCtorTable::new(),
            function_can_be_made_defined: FunctionCanBeMadeDefinedTable::new(),
            case_pattern_is_variable: CasePatternIsVariableTable::new(),
            case_pattern_is_wildcard: CasePatternIsWildcardTable::new(),
            is_pattern_ctor_arg: IsPatternCtorArgTable::new(),
            are_pattern_ctor_args: ArePatternCtorArgsTable::new(),
            pattern_ctor_arg_is_app: PatternCtorArgIsAppTable::new(),
            pattern_ctor_arg_var_is_not_fresh: PatternCtorArgVarIsNotFreshTable::new(),
            cases_contain_ctor: CasesContainCtorTable::new(),
            match_stmt_contains_ctor_of_enum: MatchStmtContainsCtorOfEnumTable::new(),
            match_stmt_should_contain_ctor: MatchStmtShouldContainCtorTable::new(),
            match_stmt_contains_ctor: MatchStmtContainsCtorTable::new(),
            real_virt_ident: RealVirtIdentTable::new(),
            virt_real_ident: VirtRealIdentTable::new(),
            var: VarTable::new(),
            rule_name: RuleNameTable::new(),
            type_decl_node_loc: TypeDeclNodeLocTable::new(),
            arg_decl_node_loc: ArgDeclNodeLocTable::new(),
            arg_decl_list_node_loc: ArgDeclListNodeLocTable::new(),
            pred_decl_node_loc: PredDeclNodeLocTable::new(),
            func_decl_node_loc: FuncDeclNodeLocTable::new(),
            ctor_decl_node_loc: CtorDeclNodeLocTable::new(),
            enum_decl_node_loc: EnumDeclNodeLocTable::new(),
            term_node_loc: TermNodeLocTable::new(),
            term_list_node_loc: TermListNodeLocTable::new(),
            match_case_node_loc: MatchCaseNodeLocTable::new(),
            opt_term_node_loc: OptTermNodeLocTable::new(),
            if_atom_node_loc: IfAtomNodeLocTable::new(),
            then_atom_node_loc: ThenAtomNodeLocTable::new(),
            stmt_node_loc: StmtNodeLocTable::new(),
            stmt_list_node_loc: StmtListNodeLocTable::new(),
            rule_decl_node_loc: RuleDeclNodeLocTable::new(),
            decl_node_loc: DeclNodeLocTable::new(),
            decl_list_node_loc: DeclListNodeLocTable::new(),
            module_node_loc: ModuleNodeLocTable::new(),
            rule_descendant_rule: RuleDescendantRuleTable::new(),
            rule_descendant_term: RuleDescendantTermTable::new(),
            rule_descendant_term_list: RuleDescendantTermListTable::new(),
            rule_descendant_opt_term: RuleDescendantOptTermTable::new(),
            rule_descendant_if_atom: RuleDescendantIfAtomTable::new(),
            rule_descendant_then_atom: RuleDescendantThenAtomTable::new(),
            rule_descendant_match_case: RuleDescendantMatchCaseTable::new(),
            rule_descendant_match_case_list: RuleDescendantMatchCaseListTable::new(),
            rule_descendant_stmt: RuleDescendantStmtTable::new(),
            rule_descendant_stmt_list: RuleDescendantStmtListTable::new(),
            rule_descendant_stmt_block_list: RuleDescendantStmtBlockListTable::new(),
            entry_scope: EntryScopeTable::new(),
            exit_scope: ExitScopeTable::new(),
            ctor_enum: CtorEnumTable::new(),
            ctors_enum: CtorsEnumTable::new(),
            cases_discriminee: CasesDiscrimineeTable::new(),
            case_discriminee: CaseDiscrimineeTable::new(),
            desugared_case_equality_atom: DesugaredCaseEqualityAtomTable::new(),
            desugared_case_equality_stmt: DesugaredCaseEqualityStmtTable::new(),
            desugared_case_block: DesugaredCaseBlockTable::new(),
            desugared_case_block_list: DesugaredCaseBlockListTable::new(),
            nil_type_list: NilTypeListTable::new(),
            cons_type_list: ConsTypeListTable::new(),
            snoc_type_list: SnocTypeListTable::new(),
            semantic_type: SemanticTypeTable::new(),
            semantic_arg_types: SemanticArgTypesTable::new(),
            semantic_pred: SemanticPredTable::new(),
            pred_arity: PredArityTable::new(),
            semantic_func: SemanticFuncTable::new(),
            domain: DomainTable::new(),
            codomain: CodomainTable::new(),
            pred_rel: PredRelTable::new(),
            func_rel: FuncRelTable::new(),
            arity: ArityTable::new(),
            dom: DomTable::new(),
            cod: CodTable::new(),
            nil_el_list: NilElListTable::new(),
            cons_el_list: ConsElListTable::new(),
            snoc_el_list: SnocElListTable::new(),
            el_structure: ElStructureTable::new(),
            els_structure: ElsStructureTable::new(),
            func_app: FuncAppTable::new(),
            map_el: MapElTable::new(),
            map_els: MapElsTable::new(),
            type_symbol: TypeSymbolTable::new(),
            pred_symbol: PredSymbolTable::new(),
            func_symbol: FuncSymbolTable::new(),
            rule_symbol: RuleSymbolTable::new(),
            enum_symbol: EnumSymbolTable::new(),
            ctor_symbol: CtorSymbolTable::new(),
            zero: ZeroTable::new(),
            succ: SuccTable::new(),
            type_list_len: TypeListLenTable::new(),
            term_list_len: TermListLenTable::new(),
            before_rule_structure: BeforeRuleStructureTable::new(),
            if_atom_morphism: IfAtomMorphismTable::new(),
            then_atom_morphism: ThenAtomMorphismTable::new(),
            branch_stmt_morphism: BranchStmtMorphismTable::new(),
            match_stmt_morphism: MatchStmtMorphismTable::new(),
            semantic_name: SemanticNameTable::new(),
            semantic_el: SemanticElTable::new(),
            semantic_els: SemanticElsTable::new(),
            wildcard_name: WildcardNameTable::new(),
            match_case_pattern_ctor: MatchCasePatternCtorTable::new(),
            cases_determined_enum: CasesDeterminedEnumTable::new(),
            empty_join_is_dirty: true,
        }
    }

    /// Closes the model under all axioms.
    /// Depending on the axioms and the model, this may run indefinitely.
    #[allow(dead_code)]
    pub fn close(&mut self) {
        self.close_until(|_: &Self| false);
    }
    /// Closes the model under all axioms until `condition` is satisfied.
    /// Depending on the axioms and `condition`, this may run indefinitely.
    /// Returns `true` if the `condition` eventually holds.
    /// Returns `false` if the model could be closed under all axioms but `condition` still does not hold.
    #[allow(dead_code)]
    pub fn close_until(&mut self, condition: impl Fn(&Self) -> bool) -> bool {
        let mut delta = ModelDelta::new();

        self.canonicalize();
        if condition(self) {
            return true;
        }

        while self.is_dirty() {
            loop {
                self.implicit_functionality_0_0(&mut delta);
                self.implicit_functionality_1_0(&mut delta);
                self.implicit_functionality_2_0(&mut delta);
                self.implicit_functionality_3_0(&mut delta);
                self.implicit_functionality_4_0(&mut delta);
                self.implicit_functionality_5_0(&mut delta);
                self.implicit_functionality_6_0(&mut delta);
                self.implicit_functionality_7_0(&mut delta);
                self.implicit_functionality_8_0(&mut delta);
                self.implicit_functionality_9_0(&mut delta);
                self.implicit_functionality_10_0(&mut delta);
                self.implicit_functionality_11_0(&mut delta);
                self.implicit_functionality_12_0(&mut delta);
                self.implicit_functionality_13_0(&mut delta);
                self.implicit_functionality_14_0(&mut delta);
                self.implicit_functionality_15_0(&mut delta);
                self.implicit_functionality_16_0(&mut delta);
                self.implicit_functionality_17_0(&mut delta);
                self.implicit_functionality_18_0(&mut delta);
                self.implicit_functionality_19_0(&mut delta);
                self.implicit_functionality_20_0(&mut delta);
                self.implicit_functionality_21_0(&mut delta);
                self.implicit_functionality_22_0(&mut delta);
                self.implicit_functionality_23_0(&mut delta);
                self.implicit_functionality_24_0(&mut delta);
                self.implicit_functionality_25_0(&mut delta);
                self.implicit_functionality_26_0(&mut delta);
                self.implicit_functionality_27_0(&mut delta);
                self.implicit_functionality_28_0(&mut delta);
                self.implicit_functionality_29_0(&mut delta);
                self.implicit_functionality_30_0(&mut delta);
                self.implicit_functionality_31_0(&mut delta);
                self.implicit_functionality_32_0(&mut delta);
                self.implicit_functionality_33_0(&mut delta);
                self.implicit_functionality_34_0(&mut delta);
                self.implicit_functionality_35_0(&mut delta);
                self.implicit_functionality_36_0(&mut delta);
                self.implicit_functionality_37_0(&mut delta);
                self.implicit_functionality_38_0(&mut delta);
                self.implicit_functionality_39_0(&mut delta);
                self.implicit_functionality_40_0(&mut delta);
                self.implicit_functionality_41_0(&mut delta);
                self.implicit_functionality_42_0(&mut delta);
                self.implicit_functionality_43_0(&mut delta);
                self.implicit_functionality_44_0(&mut delta);
                self.implicit_functionality_45_0(&mut delta);
                self.implicit_functionality_46_0(&mut delta);
                self.implicit_functionality_47_0(&mut delta);
                self.implicit_functionality_48_0(&mut delta);
                self.implicit_functionality_49_0(&mut delta);
                self.implicit_functionality_50_0(&mut delta);
                self.implicit_functionality_51_0(&mut delta);
                self.implicit_functionality_52_0(&mut delta);
                self.implicit_functionality_53_0(&mut delta);
                self.implicit_functionality_54_0(&mut delta);
                self.implicit_functionality_55_0(&mut delta);
                self.implicit_functionality_56_0(&mut delta);
                self.implicit_functionality_57_0(&mut delta);
                self.implicit_functionality_58_0(&mut delta);
                self.implicit_functionality_59_0(&mut delta);
                self.implicit_functionality_60_0(&mut delta);
                self.implicit_functionality_61_0(&mut delta);
                self.implicit_functionality_62_0(&mut delta);
                self.implicit_functionality_63_0(&mut delta);
                self.implicit_functionality_64_0(&mut delta);
                self.implicit_functionality_65_0(&mut delta);
                self.implicit_functionality_66_0(&mut delta);
                self.implicit_functionality_67_0(&mut delta);
                self.implicit_functionality_68_0(&mut delta);
                self.implicit_functionality_69_0(&mut delta);
                self.implicit_functionality_70_0(&mut delta);
                self.implicit_functionality_71_0(&mut delta);
                self.implicit_functionality_72_0(&mut delta);
                self.implicit_functionality_73_0(&mut delta);
                self.implicit_functionality_74_0(&mut delta);
                self.implicit_functionality_75_0(&mut delta);
                self.implicit_functionality_76_0(&mut delta);
                self.implicit_functionality_77_0(&mut delta);
                self.implicit_functionality_78_0(&mut delta);
                self.implicit_functionality_79_0(&mut delta);
                self.implicit_functionality_80_0(&mut delta);
                self.implicit_functionality_81_0(&mut delta);
                self.implicit_functionality_82_0(&mut delta);
                self.implicit_functionality_83_0(&mut delta);
                self.implicit_functionality_84_0(&mut delta);
                self.implicit_functionality_85_0(&mut delta);
                self.implicit_functionality_86_0(&mut delta);
                self.implicit_functionality_87_0(&mut delta);
                self.real_virt_ident_total_0(&mut delta);
                self.virt_real_ident_retraction_0(&mut delta);
                self.rule_descendant_rule_total_0(&mut delta);
                self.rule_descendant_term_total_0(&mut delta);
                self.rule_descendant_term_list_total_0(&mut delta);
                self.rule_descendant_opt_term_total_0(&mut delta);
                self.rule_descendant_if_atom_total_0(&mut delta);
                self.rule_descendant_then_atom_total_0(&mut delta);
                self.rule_descendant_match_case_total_0(&mut delta);
                self.rule_descendant_match_case_list_total_0(&mut delta);
                self.rule_descendant_stmt_total_0(&mut delta);
                self.rule_descendant_stmt_list_total_0(&mut delta);
                self.rule_descendant_stmt_block_list_total_0(&mut delta);
                self.scope_extension_vars_0(&mut delta);
                self.entry_exit_scope_total_0(&mut delta);
                self.exit_scope_extends_entry_scope_0(&mut delta);
                self.scope_single_child_scopes_0(&mut delta);
                self.scope_extension_siblings_parent_first_0(&mut delta);
                self.scope_extension_siblings_first_second_0(&mut delta);
                self.scope_extension_siblings_second_parent_0(&mut delta);
                self.scopes_rule_0(&mut delta);
                self.scopes_stmt_list_cons_0(&mut delta);
                self.scopes_stmt_block_list_cons_0(&mut delta);
                self.scopes_stmt_if_0(&mut delta);
                self.scopes_stmt_then_0(&mut delta);
                self.scopes_stmt_branch_0(&mut delta);
                self.scopes_stmt_match_0(&mut delta);
                self.scopes_if_atom_equal_0(&mut delta);
                self.scopes_if_atom_defined_0(&mut delta);
                self.scopes_if_atom_pred_0(&mut delta);
                self.scopes_if_atom_var_0(&mut delta);
                self.scopes_then_atom_equal_0(&mut delta);
                self.scopes_then_atom_defined_0(&mut delta);
                self.scopes_then_atom_pred_0(&mut delta);
                self.scopes_term_list_cons_0(&mut delta);
                self.scopes_opt_term_some_0(&mut delta);
                self.scopes_term_app_0(&mut delta);
                self.scopes_term_var_0(&mut delta);
                self.enum_ctors_0(&mut delta);
                self.enum_ctors_cons_0(&mut delta);
                self.match_stmt_cases_discriminee_0(&mut delta);
                self.cases_match_stmt_cons_0(&mut delta);
                self.desugared_case_equality_stmt_loc_0(&mut delta);
                self.desugared_case_defined_0(&mut delta);
                self.desugared_case_block_list_defined_0(&mut delta);
                self.desugared_case_equality_atom_stmt_0(&mut delta);
                self.desugared_case_block_structure_0(&mut delta);
                self.desugared_case_blocks_0(&mut delta);
                self.scopes_desugared_case_0(&mut delta);
                self.scopes_desugared_case_list_0(&mut delta);
                self.type_list_nil_not_cons_0(&mut delta);
                self.type_list_cons_injective_0(&mut delta);
                self.semantic_decl_type_0(&mut delta);
                self.semantic_decl_enum_0(&mut delta);
                self.semantic_arg_types_nil_0(&mut delta);
                self.semantic_arg_types_cons_0(&mut delta);
                self.semantic_decl_pred_0(&mut delta);
                self.pred_arity_decl_0(&mut delta);
                self.semantic_decl_func_0(&mut delta);
                self.semantic_decl_func_ctor_0(&mut delta);
                self.func_decl_domain_codomain_0(&mut delta);
                self.ctor_decl_domain_0(&mut delta);
                self.ctor_decl_codomain_0(&mut delta);
                self.rel_constructors_pred_total_0(&mut delta);
                self.rel_constructors_func_total_0(&mut delta);
                self.arity_laws_0(&mut delta);
                self.el_list_cons_injective_0(&mut delta);
                self.el_list_snoc_injective_0(&mut delta);
                self.el_list_cons_nil_0(&mut delta);
                self.el_list_snoc_nil_0(&mut delta);
                self.nil_els_structure_0(&mut delta);
                self.cons_els_structure_0(&mut delta);
                self.snoc_els_structure_0(&mut delta);
                self.var_structure_0(&mut delta);
                self.nil_el_types_0(&mut delta);
                self.cons_el_types_0(&mut delta);
                self.cons_el_types_reverse_0(&mut delta);
                self.snoc_el_types_0(&mut delta);
                self.snoc_el_types_reverse_0(&mut delta);
                self.rel_app_types_0(&mut delta);
                self.rel_app_func_app_0(&mut delta);
                self.rel_app_constrained_0(&mut delta);
                self.constrained_head_tail_0(&mut delta);
                self.constrained_init_snoc_0(&mut delta);
                self.dom_total_0(&mut delta);
                self.cod_total_0(&mut delta);
                self.map_el_structure_0(&mut delta);
                self.map_el_defined_0(&mut delta);
                self.map_els_defined_0(&mut delta);
                self.map_var_0(&mut delta);
                self.map_rel_app_0(&mut delta);
                self.map_preserves_el_type_0(&mut delta);
                self.map_reflects_el_type_0(&mut delta);
                self.in_ker_rule_0(&mut delta);
                self.el_in_img_rule_0(&mut delta);
                self.rel_tuple_in_img_law_0(&mut delta);
                self.anonymous_rule_96_0(&mut delta);
                self.type_decl_defines_symbol_0(&mut delta);
                self.enum_decl_defines_symbol_0(&mut delta);
                self.pred_decl_defines_symbol_0(&mut delta);
                self.func_decl_defines_symbol_0(&mut delta);
                self.ctor_decl_defines_symbol_0(&mut delta);
                self.rule_decl_defines_symbol_0(&mut delta);
                self.arg_decl_should_be_type_0(&mut delta);
                self.result_should_be_type_0(&mut delta);
                self.var_atom_should_be_type_0(&mut delta);
                self.pred_if_atom_should_be_pred_0(&mut delta);
                self.pred_then_atom_should_be_pred_0(&mut delta);
                self.app_atom_should_be_func_0(&mut delta);
                self.type_list_len_total_0(&mut delta);
                self.type_list_len_nil_0(&mut delta);
                self.type_list_len_cons_0(&mut delta);
                self.type_list_len_snoc_0(&mut delta);
                self.term_list_len_total_0(&mut delta);
                self.term_list_len_nil_0(&mut delta);
                self.term_list_len_cons_0(&mut delta);
                self.pred_if_atom_arg_num_should_match_0(&mut delta);
                self.pred_then_atom_arg_num_should_match_0(&mut delta);
                self.app_term_arg_num_should_match_0(&mut delta);
                self.cfg_edge_stmts_stmt_cons_0(&mut delta);
                self.cfg_edge_stmts_stmt_singleton_0(&mut delta);
                self.cfg_edge_stmt_stmts_cons_0(&mut delta);
                self.cfg_edge_stmt_stmts_nil_0(&mut delta);
                self.cfg_edge_fork_cons_0(&mut delta);
                self.cfg_edge_join_cons_0(&mut delta);
                self.cfg_edge_if_0(&mut delta);
                self.cfg_edge_then_0(&mut delta);
                self.cfg_edge_branch_fork_blocks_0(&mut delta);
                self.cfg_edge_match_fork_blocks_0(&mut delta);
                self.cfg_edge_branch_join_blocks_0(&mut delta);
                self.cfg_edge_match_join_blocks_0(&mut delta);
                self.before_rule_structure_total_0(&mut delta);
                self.before_first_rule_stmt_0(&mut delta);
                self.cfg_edge_stmt_structure_0(&mut delta);
                self.if_atom_morphism_dom_0(&mut delta);
                self.then_atom_morphism_dom_0(&mut delta);
                self.branch_stmt_morphism_dom_0(&mut delta);
                self.match_stmt_morphism_dom_0(&mut delta);
                self.if_stmt_morphism_defined_0(&mut delta);
                self.then_stmt_morphism_defined_0(&mut delta);
                self.branch_stmt_morphism_defined_0(&mut delta);
                self.match_stmt_morphism_defined_0(&mut delta);
                self.if_stmt_morphism_is_if_0(&mut delta);
                self.then_equal_stmt_morphism_is_surj_0(&mut delta);
                self.then_pred_stmt_morphism_is_surj_0(&mut delta);
                self.then_defined_stmt_morphism_is_non_surj_0(&mut delta);
                self.branch_stmt_morphism_is_noop_0(&mut delta);
                self.match_stmt_morphism_is_if_0(&mut delta);
                self.stmt_structure_morphism_0(&mut delta);
                self.if_stmt_structure_0(&mut delta);
                self.then_stmt_structure_0(&mut delta);
                self.match_stmt_structure_0(&mut delta);
                self.equal_if_atom_structure_0(&mut delta);
                self.defined_if_atom_structure_0(&mut delta);
                self.pred_if_atom_structure_0(&mut delta);
                self.var_if_atom_structure_0(&mut delta);
                self.equal_then_atom_structure_0(&mut delta);
                self.defined_then_atom_structure_0(&mut delta);
                self.pred_then_atom_structure_0(&mut delta);
                self.cons_term_list_structure_0(&mut delta);
                self.some_opt_term_structure_0(&mut delta);
                self.app_term_structure_0(&mut delta);
                self.semantic_name_defined_0(&mut delta);
                self.semantic_name_extension_scope_0(&mut delta);
                self.semantic_el_defined_0(&mut delta);
                self.semantic_els_nil_0(&mut delta);
                self.semantic_els_cons_0(&mut delta);
                self.semantic_el_struct_0(&mut delta);
                self.semantic_els_struct_0(&mut delta);
                self.app_term_semantics_0(&mut delta);
                self.var_term_semantics_0(&mut delta);
                self.wildcard_name_defined_0(&mut delta);
                self.wildcard_term_semantics_0(&mut delta);
                self.equal_if_atom_semantics_0(&mut delta);
                self.pred_if_atom_semantics_0(&mut delta);
                self.var_if_atom_semantics_0(&mut delta);
                self.equal_then_atom_semantics_0(&mut delta);
                self.defined_then_atom_semantics_0(&mut delta);
                self.pred_then_atom_semantics_0(&mut delta);
                self.terms_should_be_epic_ok_cons_0(&mut delta);
                self.terms_should_be_epic_ok_app_0(&mut delta);
                self.then_atom_epic_ok_equal_0(&mut delta);
                self.then_atom_epic_ok_defined_0(&mut delta);
                self.then_atom_epic_ok_pred_0(&mut delta);
                self.surjective_codomain_should_be_ok_0(&mut delta);
                self.non_surjective_codomain_should_be_ok_0(&mut delta);
                self.surjective_img_el_is_ok_0(&mut delta);
                self.surjective_exempted_then_defined_term_0(&mut delta);
                self.defined_then_should_be_given_by_ctor_0(&mut delta);
                self.ctor_app_is_given_by_ctor_0(&mut delta);
                self.function_can_be_made_defined_if_codomain_normal_type_0(&mut delta);
                self.function_can_be_defined_if_constructor_0(&mut delta);
                self.case_pattern_is_variable_defined_0(&mut delta);
                self.case_pattern_is_wildcard_defined_0(&mut delta);
                self.case_pattern_app_should_be_constructor_0(&mut delta);
                self.match_case_pattern_ctor_defined_0(&mut delta);
                self.is_pattern_ctor_arg_cons_0(&mut delta);
                self.are_pattern_ctor_args_defined_0(&mut delta);
                self.pattern_ctor_arg_is_app_defined_0(&mut delta);
                self.pattern_ctor_arg_var_is_not_fresh_defined_0(&mut delta);
                self.contains_ctor_case_head_0(&mut delta);
                self.contains_ctor_case_tail_0(&mut delta);
                self.match_stmt_contains_ctor_of_enum_defined_0(&mut delta);
                self.ctor_cases_determine_enum_singleton_0(&mut delta);
                self.ctor_cases_determine_enum_cons_0(&mut delta);
                self.match_term_type_if_cases_determine_enum_0(&mut delta);
                self.match_stmt_should_contain_ctor_defined_0(&mut delta);
                self.match_stmt_contains_ctor_defined_0(&mut delta);

                self.drop_dirt();
                delta.apply_surjective(self);
                self.canonicalize();

                if condition(self) {
                    return true;
                }

                if !self.is_dirty() {
                    break;
                }
            }

            delta.apply_non_surjective(self);
            if condition(self) {
                return true;
            }
        }

        false
    }
    /// Returns and iterator over elements of sort `Ident`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_ident(&self) -> impl '_ + Iterator<Item = Ident> {
        self.ident_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_ident(&self, el: Ident) -> Ident {
        if el.0 as usize >= self.ident_equalities.len() {
            el
        } else {
            self.ident_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_ident(&self, lhs: Ident, rhs: Ident) -> bool {
        self.root_ident(lhs) == self.root_ident(rhs)
    }

    /// Returns and iterator over elements of sort `VirtIdent`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_virt_ident(&self) -> impl '_ + Iterator<Item = VirtIdent> {
        self.virt_ident_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_virt_ident(&self, el: VirtIdent) -> VirtIdent {
        if el.0 as usize >= self.virt_ident_equalities.len() {
            el
        } else {
            self.virt_ident_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_virt_ident(&self, lhs: VirtIdent, rhs: VirtIdent) -> bool {
        self.root_virt_ident(lhs) == self.root_virt_ident(rhs)
    }

    /// Returns and iterator over elements of sort `TypeDeclNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_type_decl_node(&self) -> impl '_ + Iterator<Item = TypeDeclNode> {
        self.type_decl_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_type_decl_node(&self, el: TypeDeclNode) -> TypeDeclNode {
        if el.0 as usize >= self.type_decl_node_equalities.len() {
            el
        } else {
            self.type_decl_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_type_decl_node(&self, lhs: TypeDeclNode, rhs: TypeDeclNode) -> bool {
        self.root_type_decl_node(lhs) == self.root_type_decl_node(rhs)
    }

    /// Returns and iterator over elements of sort `ArgDeclNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_arg_decl_node(&self) -> impl '_ + Iterator<Item = ArgDeclNode> {
        self.arg_decl_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_arg_decl_node(&self, el: ArgDeclNode) -> ArgDeclNode {
        if el.0 as usize >= self.arg_decl_node_equalities.len() {
            el
        } else {
            self.arg_decl_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_arg_decl_node(&self, lhs: ArgDeclNode, rhs: ArgDeclNode) -> bool {
        self.root_arg_decl_node(lhs) == self.root_arg_decl_node(rhs)
    }

    /// Returns and iterator over elements of sort `ArgDeclListNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_arg_decl_list_node(&self) -> impl '_ + Iterator<Item = ArgDeclListNode> {
        self.arg_decl_list_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_arg_decl_list_node(&self, el: ArgDeclListNode) -> ArgDeclListNode {
        if el.0 as usize >= self.arg_decl_list_node_equalities.len() {
            el
        } else {
            self.arg_decl_list_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_arg_decl_list_node(&self, lhs: ArgDeclListNode, rhs: ArgDeclListNode) -> bool {
        self.root_arg_decl_list_node(lhs) == self.root_arg_decl_list_node(rhs)
    }

    /// Returns and iterator over elements of sort `PredDeclNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_pred_decl_node(&self) -> impl '_ + Iterator<Item = PredDeclNode> {
        self.pred_decl_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_pred_decl_node(&self, el: PredDeclNode) -> PredDeclNode {
        if el.0 as usize >= self.pred_decl_node_equalities.len() {
            el
        } else {
            self.pred_decl_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_pred_decl_node(&self, lhs: PredDeclNode, rhs: PredDeclNode) -> bool {
        self.root_pred_decl_node(lhs) == self.root_pred_decl_node(rhs)
    }

    /// Returns and iterator over elements of sort `FuncDeclNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_func_decl_node(&self) -> impl '_ + Iterator<Item = FuncDeclNode> {
        self.func_decl_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_func_decl_node(&self, el: FuncDeclNode) -> FuncDeclNode {
        if el.0 as usize >= self.func_decl_node_equalities.len() {
            el
        } else {
            self.func_decl_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_func_decl_node(&self, lhs: FuncDeclNode, rhs: FuncDeclNode) -> bool {
        self.root_func_decl_node(lhs) == self.root_func_decl_node(rhs)
    }

    /// Returns and iterator over elements of sort `CtorDeclNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_ctor_decl_node(&self) -> impl '_ + Iterator<Item = CtorDeclNode> {
        self.ctor_decl_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_ctor_decl_node(&self, el: CtorDeclNode) -> CtorDeclNode {
        if el.0 as usize >= self.ctor_decl_node_equalities.len() {
            el
        } else {
            self.ctor_decl_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_ctor_decl_node(&self, lhs: CtorDeclNode, rhs: CtorDeclNode) -> bool {
        self.root_ctor_decl_node(lhs) == self.root_ctor_decl_node(rhs)
    }

    /// Returns and iterator over elements of sort `CtorDeclListNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_ctor_decl_list_node(&self) -> impl '_ + Iterator<Item = CtorDeclListNode> {
        self.ctor_decl_list_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_ctor_decl_list_node(&self, el: CtorDeclListNode) -> CtorDeclListNode {
        if el.0 as usize >= self.ctor_decl_list_node_equalities.len() {
            el
        } else {
            self.ctor_decl_list_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_ctor_decl_list_node(
        &self,
        lhs: CtorDeclListNode,
        rhs: CtorDeclListNode,
    ) -> bool {
        self.root_ctor_decl_list_node(lhs) == self.root_ctor_decl_list_node(rhs)
    }

    /// Returns and iterator over elements of sort `EnumDeclNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_enum_decl_node(&self) -> impl '_ + Iterator<Item = EnumDeclNode> {
        self.enum_decl_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_enum_decl_node(&self, el: EnumDeclNode) -> EnumDeclNode {
        if el.0 as usize >= self.enum_decl_node_equalities.len() {
            el
        } else {
            self.enum_decl_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_enum_decl_node(&self, lhs: EnumDeclNode, rhs: EnumDeclNode) -> bool {
        self.root_enum_decl_node(lhs) == self.root_enum_decl_node(rhs)
    }

    /// Returns and iterator over elements of sort `TermNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_term_node(&self) -> impl '_ + Iterator<Item = TermNode> {
        self.term_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_term_node(&self, el: TermNode) -> TermNode {
        if el.0 as usize >= self.term_node_equalities.len() {
            el
        } else {
            self.term_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_term_node(&self, lhs: TermNode, rhs: TermNode) -> bool {
        self.root_term_node(lhs) == self.root_term_node(rhs)
    }

    /// Returns and iterator over elements of sort `TermListNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_term_list_node(&self) -> impl '_ + Iterator<Item = TermListNode> {
        self.term_list_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_term_list_node(&self, el: TermListNode) -> TermListNode {
        if el.0 as usize >= self.term_list_node_equalities.len() {
            el
        } else {
            self.term_list_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_term_list_node(&self, lhs: TermListNode, rhs: TermListNode) -> bool {
        self.root_term_list_node(lhs) == self.root_term_list_node(rhs)
    }

    /// Returns and iterator over elements of sort `OptTermNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_opt_term_node(&self) -> impl '_ + Iterator<Item = OptTermNode> {
        self.opt_term_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_opt_term_node(&self, el: OptTermNode) -> OptTermNode {
        if el.0 as usize >= self.opt_term_node_equalities.len() {
            el
        } else {
            self.opt_term_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_opt_term_node(&self, lhs: OptTermNode, rhs: OptTermNode) -> bool {
        self.root_opt_term_node(lhs) == self.root_opt_term_node(rhs)
    }

    /// Returns and iterator over elements of sort `MatchCaseNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_match_case_node(&self) -> impl '_ + Iterator<Item = MatchCaseNode> {
        self.match_case_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_match_case_node(&self, el: MatchCaseNode) -> MatchCaseNode {
        if el.0 as usize >= self.match_case_node_equalities.len() {
            el
        } else {
            self.match_case_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_match_case_node(&self, lhs: MatchCaseNode, rhs: MatchCaseNode) -> bool {
        self.root_match_case_node(lhs) == self.root_match_case_node(rhs)
    }

    /// Returns and iterator over elements of sort `StmtListNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_stmt_list_node(&self) -> impl '_ + Iterator<Item = StmtListNode> {
        self.stmt_list_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_stmt_list_node(&self, el: StmtListNode) -> StmtListNode {
        if el.0 as usize >= self.stmt_list_node_equalities.len() {
            el
        } else {
            self.stmt_list_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_stmt_list_node(&self, lhs: StmtListNode, rhs: StmtListNode) -> bool {
        self.root_stmt_list_node(lhs) == self.root_stmt_list_node(rhs)
    }

    /// Returns and iterator over elements of sort `MatchCaseListNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_match_case_list_node(&self) -> impl '_ + Iterator<Item = MatchCaseListNode> {
        self.match_case_list_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_match_case_list_node(&self, el: MatchCaseListNode) -> MatchCaseListNode {
        if el.0 as usize >= self.match_case_list_node_equalities.len() {
            el
        } else {
            self.match_case_list_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_match_case_list_node(
        &self,
        lhs: MatchCaseListNode,
        rhs: MatchCaseListNode,
    ) -> bool {
        self.root_match_case_list_node(lhs) == self.root_match_case_list_node(rhs)
    }

    /// Returns and iterator over elements of sort `IfAtomNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_if_atom_node(&self) -> impl '_ + Iterator<Item = IfAtomNode> {
        self.if_atom_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_if_atom_node(&self, el: IfAtomNode) -> IfAtomNode {
        if el.0 as usize >= self.if_atom_node_equalities.len() {
            el
        } else {
            self.if_atom_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_if_atom_node(&self, lhs: IfAtomNode, rhs: IfAtomNode) -> bool {
        self.root_if_atom_node(lhs) == self.root_if_atom_node(rhs)
    }

    /// Returns and iterator over elements of sort `ThenAtomNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_then_atom_node(&self) -> impl '_ + Iterator<Item = ThenAtomNode> {
        self.then_atom_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_then_atom_node(&self, el: ThenAtomNode) -> ThenAtomNode {
        if el.0 as usize >= self.then_atom_node_equalities.len() {
            el
        } else {
            self.then_atom_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_then_atom_node(&self, lhs: ThenAtomNode, rhs: ThenAtomNode) -> bool {
        self.root_then_atom_node(lhs) == self.root_then_atom_node(rhs)
    }

    /// Returns and iterator over elements of sort `StmtNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_stmt_node(&self) -> impl '_ + Iterator<Item = StmtNode> {
        self.stmt_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_stmt_node(&self, el: StmtNode) -> StmtNode {
        if el.0 as usize >= self.stmt_node_equalities.len() {
            el
        } else {
            self.stmt_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_stmt_node(&self, lhs: StmtNode, rhs: StmtNode) -> bool {
        self.root_stmt_node(lhs) == self.root_stmt_node(rhs)
    }

    /// Returns and iterator over elements of sort `StmtBlockListNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_stmt_block_list_node(&self) -> impl '_ + Iterator<Item = StmtBlockListNode> {
        self.stmt_block_list_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_stmt_block_list_node(&self, el: StmtBlockListNode) -> StmtBlockListNode {
        if el.0 as usize >= self.stmt_block_list_node_equalities.len() {
            el
        } else {
            self.stmt_block_list_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_stmt_block_list_node(
        &self,
        lhs: StmtBlockListNode,
        rhs: StmtBlockListNode,
    ) -> bool {
        self.root_stmt_block_list_node(lhs) == self.root_stmt_block_list_node(rhs)
    }

    /// Returns and iterator over elements of sort `RuleDeclNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_rule_decl_node(&self) -> impl '_ + Iterator<Item = RuleDeclNode> {
        self.rule_decl_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_rule_decl_node(&self, el: RuleDeclNode) -> RuleDeclNode {
        if el.0 as usize >= self.rule_decl_node_equalities.len() {
            el
        } else {
            self.rule_decl_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_rule_decl_node(&self, lhs: RuleDeclNode, rhs: RuleDeclNode) -> bool {
        self.root_rule_decl_node(lhs) == self.root_rule_decl_node(rhs)
    }

    /// Returns and iterator over elements of sort `DeclNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_decl_node(&self) -> impl '_ + Iterator<Item = DeclNode> {
        self.decl_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_decl_node(&self, el: DeclNode) -> DeclNode {
        if el.0 as usize >= self.decl_node_equalities.len() {
            el
        } else {
            self.decl_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_decl_node(&self, lhs: DeclNode, rhs: DeclNode) -> bool {
        self.root_decl_node(lhs) == self.root_decl_node(rhs)
    }

    /// Returns and iterator over elements of sort `DeclListNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_decl_list_node(&self) -> impl '_ + Iterator<Item = DeclListNode> {
        self.decl_list_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_decl_list_node(&self, el: DeclListNode) -> DeclListNode {
        if el.0 as usize >= self.decl_list_node_equalities.len() {
            el
        } else {
            self.decl_list_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_decl_list_node(&self, lhs: DeclListNode, rhs: DeclListNode) -> bool {
        self.root_decl_list_node(lhs) == self.root_decl_list_node(rhs)
    }

    /// Returns and iterator over elements of sort `ModuleNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_module_node(&self) -> impl '_ + Iterator<Item = ModuleNode> {
        self.module_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_module_node(&self, el: ModuleNode) -> ModuleNode {
        if el.0 as usize >= self.module_node_equalities.len() {
            el
        } else {
            self.module_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_module_node(&self, lhs: ModuleNode, rhs: ModuleNode) -> bool {
        self.root_module_node(lhs) == self.root_module_node(rhs)
    }

    /// Returns and iterator over elements of sort `Loc`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_loc(&self) -> impl '_ + Iterator<Item = Loc> {
        self.loc_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_loc(&self, el: Loc) -> Loc {
        if el.0 as usize >= self.loc_equalities.len() {
            el
        } else {
            self.loc_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_loc(&self, lhs: Loc, rhs: Loc) -> bool {
        self.root_loc(lhs) == self.root_loc(rhs)
    }

    /// Returns and iterator over elements of sort `RuleDescendantNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_rule_descendant_node(&self) -> impl '_ + Iterator<Item = RuleDescendantNode> {
        self.rule_descendant_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_rule_descendant_node(&self, el: RuleDescendantNode) -> RuleDescendantNode {
        if el.0 as usize >= self.rule_descendant_node_equalities.len() {
            el
        } else {
            self.rule_descendant_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_rule_descendant_node(
        &self,
        lhs: RuleDescendantNode,
        rhs: RuleDescendantNode,
    ) -> bool {
        self.root_rule_descendant_node(lhs) == self.root_rule_descendant_node(rhs)
    }

    /// Returns and iterator over elements of sort `Scope`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_scope(&self) -> impl '_ + Iterator<Item = Scope> {
        self.scope_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_scope(&self, el: Scope) -> Scope {
        if el.0 as usize >= self.scope_equalities.len() {
            el
        } else {
            self.scope_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_scope(&self, lhs: Scope, rhs: Scope) -> bool {
        self.root_scope(lhs) == self.root_scope(rhs)
    }

    /// Returns and iterator over elements of sort `Type`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_type(&self) -> impl '_ + Iterator<Item = Type> {
        self.type_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_type(&self, el: Type) -> Type {
        if el.0 as usize >= self.type_equalities.len() {
            el
        } else {
            self.type_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_type(&self, lhs: Type, rhs: Type) -> bool {
        self.root_type(lhs) == self.root_type(rhs)
    }

    /// Returns and iterator over elements of sort `TypeList`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_type_list(&self) -> impl '_ + Iterator<Item = TypeList> {
        self.type_list_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_type_list(&self, el: TypeList) -> TypeList {
        if el.0 as usize >= self.type_list_equalities.len() {
            el
        } else {
            self.type_list_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_type_list(&self, lhs: TypeList, rhs: TypeList) -> bool {
        self.root_type_list(lhs) == self.root_type_list(rhs)
    }

    /// Returns and iterator over elements of sort `Pred`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_pred(&self) -> impl '_ + Iterator<Item = Pred> {
        self.pred_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_pred(&self, el: Pred) -> Pred {
        if el.0 as usize >= self.pred_equalities.len() {
            el
        } else {
            self.pred_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_pred(&self, lhs: Pred, rhs: Pred) -> bool {
        self.root_pred(lhs) == self.root_pred(rhs)
    }

    /// Returns and iterator over elements of sort `Func`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_func(&self) -> impl '_ + Iterator<Item = Func> {
        self.func_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_func(&self, el: Func) -> Func {
        if el.0 as usize >= self.func_equalities.len() {
            el
        } else {
            self.func_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_func(&self, lhs: Func, rhs: Func) -> bool {
        self.root_func(lhs) == self.root_func(rhs)
    }

    /// Returns and iterator over elements of sort `Rel`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_rel(&self) -> impl '_ + Iterator<Item = Rel> {
        self.rel_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_rel(&self, el: Rel) -> Rel {
        if el.0 as usize >= self.rel_equalities.len() {
            el
        } else {
            self.rel_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_rel(&self, lhs: Rel, rhs: Rel) -> bool {
        self.root_rel(lhs) == self.root_rel(rhs)
    }

    /// Returns and iterator over elements of sort `Structure`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_structure(&self) -> impl '_ + Iterator<Item = Structure> {
        self.structure_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_structure(&self, el: Structure) -> Structure {
        if el.0 as usize >= self.structure_equalities.len() {
            el
        } else {
            self.structure_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_structure(&self, lhs: Structure, rhs: Structure) -> bool {
        self.root_structure(lhs) == self.root_structure(rhs)
    }

    /// Returns and iterator over elements of sort `El`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_el(&self) -> impl '_ + Iterator<Item = El> {
        self.el_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_el(&self, el: El) -> El {
        if el.0 as usize >= self.el_equalities.len() {
            el
        } else {
            self.el_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_el(&self, lhs: El, rhs: El) -> bool {
        self.root_el(lhs) == self.root_el(rhs)
    }

    /// Returns and iterator over elements of sort `ElList`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_el_list(&self) -> impl '_ + Iterator<Item = ElList> {
        self.el_list_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_el_list(&self, el: ElList) -> ElList {
        if el.0 as usize >= self.el_list_equalities.len() {
            el
        } else {
            self.el_list_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_el_list(&self, lhs: ElList, rhs: ElList) -> bool {
        self.root_el_list(lhs) == self.root_el_list(rhs)
    }

    /// Returns and iterator over elements of sort `ElName`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_el_name(&self) -> impl '_ + Iterator<Item = ElName> {
        self.el_name_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_el_name(&self, el: ElName) -> ElName {
        if el.0 as usize >= self.el_name_equalities.len() {
            el
        } else {
            self.el_name_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_el_name(&self, lhs: ElName, rhs: ElName) -> bool {
        self.root_el_name(lhs) == self.root_el_name(rhs)
    }

    /// Returns and iterator over elements of sort `Morphism`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_morphism(&self) -> impl '_ + Iterator<Item = Morphism> {
        self.morphism_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_morphism(&self, el: Morphism) -> Morphism {
        if el.0 as usize >= self.morphism_equalities.len() {
            el
        } else {
            self.morphism_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_morphism(&self, lhs: Morphism, rhs: Morphism) -> bool {
        self.root_morphism(lhs) == self.root_morphism(rhs)
    }

    /// Returns and iterator over elements of sort `SymbolKind`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_symbol_kind(&self) -> impl '_ + Iterator<Item = SymbolKind> {
        self.symbol_kind_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_symbol_kind(&self, el: SymbolKind) -> SymbolKind {
        if el.0 as usize >= self.symbol_kind_equalities.len() {
            el
        } else {
            self.symbol_kind_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_symbol_kind(&self, lhs: SymbolKind, rhs: SymbolKind) -> bool {
        self.root_symbol_kind(lhs) == self.root_symbol_kind(rhs)
    }

    /// Returns and iterator over elements of sort `Nat`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_nat(&self) -> impl '_ + Iterator<Item = Nat> {
        self.nat_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_nat(&self, el: Nat) -> Nat {
        if el.0 as usize >= self.nat_equalities.len() {
            el
        } else {
            self.nat_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_nat(&self, lhs: Nat, rhs: Nat) -> bool {
        self.root_nat(lhs) == self.root_nat(rhs)
    }

    /// Adjoins a new element of type [Ident].
    #[allow(dead_code)]
    fn new_ident_internal(&mut self) -> Ident {
        let old_len = self.ident_equalities.len();
        self.ident_equalities.increase_size_to(old_len + 1);
        let el = Ident::from(u32::try_from(old_len).unwrap());

        self.ident_dirty.insert(el);
        self.ident_all.insert(el);

        assert!(self.ident_weights.len() == old_len);
        self.ident_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_ident(&mut self, mut lhs: Ident, mut rhs: Ident) {
        lhs = self.ident_equalities.root(lhs);
        rhs = self.ident_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.ident_weights[lhs.0 as usize];
        let rhs_weight = self.ident_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.ident_equalities.union_roots_into(child, root);

        self.ident_all.remove(&child);
        self.ident_dirty.remove(&child);
        self.ident_uprooted.push(child);
    }
    /// Adjoins a new element of type [VirtIdent].
    #[allow(dead_code)]
    fn new_virt_ident_internal(&mut self) -> VirtIdent {
        let old_len = self.virt_ident_equalities.len();
        self.virt_ident_equalities.increase_size_to(old_len + 1);
        let el = VirtIdent::from(u32::try_from(old_len).unwrap());

        self.virt_ident_dirty.insert(el);
        self.virt_ident_all.insert(el);

        assert!(self.virt_ident_weights.len() == old_len);
        self.virt_ident_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_virt_ident(&mut self, mut lhs: VirtIdent, mut rhs: VirtIdent) {
        lhs = self.virt_ident_equalities.root(lhs);
        rhs = self.virt_ident_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.virt_ident_weights[lhs.0 as usize];
        let rhs_weight = self.virt_ident_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.virt_ident_equalities.union_roots_into(child, root);

        self.virt_ident_all.remove(&child);
        self.virt_ident_dirty.remove(&child);
        self.virt_ident_uprooted.push(child);
    }
    /// Adjoins a new element of type [TypeDeclNode].
    #[allow(dead_code)]
    fn new_type_decl_node_internal(&mut self) -> TypeDeclNode {
        let old_len = self.type_decl_node_equalities.len();
        self.type_decl_node_equalities.increase_size_to(old_len + 1);
        let el = TypeDeclNode::from(u32::try_from(old_len).unwrap());

        self.type_decl_node_dirty.insert(el);
        self.type_decl_node_all.insert(el);

        assert!(self.type_decl_node_weights.len() == old_len);
        self.type_decl_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_type_decl_node(&mut self, mut lhs: TypeDeclNode, mut rhs: TypeDeclNode) {
        lhs = self.type_decl_node_equalities.root(lhs);
        rhs = self.type_decl_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.type_decl_node_weights[lhs.0 as usize];
        let rhs_weight = self.type_decl_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.type_decl_node_equalities.union_roots_into(child, root);

        self.type_decl_node_all.remove(&child);
        self.type_decl_node_dirty.remove(&child);
        self.type_decl_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [ArgDeclNode].
    #[allow(dead_code)]
    fn new_arg_decl_node_internal(&mut self) -> ArgDeclNode {
        let old_len = self.arg_decl_node_equalities.len();
        self.arg_decl_node_equalities.increase_size_to(old_len + 1);
        let el = ArgDeclNode::from(u32::try_from(old_len).unwrap());

        self.arg_decl_node_dirty.insert(el);
        self.arg_decl_node_all.insert(el);

        assert!(self.arg_decl_node_weights.len() == old_len);
        self.arg_decl_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_arg_decl_node(&mut self, mut lhs: ArgDeclNode, mut rhs: ArgDeclNode) {
        lhs = self.arg_decl_node_equalities.root(lhs);
        rhs = self.arg_decl_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.arg_decl_node_weights[lhs.0 as usize];
        let rhs_weight = self.arg_decl_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.arg_decl_node_equalities.union_roots_into(child, root);

        self.arg_decl_node_all.remove(&child);
        self.arg_decl_node_dirty.remove(&child);
        self.arg_decl_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [ArgDeclListNode].
    #[allow(dead_code)]
    fn new_arg_decl_list_node_internal(&mut self) -> ArgDeclListNode {
        let old_len = self.arg_decl_list_node_equalities.len();
        self.arg_decl_list_node_equalities
            .increase_size_to(old_len + 1);
        let el = ArgDeclListNode::from(u32::try_from(old_len).unwrap());

        self.arg_decl_list_node_dirty.insert(el);
        self.arg_decl_list_node_all.insert(el);

        assert!(self.arg_decl_list_node_weights.len() == old_len);
        self.arg_decl_list_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_arg_decl_list_node(
        &mut self,
        mut lhs: ArgDeclListNode,
        mut rhs: ArgDeclListNode,
    ) {
        lhs = self.arg_decl_list_node_equalities.root(lhs);
        rhs = self.arg_decl_list_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.arg_decl_list_node_weights[lhs.0 as usize];
        let rhs_weight = self.arg_decl_list_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.arg_decl_list_node_equalities
            .union_roots_into(child, root);

        self.arg_decl_list_node_all.remove(&child);
        self.arg_decl_list_node_dirty.remove(&child);
        self.arg_decl_list_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [PredDeclNode].
    #[allow(dead_code)]
    fn new_pred_decl_node_internal(&mut self) -> PredDeclNode {
        let old_len = self.pred_decl_node_equalities.len();
        self.pred_decl_node_equalities.increase_size_to(old_len + 1);
        let el = PredDeclNode::from(u32::try_from(old_len).unwrap());

        self.pred_decl_node_dirty.insert(el);
        self.pred_decl_node_all.insert(el);

        assert!(self.pred_decl_node_weights.len() == old_len);
        self.pred_decl_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_pred_decl_node(&mut self, mut lhs: PredDeclNode, mut rhs: PredDeclNode) {
        lhs = self.pred_decl_node_equalities.root(lhs);
        rhs = self.pred_decl_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.pred_decl_node_weights[lhs.0 as usize];
        let rhs_weight = self.pred_decl_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.pred_decl_node_equalities.union_roots_into(child, root);

        self.pred_decl_node_all.remove(&child);
        self.pred_decl_node_dirty.remove(&child);
        self.pred_decl_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [FuncDeclNode].
    #[allow(dead_code)]
    fn new_func_decl_node_internal(&mut self) -> FuncDeclNode {
        let old_len = self.func_decl_node_equalities.len();
        self.func_decl_node_equalities.increase_size_to(old_len + 1);
        let el = FuncDeclNode::from(u32::try_from(old_len).unwrap());

        self.func_decl_node_dirty.insert(el);
        self.func_decl_node_all.insert(el);

        assert!(self.func_decl_node_weights.len() == old_len);
        self.func_decl_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_func_decl_node(&mut self, mut lhs: FuncDeclNode, mut rhs: FuncDeclNode) {
        lhs = self.func_decl_node_equalities.root(lhs);
        rhs = self.func_decl_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.func_decl_node_weights[lhs.0 as usize];
        let rhs_weight = self.func_decl_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.func_decl_node_equalities.union_roots_into(child, root);

        self.func_decl_node_all.remove(&child);
        self.func_decl_node_dirty.remove(&child);
        self.func_decl_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [CtorDeclNode].
    #[allow(dead_code)]
    fn new_ctor_decl_node_internal(&mut self) -> CtorDeclNode {
        let old_len = self.ctor_decl_node_equalities.len();
        self.ctor_decl_node_equalities.increase_size_to(old_len + 1);
        let el = CtorDeclNode::from(u32::try_from(old_len).unwrap());

        self.ctor_decl_node_dirty.insert(el);
        self.ctor_decl_node_all.insert(el);

        assert!(self.ctor_decl_node_weights.len() == old_len);
        self.ctor_decl_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_ctor_decl_node(&mut self, mut lhs: CtorDeclNode, mut rhs: CtorDeclNode) {
        lhs = self.ctor_decl_node_equalities.root(lhs);
        rhs = self.ctor_decl_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.ctor_decl_node_weights[lhs.0 as usize];
        let rhs_weight = self.ctor_decl_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.ctor_decl_node_equalities.union_roots_into(child, root);

        self.ctor_decl_node_all.remove(&child);
        self.ctor_decl_node_dirty.remove(&child);
        self.ctor_decl_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [CtorDeclListNode].
    #[allow(dead_code)]
    fn new_ctor_decl_list_node_internal(&mut self) -> CtorDeclListNode {
        let old_len = self.ctor_decl_list_node_equalities.len();
        self.ctor_decl_list_node_equalities
            .increase_size_to(old_len + 1);
        let el = CtorDeclListNode::from(u32::try_from(old_len).unwrap());

        self.ctor_decl_list_node_dirty.insert(el);
        self.ctor_decl_list_node_all.insert(el);

        assert!(self.ctor_decl_list_node_weights.len() == old_len);
        self.ctor_decl_list_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_ctor_decl_list_node(
        &mut self,
        mut lhs: CtorDeclListNode,
        mut rhs: CtorDeclListNode,
    ) {
        lhs = self.ctor_decl_list_node_equalities.root(lhs);
        rhs = self.ctor_decl_list_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.ctor_decl_list_node_weights[lhs.0 as usize];
        let rhs_weight = self.ctor_decl_list_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.ctor_decl_list_node_equalities
            .union_roots_into(child, root);

        self.ctor_decl_list_node_all.remove(&child);
        self.ctor_decl_list_node_dirty.remove(&child);
        self.ctor_decl_list_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [EnumDeclNode].
    #[allow(dead_code)]
    fn new_enum_decl_node_internal(&mut self) -> EnumDeclNode {
        let old_len = self.enum_decl_node_equalities.len();
        self.enum_decl_node_equalities.increase_size_to(old_len + 1);
        let el = EnumDeclNode::from(u32::try_from(old_len).unwrap());

        self.enum_decl_node_dirty.insert(el);
        self.enum_decl_node_all.insert(el);

        assert!(self.enum_decl_node_weights.len() == old_len);
        self.enum_decl_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_enum_decl_node(&mut self, mut lhs: EnumDeclNode, mut rhs: EnumDeclNode) {
        lhs = self.enum_decl_node_equalities.root(lhs);
        rhs = self.enum_decl_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.enum_decl_node_weights[lhs.0 as usize];
        let rhs_weight = self.enum_decl_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.enum_decl_node_equalities.union_roots_into(child, root);

        self.enum_decl_node_all.remove(&child);
        self.enum_decl_node_dirty.remove(&child);
        self.enum_decl_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [TermNode].
    #[allow(dead_code)]
    fn new_term_node_internal(&mut self) -> TermNode {
        let old_len = self.term_node_equalities.len();
        self.term_node_equalities.increase_size_to(old_len + 1);
        let el = TermNode::from(u32::try_from(old_len).unwrap());

        self.term_node_dirty.insert(el);
        self.term_node_all.insert(el);

        assert!(self.term_node_weights.len() == old_len);
        self.term_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_term_node(&mut self, mut lhs: TermNode, mut rhs: TermNode) {
        lhs = self.term_node_equalities.root(lhs);
        rhs = self.term_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.term_node_weights[lhs.0 as usize];
        let rhs_weight = self.term_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.term_node_equalities.union_roots_into(child, root);

        self.term_node_all.remove(&child);
        self.term_node_dirty.remove(&child);
        self.term_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [TermListNode].
    #[allow(dead_code)]
    fn new_term_list_node_internal(&mut self) -> TermListNode {
        let old_len = self.term_list_node_equalities.len();
        self.term_list_node_equalities.increase_size_to(old_len + 1);
        let el = TermListNode::from(u32::try_from(old_len).unwrap());

        self.term_list_node_dirty.insert(el);
        self.term_list_node_all.insert(el);

        assert!(self.term_list_node_weights.len() == old_len);
        self.term_list_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_term_list_node(&mut self, mut lhs: TermListNode, mut rhs: TermListNode) {
        lhs = self.term_list_node_equalities.root(lhs);
        rhs = self.term_list_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.term_list_node_weights[lhs.0 as usize];
        let rhs_weight = self.term_list_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.term_list_node_equalities.union_roots_into(child, root);

        self.term_list_node_all.remove(&child);
        self.term_list_node_dirty.remove(&child);
        self.term_list_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [OptTermNode].
    #[allow(dead_code)]
    fn new_opt_term_node_internal(&mut self) -> OptTermNode {
        let old_len = self.opt_term_node_equalities.len();
        self.opt_term_node_equalities.increase_size_to(old_len + 1);
        let el = OptTermNode::from(u32::try_from(old_len).unwrap());

        self.opt_term_node_dirty.insert(el);
        self.opt_term_node_all.insert(el);

        assert!(self.opt_term_node_weights.len() == old_len);
        self.opt_term_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_opt_term_node(&mut self, mut lhs: OptTermNode, mut rhs: OptTermNode) {
        lhs = self.opt_term_node_equalities.root(lhs);
        rhs = self.opt_term_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.opt_term_node_weights[lhs.0 as usize];
        let rhs_weight = self.opt_term_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.opt_term_node_equalities.union_roots_into(child, root);

        self.opt_term_node_all.remove(&child);
        self.opt_term_node_dirty.remove(&child);
        self.opt_term_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [MatchCaseNode].
    #[allow(dead_code)]
    fn new_match_case_node_internal(&mut self) -> MatchCaseNode {
        let old_len = self.match_case_node_equalities.len();
        self.match_case_node_equalities
            .increase_size_to(old_len + 1);
        let el = MatchCaseNode::from(u32::try_from(old_len).unwrap());

        self.match_case_node_dirty.insert(el);
        self.match_case_node_all.insert(el);

        assert!(self.match_case_node_weights.len() == old_len);
        self.match_case_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_match_case_node(&mut self, mut lhs: MatchCaseNode, mut rhs: MatchCaseNode) {
        lhs = self.match_case_node_equalities.root(lhs);
        rhs = self.match_case_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.match_case_node_weights[lhs.0 as usize];
        let rhs_weight = self.match_case_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.match_case_node_equalities
            .union_roots_into(child, root);

        self.match_case_node_all.remove(&child);
        self.match_case_node_dirty.remove(&child);
        self.match_case_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [MatchCaseListNode].
    #[allow(dead_code)]
    fn new_match_case_list_node_internal(&mut self) -> MatchCaseListNode {
        let old_len = self.match_case_list_node_equalities.len();
        self.match_case_list_node_equalities
            .increase_size_to(old_len + 1);
        let el = MatchCaseListNode::from(u32::try_from(old_len).unwrap());

        self.match_case_list_node_dirty.insert(el);
        self.match_case_list_node_all.insert(el);

        assert!(self.match_case_list_node_weights.len() == old_len);
        self.match_case_list_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_match_case_list_node(
        &mut self,
        mut lhs: MatchCaseListNode,
        mut rhs: MatchCaseListNode,
    ) {
        lhs = self.match_case_list_node_equalities.root(lhs);
        rhs = self.match_case_list_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.match_case_list_node_weights[lhs.0 as usize];
        let rhs_weight = self.match_case_list_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.match_case_list_node_equalities
            .union_roots_into(child, root);

        self.match_case_list_node_all.remove(&child);
        self.match_case_list_node_dirty.remove(&child);
        self.match_case_list_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [IfAtomNode].
    #[allow(dead_code)]
    fn new_if_atom_node_internal(&mut self) -> IfAtomNode {
        let old_len = self.if_atom_node_equalities.len();
        self.if_atom_node_equalities.increase_size_to(old_len + 1);
        let el = IfAtomNode::from(u32::try_from(old_len).unwrap());

        self.if_atom_node_dirty.insert(el);
        self.if_atom_node_all.insert(el);

        assert!(self.if_atom_node_weights.len() == old_len);
        self.if_atom_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_if_atom_node(&mut self, mut lhs: IfAtomNode, mut rhs: IfAtomNode) {
        lhs = self.if_atom_node_equalities.root(lhs);
        rhs = self.if_atom_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.if_atom_node_weights[lhs.0 as usize];
        let rhs_weight = self.if_atom_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.if_atom_node_equalities.union_roots_into(child, root);

        self.if_atom_node_all.remove(&child);
        self.if_atom_node_dirty.remove(&child);
        self.if_atom_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [ThenAtomNode].
    #[allow(dead_code)]
    fn new_then_atom_node_internal(&mut self) -> ThenAtomNode {
        let old_len = self.then_atom_node_equalities.len();
        self.then_atom_node_equalities.increase_size_to(old_len + 1);
        let el = ThenAtomNode::from(u32::try_from(old_len).unwrap());

        self.then_atom_node_dirty.insert(el);
        self.then_atom_node_all.insert(el);

        assert!(self.then_atom_node_weights.len() == old_len);
        self.then_atom_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_then_atom_node(&mut self, mut lhs: ThenAtomNode, mut rhs: ThenAtomNode) {
        lhs = self.then_atom_node_equalities.root(lhs);
        rhs = self.then_atom_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.then_atom_node_weights[lhs.0 as usize];
        let rhs_weight = self.then_atom_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.then_atom_node_equalities.union_roots_into(child, root);

        self.then_atom_node_all.remove(&child);
        self.then_atom_node_dirty.remove(&child);
        self.then_atom_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [StmtNode].
    #[allow(dead_code)]
    fn new_stmt_node_internal(&mut self) -> StmtNode {
        let old_len = self.stmt_node_equalities.len();
        self.stmt_node_equalities.increase_size_to(old_len + 1);
        let el = StmtNode::from(u32::try_from(old_len).unwrap());

        self.stmt_node_dirty.insert(el);
        self.stmt_node_all.insert(el);

        assert!(self.stmt_node_weights.len() == old_len);
        self.stmt_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_stmt_node(&mut self, mut lhs: StmtNode, mut rhs: StmtNode) {
        lhs = self.stmt_node_equalities.root(lhs);
        rhs = self.stmt_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.stmt_node_weights[lhs.0 as usize];
        let rhs_weight = self.stmt_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.stmt_node_equalities.union_roots_into(child, root);

        self.stmt_node_all.remove(&child);
        self.stmt_node_dirty.remove(&child);
        self.stmt_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [StmtListNode].
    #[allow(dead_code)]
    fn new_stmt_list_node_internal(&mut self) -> StmtListNode {
        let old_len = self.stmt_list_node_equalities.len();
        self.stmt_list_node_equalities.increase_size_to(old_len + 1);
        let el = StmtListNode::from(u32::try_from(old_len).unwrap());

        self.stmt_list_node_dirty.insert(el);
        self.stmt_list_node_all.insert(el);

        assert!(self.stmt_list_node_weights.len() == old_len);
        self.stmt_list_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_stmt_list_node(&mut self, mut lhs: StmtListNode, mut rhs: StmtListNode) {
        lhs = self.stmt_list_node_equalities.root(lhs);
        rhs = self.stmt_list_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.stmt_list_node_weights[lhs.0 as usize];
        let rhs_weight = self.stmt_list_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.stmt_list_node_equalities.union_roots_into(child, root);

        self.stmt_list_node_all.remove(&child);
        self.stmt_list_node_dirty.remove(&child);
        self.stmt_list_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [StmtBlockListNode].
    #[allow(dead_code)]
    fn new_stmt_block_list_node_internal(&mut self) -> StmtBlockListNode {
        let old_len = self.stmt_block_list_node_equalities.len();
        self.stmt_block_list_node_equalities
            .increase_size_to(old_len + 1);
        let el = StmtBlockListNode::from(u32::try_from(old_len).unwrap());

        self.stmt_block_list_node_dirty.insert(el);
        self.stmt_block_list_node_all.insert(el);

        assert!(self.stmt_block_list_node_weights.len() == old_len);
        self.stmt_block_list_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_stmt_block_list_node(
        &mut self,
        mut lhs: StmtBlockListNode,
        mut rhs: StmtBlockListNode,
    ) {
        lhs = self.stmt_block_list_node_equalities.root(lhs);
        rhs = self.stmt_block_list_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.stmt_block_list_node_weights[lhs.0 as usize];
        let rhs_weight = self.stmt_block_list_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.stmt_block_list_node_equalities
            .union_roots_into(child, root);

        self.stmt_block_list_node_all.remove(&child);
        self.stmt_block_list_node_dirty.remove(&child);
        self.stmt_block_list_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [RuleDeclNode].
    #[allow(dead_code)]
    fn new_rule_decl_node_internal(&mut self) -> RuleDeclNode {
        let old_len = self.rule_decl_node_equalities.len();
        self.rule_decl_node_equalities.increase_size_to(old_len + 1);
        let el = RuleDeclNode::from(u32::try_from(old_len).unwrap());

        self.rule_decl_node_dirty.insert(el);
        self.rule_decl_node_all.insert(el);

        assert!(self.rule_decl_node_weights.len() == old_len);
        self.rule_decl_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_rule_decl_node(&mut self, mut lhs: RuleDeclNode, mut rhs: RuleDeclNode) {
        lhs = self.rule_decl_node_equalities.root(lhs);
        rhs = self.rule_decl_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.rule_decl_node_weights[lhs.0 as usize];
        let rhs_weight = self.rule_decl_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.rule_decl_node_equalities.union_roots_into(child, root);

        self.rule_decl_node_all.remove(&child);
        self.rule_decl_node_dirty.remove(&child);
        self.rule_decl_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [DeclNode].
    #[allow(dead_code)]
    fn new_decl_node_internal(&mut self) -> DeclNode {
        let old_len = self.decl_node_equalities.len();
        self.decl_node_equalities.increase_size_to(old_len + 1);
        let el = DeclNode::from(u32::try_from(old_len).unwrap());

        self.decl_node_dirty.insert(el);
        self.decl_node_all.insert(el);

        assert!(self.decl_node_weights.len() == old_len);
        self.decl_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_decl_node(&mut self, mut lhs: DeclNode, mut rhs: DeclNode) {
        lhs = self.decl_node_equalities.root(lhs);
        rhs = self.decl_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.decl_node_weights[lhs.0 as usize];
        let rhs_weight = self.decl_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.decl_node_equalities.union_roots_into(child, root);

        self.decl_node_all.remove(&child);
        self.decl_node_dirty.remove(&child);
        self.decl_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [DeclListNode].
    #[allow(dead_code)]
    fn new_decl_list_node_internal(&mut self) -> DeclListNode {
        let old_len = self.decl_list_node_equalities.len();
        self.decl_list_node_equalities.increase_size_to(old_len + 1);
        let el = DeclListNode::from(u32::try_from(old_len).unwrap());

        self.decl_list_node_dirty.insert(el);
        self.decl_list_node_all.insert(el);

        assert!(self.decl_list_node_weights.len() == old_len);
        self.decl_list_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_decl_list_node(&mut self, mut lhs: DeclListNode, mut rhs: DeclListNode) {
        lhs = self.decl_list_node_equalities.root(lhs);
        rhs = self.decl_list_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.decl_list_node_weights[lhs.0 as usize];
        let rhs_weight = self.decl_list_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.decl_list_node_equalities.union_roots_into(child, root);

        self.decl_list_node_all.remove(&child);
        self.decl_list_node_dirty.remove(&child);
        self.decl_list_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [ModuleNode].
    #[allow(dead_code)]
    fn new_module_node_internal(&mut self) -> ModuleNode {
        let old_len = self.module_node_equalities.len();
        self.module_node_equalities.increase_size_to(old_len + 1);
        let el = ModuleNode::from(u32::try_from(old_len).unwrap());

        self.module_node_dirty.insert(el);
        self.module_node_all.insert(el);

        assert!(self.module_node_weights.len() == old_len);
        self.module_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_module_node(&mut self, mut lhs: ModuleNode, mut rhs: ModuleNode) {
        lhs = self.module_node_equalities.root(lhs);
        rhs = self.module_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.module_node_weights[lhs.0 as usize];
        let rhs_weight = self.module_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.module_node_equalities.union_roots_into(child, root);

        self.module_node_all.remove(&child);
        self.module_node_dirty.remove(&child);
        self.module_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [Loc].
    #[allow(dead_code)]
    fn new_loc_internal(&mut self) -> Loc {
        let old_len = self.loc_equalities.len();
        self.loc_equalities.increase_size_to(old_len + 1);
        let el = Loc::from(u32::try_from(old_len).unwrap());

        self.loc_dirty.insert(el);
        self.loc_all.insert(el);

        assert!(self.loc_weights.len() == old_len);
        self.loc_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_loc(&mut self, mut lhs: Loc, mut rhs: Loc) {
        lhs = self.loc_equalities.root(lhs);
        rhs = self.loc_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.loc_weights[lhs.0 as usize];
        let rhs_weight = self.loc_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.loc_equalities.union_roots_into(child, root);

        self.loc_all.remove(&child);
        self.loc_dirty.remove(&child);
        self.loc_uprooted.push(child);
    }
    /// Adjoins a new element of type [RuleDescendantNode].
    #[allow(dead_code)]
    fn new_rule_descendant_node_internal(&mut self) -> RuleDescendantNode {
        let old_len = self.rule_descendant_node_equalities.len();
        self.rule_descendant_node_equalities
            .increase_size_to(old_len + 1);
        let el = RuleDescendantNode::from(u32::try_from(old_len).unwrap());

        self.rule_descendant_node_dirty.insert(el);
        self.rule_descendant_node_all.insert(el);

        assert!(self.rule_descendant_node_weights.len() == old_len);
        self.rule_descendant_node_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_rule_descendant_node(
        &mut self,
        mut lhs: RuleDescendantNode,
        mut rhs: RuleDescendantNode,
    ) {
        lhs = self.rule_descendant_node_equalities.root(lhs);
        rhs = self.rule_descendant_node_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.rule_descendant_node_weights[lhs.0 as usize];
        let rhs_weight = self.rule_descendant_node_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.rule_descendant_node_equalities
            .union_roots_into(child, root);

        self.rule_descendant_node_all.remove(&child);
        self.rule_descendant_node_dirty.remove(&child);
        self.rule_descendant_node_uprooted.push(child);
    }
    /// Adjoins a new element of type [Scope].
    #[allow(dead_code)]
    fn new_scope_internal(&mut self) -> Scope {
        let old_len = self.scope_equalities.len();
        self.scope_equalities.increase_size_to(old_len + 1);
        let el = Scope::from(u32::try_from(old_len).unwrap());

        self.scope_dirty.insert(el);
        self.scope_all.insert(el);

        assert!(self.scope_weights.len() == old_len);
        self.scope_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_scope(&mut self, mut lhs: Scope, mut rhs: Scope) {
        lhs = self.scope_equalities.root(lhs);
        rhs = self.scope_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.scope_weights[lhs.0 as usize];
        let rhs_weight = self.scope_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.scope_equalities.union_roots_into(child, root);

        self.scope_all.remove(&child);
        self.scope_dirty.remove(&child);
        self.scope_uprooted.push(child);
    }
    /// Adjoins a new element of type [Type].
    #[allow(dead_code)]
    fn new_type_internal(&mut self) -> Type {
        let old_len = self.type_equalities.len();
        self.type_equalities.increase_size_to(old_len + 1);
        let el = Type::from(u32::try_from(old_len).unwrap());

        self.type_dirty.insert(el);
        self.type_all.insert(el);

        assert!(self.type_weights.len() == old_len);
        self.type_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_type(&mut self, mut lhs: Type, mut rhs: Type) {
        lhs = self.type_equalities.root(lhs);
        rhs = self.type_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.type_weights[lhs.0 as usize];
        let rhs_weight = self.type_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.type_equalities.union_roots_into(child, root);

        self.type_all.remove(&child);
        self.type_dirty.remove(&child);
        self.type_uprooted.push(child);
    }
    /// Adjoins a new element of type [Pred].
    #[allow(dead_code)]
    fn new_pred_internal(&mut self) -> Pred {
        let old_len = self.pred_equalities.len();
        self.pred_equalities.increase_size_to(old_len + 1);
        let el = Pred::from(u32::try_from(old_len).unwrap());

        self.pred_dirty.insert(el);
        self.pred_all.insert(el);

        assert!(self.pred_weights.len() == old_len);
        self.pred_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_pred(&mut self, mut lhs: Pred, mut rhs: Pred) {
        lhs = self.pred_equalities.root(lhs);
        rhs = self.pred_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.pred_weights[lhs.0 as usize];
        let rhs_weight = self.pred_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.pred_equalities.union_roots_into(child, root);

        self.pred_all.remove(&child);
        self.pred_dirty.remove(&child);
        self.pred_uprooted.push(child);
    }
    /// Adjoins a new element of type [Func].
    #[allow(dead_code)]
    fn new_func_internal(&mut self) -> Func {
        let old_len = self.func_equalities.len();
        self.func_equalities.increase_size_to(old_len + 1);
        let el = Func::from(u32::try_from(old_len).unwrap());

        self.func_dirty.insert(el);
        self.func_all.insert(el);

        assert!(self.func_weights.len() == old_len);
        self.func_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_func(&mut self, mut lhs: Func, mut rhs: Func) {
        lhs = self.func_equalities.root(lhs);
        rhs = self.func_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.func_weights[lhs.0 as usize];
        let rhs_weight = self.func_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.func_equalities.union_roots_into(child, root);

        self.func_all.remove(&child);
        self.func_dirty.remove(&child);
        self.func_uprooted.push(child);
    }
    /// Adjoins a new element of type [Structure].
    #[allow(dead_code)]
    fn new_structure_internal(&mut self) -> Structure {
        let old_len = self.structure_equalities.len();
        self.structure_equalities.increase_size_to(old_len + 1);
        let el = Structure::from(u32::try_from(old_len).unwrap());

        self.structure_dirty.insert(el);
        self.structure_all.insert(el);

        assert!(self.structure_weights.len() == old_len);
        self.structure_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_structure(&mut self, mut lhs: Structure, mut rhs: Structure) {
        lhs = self.structure_equalities.root(lhs);
        rhs = self.structure_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.structure_weights[lhs.0 as usize];
        let rhs_weight = self.structure_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.structure_equalities.union_roots_into(child, root);

        self.structure_all.remove(&child);
        self.structure_dirty.remove(&child);
        self.structure_uprooted.push(child);
    }
    /// Adjoins a new element of type [El].
    #[allow(dead_code)]
    fn new_el_internal(&mut self) -> El {
        let old_len = self.el_equalities.len();
        self.el_equalities.increase_size_to(old_len + 1);
        let el = El::from(u32::try_from(old_len).unwrap());

        self.el_dirty.insert(el);
        self.el_all.insert(el);

        assert!(self.el_weights.len() == old_len);
        self.el_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_el(&mut self, mut lhs: El, mut rhs: El) {
        lhs = self.el_equalities.root(lhs);
        rhs = self.el_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.el_weights[lhs.0 as usize];
        let rhs_weight = self.el_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.el_equalities.union_roots_into(child, root);

        self.el_all.remove(&child);
        self.el_dirty.remove(&child);
        self.el_uprooted.push(child);
    }
    /// Adjoins a new element of type [ElName].
    #[allow(dead_code)]
    fn new_el_name_internal(&mut self) -> ElName {
        let old_len = self.el_name_equalities.len();
        self.el_name_equalities.increase_size_to(old_len + 1);
        let el = ElName::from(u32::try_from(old_len).unwrap());

        self.el_name_dirty.insert(el);
        self.el_name_all.insert(el);

        assert!(self.el_name_weights.len() == old_len);
        self.el_name_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_el_name(&mut self, mut lhs: ElName, mut rhs: ElName) {
        lhs = self.el_name_equalities.root(lhs);
        rhs = self.el_name_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.el_name_weights[lhs.0 as usize];
        let rhs_weight = self.el_name_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.el_name_equalities.union_roots_into(child, root);

        self.el_name_all.remove(&child);
        self.el_name_dirty.remove(&child);
        self.el_name_uprooted.push(child);
    }
    /// Adjoins a new element of type [Morphism].
    #[allow(dead_code)]
    fn new_morphism_internal(&mut self) -> Morphism {
        let old_len = self.morphism_equalities.len();
        self.morphism_equalities.increase_size_to(old_len + 1);
        let el = Morphism::from(u32::try_from(old_len).unwrap());

        self.morphism_dirty.insert(el);
        self.morphism_all.insert(el);

        assert!(self.morphism_weights.len() == old_len);
        self.morphism_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_morphism(&mut self, mut lhs: Morphism, mut rhs: Morphism) {
        lhs = self.morphism_equalities.root(lhs);
        rhs = self.morphism_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.morphism_weights[lhs.0 as usize];
        let rhs_weight = self.morphism_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.morphism_equalities.union_roots_into(child, root);

        self.morphism_all.remove(&child);
        self.morphism_dirty.remove(&child);
        self.morphism_uprooted.push(child);
    }
    /// Adjoins a new element of type [SymbolKind].
    #[allow(dead_code)]
    fn new_symbol_kind_internal(&mut self) -> SymbolKind {
        let old_len = self.symbol_kind_equalities.len();
        self.symbol_kind_equalities.increase_size_to(old_len + 1);
        let el = SymbolKind::from(u32::try_from(old_len).unwrap());

        self.symbol_kind_dirty.insert(el);
        self.symbol_kind_all.insert(el);

        assert!(self.symbol_kind_weights.len() == old_len);
        self.symbol_kind_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_symbol_kind(&mut self, mut lhs: SymbolKind, mut rhs: SymbolKind) {
        lhs = self.symbol_kind_equalities.root(lhs);
        rhs = self.symbol_kind_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.symbol_kind_weights[lhs.0 as usize];
        let rhs_weight = self.symbol_kind_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.symbol_kind_equalities.union_roots_into(child, root);

        self.symbol_kind_all.remove(&child);
        self.symbol_kind_dirty.remove(&child);
        self.symbol_kind_uprooted.push(child);
    }
    /// Adjoins a new element of type [Nat].
    #[allow(dead_code)]
    fn new_nat_internal(&mut self) -> Nat {
        let old_len = self.nat_equalities.len();
        self.nat_equalities.increase_size_to(old_len + 1);
        let el = Nat::from(u32::try_from(old_len).unwrap());

        self.nat_dirty.insert(el);
        self.nat_all.insert(el);

        assert!(self.nat_weights.len() == old_len);
        self.nat_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_nat(&mut self, mut lhs: Nat, mut rhs: Nat) {
        lhs = self.nat_equalities.root(lhs);
        rhs = self.nat_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.nat_weights[lhs.0 as usize];
        let rhs_weight = self.nat_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.nat_equalities.union_roots_into(child, root);

        self.nat_all.remove(&child);
        self.nat_dirty.remove(&child);
        self.nat_uprooted.push(child);
    }
    /// Adjoins a new element of type [TypeList].
    #[allow(dead_code)]
    fn new_type_list_internal(&mut self) -> TypeList {
        let old_len = self.type_list_equalities.len();
        self.type_list_equalities.increase_size_to(old_len + 1);
        let el = TypeList::from(u32::try_from(old_len).unwrap());

        self.type_list_dirty.insert(el);
        self.type_list_all.insert(el);

        assert!(self.type_list_weights.len() == old_len);
        self.type_list_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_type_list(&mut self, mut lhs: TypeList, mut rhs: TypeList) {
        lhs = self.type_list_equalities.root(lhs);
        rhs = self.type_list_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.type_list_weights[lhs.0 as usize];
        let rhs_weight = self.type_list_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.type_list_equalities.union_roots_into(child, root);

        self.type_list_all.remove(&child);
        self.type_list_dirty.remove(&child);
        self.type_list_uprooted.push(child);
    }
    /// Adjoins a new element of type [Rel].
    #[allow(dead_code)]
    fn new_rel_internal(&mut self) -> Rel {
        let old_len = self.rel_equalities.len();
        self.rel_equalities.increase_size_to(old_len + 1);
        let el = Rel::from(u32::try_from(old_len).unwrap());

        self.rel_dirty.insert(el);
        self.rel_all.insert(el);

        assert!(self.rel_weights.len() == old_len);
        self.rel_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_rel(&mut self, mut lhs: Rel, mut rhs: Rel) {
        lhs = self.rel_equalities.root(lhs);
        rhs = self.rel_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.rel_weights[lhs.0 as usize];
        let rhs_weight = self.rel_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.rel_equalities.union_roots_into(child, root);

        self.rel_all.remove(&child);
        self.rel_dirty.remove(&child);
        self.rel_uprooted.push(child);
    }
    /// Adjoins a new element of type [ElList].
    #[allow(dead_code)]
    fn new_el_list_internal(&mut self) -> ElList {
        let old_len = self.el_list_equalities.len();
        self.el_list_equalities.increase_size_to(old_len + 1);
        let el = ElList::from(u32::try_from(old_len).unwrap());

        self.el_list_dirty.insert(el);
        self.el_list_all.insert(el);

        assert!(self.el_list_weights.len() == old_len);
        self.el_list_weights.push(0);

        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_el_list(&mut self, mut lhs: ElList, mut rhs: ElList) {
        lhs = self.el_list_equalities.root(lhs);
        rhs = self.el_list_equalities.root(rhs);
        if lhs == rhs {
            return;
        }

        let lhs_weight = self.el_list_weights[lhs.0 as usize];
        let rhs_weight = self.el_list_weights[rhs.0 as usize];
        let (root, child) = if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

        self.el_list_equalities.union_roots_into(child, root);

        self.el_list_all.remove(&child);
        self.el_list_dirty.remove(&child);
        self.el_list_uprooted.push(child);
    }
    /// Adjoins a new element of type [Ident].
    #[allow(dead_code)]
    pub fn new_ident(&mut self) -> Ident {
        self.new_ident_internal()
    }
    /// Adjoins a new element of type [VirtIdent].
    #[allow(dead_code)]
    pub fn new_virt_ident(&mut self) -> VirtIdent {
        self.new_virt_ident_internal()
    }
    /// Adjoins a new element of type [TypeDeclNode].
    #[allow(dead_code)]
    pub fn new_type_decl_node(&mut self) -> TypeDeclNode {
        self.new_type_decl_node_internal()
    }
    /// Adjoins a new element of type [ArgDeclNode].
    #[allow(dead_code)]
    pub fn new_arg_decl_node(&mut self) -> ArgDeclNode {
        self.new_arg_decl_node_internal()
    }
    /// Adjoins a new element of type [ArgDeclListNode].
    #[allow(dead_code)]
    pub fn new_arg_decl_list_node(&mut self) -> ArgDeclListNode {
        self.new_arg_decl_list_node_internal()
    }
    /// Adjoins a new element of type [PredDeclNode].
    #[allow(dead_code)]
    pub fn new_pred_decl_node(&mut self) -> PredDeclNode {
        self.new_pred_decl_node_internal()
    }
    /// Adjoins a new element of type [FuncDeclNode].
    #[allow(dead_code)]
    pub fn new_func_decl_node(&mut self) -> FuncDeclNode {
        self.new_func_decl_node_internal()
    }
    /// Adjoins a new element of type [CtorDeclNode].
    #[allow(dead_code)]
    pub fn new_ctor_decl_node(&mut self) -> CtorDeclNode {
        self.new_ctor_decl_node_internal()
    }
    /// Adjoins a new element of type [CtorDeclListNode].
    #[allow(dead_code)]
    pub fn new_ctor_decl_list_node(&mut self) -> CtorDeclListNode {
        self.new_ctor_decl_list_node_internal()
    }
    /// Adjoins a new element of type [EnumDeclNode].
    #[allow(dead_code)]
    pub fn new_enum_decl_node(&mut self) -> EnumDeclNode {
        self.new_enum_decl_node_internal()
    }
    /// Adjoins a new element of type [TermNode].
    #[allow(dead_code)]
    pub fn new_term_node(&mut self) -> TermNode {
        self.new_term_node_internal()
    }
    /// Adjoins a new element of type [TermListNode].
    #[allow(dead_code)]
    pub fn new_term_list_node(&mut self) -> TermListNode {
        self.new_term_list_node_internal()
    }
    /// Adjoins a new element of type [OptTermNode].
    #[allow(dead_code)]
    pub fn new_opt_term_node(&mut self) -> OptTermNode {
        self.new_opt_term_node_internal()
    }
    /// Adjoins a new element of type [MatchCaseNode].
    #[allow(dead_code)]
    pub fn new_match_case_node(&mut self) -> MatchCaseNode {
        self.new_match_case_node_internal()
    }
    /// Adjoins a new element of type [MatchCaseListNode].
    #[allow(dead_code)]
    pub fn new_match_case_list_node(&mut self) -> MatchCaseListNode {
        self.new_match_case_list_node_internal()
    }
    /// Adjoins a new element of type [IfAtomNode].
    #[allow(dead_code)]
    pub fn new_if_atom_node(&mut self) -> IfAtomNode {
        self.new_if_atom_node_internal()
    }
    /// Adjoins a new element of type [ThenAtomNode].
    #[allow(dead_code)]
    pub fn new_then_atom_node(&mut self) -> ThenAtomNode {
        self.new_then_atom_node_internal()
    }
    /// Adjoins a new element of type [StmtNode].
    #[allow(dead_code)]
    pub fn new_stmt_node(&mut self) -> StmtNode {
        self.new_stmt_node_internal()
    }
    /// Adjoins a new element of type [StmtListNode].
    #[allow(dead_code)]
    pub fn new_stmt_list_node(&mut self) -> StmtListNode {
        self.new_stmt_list_node_internal()
    }
    /// Adjoins a new element of type [StmtBlockListNode].
    #[allow(dead_code)]
    pub fn new_stmt_block_list_node(&mut self) -> StmtBlockListNode {
        self.new_stmt_block_list_node_internal()
    }
    /// Adjoins a new element of type [RuleDeclNode].
    #[allow(dead_code)]
    pub fn new_rule_decl_node(&mut self) -> RuleDeclNode {
        self.new_rule_decl_node_internal()
    }
    /// Adjoins a new element of type [DeclNode].
    #[allow(dead_code)]
    pub fn new_decl_node(&mut self) -> DeclNode {
        self.new_decl_node_internal()
    }
    /// Adjoins a new element of type [DeclListNode].
    #[allow(dead_code)]
    pub fn new_decl_list_node(&mut self) -> DeclListNode {
        self.new_decl_list_node_internal()
    }
    /// Adjoins a new element of type [ModuleNode].
    #[allow(dead_code)]
    pub fn new_module_node(&mut self) -> ModuleNode {
        self.new_module_node_internal()
    }
    /// Adjoins a new element of type [Loc].
    #[allow(dead_code)]
    pub fn new_loc(&mut self) -> Loc {
        self.new_loc_internal()
    }
    /// Adjoins a new element of type [RuleDescendantNode].
    #[allow(dead_code)]
    pub fn new_rule_descendant_node(&mut self) -> RuleDescendantNode {
        self.new_rule_descendant_node_internal()
    }
    /// Adjoins a new element of type [Scope].
    #[allow(dead_code)]
    pub fn new_scope(&mut self) -> Scope {
        self.new_scope_internal()
    }
    /// Adjoins a new element of type [Type].
    #[allow(dead_code)]
    pub fn new_type(&mut self) -> Type {
        self.new_type_internal()
    }
    /// Adjoins a new element of type [Pred].
    #[allow(dead_code)]
    pub fn new_pred(&mut self) -> Pred {
        self.new_pred_internal()
    }
    /// Adjoins a new element of type [Func].
    #[allow(dead_code)]
    pub fn new_func(&mut self) -> Func {
        self.new_func_internal()
    }
    /// Adjoins a new element of type [Structure].
    #[allow(dead_code)]
    pub fn new_structure(&mut self) -> Structure {
        self.new_structure_internal()
    }
    /// Adjoins a new element of type [El].
    #[allow(dead_code)]
    pub fn new_el(&mut self) -> El {
        self.new_el_internal()
    }
    /// Adjoins a new element of type [ElName].
    #[allow(dead_code)]
    pub fn new_el_name(&mut self) -> ElName {
        self.new_el_name_internal()
    }
    /// Adjoins a new element of type [Morphism].
    #[allow(dead_code)]
    pub fn new_morphism(&mut self) -> Morphism {
        self.new_morphism_internal()
    }
    /// Adjoins a new element of type [SymbolKind].
    #[allow(dead_code)]
    pub fn new_symbol_kind(&mut self) -> SymbolKind {
        self.new_symbol_kind_internal()
    }
    /// Adjoins a new element of type [Nat].
    #[allow(dead_code)]
    pub fn new_nat(&mut self) -> Nat {
        self.new_nat_internal()
    }
    /// Adjoins a new element of type [TypeList].
    #[allow(dead_code)]
    pub fn new_type_list(&mut self, value: TypeListEnum) -> TypeList {
        match value {
            TypeListEnum::NilTypeList() => self.define_nil_type_list(),
            TypeListEnum::ConsTypeList(tm0, tm1) => self.define_cons_type_list(tm0, tm1),
            TypeListEnum::SnocTypeList(tm0, tm1) => self.define_snoc_type_list(tm0, tm1),
        }
    }
    /// Adjoins a new element of type [Rel].
    #[allow(dead_code)]
    pub fn new_rel(&mut self, value: RelEnum) -> Rel {
        match value {
            RelEnum::PredRel(tm0) => self.define_pred_rel(tm0),
            RelEnum::FuncRel(tm0) => self.define_func_rel(tm0),
        }
    }
    /// Adjoins a new element of type [ElList].
    #[allow(dead_code)]
    pub fn new_el_list(&mut self, value: ElListEnum) -> ElList {
        match value {
            ElListEnum::NilElList(tm0) => self.define_nil_el_list(tm0),
            ElListEnum::ConsElList(tm0, tm1) => self.define_cons_el_list(tm0, tm1),
            ElListEnum::SnocElList(tm0, tm1) => self.define_snoc_el_list(tm0, tm1),
        }
    }
    /// Evaluates `real_virt_ident(arg0)`.
    #[allow(dead_code)]
    pub fn real_virt_ident(&self, mut arg0: Ident) -> Option<VirtIdent> {
        arg0 = self.root_ident(arg0);
        self.real_virt_ident.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `real_virt_ident` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_real_virt_ident(&self) -> impl '_ + Iterator<Item = (Ident, VirtIdent)> {
        self.real_virt_ident.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `real_virt_ident(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_real_virt_ident(&mut self, mut tm0: Ident, mut tm1: VirtIdent) {
        tm0 = self.ident_equalities.root(tm0);
        tm1 = self.virt_ident_equalities.root(tm1);
        if self.real_virt_ident.insert(RealVirtIdent(tm0, tm1)) {
            let weight0 = &mut self.ident_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(RealVirtIdentTable::WEIGHT);

            let weight1 = &mut self.virt_ident_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(RealVirtIdentTable::WEIGHT);
        }
    }

    /// Evaluates `virt_real_ident(arg0)`.
    #[allow(dead_code)]
    pub fn virt_real_ident(&self, mut arg0: VirtIdent) -> Option<Ident> {
        arg0 = self.root_virt_ident(arg0);
        self.virt_real_ident.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `virt_real_ident` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_virt_real_ident(&self) -> impl '_ + Iterator<Item = (VirtIdent, Ident)> {
        self.virt_real_ident.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `virt_real_ident(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_virt_real_ident(&mut self, mut tm0: VirtIdent, mut tm1: Ident) {
        tm0 = self.virt_ident_equalities.root(tm0);
        tm1 = self.ident_equalities.root(tm1);
        if self.virt_real_ident.insert(VirtRealIdent(tm0, tm1)) {
            let weight0 = &mut self.virt_ident_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(VirtRealIdentTable::WEIGHT);

            let weight1 = &mut self.ident_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(VirtRealIdentTable::WEIGHT);
        }
    }

    /// Evaluates `var(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn var(&self, mut arg0: Structure, mut arg1: ElName) -> Option<El> {
        arg0 = self.root_structure(arg0);
        arg1 = self.root_el_name(arg1);
        self.var.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
    }
    /// Returns an iterator over tuples in the graph of the `var` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_var(&self) -> impl '_ + Iterator<Item = (Structure, ElName, El)> {
        self.var.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `var(tm0, tm1) = tm2` hold.

    #[allow(dead_code)]
    pub fn insert_var(&mut self, mut tm0: Structure, mut tm1: ElName, mut tm2: El) {
        tm0 = self.structure_equalities.root(tm0);
        tm1 = self.el_name_equalities.root(tm1);
        tm2 = self.el_equalities.root(tm2);
        if self.var.insert(Var(tm0, tm1, tm2)) {
            let weight0 = &mut self.structure_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(VarTable::WEIGHT);

            let weight1 = &mut self.el_name_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(VarTable::WEIGHT);

            let weight2 = &mut self.el_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(VarTable::WEIGHT);
        }
    }

    /// Evaluates `rule_name(arg0)`.
    #[allow(dead_code)]
    pub fn rule_name(&self, mut arg0: RuleDeclNode) -> Option<Ident> {
        arg0 = self.root_rule_decl_node(arg0);
        self.rule_name.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `rule_name` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_name(&self) -> impl '_ + Iterator<Item = (RuleDeclNode, Ident)> {
        self.rule_name.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_name(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_rule_name(&mut self, mut tm0: RuleDeclNode, mut tm1: Ident) {
        tm0 = self.rule_decl_node_equalities.root(tm0);
        tm1 = self.ident_equalities.root(tm1);
        if self.rule_name.insert(RuleName(tm0, tm1)) {
            let weight0 = &mut self.rule_decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(RuleNameTable::WEIGHT);

            let weight1 = &mut self.ident_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(RuleNameTable::WEIGHT);
        }
    }

    /// Evaluates `type_decl_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn type_decl_node_loc(&self, mut arg0: TypeDeclNode) -> Option<Loc> {
        arg0 = self.root_type_decl_node(arg0);
        self.type_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `type_decl_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_type_decl_node_loc(&self) -> impl '_ + Iterator<Item = (TypeDeclNode, Loc)> {
        self.type_decl_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `type_decl_node_loc(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_type_decl_node_loc(&mut self, mut tm0: TypeDeclNode, mut tm1: Loc) {
        tm0 = self.type_decl_node_equalities.root(tm0);
        tm1 = self.loc_equalities.root(tm1);
        if self.type_decl_node_loc.insert(TypeDeclNodeLoc(tm0, tm1)) {
            let weight0 = &mut self.type_decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(TypeDeclNodeLocTable::WEIGHT);

            let weight1 = &mut self.loc_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(TypeDeclNodeLocTable::WEIGHT);
        }
    }

    /// Evaluates `arg_decl_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn arg_decl_node_loc(&self, mut arg0: ArgDeclNode) -> Option<Loc> {
        arg0 = self.root_arg_decl_node(arg0);
        self.arg_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `arg_decl_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_arg_decl_node_loc(&self) -> impl '_ + Iterator<Item = (ArgDeclNode, Loc)> {
        self.arg_decl_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `arg_decl_node_loc(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_arg_decl_node_loc(&mut self, mut tm0: ArgDeclNode, mut tm1: Loc) {
        tm0 = self.arg_decl_node_equalities.root(tm0);
        tm1 = self.loc_equalities.root(tm1);
        if self.arg_decl_node_loc.insert(ArgDeclNodeLoc(tm0, tm1)) {
            let weight0 = &mut self.arg_decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ArgDeclNodeLocTable::WEIGHT);

            let weight1 = &mut self.loc_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ArgDeclNodeLocTable::WEIGHT);
        }
    }

    /// Evaluates `arg_decl_list_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn arg_decl_list_node_loc(&self, mut arg0: ArgDeclListNode) -> Option<Loc> {
        arg0 = self.root_arg_decl_list_node(arg0);
        self.arg_decl_list_node_loc
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `arg_decl_list_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_arg_decl_list_node_loc(&self) -> impl '_ + Iterator<Item = (ArgDeclListNode, Loc)> {
        self.arg_decl_list_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `arg_decl_list_node_loc(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_arg_decl_list_node_loc(&mut self, mut tm0: ArgDeclListNode, mut tm1: Loc) {
        tm0 = self.arg_decl_list_node_equalities.root(tm0);
        tm1 = self.loc_equalities.root(tm1);
        if self
            .arg_decl_list_node_loc
            .insert(ArgDeclListNodeLoc(tm0, tm1))
        {
            let weight0 = &mut self.arg_decl_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ArgDeclListNodeLocTable::WEIGHT);

            let weight1 = &mut self.loc_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ArgDeclListNodeLocTable::WEIGHT);
        }
    }

    /// Evaluates `pred_decl_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn pred_decl_node_loc(&self, mut arg0: PredDeclNode) -> Option<Loc> {
        arg0 = self.root_pred_decl_node(arg0);
        self.pred_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `pred_decl_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_pred_decl_node_loc(&self) -> impl '_ + Iterator<Item = (PredDeclNode, Loc)> {
        self.pred_decl_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `pred_decl_node_loc(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_pred_decl_node_loc(&mut self, mut tm0: PredDeclNode, mut tm1: Loc) {
        tm0 = self.pred_decl_node_equalities.root(tm0);
        tm1 = self.loc_equalities.root(tm1);
        if self.pred_decl_node_loc.insert(PredDeclNodeLoc(tm0, tm1)) {
            let weight0 = &mut self.pred_decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(PredDeclNodeLocTable::WEIGHT);

            let weight1 = &mut self.loc_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(PredDeclNodeLocTable::WEIGHT);
        }
    }

    /// Evaluates `func_decl_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn func_decl_node_loc(&self, mut arg0: FuncDeclNode) -> Option<Loc> {
        arg0 = self.root_func_decl_node(arg0);
        self.func_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `func_decl_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_func_decl_node_loc(&self) -> impl '_ + Iterator<Item = (FuncDeclNode, Loc)> {
        self.func_decl_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `func_decl_node_loc(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_func_decl_node_loc(&mut self, mut tm0: FuncDeclNode, mut tm1: Loc) {
        tm0 = self.func_decl_node_equalities.root(tm0);
        tm1 = self.loc_equalities.root(tm1);
        if self.func_decl_node_loc.insert(FuncDeclNodeLoc(tm0, tm1)) {
            let weight0 = &mut self.func_decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(FuncDeclNodeLocTable::WEIGHT);

            let weight1 = &mut self.loc_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(FuncDeclNodeLocTable::WEIGHT);
        }
    }

    /// Evaluates `ctor_decl_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn ctor_decl_node_loc(&self, mut arg0: CtorDeclNode) -> Option<Loc> {
        arg0 = self.root_ctor_decl_node(arg0);
        self.ctor_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `ctor_decl_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_ctor_decl_node_loc(&self) -> impl '_ + Iterator<Item = (CtorDeclNode, Loc)> {
        self.ctor_decl_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `ctor_decl_node_loc(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_ctor_decl_node_loc(&mut self, mut tm0: CtorDeclNode, mut tm1: Loc) {
        tm0 = self.ctor_decl_node_equalities.root(tm0);
        tm1 = self.loc_equalities.root(tm1);
        if self.ctor_decl_node_loc.insert(CtorDeclNodeLoc(tm0, tm1)) {
            let weight0 = &mut self.ctor_decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(CtorDeclNodeLocTable::WEIGHT);

            let weight1 = &mut self.loc_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(CtorDeclNodeLocTable::WEIGHT);
        }
    }

    /// Evaluates `enum_decl_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn enum_decl_node_loc(&self, mut arg0: EnumDeclNode) -> Option<Loc> {
        arg0 = self.root_enum_decl_node(arg0);
        self.enum_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `enum_decl_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_enum_decl_node_loc(&self) -> impl '_ + Iterator<Item = (EnumDeclNode, Loc)> {
        self.enum_decl_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `enum_decl_node_loc(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_enum_decl_node_loc(&mut self, mut tm0: EnumDeclNode, mut tm1: Loc) {
        tm0 = self.enum_decl_node_equalities.root(tm0);
        tm1 = self.loc_equalities.root(tm1);
        if self.enum_decl_node_loc.insert(EnumDeclNodeLoc(tm0, tm1)) {
            let weight0 = &mut self.enum_decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(EnumDeclNodeLocTable::WEIGHT);

            let weight1 = &mut self.loc_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(EnumDeclNodeLocTable::WEIGHT);
        }
    }

    /// Evaluates `term_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn term_node_loc(&self, mut arg0: TermNode) -> Option<Loc> {
        arg0 = self.root_term_node(arg0);
        self.term_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `term_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_term_node_loc(&self) -> impl '_ + Iterator<Item = (TermNode, Loc)> {
        self.term_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `term_node_loc(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_term_node_loc(&mut self, mut tm0: TermNode, mut tm1: Loc) {
        tm0 = self.term_node_equalities.root(tm0);
        tm1 = self.loc_equalities.root(tm1);
        if self.term_node_loc.insert(TermNodeLoc(tm0, tm1)) {
            let weight0 = &mut self.term_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(TermNodeLocTable::WEIGHT);

            let weight1 = &mut self.loc_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(TermNodeLocTable::WEIGHT);
        }
    }

    /// Evaluates `term_list_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn term_list_node_loc(&self, mut arg0: TermListNode) -> Option<Loc> {
        arg0 = self.root_term_list_node(arg0);
        self.term_list_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `term_list_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_term_list_node_loc(&self) -> impl '_ + Iterator<Item = (TermListNode, Loc)> {
        self.term_list_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `term_list_node_loc(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_term_list_node_loc(&mut self, mut tm0: TermListNode, mut tm1: Loc) {
        tm0 = self.term_list_node_equalities.root(tm0);
        tm1 = self.loc_equalities.root(tm1);
        if self.term_list_node_loc.insert(TermListNodeLoc(tm0, tm1)) {
            let weight0 = &mut self.term_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(TermListNodeLocTable::WEIGHT);

            let weight1 = &mut self.loc_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(TermListNodeLocTable::WEIGHT);
        }
    }

    /// Evaluates `match_case_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn match_case_node_loc(&self, mut arg0: MatchCaseNode) -> Option<Loc> {
        arg0 = self.root_match_case_node(arg0);
        self.match_case_node_loc
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `match_case_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_match_case_node_loc(&self) -> impl '_ + Iterator<Item = (MatchCaseNode, Loc)> {
        self.match_case_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `match_case_node_loc(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_match_case_node_loc(&mut self, mut tm0: MatchCaseNode, mut tm1: Loc) {
        tm0 = self.match_case_node_equalities.root(tm0);
        tm1 = self.loc_equalities.root(tm1);
        if self.match_case_node_loc.insert(MatchCaseNodeLoc(tm0, tm1)) {
            let weight0 = &mut self.match_case_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(MatchCaseNodeLocTable::WEIGHT);

            let weight1 = &mut self.loc_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(MatchCaseNodeLocTable::WEIGHT);
        }
    }

    /// Evaluates `opt_term_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn opt_term_node_loc(&self, mut arg0: OptTermNode) -> Option<Loc> {
        arg0 = self.root_opt_term_node(arg0);
        self.opt_term_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `opt_term_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_opt_term_node_loc(&self) -> impl '_ + Iterator<Item = (OptTermNode, Loc)> {
        self.opt_term_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `opt_term_node_loc(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_opt_term_node_loc(&mut self, mut tm0: OptTermNode, mut tm1: Loc) {
        tm0 = self.opt_term_node_equalities.root(tm0);
        tm1 = self.loc_equalities.root(tm1);
        if self.opt_term_node_loc.insert(OptTermNodeLoc(tm0, tm1)) {
            let weight0 = &mut self.opt_term_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(OptTermNodeLocTable::WEIGHT);

            let weight1 = &mut self.loc_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(OptTermNodeLocTable::WEIGHT);
        }
    }

    /// Evaluates `if_atom_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn if_atom_node_loc(&self, mut arg0: IfAtomNode) -> Option<Loc> {
        arg0 = self.root_if_atom_node(arg0);
        self.if_atom_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `if_atom_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_if_atom_node_loc(&self) -> impl '_ + Iterator<Item = (IfAtomNode, Loc)> {
        self.if_atom_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `if_atom_node_loc(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_if_atom_node_loc(&mut self, mut tm0: IfAtomNode, mut tm1: Loc) {
        tm0 = self.if_atom_node_equalities.root(tm0);
        tm1 = self.loc_equalities.root(tm1);
        if self.if_atom_node_loc.insert(IfAtomNodeLoc(tm0, tm1)) {
            let weight0 = &mut self.if_atom_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(IfAtomNodeLocTable::WEIGHT);

            let weight1 = &mut self.loc_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(IfAtomNodeLocTable::WEIGHT);
        }
    }

    /// Evaluates `then_atom_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn then_atom_node_loc(&self, mut arg0: ThenAtomNode) -> Option<Loc> {
        arg0 = self.root_then_atom_node(arg0);
        self.then_atom_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `then_atom_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_then_atom_node_loc(&self) -> impl '_ + Iterator<Item = (ThenAtomNode, Loc)> {
        self.then_atom_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `then_atom_node_loc(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_then_atom_node_loc(&mut self, mut tm0: ThenAtomNode, mut tm1: Loc) {
        tm0 = self.then_atom_node_equalities.root(tm0);
        tm1 = self.loc_equalities.root(tm1);
        if self.then_atom_node_loc.insert(ThenAtomNodeLoc(tm0, tm1)) {
            let weight0 = &mut self.then_atom_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ThenAtomNodeLocTable::WEIGHT);

            let weight1 = &mut self.loc_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ThenAtomNodeLocTable::WEIGHT);
        }
    }

    /// Evaluates `stmt_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn stmt_node_loc(&self, mut arg0: StmtNode) -> Option<Loc> {
        arg0 = self.root_stmt_node(arg0);
        self.stmt_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `stmt_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_stmt_node_loc(&self) -> impl '_ + Iterator<Item = (StmtNode, Loc)> {
        self.stmt_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `stmt_node_loc(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_stmt_node_loc(&mut self, mut tm0: StmtNode, mut tm1: Loc) {
        tm0 = self.stmt_node_equalities.root(tm0);
        tm1 = self.loc_equalities.root(tm1);
        if self.stmt_node_loc.insert(StmtNodeLoc(tm0, tm1)) {
            let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(StmtNodeLocTable::WEIGHT);

            let weight1 = &mut self.loc_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(StmtNodeLocTable::WEIGHT);
        }
    }

    /// Evaluates `stmt_list_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn stmt_list_node_loc(&self, mut arg0: StmtListNode) -> Option<Loc> {
        arg0 = self.root_stmt_list_node(arg0);
        self.stmt_list_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `stmt_list_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_stmt_list_node_loc(&self) -> impl '_ + Iterator<Item = (StmtListNode, Loc)> {
        self.stmt_list_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `stmt_list_node_loc(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_stmt_list_node_loc(&mut self, mut tm0: StmtListNode, mut tm1: Loc) {
        tm0 = self.stmt_list_node_equalities.root(tm0);
        tm1 = self.loc_equalities.root(tm1);
        if self.stmt_list_node_loc.insert(StmtListNodeLoc(tm0, tm1)) {
            let weight0 = &mut self.stmt_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(StmtListNodeLocTable::WEIGHT);

            let weight1 = &mut self.loc_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(StmtListNodeLocTable::WEIGHT);
        }
    }

    /// Evaluates `rule_decl_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn rule_decl_node_loc(&self, mut arg0: RuleDeclNode) -> Option<Loc> {
        arg0 = self.root_rule_decl_node(arg0);
        self.rule_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `rule_decl_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_decl_node_loc(&self) -> impl '_ + Iterator<Item = (RuleDeclNode, Loc)> {
        self.rule_decl_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_decl_node_loc(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_rule_decl_node_loc(&mut self, mut tm0: RuleDeclNode, mut tm1: Loc) {
        tm0 = self.rule_decl_node_equalities.root(tm0);
        tm1 = self.loc_equalities.root(tm1);
        if self.rule_decl_node_loc.insert(RuleDeclNodeLoc(tm0, tm1)) {
            let weight0 = &mut self.rule_decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(RuleDeclNodeLocTable::WEIGHT);

            let weight1 = &mut self.loc_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(RuleDeclNodeLocTable::WEIGHT);
        }
    }

    /// Evaluates `decl_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn decl_node_loc(&self, mut arg0: DeclNode) -> Option<Loc> {
        arg0 = self.root_decl_node(arg0);
        self.decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `decl_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_decl_node_loc(&self) -> impl '_ + Iterator<Item = (DeclNode, Loc)> {
        self.decl_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `decl_node_loc(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_decl_node_loc(&mut self, mut tm0: DeclNode, mut tm1: Loc) {
        tm0 = self.decl_node_equalities.root(tm0);
        tm1 = self.loc_equalities.root(tm1);
        if self.decl_node_loc.insert(DeclNodeLoc(tm0, tm1)) {
            let weight0 = &mut self.decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(DeclNodeLocTable::WEIGHT);

            let weight1 = &mut self.loc_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(DeclNodeLocTable::WEIGHT);
        }
    }

    /// Evaluates `decl_list_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn decl_list_node_loc(&self, mut arg0: DeclListNode) -> Option<Loc> {
        arg0 = self.root_decl_list_node(arg0);
        self.decl_list_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `decl_list_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_decl_list_node_loc(&self) -> impl '_ + Iterator<Item = (DeclListNode, Loc)> {
        self.decl_list_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `decl_list_node_loc(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_decl_list_node_loc(&mut self, mut tm0: DeclListNode, mut tm1: Loc) {
        tm0 = self.decl_list_node_equalities.root(tm0);
        tm1 = self.loc_equalities.root(tm1);
        if self.decl_list_node_loc.insert(DeclListNodeLoc(tm0, tm1)) {
            let weight0 = &mut self.decl_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(DeclListNodeLocTable::WEIGHT);

            let weight1 = &mut self.loc_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(DeclListNodeLocTable::WEIGHT);
        }
    }

    /// Evaluates `module_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn module_node_loc(&self, mut arg0: ModuleNode) -> Option<Loc> {
        arg0 = self.root_module_node(arg0);
        self.module_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `module_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_module_node_loc(&self) -> impl '_ + Iterator<Item = (ModuleNode, Loc)> {
        self.module_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `module_node_loc(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_module_node_loc(&mut self, mut tm0: ModuleNode, mut tm1: Loc) {
        tm0 = self.module_node_equalities.root(tm0);
        tm1 = self.loc_equalities.root(tm1);
        if self.module_node_loc.insert(ModuleNodeLoc(tm0, tm1)) {
            let weight0 = &mut self.module_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ModuleNodeLocTable::WEIGHT);

            let weight1 = &mut self.loc_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ModuleNodeLocTable::WEIGHT);
        }
    }

    /// Evaluates `rule_descendant_rule(arg0)`.
    #[allow(dead_code)]
    pub fn rule_descendant_rule(&self, mut arg0: RuleDeclNode) -> Option<RuleDescendantNode> {
        arg0 = self.root_rule_decl_node(arg0);
        self.rule_descendant_rule
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `rule_descendant_rule` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_descendant_rule(
        &self,
    ) -> impl '_ + Iterator<Item = (RuleDeclNode, RuleDescendantNode)> {
        self.rule_descendant_rule.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_descendant_rule(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_rule_descendant_rule(
        &mut self,
        mut tm0: RuleDeclNode,
        mut tm1: RuleDescendantNode,
    ) {
        tm0 = self.rule_decl_node_equalities.root(tm0);
        tm1 = self.rule_descendant_node_equalities.root(tm1);
        if self
            .rule_descendant_rule
            .insert(RuleDescendantRule(tm0, tm1))
        {
            let weight0 = &mut self.rule_decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(RuleDescendantRuleTable::WEIGHT);

            let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(RuleDescendantRuleTable::WEIGHT);
        }
    }

    /// Evaluates `rule_descendant_term(arg0)`.
    #[allow(dead_code)]
    pub fn rule_descendant_term(&self, mut arg0: TermNode) -> Option<RuleDescendantNode> {
        arg0 = self.root_term_node(arg0);
        self.rule_descendant_term
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `rule_descendant_term` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_descendant_term(
        &self,
    ) -> impl '_ + Iterator<Item = (TermNode, RuleDescendantNode)> {
        self.rule_descendant_term.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_descendant_term(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_rule_descendant_term(&mut self, mut tm0: TermNode, mut tm1: RuleDescendantNode) {
        tm0 = self.term_node_equalities.root(tm0);
        tm1 = self.rule_descendant_node_equalities.root(tm1);
        if self
            .rule_descendant_term
            .insert(RuleDescendantTerm(tm0, tm1))
        {
            let weight0 = &mut self.term_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(RuleDescendantTermTable::WEIGHT);

            let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(RuleDescendantTermTable::WEIGHT);
        }
    }

    /// Evaluates `rule_descendant_term_list(arg0)`.
    #[allow(dead_code)]
    pub fn rule_descendant_term_list(&self, mut arg0: TermListNode) -> Option<RuleDescendantNode> {
        arg0 = self.root_term_list_node(arg0);
        self.rule_descendant_term_list
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `rule_descendant_term_list` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_descendant_term_list(
        &self,
    ) -> impl '_ + Iterator<Item = (TermListNode, RuleDescendantNode)> {
        self.rule_descendant_term_list
            .iter_all()
            .map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_descendant_term_list(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_rule_descendant_term_list(
        &mut self,
        mut tm0: TermListNode,
        mut tm1: RuleDescendantNode,
    ) {
        tm0 = self.term_list_node_equalities.root(tm0);
        tm1 = self.rule_descendant_node_equalities.root(tm1);
        if self
            .rule_descendant_term_list
            .insert(RuleDescendantTermList(tm0, tm1))
        {
            let weight0 = &mut self.term_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(RuleDescendantTermListTable::WEIGHT);

            let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(RuleDescendantTermListTable::WEIGHT);
        }
    }

    /// Evaluates `rule_descendant_opt_term(arg0)`.
    #[allow(dead_code)]
    pub fn rule_descendant_opt_term(&self, mut arg0: OptTermNode) -> Option<RuleDescendantNode> {
        arg0 = self.root_opt_term_node(arg0);
        self.rule_descendant_opt_term
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `rule_descendant_opt_term` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_descendant_opt_term(
        &self,
    ) -> impl '_ + Iterator<Item = (OptTermNode, RuleDescendantNode)> {
        self.rule_descendant_opt_term.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_descendant_opt_term(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_rule_descendant_opt_term(
        &mut self,
        mut tm0: OptTermNode,
        mut tm1: RuleDescendantNode,
    ) {
        tm0 = self.opt_term_node_equalities.root(tm0);
        tm1 = self.rule_descendant_node_equalities.root(tm1);
        if self
            .rule_descendant_opt_term
            .insert(RuleDescendantOptTerm(tm0, tm1))
        {
            let weight0 = &mut self.opt_term_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(RuleDescendantOptTermTable::WEIGHT);

            let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(RuleDescendantOptTermTable::WEIGHT);
        }
    }

    /// Evaluates `rule_descendant_if_atom(arg0)`.
    #[allow(dead_code)]
    pub fn rule_descendant_if_atom(&self, mut arg0: IfAtomNode) -> Option<RuleDescendantNode> {
        arg0 = self.root_if_atom_node(arg0);
        self.rule_descendant_if_atom
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `rule_descendant_if_atom` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_descendant_if_atom(
        &self,
    ) -> impl '_ + Iterator<Item = (IfAtomNode, RuleDescendantNode)> {
        self.rule_descendant_if_atom.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_descendant_if_atom(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_rule_descendant_if_atom(
        &mut self,
        mut tm0: IfAtomNode,
        mut tm1: RuleDescendantNode,
    ) {
        tm0 = self.if_atom_node_equalities.root(tm0);
        tm1 = self.rule_descendant_node_equalities.root(tm1);
        if self
            .rule_descendant_if_atom
            .insert(RuleDescendantIfAtom(tm0, tm1))
        {
            let weight0 = &mut self.if_atom_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(RuleDescendantIfAtomTable::WEIGHT);

            let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(RuleDescendantIfAtomTable::WEIGHT);
        }
    }

    /// Evaluates `rule_descendant_then_atom(arg0)`.
    #[allow(dead_code)]
    pub fn rule_descendant_then_atom(&self, mut arg0: ThenAtomNode) -> Option<RuleDescendantNode> {
        arg0 = self.root_then_atom_node(arg0);
        self.rule_descendant_then_atom
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `rule_descendant_then_atom` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_descendant_then_atom(
        &self,
    ) -> impl '_ + Iterator<Item = (ThenAtomNode, RuleDescendantNode)> {
        self.rule_descendant_then_atom
            .iter_all()
            .map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_descendant_then_atom(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_rule_descendant_then_atom(
        &mut self,
        mut tm0: ThenAtomNode,
        mut tm1: RuleDescendantNode,
    ) {
        tm0 = self.then_atom_node_equalities.root(tm0);
        tm1 = self.rule_descendant_node_equalities.root(tm1);
        if self
            .rule_descendant_then_atom
            .insert(RuleDescendantThenAtom(tm0, tm1))
        {
            let weight0 = &mut self.then_atom_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(RuleDescendantThenAtomTable::WEIGHT);

            let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(RuleDescendantThenAtomTable::WEIGHT);
        }
    }

    /// Evaluates `rule_descendant_match_case(arg0)`.
    #[allow(dead_code)]
    pub fn rule_descendant_match_case(
        &self,
        mut arg0: MatchCaseNode,
    ) -> Option<RuleDescendantNode> {
        arg0 = self.root_match_case_node(arg0);
        self.rule_descendant_match_case
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `rule_descendant_match_case` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_descendant_match_case(
        &self,
    ) -> impl '_ + Iterator<Item = (MatchCaseNode, RuleDescendantNode)> {
        self.rule_descendant_match_case
            .iter_all()
            .map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_descendant_match_case(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_rule_descendant_match_case(
        &mut self,
        mut tm0: MatchCaseNode,
        mut tm1: RuleDescendantNode,
    ) {
        tm0 = self.match_case_node_equalities.root(tm0);
        tm1 = self.rule_descendant_node_equalities.root(tm1);
        if self
            .rule_descendant_match_case
            .insert(RuleDescendantMatchCase(tm0, tm1))
        {
            let weight0 = &mut self.match_case_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(RuleDescendantMatchCaseTable::WEIGHT);

            let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(RuleDescendantMatchCaseTable::WEIGHT);
        }
    }

    /// Evaluates `rule_descendant_match_case_list(arg0)`.
    #[allow(dead_code)]
    pub fn rule_descendant_match_case_list(
        &self,
        mut arg0: MatchCaseListNode,
    ) -> Option<RuleDescendantNode> {
        arg0 = self.root_match_case_list_node(arg0);
        self.rule_descendant_match_case_list
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `rule_descendant_match_case_list` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_descendant_match_case_list(
        &self,
    ) -> impl '_ + Iterator<Item = (MatchCaseListNode, RuleDescendantNode)> {
        self.rule_descendant_match_case_list
            .iter_all()
            .map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_descendant_match_case_list(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_rule_descendant_match_case_list(
        &mut self,
        mut tm0: MatchCaseListNode,
        mut tm1: RuleDescendantNode,
    ) {
        tm0 = self.match_case_list_node_equalities.root(tm0);
        tm1 = self.rule_descendant_node_equalities.root(tm1);
        if self
            .rule_descendant_match_case_list
            .insert(RuleDescendantMatchCaseList(tm0, tm1))
        {
            let weight0 = &mut self.match_case_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(RuleDescendantMatchCaseListTable::WEIGHT);

            let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(RuleDescendantMatchCaseListTable::WEIGHT);
        }
    }

    /// Evaluates `rule_descendant_stmt(arg0)`.
    #[allow(dead_code)]
    pub fn rule_descendant_stmt(&self, mut arg0: StmtNode) -> Option<RuleDescendantNode> {
        arg0 = self.root_stmt_node(arg0);
        self.rule_descendant_stmt
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `rule_descendant_stmt` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_descendant_stmt(
        &self,
    ) -> impl '_ + Iterator<Item = (StmtNode, RuleDescendantNode)> {
        self.rule_descendant_stmt.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_descendant_stmt(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_rule_descendant_stmt(&mut self, mut tm0: StmtNode, mut tm1: RuleDescendantNode) {
        tm0 = self.stmt_node_equalities.root(tm0);
        tm1 = self.rule_descendant_node_equalities.root(tm1);
        if self
            .rule_descendant_stmt
            .insert(RuleDescendantStmt(tm0, tm1))
        {
            let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(RuleDescendantStmtTable::WEIGHT);

            let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(RuleDescendantStmtTable::WEIGHT);
        }
    }

    /// Evaluates `rule_descendant_stmt_list(arg0)`.
    #[allow(dead_code)]
    pub fn rule_descendant_stmt_list(&self, mut arg0: StmtListNode) -> Option<RuleDescendantNode> {
        arg0 = self.root_stmt_list_node(arg0);
        self.rule_descendant_stmt_list
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `rule_descendant_stmt_list` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_descendant_stmt_list(
        &self,
    ) -> impl '_ + Iterator<Item = (StmtListNode, RuleDescendantNode)> {
        self.rule_descendant_stmt_list
            .iter_all()
            .map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_descendant_stmt_list(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_rule_descendant_stmt_list(
        &mut self,
        mut tm0: StmtListNode,
        mut tm1: RuleDescendantNode,
    ) {
        tm0 = self.stmt_list_node_equalities.root(tm0);
        tm1 = self.rule_descendant_node_equalities.root(tm1);
        if self
            .rule_descendant_stmt_list
            .insert(RuleDescendantStmtList(tm0, tm1))
        {
            let weight0 = &mut self.stmt_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(RuleDescendantStmtListTable::WEIGHT);

            let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(RuleDescendantStmtListTable::WEIGHT);
        }
    }

    /// Evaluates `rule_descendant_stmt_block_list(arg0)`.
    #[allow(dead_code)]
    pub fn rule_descendant_stmt_block_list(
        &self,
        mut arg0: StmtBlockListNode,
    ) -> Option<RuleDescendantNode> {
        arg0 = self.root_stmt_block_list_node(arg0);
        self.rule_descendant_stmt_block_list
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `rule_descendant_stmt_block_list` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_descendant_stmt_block_list(
        &self,
    ) -> impl '_ + Iterator<Item = (StmtBlockListNode, RuleDescendantNode)> {
        self.rule_descendant_stmt_block_list
            .iter_all()
            .map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_descendant_stmt_block_list(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_rule_descendant_stmt_block_list(
        &mut self,
        mut tm0: StmtBlockListNode,
        mut tm1: RuleDescendantNode,
    ) {
        tm0 = self.stmt_block_list_node_equalities.root(tm0);
        tm1 = self.rule_descendant_node_equalities.root(tm1);
        if self
            .rule_descendant_stmt_block_list
            .insert(RuleDescendantStmtBlockList(tm0, tm1))
        {
            let weight0 = &mut self.stmt_block_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(RuleDescendantStmtBlockListTable::WEIGHT);

            let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(RuleDescendantStmtBlockListTable::WEIGHT);
        }
    }

    /// Evaluates `entry_scope(arg0)`.
    #[allow(dead_code)]
    pub fn entry_scope(&self, mut arg0: RuleDescendantNode) -> Option<Scope> {
        arg0 = self.root_rule_descendant_node(arg0);
        self.entry_scope.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `entry_scope` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_entry_scope(&self) -> impl '_ + Iterator<Item = (RuleDescendantNode, Scope)> {
        self.entry_scope.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `entry_scope(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_entry_scope(&mut self, mut tm0: RuleDescendantNode, mut tm1: Scope) {
        tm0 = self.rule_descendant_node_equalities.root(tm0);
        tm1 = self.scope_equalities.root(tm1);
        if self.entry_scope.insert(EntryScope(tm0, tm1)) {
            let weight0 = &mut self.rule_descendant_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(EntryScopeTable::WEIGHT);

            let weight1 = &mut self.scope_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(EntryScopeTable::WEIGHT);
        }
    }

    /// Evaluates `exit_scope(arg0)`.
    #[allow(dead_code)]
    pub fn exit_scope(&self, mut arg0: RuleDescendantNode) -> Option<Scope> {
        arg0 = self.root_rule_descendant_node(arg0);
        self.exit_scope.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `exit_scope` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_exit_scope(&self) -> impl '_ + Iterator<Item = (RuleDescendantNode, Scope)> {
        self.exit_scope.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `exit_scope(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_exit_scope(&mut self, mut tm0: RuleDescendantNode, mut tm1: Scope) {
        tm0 = self.rule_descendant_node_equalities.root(tm0);
        tm1 = self.scope_equalities.root(tm1);
        if self.exit_scope.insert(ExitScope(tm0, tm1)) {
            let weight0 = &mut self.rule_descendant_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ExitScopeTable::WEIGHT);

            let weight1 = &mut self.scope_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ExitScopeTable::WEIGHT);
        }
    }

    /// Evaluates `ctor_enum(arg0)`.
    #[allow(dead_code)]
    pub fn ctor_enum(&self, mut arg0: CtorDeclNode) -> Option<EnumDeclNode> {
        arg0 = self.root_ctor_decl_node(arg0);
        self.ctor_enum.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `ctor_enum` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_ctor_enum(&self) -> impl '_ + Iterator<Item = (CtorDeclNode, EnumDeclNode)> {
        self.ctor_enum.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `ctor_enum(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_ctor_enum(&mut self, mut tm0: CtorDeclNode, mut tm1: EnumDeclNode) {
        tm0 = self.ctor_decl_node_equalities.root(tm0);
        tm1 = self.enum_decl_node_equalities.root(tm1);
        if self.ctor_enum.insert(CtorEnum(tm0, tm1)) {
            let weight0 = &mut self.ctor_decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(CtorEnumTable::WEIGHT);

            let weight1 = &mut self.enum_decl_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(CtorEnumTable::WEIGHT);
        }
    }

    /// Evaluates `ctors_enum(arg0)`.
    #[allow(dead_code)]
    pub fn ctors_enum(&self, mut arg0: CtorDeclListNode) -> Option<EnumDeclNode> {
        arg0 = self.root_ctor_decl_list_node(arg0);
        self.ctors_enum.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `ctors_enum` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_ctors_enum(&self) -> impl '_ + Iterator<Item = (CtorDeclListNode, EnumDeclNode)> {
        self.ctors_enum.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `ctors_enum(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_ctors_enum(&mut self, mut tm0: CtorDeclListNode, mut tm1: EnumDeclNode) {
        tm0 = self.ctor_decl_list_node_equalities.root(tm0);
        tm1 = self.enum_decl_node_equalities.root(tm1);
        if self.ctors_enum.insert(CtorsEnum(tm0, tm1)) {
            let weight0 = &mut self.ctor_decl_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(CtorsEnumTable::WEIGHT);

            let weight1 = &mut self.enum_decl_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(CtorsEnumTable::WEIGHT);
        }
    }

    /// Evaluates `cases_discriminee(arg0)`.
    #[allow(dead_code)]
    pub fn cases_discriminee(&self, mut arg0: MatchCaseListNode) -> Option<TermNode> {
        arg0 = self.root_match_case_list_node(arg0);
        self.cases_discriminee.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `cases_discriminee` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_cases_discriminee(
        &self,
    ) -> impl '_ + Iterator<Item = (MatchCaseListNode, TermNode)> {
        self.cases_discriminee.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `cases_discriminee(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_cases_discriminee(&mut self, mut tm0: MatchCaseListNode, mut tm1: TermNode) {
        tm0 = self.match_case_list_node_equalities.root(tm0);
        tm1 = self.term_node_equalities.root(tm1);
        if self.cases_discriminee.insert(CasesDiscriminee(tm0, tm1)) {
            let weight0 = &mut self.match_case_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(CasesDiscrimineeTable::WEIGHT);

            let weight1 = &mut self.term_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(CasesDiscrimineeTable::WEIGHT);
        }
    }

    /// Evaluates `case_discriminee(arg0)`.
    #[allow(dead_code)]
    pub fn case_discriminee(&self, mut arg0: MatchCaseNode) -> Option<TermNode> {
        arg0 = self.root_match_case_node(arg0);
        self.case_discriminee.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `case_discriminee` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_case_discriminee(&self) -> impl '_ + Iterator<Item = (MatchCaseNode, TermNode)> {
        self.case_discriminee.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `case_discriminee(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_case_discriminee(&mut self, mut tm0: MatchCaseNode, mut tm1: TermNode) {
        tm0 = self.match_case_node_equalities.root(tm0);
        tm1 = self.term_node_equalities.root(tm1);
        if self.case_discriminee.insert(CaseDiscriminee(tm0, tm1)) {
            let weight0 = &mut self.match_case_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(CaseDiscrimineeTable::WEIGHT);

            let weight1 = &mut self.term_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(CaseDiscrimineeTable::WEIGHT);
        }
    }

    /// Evaluates `desugared_case_equality_atom(arg0)`.
    #[allow(dead_code)]
    pub fn desugared_case_equality_atom(&self, mut arg0: MatchCaseNode) -> Option<IfAtomNode> {
        arg0 = self.root_match_case_node(arg0);
        self.desugared_case_equality_atom
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `desugared_case_equality_atom` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_desugared_case_equality_atom(
        &self,
    ) -> impl '_ + Iterator<Item = (MatchCaseNode, IfAtomNode)> {
        self.desugared_case_equality_atom
            .iter_all()
            .map(|t| (t.0, t.1))
    }
    /// Makes the equation `desugared_case_equality_atom(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_desugared_case_equality_atom(
        &mut self,
        mut tm0: MatchCaseNode,
        mut tm1: IfAtomNode,
    ) {
        tm0 = self.match_case_node_equalities.root(tm0);
        tm1 = self.if_atom_node_equalities.root(tm1);
        if self
            .desugared_case_equality_atom
            .insert(DesugaredCaseEqualityAtom(tm0, tm1))
        {
            let weight0 = &mut self.match_case_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(DesugaredCaseEqualityAtomTable::WEIGHT);

            let weight1 = &mut self.if_atom_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(DesugaredCaseEqualityAtomTable::WEIGHT);
        }
    }

    /// Evaluates `desugared_case_equality_stmt(arg0)`.
    #[allow(dead_code)]
    pub fn desugared_case_equality_stmt(&self, mut arg0: MatchCaseNode) -> Option<StmtNode> {
        arg0 = self.root_match_case_node(arg0);
        self.desugared_case_equality_stmt
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `desugared_case_equality_stmt` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_desugared_case_equality_stmt(
        &self,
    ) -> impl '_ + Iterator<Item = (MatchCaseNode, StmtNode)> {
        self.desugared_case_equality_stmt
            .iter_all()
            .map(|t| (t.0, t.1))
    }
    /// Makes the equation `desugared_case_equality_stmt(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_desugared_case_equality_stmt(
        &mut self,
        mut tm0: MatchCaseNode,
        mut tm1: StmtNode,
    ) {
        tm0 = self.match_case_node_equalities.root(tm0);
        tm1 = self.stmt_node_equalities.root(tm1);
        if self
            .desugared_case_equality_stmt
            .insert(DesugaredCaseEqualityStmt(tm0, tm1))
        {
            let weight0 = &mut self.match_case_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(DesugaredCaseEqualityStmtTable::WEIGHT);

            let weight1 = &mut self.stmt_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(DesugaredCaseEqualityStmtTable::WEIGHT);
        }
    }

    /// Evaluates `desugared_case_block(arg0)`.
    #[allow(dead_code)]
    pub fn desugared_case_block(&self, mut arg0: MatchCaseNode) -> Option<StmtListNode> {
        arg0 = self.root_match_case_node(arg0);
        self.desugared_case_block
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `desugared_case_block` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_desugared_case_block(
        &self,
    ) -> impl '_ + Iterator<Item = (MatchCaseNode, StmtListNode)> {
        self.desugared_case_block.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `desugared_case_block(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_desugared_case_block(&mut self, mut tm0: MatchCaseNode, mut tm1: StmtListNode) {
        tm0 = self.match_case_node_equalities.root(tm0);
        tm1 = self.stmt_list_node_equalities.root(tm1);
        if self
            .desugared_case_block
            .insert(DesugaredCaseBlock(tm0, tm1))
        {
            let weight0 = &mut self.match_case_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(DesugaredCaseBlockTable::WEIGHT);

            let weight1 = &mut self.stmt_list_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(DesugaredCaseBlockTable::WEIGHT);
        }
    }

    /// Evaluates `desugared_case_block_list(arg0)`.
    #[allow(dead_code)]
    pub fn desugared_case_block_list(
        &self,
        mut arg0: MatchCaseListNode,
    ) -> Option<StmtBlockListNode> {
        arg0 = self.root_match_case_list_node(arg0);
        self.desugared_case_block_list
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `desugared_case_block_list` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_desugared_case_block_list(
        &self,
    ) -> impl '_ + Iterator<Item = (MatchCaseListNode, StmtBlockListNode)> {
        self.desugared_case_block_list
            .iter_all()
            .map(|t| (t.0, t.1))
    }
    /// Makes the equation `desugared_case_block_list(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_desugared_case_block_list(
        &mut self,
        mut tm0: MatchCaseListNode,
        mut tm1: StmtBlockListNode,
    ) {
        tm0 = self.match_case_list_node_equalities.root(tm0);
        tm1 = self.stmt_block_list_node_equalities.root(tm1);
        if self
            .desugared_case_block_list
            .insert(DesugaredCaseBlockList(tm0, tm1))
        {
            let weight0 = &mut self.match_case_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(DesugaredCaseBlockListTable::WEIGHT);

            let weight1 = &mut self.stmt_block_list_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(DesugaredCaseBlockListTable::WEIGHT);
        }
    }

    /// Evaluates `NilTypeList()`.
    #[allow(dead_code)]
    pub fn nil_type_list(&self) -> Option<TypeList> {
        self.nil_type_list.iter_all().next().map(|t| t.0)
    }
    /// Returns an iterator over `NilTypeList` constants.
    /// The iterator may yield more than one element if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_nil_type_list(&self) -> impl '_ + Iterator<Item = TypeList> {
        self.nil_type_list.iter_all().map(|t| t.0)
    }
    /// Makes the equation `nil_type_list() = tm0` hold.

    #[allow(dead_code)]
    pub fn insert_nil_type_list(&mut self, mut tm0: TypeList) {
        tm0 = self.type_list_equalities.root(tm0);
        if self.nil_type_list.insert(NilTypeList(tm0)) {
            let weight0 = &mut self.type_list_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(NilTypeListTable::WEIGHT);
        }
    }

    /// Evaluates `ConsTypeList(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn cons_type_list(&self, mut arg0: Type, mut arg1: TypeList) -> Option<TypeList> {
        arg0 = self.root_type(arg0);
        arg1 = self.root_type_list(arg1);
        self.cons_type_list
            .iter_all_0_1(arg0, arg1)
            .next()
            .map(|t| t.2)
    }
    /// Returns an iterator over tuples in the graph of the `ConsTypeList` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_cons_type_list(&self) -> impl '_ + Iterator<Item = (Type, TypeList, TypeList)> {
        self.cons_type_list.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `cons_type_list(tm0, tm1) = tm2` hold.

    #[allow(dead_code)]
    pub fn insert_cons_type_list(&mut self, mut tm0: Type, mut tm1: TypeList, mut tm2: TypeList) {
        tm0 = self.type_equalities.root(tm0);
        tm1 = self.type_list_equalities.root(tm1);
        tm2 = self.type_list_equalities.root(tm2);
        if self.cons_type_list.insert(ConsTypeList(tm0, tm1, tm2)) {
            let weight0 = &mut self.type_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ConsTypeListTable::WEIGHT);

            let weight1 = &mut self.type_list_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ConsTypeListTable::WEIGHT);

            let weight2 = &mut self.type_list_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(ConsTypeListTable::WEIGHT);
        }
    }

    /// Evaluates `SnocTypeList(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn snoc_type_list(&self, mut arg0: TypeList, mut arg1: Type) -> Option<TypeList> {
        arg0 = self.root_type_list(arg0);
        arg1 = self.root_type(arg1);
        self.snoc_type_list
            .iter_all_0_1(arg0, arg1)
            .next()
            .map(|t| t.2)
    }
    /// Returns an iterator over tuples in the graph of the `SnocTypeList` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_snoc_type_list(&self) -> impl '_ + Iterator<Item = (TypeList, Type, TypeList)> {
        self.snoc_type_list.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `snoc_type_list(tm0, tm1) = tm2` hold.

    #[allow(dead_code)]
    pub fn insert_snoc_type_list(&mut self, mut tm0: TypeList, mut tm1: Type, mut tm2: TypeList) {
        tm0 = self.type_list_equalities.root(tm0);
        tm1 = self.type_equalities.root(tm1);
        tm2 = self.type_list_equalities.root(tm2);
        if self.snoc_type_list.insert(SnocTypeList(tm0, tm1, tm2)) {
            let weight0 = &mut self.type_list_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(SnocTypeListTable::WEIGHT);

            let weight1 = &mut self.type_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(SnocTypeListTable::WEIGHT);

            let weight2 = &mut self.type_list_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(SnocTypeListTable::WEIGHT);
        }
    }

    /// Evaluates `semantic_type(arg0)`.
    #[allow(dead_code)]
    pub fn semantic_type(&self, mut arg0: Ident) -> Option<Type> {
        arg0 = self.root_ident(arg0);
        self.semantic_type.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `semantic_type` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_semantic_type(&self) -> impl '_ + Iterator<Item = (Ident, Type)> {
        self.semantic_type.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `semantic_type(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_semantic_type(&mut self, mut tm0: Ident, mut tm1: Type) {
        tm0 = self.ident_equalities.root(tm0);
        tm1 = self.type_equalities.root(tm1);
        if self.semantic_type.insert(SemanticType(tm0, tm1)) {
            let weight0 = &mut self.ident_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(SemanticTypeTable::WEIGHT);

            let weight1 = &mut self.type_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(SemanticTypeTable::WEIGHT);
        }
    }

    /// Evaluates `semantic_arg_types(arg0)`.
    #[allow(dead_code)]
    pub fn semantic_arg_types(&self, mut arg0: ArgDeclListNode) -> Option<TypeList> {
        arg0 = self.root_arg_decl_list_node(arg0);
        self.semantic_arg_types.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `semantic_arg_types` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_semantic_arg_types(
        &self,
    ) -> impl '_ + Iterator<Item = (ArgDeclListNode, TypeList)> {
        self.semantic_arg_types.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `semantic_arg_types(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_semantic_arg_types(&mut self, mut tm0: ArgDeclListNode, mut tm1: TypeList) {
        tm0 = self.arg_decl_list_node_equalities.root(tm0);
        tm1 = self.type_list_equalities.root(tm1);
        if self.semantic_arg_types.insert(SemanticArgTypes(tm0, tm1)) {
            let weight0 = &mut self.arg_decl_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(SemanticArgTypesTable::WEIGHT);

            let weight1 = &mut self.type_list_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(SemanticArgTypesTable::WEIGHT);
        }
    }

    /// Evaluates `semantic_pred(arg0)`.
    #[allow(dead_code)]
    pub fn semantic_pred(&self, mut arg0: Ident) -> Option<Pred> {
        arg0 = self.root_ident(arg0);
        self.semantic_pred.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `semantic_pred` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_semantic_pred(&self) -> impl '_ + Iterator<Item = (Ident, Pred)> {
        self.semantic_pred.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `semantic_pred(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_semantic_pred(&mut self, mut tm0: Ident, mut tm1: Pred) {
        tm0 = self.ident_equalities.root(tm0);
        tm1 = self.pred_equalities.root(tm1);
        if self.semantic_pred.insert(SemanticPred(tm0, tm1)) {
            let weight0 = &mut self.ident_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(SemanticPredTable::WEIGHT);

            let weight1 = &mut self.pred_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(SemanticPredTable::WEIGHT);
        }
    }

    /// Evaluates `pred_arity(arg0)`.
    #[allow(dead_code)]
    pub fn pred_arity(&self, mut arg0: Pred) -> Option<TypeList> {
        arg0 = self.root_pred(arg0);
        self.pred_arity.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `pred_arity` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_pred_arity(&self) -> impl '_ + Iterator<Item = (Pred, TypeList)> {
        self.pred_arity.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `pred_arity(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_pred_arity(&mut self, mut tm0: Pred, mut tm1: TypeList) {
        tm0 = self.pred_equalities.root(tm0);
        tm1 = self.type_list_equalities.root(tm1);
        if self.pred_arity.insert(PredArity(tm0, tm1)) {
            let weight0 = &mut self.pred_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(PredArityTable::WEIGHT);

            let weight1 = &mut self.type_list_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(PredArityTable::WEIGHT);
        }
    }

    /// Evaluates `semantic_func(arg0)`.
    #[allow(dead_code)]
    pub fn semantic_func(&self, mut arg0: Ident) -> Option<Func> {
        arg0 = self.root_ident(arg0);
        self.semantic_func.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `semantic_func` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_semantic_func(&self) -> impl '_ + Iterator<Item = (Ident, Func)> {
        self.semantic_func.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `semantic_func(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_semantic_func(&mut self, mut tm0: Ident, mut tm1: Func) {
        tm0 = self.ident_equalities.root(tm0);
        tm1 = self.func_equalities.root(tm1);
        if self.semantic_func.insert(SemanticFunc(tm0, tm1)) {
            let weight0 = &mut self.ident_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(SemanticFuncTable::WEIGHT);

            let weight1 = &mut self.func_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(SemanticFuncTable::WEIGHT);
        }
    }

    /// Evaluates `domain(arg0)`.
    #[allow(dead_code)]
    pub fn domain(&self, mut arg0: Func) -> Option<TypeList> {
        arg0 = self.root_func(arg0);
        self.domain.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `domain` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_domain(&self) -> impl '_ + Iterator<Item = (Func, TypeList)> {
        self.domain.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `domain(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_domain(&mut self, mut tm0: Func, mut tm1: TypeList) {
        tm0 = self.func_equalities.root(tm0);
        tm1 = self.type_list_equalities.root(tm1);
        if self.domain.insert(Domain(tm0, tm1)) {
            let weight0 = &mut self.func_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(DomainTable::WEIGHT);

            let weight1 = &mut self.type_list_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(DomainTable::WEIGHT);
        }
    }

    /// Evaluates `codomain(arg0)`.
    #[allow(dead_code)]
    pub fn codomain(&self, mut arg0: Func) -> Option<Type> {
        arg0 = self.root_func(arg0);
        self.codomain.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `codomain` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_codomain(&self) -> impl '_ + Iterator<Item = (Func, Type)> {
        self.codomain.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `codomain(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_codomain(&mut self, mut tm0: Func, mut tm1: Type) {
        tm0 = self.func_equalities.root(tm0);
        tm1 = self.type_equalities.root(tm1);
        if self.codomain.insert(Codomain(tm0, tm1)) {
            let weight0 = &mut self.func_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(CodomainTable::WEIGHT);

            let weight1 = &mut self.type_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(CodomainTable::WEIGHT);
        }
    }

    /// Evaluates `PredRel(arg0)`.
    #[allow(dead_code)]
    pub fn pred_rel(&self, mut arg0: Pred) -> Option<Rel> {
        arg0 = self.root_pred(arg0);
        self.pred_rel.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `PredRel` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_pred_rel(&self) -> impl '_ + Iterator<Item = (Pred, Rel)> {
        self.pred_rel.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `pred_rel(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_pred_rel(&mut self, mut tm0: Pred, mut tm1: Rel) {
        tm0 = self.pred_equalities.root(tm0);
        tm1 = self.rel_equalities.root(tm1);
        if self.pred_rel.insert(PredRel(tm0, tm1)) {
            let weight0 = &mut self.pred_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(PredRelTable::WEIGHT);

            let weight1 = &mut self.rel_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(PredRelTable::WEIGHT);
        }
    }

    /// Evaluates `FuncRel(arg0)`.
    #[allow(dead_code)]
    pub fn func_rel(&self, mut arg0: Func) -> Option<Rel> {
        arg0 = self.root_func(arg0);
        self.func_rel.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `FuncRel` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_func_rel(&self) -> impl '_ + Iterator<Item = (Func, Rel)> {
        self.func_rel.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `func_rel(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_func_rel(&mut self, mut tm0: Func, mut tm1: Rel) {
        tm0 = self.func_equalities.root(tm0);
        tm1 = self.rel_equalities.root(tm1);
        if self.func_rel.insert(FuncRel(tm0, tm1)) {
            let weight0 = &mut self.func_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(FuncRelTable::WEIGHT);

            let weight1 = &mut self.rel_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(FuncRelTable::WEIGHT);
        }
    }

    /// Evaluates `arity(arg0)`.
    #[allow(dead_code)]
    pub fn arity(&self, mut arg0: Rel) -> Option<TypeList> {
        arg0 = self.root_rel(arg0);
        self.arity.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `arity` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_arity(&self) -> impl '_ + Iterator<Item = (Rel, TypeList)> {
        self.arity.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `arity(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_arity(&mut self, mut tm0: Rel, mut tm1: TypeList) {
        tm0 = self.rel_equalities.root(tm0);
        tm1 = self.type_list_equalities.root(tm1);
        if self.arity.insert(Arity(tm0, tm1)) {
            let weight0 = &mut self.rel_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ArityTable::WEIGHT);

            let weight1 = &mut self.type_list_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ArityTable::WEIGHT);
        }
    }

    /// Evaluates `dom(arg0)`.
    #[allow(dead_code)]
    pub fn dom(&self, mut arg0: Morphism) -> Option<Structure> {
        arg0 = self.root_morphism(arg0);
        self.dom.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `dom` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_dom(&self) -> impl '_ + Iterator<Item = (Morphism, Structure)> {
        self.dom.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `dom(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_dom(&mut self, mut tm0: Morphism, mut tm1: Structure) {
        tm0 = self.morphism_equalities.root(tm0);
        tm1 = self.structure_equalities.root(tm1);
        if self.dom.insert(Dom(tm0, tm1)) {
            let weight0 = &mut self.morphism_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(DomTable::WEIGHT);

            let weight1 = &mut self.structure_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(DomTable::WEIGHT);
        }
    }

    /// Evaluates `cod(arg0)`.
    #[allow(dead_code)]
    pub fn cod(&self, mut arg0: Morphism) -> Option<Structure> {
        arg0 = self.root_morphism(arg0);
        self.cod.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `cod` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_cod(&self) -> impl '_ + Iterator<Item = (Morphism, Structure)> {
        self.cod.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `cod(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_cod(&mut self, mut tm0: Morphism, mut tm1: Structure) {
        tm0 = self.morphism_equalities.root(tm0);
        tm1 = self.structure_equalities.root(tm1);
        if self.cod.insert(Cod(tm0, tm1)) {
            let weight0 = &mut self.morphism_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(CodTable::WEIGHT);

            let weight1 = &mut self.structure_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(CodTable::WEIGHT);
        }
    }

    /// Evaluates `NilElList(arg0)`.
    #[allow(dead_code)]
    pub fn nil_el_list(&self, mut arg0: Structure) -> Option<ElList> {
        arg0 = self.root_structure(arg0);
        self.nil_el_list.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `NilElList` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_nil_el_list(&self) -> impl '_ + Iterator<Item = (Structure, ElList)> {
        self.nil_el_list.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `nil_el_list(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_nil_el_list(&mut self, mut tm0: Structure, mut tm1: ElList) {
        tm0 = self.structure_equalities.root(tm0);
        tm1 = self.el_list_equalities.root(tm1);
        if self.nil_el_list.insert(NilElList(tm0, tm1)) {
            let weight0 = &mut self.structure_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(NilElListTable::WEIGHT);

            let weight1 = &mut self.el_list_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(NilElListTable::WEIGHT);
        }
    }

    /// Evaluates `ConsElList(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn cons_el_list(&self, mut arg0: El, mut arg1: ElList) -> Option<ElList> {
        arg0 = self.root_el(arg0);
        arg1 = self.root_el_list(arg1);
        self.cons_el_list
            .iter_all_0_1(arg0, arg1)
            .next()
            .map(|t| t.2)
    }
    /// Returns an iterator over tuples in the graph of the `ConsElList` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_cons_el_list(&self) -> impl '_ + Iterator<Item = (El, ElList, ElList)> {
        self.cons_el_list.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `cons_el_list(tm0, tm1) = tm2` hold.

    #[allow(dead_code)]
    pub fn insert_cons_el_list(&mut self, mut tm0: El, mut tm1: ElList, mut tm2: ElList) {
        tm0 = self.el_equalities.root(tm0);
        tm1 = self.el_list_equalities.root(tm1);
        tm2 = self.el_list_equalities.root(tm2);
        if self.cons_el_list.insert(ConsElList(tm0, tm1, tm2)) {
            let weight0 = &mut self.el_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ConsElListTable::WEIGHT);

            let weight1 = &mut self.el_list_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ConsElListTable::WEIGHT);

            let weight2 = &mut self.el_list_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(ConsElListTable::WEIGHT);
        }
    }

    /// Evaluates `SnocElList(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn snoc_el_list(&self, mut arg0: ElList, mut arg1: El) -> Option<ElList> {
        arg0 = self.root_el_list(arg0);
        arg1 = self.root_el(arg1);
        self.snoc_el_list
            .iter_all_0_1(arg0, arg1)
            .next()
            .map(|t| t.2)
    }
    /// Returns an iterator over tuples in the graph of the `SnocElList` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_snoc_el_list(&self) -> impl '_ + Iterator<Item = (ElList, El, ElList)> {
        self.snoc_el_list.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `snoc_el_list(tm0, tm1) = tm2` hold.

    #[allow(dead_code)]
    pub fn insert_snoc_el_list(&mut self, mut tm0: ElList, mut tm1: El, mut tm2: ElList) {
        tm0 = self.el_list_equalities.root(tm0);
        tm1 = self.el_equalities.root(tm1);
        tm2 = self.el_list_equalities.root(tm2);
        if self.snoc_el_list.insert(SnocElList(tm0, tm1, tm2)) {
            let weight0 = &mut self.el_list_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(SnocElListTable::WEIGHT);

            let weight1 = &mut self.el_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(SnocElListTable::WEIGHT);

            let weight2 = &mut self.el_list_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(SnocElListTable::WEIGHT);
        }
    }

    /// Evaluates `el_structure(arg0)`.
    #[allow(dead_code)]
    pub fn el_structure(&self, mut arg0: El) -> Option<Structure> {
        arg0 = self.root_el(arg0);
        self.el_structure.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `el_structure` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_el_structure(&self) -> impl '_ + Iterator<Item = (El, Structure)> {
        self.el_structure.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `el_structure(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_el_structure(&mut self, mut tm0: El, mut tm1: Structure) {
        tm0 = self.el_equalities.root(tm0);
        tm1 = self.structure_equalities.root(tm1);
        if self.el_structure.insert(ElStructure(tm0, tm1)) {
            let weight0 = &mut self.el_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ElStructureTable::WEIGHT);

            let weight1 = &mut self.structure_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ElStructureTable::WEIGHT);
        }
    }

    /// Evaluates `els_structure(arg0)`.
    #[allow(dead_code)]
    pub fn els_structure(&self, mut arg0: ElList) -> Option<Structure> {
        arg0 = self.root_el_list(arg0);
        self.els_structure.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `els_structure` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_els_structure(&self) -> impl '_ + Iterator<Item = (ElList, Structure)> {
        self.els_structure.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `els_structure(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_els_structure(&mut self, mut tm0: ElList, mut tm1: Structure) {
        tm0 = self.el_list_equalities.root(tm0);
        tm1 = self.structure_equalities.root(tm1);
        if self.els_structure.insert(ElsStructure(tm0, tm1)) {
            let weight0 = &mut self.el_list_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ElsStructureTable::WEIGHT);

            let weight1 = &mut self.structure_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ElsStructureTable::WEIGHT);
        }
    }

    /// Evaluates `func_app(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn func_app(&self, mut arg0: Func, mut arg1: ElList) -> Option<El> {
        arg0 = self.root_func(arg0);
        arg1 = self.root_el_list(arg1);
        self.func_app.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
    }
    /// Returns an iterator over tuples in the graph of the `func_app` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_func_app(&self) -> impl '_ + Iterator<Item = (Func, ElList, El)> {
        self.func_app.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `func_app(tm0, tm1) = tm2` hold.

    #[allow(dead_code)]
    pub fn insert_func_app(&mut self, mut tm0: Func, mut tm1: ElList, mut tm2: El) {
        tm0 = self.func_equalities.root(tm0);
        tm1 = self.el_list_equalities.root(tm1);
        tm2 = self.el_equalities.root(tm2);
        if self.func_app.insert(FuncApp(tm0, tm1, tm2)) {
            let weight0 = &mut self.func_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(FuncAppTable::WEIGHT);

            let weight1 = &mut self.el_list_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(FuncAppTable::WEIGHT);

            let weight2 = &mut self.el_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(FuncAppTable::WEIGHT);
        }
    }

    /// Evaluates `map_el(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn map_el(&self, mut arg0: Morphism, mut arg1: El) -> Option<El> {
        arg0 = self.root_morphism(arg0);
        arg1 = self.root_el(arg1);
        self.map_el.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
    }
    /// Returns an iterator over tuples in the graph of the `map_el` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_map_el(&self) -> impl '_ + Iterator<Item = (Morphism, El, El)> {
        self.map_el.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `map_el(tm0, tm1) = tm2` hold.

    #[allow(dead_code)]
    pub fn insert_map_el(&mut self, mut tm0: Morphism, mut tm1: El, mut tm2: El) {
        tm0 = self.morphism_equalities.root(tm0);
        tm1 = self.el_equalities.root(tm1);
        tm2 = self.el_equalities.root(tm2);
        if self.map_el.insert(MapEl(tm0, tm1, tm2)) {
            let weight0 = &mut self.morphism_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(MapElTable::WEIGHT);

            let weight1 = &mut self.el_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(MapElTable::WEIGHT);

            let weight2 = &mut self.el_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(MapElTable::WEIGHT);
        }
    }

    /// Evaluates `map_els(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn map_els(&self, mut arg0: Morphism, mut arg1: ElList) -> Option<ElList> {
        arg0 = self.root_morphism(arg0);
        arg1 = self.root_el_list(arg1);
        self.map_els.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
    }
    /// Returns an iterator over tuples in the graph of the `map_els` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_map_els(&self) -> impl '_ + Iterator<Item = (Morphism, ElList, ElList)> {
        self.map_els.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `map_els(tm0, tm1) = tm2` hold.

    #[allow(dead_code)]
    pub fn insert_map_els(&mut self, mut tm0: Morphism, mut tm1: ElList, mut tm2: ElList) {
        tm0 = self.morphism_equalities.root(tm0);
        tm1 = self.el_list_equalities.root(tm1);
        tm2 = self.el_list_equalities.root(tm2);
        if self.map_els.insert(MapEls(tm0, tm1, tm2)) {
            let weight0 = &mut self.morphism_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(MapElsTable::WEIGHT);

            let weight1 = &mut self.el_list_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(MapElsTable::WEIGHT);

            let weight2 = &mut self.el_list_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(MapElsTable::WEIGHT);
        }
    }

    /// Evaluates `type_symbol()`.
    #[allow(dead_code)]
    pub fn type_symbol(&self) -> Option<SymbolKind> {
        self.type_symbol.iter_all().next().map(|t| t.0)
    }
    /// Returns an iterator over `type_symbol` constants.
    /// The iterator may yield more than one element if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_type_symbol(&self) -> impl '_ + Iterator<Item = SymbolKind> {
        self.type_symbol.iter_all().map(|t| t.0)
    }
    /// Makes the equation `type_symbol() = tm0` hold.

    #[allow(dead_code)]
    pub fn insert_type_symbol(&mut self, mut tm0: SymbolKind) {
        tm0 = self.symbol_kind_equalities.root(tm0);
        if self.type_symbol.insert(TypeSymbol(tm0)) {
            let weight0 = &mut self.symbol_kind_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(TypeSymbolTable::WEIGHT);
        }
    }

    /// Evaluates `pred_symbol()`.
    #[allow(dead_code)]
    pub fn pred_symbol(&self) -> Option<SymbolKind> {
        self.pred_symbol.iter_all().next().map(|t| t.0)
    }
    /// Returns an iterator over `pred_symbol` constants.
    /// The iterator may yield more than one element if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_pred_symbol(&self) -> impl '_ + Iterator<Item = SymbolKind> {
        self.pred_symbol.iter_all().map(|t| t.0)
    }
    /// Makes the equation `pred_symbol() = tm0` hold.

    #[allow(dead_code)]
    pub fn insert_pred_symbol(&mut self, mut tm0: SymbolKind) {
        tm0 = self.symbol_kind_equalities.root(tm0);
        if self.pred_symbol.insert(PredSymbol(tm0)) {
            let weight0 = &mut self.symbol_kind_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(PredSymbolTable::WEIGHT);
        }
    }

    /// Evaluates `func_symbol()`.
    #[allow(dead_code)]
    pub fn func_symbol(&self) -> Option<SymbolKind> {
        self.func_symbol.iter_all().next().map(|t| t.0)
    }
    /// Returns an iterator over `func_symbol` constants.
    /// The iterator may yield more than one element if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_func_symbol(&self) -> impl '_ + Iterator<Item = SymbolKind> {
        self.func_symbol.iter_all().map(|t| t.0)
    }
    /// Makes the equation `func_symbol() = tm0` hold.

    #[allow(dead_code)]
    pub fn insert_func_symbol(&mut self, mut tm0: SymbolKind) {
        tm0 = self.symbol_kind_equalities.root(tm0);
        if self.func_symbol.insert(FuncSymbol(tm0)) {
            let weight0 = &mut self.symbol_kind_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(FuncSymbolTable::WEIGHT);
        }
    }

    /// Evaluates `rule_symbol()`.
    #[allow(dead_code)]
    pub fn rule_symbol(&self) -> Option<SymbolKind> {
        self.rule_symbol.iter_all().next().map(|t| t.0)
    }
    /// Returns an iterator over `rule_symbol` constants.
    /// The iterator may yield more than one element if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_symbol(&self) -> impl '_ + Iterator<Item = SymbolKind> {
        self.rule_symbol.iter_all().map(|t| t.0)
    }
    /// Makes the equation `rule_symbol() = tm0` hold.

    #[allow(dead_code)]
    pub fn insert_rule_symbol(&mut self, mut tm0: SymbolKind) {
        tm0 = self.symbol_kind_equalities.root(tm0);
        if self.rule_symbol.insert(RuleSymbol(tm0)) {
            let weight0 = &mut self.symbol_kind_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(RuleSymbolTable::WEIGHT);
        }
    }

    /// Evaluates `enum_symbol()`.
    #[allow(dead_code)]
    pub fn enum_symbol(&self) -> Option<SymbolKind> {
        self.enum_symbol.iter_all().next().map(|t| t.0)
    }
    /// Returns an iterator over `enum_symbol` constants.
    /// The iterator may yield more than one element if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_enum_symbol(&self) -> impl '_ + Iterator<Item = SymbolKind> {
        self.enum_symbol.iter_all().map(|t| t.0)
    }
    /// Makes the equation `enum_symbol() = tm0` hold.

    #[allow(dead_code)]
    pub fn insert_enum_symbol(&mut self, mut tm0: SymbolKind) {
        tm0 = self.symbol_kind_equalities.root(tm0);
        if self.enum_symbol.insert(EnumSymbol(tm0)) {
            let weight0 = &mut self.symbol_kind_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(EnumSymbolTable::WEIGHT);
        }
    }

    /// Evaluates `ctor_symbol()`.
    #[allow(dead_code)]
    pub fn ctor_symbol(&self) -> Option<SymbolKind> {
        self.ctor_symbol.iter_all().next().map(|t| t.0)
    }
    /// Returns an iterator over `ctor_symbol` constants.
    /// The iterator may yield more than one element if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_ctor_symbol(&self) -> impl '_ + Iterator<Item = SymbolKind> {
        self.ctor_symbol.iter_all().map(|t| t.0)
    }
    /// Makes the equation `ctor_symbol() = tm0` hold.

    #[allow(dead_code)]
    pub fn insert_ctor_symbol(&mut self, mut tm0: SymbolKind) {
        tm0 = self.symbol_kind_equalities.root(tm0);
        if self.ctor_symbol.insert(CtorSymbol(tm0)) {
            let weight0 = &mut self.symbol_kind_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(CtorSymbolTable::WEIGHT);
        }
    }

    /// Evaluates `zero()`.
    #[allow(dead_code)]
    pub fn zero(&self) -> Option<Nat> {
        self.zero.iter_all().next().map(|t| t.0)
    }
    /// Returns an iterator over `zero` constants.
    /// The iterator may yield more than one element if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_zero(&self) -> impl '_ + Iterator<Item = Nat> {
        self.zero.iter_all().map(|t| t.0)
    }
    /// Makes the equation `zero() = tm0` hold.

    #[allow(dead_code)]
    pub fn insert_zero(&mut self, mut tm0: Nat) {
        tm0 = self.nat_equalities.root(tm0);
        if self.zero.insert(Zero(tm0)) {
            let weight0 = &mut self.nat_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ZeroTable::WEIGHT);
        }
    }

    /// Evaluates `succ(arg0)`.
    #[allow(dead_code)]
    pub fn succ(&self, mut arg0: Nat) -> Option<Nat> {
        arg0 = self.root_nat(arg0);
        self.succ.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `succ` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_succ(&self) -> impl '_ + Iterator<Item = (Nat, Nat)> {
        self.succ.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `succ(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_succ(&mut self, mut tm0: Nat, mut tm1: Nat) {
        tm0 = self.nat_equalities.root(tm0);
        tm1 = self.nat_equalities.root(tm1);
        if self.succ.insert(Succ(tm0, tm1)) {
            let weight0 = &mut self.nat_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(SuccTable::WEIGHT);

            let weight1 = &mut self.nat_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(SuccTable::WEIGHT);
        }
    }

    /// Evaluates `type_list_len(arg0)`.
    #[allow(dead_code)]
    pub fn type_list_len(&self, mut arg0: TypeList) -> Option<Nat> {
        arg0 = self.root_type_list(arg0);
        self.type_list_len.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `type_list_len` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_type_list_len(&self) -> impl '_ + Iterator<Item = (TypeList, Nat)> {
        self.type_list_len.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `type_list_len(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_type_list_len(&mut self, mut tm0: TypeList, mut tm1: Nat) {
        tm0 = self.type_list_equalities.root(tm0);
        tm1 = self.nat_equalities.root(tm1);
        if self.type_list_len.insert(TypeListLen(tm0, tm1)) {
            let weight0 = &mut self.type_list_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(TypeListLenTable::WEIGHT);

            let weight1 = &mut self.nat_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(TypeListLenTable::WEIGHT);
        }
    }

    /// Evaluates `term_list_len(arg0)`.
    #[allow(dead_code)]
    pub fn term_list_len(&self, mut arg0: TermListNode) -> Option<Nat> {
        arg0 = self.root_term_list_node(arg0);
        self.term_list_len.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `term_list_len` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_term_list_len(&self) -> impl '_ + Iterator<Item = (TermListNode, Nat)> {
        self.term_list_len.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `term_list_len(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_term_list_len(&mut self, mut tm0: TermListNode, mut tm1: Nat) {
        tm0 = self.term_list_node_equalities.root(tm0);
        tm1 = self.nat_equalities.root(tm1);
        if self.term_list_len.insert(TermListLen(tm0, tm1)) {
            let weight0 = &mut self.term_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(TermListLenTable::WEIGHT);

            let weight1 = &mut self.nat_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(TermListLenTable::WEIGHT);
        }
    }

    /// Evaluates `before_rule_structure(arg0)`.
    #[allow(dead_code)]
    pub fn before_rule_structure(&self, mut arg0: RuleDeclNode) -> Option<Structure> {
        arg0 = self.root_rule_decl_node(arg0);
        self.before_rule_structure
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `before_rule_structure` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_before_rule_structure(
        &self,
    ) -> impl '_ + Iterator<Item = (RuleDeclNode, Structure)> {
        self.before_rule_structure.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `before_rule_structure(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_before_rule_structure(&mut self, mut tm0: RuleDeclNode, mut tm1: Structure) {
        tm0 = self.rule_decl_node_equalities.root(tm0);
        tm1 = self.structure_equalities.root(tm1);
        if self
            .before_rule_structure
            .insert(BeforeRuleStructure(tm0, tm1))
        {
            let weight0 = &mut self.rule_decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(BeforeRuleStructureTable::WEIGHT);

            let weight1 = &mut self.structure_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(BeforeRuleStructureTable::WEIGHT);
        }
    }

    /// Evaluates `if_atom_morphism(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn if_atom_morphism(&self, mut arg0: IfAtomNode, mut arg1: Structure) -> Option<Morphism> {
        arg0 = self.root_if_atom_node(arg0);
        arg1 = self.root_structure(arg1);
        self.if_atom_morphism
            .iter_all_0_1(arg0, arg1)
            .next()
            .map(|t| t.2)
    }
    /// Returns an iterator over tuples in the graph of the `if_atom_morphism` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_if_atom_morphism(
        &self,
    ) -> impl '_ + Iterator<Item = (IfAtomNode, Structure, Morphism)> {
        self.if_atom_morphism.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `if_atom_morphism(tm0, tm1) = tm2` hold.

    #[allow(dead_code)]
    pub fn insert_if_atom_morphism(
        &mut self,
        mut tm0: IfAtomNode,
        mut tm1: Structure,
        mut tm2: Morphism,
    ) {
        tm0 = self.if_atom_node_equalities.root(tm0);
        tm1 = self.structure_equalities.root(tm1);
        tm2 = self.morphism_equalities.root(tm2);
        if self.if_atom_morphism.insert(IfAtomMorphism(tm0, tm1, tm2)) {
            let weight0 = &mut self.if_atom_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(IfAtomMorphismTable::WEIGHT);

            let weight1 = &mut self.structure_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(IfAtomMorphismTable::WEIGHT);

            let weight2 = &mut self.morphism_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(IfAtomMorphismTable::WEIGHT);
        }
    }

    /// Evaluates `then_atom_morphism(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn then_atom_morphism(
        &self,
        mut arg0: ThenAtomNode,
        mut arg1: Structure,
    ) -> Option<Morphism> {
        arg0 = self.root_then_atom_node(arg0);
        arg1 = self.root_structure(arg1);
        self.then_atom_morphism
            .iter_all_0_1(arg0, arg1)
            .next()
            .map(|t| t.2)
    }
    /// Returns an iterator over tuples in the graph of the `then_atom_morphism` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_then_atom_morphism(
        &self,
    ) -> impl '_ + Iterator<Item = (ThenAtomNode, Structure, Morphism)> {
        self.then_atom_morphism.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `then_atom_morphism(tm0, tm1) = tm2` hold.

    #[allow(dead_code)]
    pub fn insert_then_atom_morphism(
        &mut self,
        mut tm0: ThenAtomNode,
        mut tm1: Structure,
        mut tm2: Morphism,
    ) {
        tm0 = self.then_atom_node_equalities.root(tm0);
        tm1 = self.structure_equalities.root(tm1);
        tm2 = self.morphism_equalities.root(tm2);
        if self
            .then_atom_morphism
            .insert(ThenAtomMorphism(tm0, tm1, tm2))
        {
            let weight0 = &mut self.then_atom_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ThenAtomMorphismTable::WEIGHT);

            let weight1 = &mut self.structure_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ThenAtomMorphismTable::WEIGHT);

            let weight2 = &mut self.morphism_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(ThenAtomMorphismTable::WEIGHT);
        }
    }

    /// Evaluates `branch_stmt_morphism(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn branch_stmt_morphism(
        &self,
        mut arg0: StmtNode,
        mut arg1: Structure,
    ) -> Option<Morphism> {
        arg0 = self.root_stmt_node(arg0);
        arg1 = self.root_structure(arg1);
        self.branch_stmt_morphism
            .iter_all_0_1(arg0, arg1)
            .next()
            .map(|t| t.2)
    }
    /// Returns an iterator over tuples in the graph of the `branch_stmt_morphism` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_branch_stmt_morphism(
        &self,
    ) -> impl '_ + Iterator<Item = (StmtNode, Structure, Morphism)> {
        self.branch_stmt_morphism
            .iter_all()
            .map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `branch_stmt_morphism(tm0, tm1) = tm2` hold.

    #[allow(dead_code)]
    pub fn insert_branch_stmt_morphism(
        &mut self,
        mut tm0: StmtNode,
        mut tm1: Structure,
        mut tm2: Morphism,
    ) {
        tm0 = self.stmt_node_equalities.root(tm0);
        tm1 = self.structure_equalities.root(tm1);
        tm2 = self.morphism_equalities.root(tm2);
        if self
            .branch_stmt_morphism
            .insert(BranchStmtMorphism(tm0, tm1, tm2))
        {
            let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(BranchStmtMorphismTable::WEIGHT);

            let weight1 = &mut self.structure_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(BranchStmtMorphismTable::WEIGHT);

            let weight2 = &mut self.morphism_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(BranchStmtMorphismTable::WEIGHT);
        }
    }

    /// Evaluates `match_stmt_morphism(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn match_stmt_morphism(&self, mut arg0: StmtNode, mut arg1: Structure) -> Option<Morphism> {
        arg0 = self.root_stmt_node(arg0);
        arg1 = self.root_structure(arg1);
        self.match_stmt_morphism
            .iter_all_0_1(arg0, arg1)
            .next()
            .map(|t| t.2)
    }
    /// Returns an iterator over tuples in the graph of the `match_stmt_morphism` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_match_stmt_morphism(
        &self,
    ) -> impl '_ + Iterator<Item = (StmtNode, Structure, Morphism)> {
        self.match_stmt_morphism.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `match_stmt_morphism(tm0, tm1) = tm2` hold.

    #[allow(dead_code)]
    pub fn insert_match_stmt_morphism(
        &mut self,
        mut tm0: StmtNode,
        mut tm1: Structure,
        mut tm2: Morphism,
    ) {
        tm0 = self.stmt_node_equalities.root(tm0);
        tm1 = self.structure_equalities.root(tm1);
        tm2 = self.morphism_equalities.root(tm2);
        if self
            .match_stmt_morphism
            .insert(MatchStmtMorphism(tm0, tm1, tm2))
        {
            let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(MatchStmtMorphismTable::WEIGHT);

            let weight1 = &mut self.structure_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(MatchStmtMorphismTable::WEIGHT);

            let weight2 = &mut self.morphism_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(MatchStmtMorphismTable::WEIGHT);
        }
    }

    /// Evaluates `semantic_name(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn semantic_name(&self, mut arg0: VirtIdent, mut arg1: Scope) -> Option<ElName> {
        arg0 = self.root_virt_ident(arg0);
        arg1 = self.root_scope(arg1);
        self.semantic_name
            .iter_all_0_1(arg0, arg1)
            .next()
            .map(|t| t.2)
    }
    /// Returns an iterator over tuples in the graph of the `semantic_name` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_semantic_name(&self) -> impl '_ + Iterator<Item = (VirtIdent, Scope, ElName)> {
        self.semantic_name.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `semantic_name(tm0, tm1) = tm2` hold.

    #[allow(dead_code)]
    pub fn insert_semantic_name(&mut self, mut tm0: VirtIdent, mut tm1: Scope, mut tm2: ElName) {
        tm0 = self.virt_ident_equalities.root(tm0);
        tm1 = self.scope_equalities.root(tm1);
        tm2 = self.el_name_equalities.root(tm2);
        if self.semantic_name.insert(SemanticName(tm0, tm1, tm2)) {
            let weight0 = &mut self.virt_ident_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(SemanticNameTable::WEIGHT);

            let weight1 = &mut self.scope_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(SemanticNameTable::WEIGHT);

            let weight2 = &mut self.el_name_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(SemanticNameTable::WEIGHT);
        }
    }

    /// Evaluates `semantic_el(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn semantic_el(&self, mut arg0: TermNode, mut arg1: Structure) -> Option<El> {
        arg0 = self.root_term_node(arg0);
        arg1 = self.root_structure(arg1);
        self.semantic_el
            .iter_all_0_1(arg0, arg1)
            .next()
            .map(|t| t.2)
    }
    /// Returns an iterator over tuples in the graph of the `semantic_el` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_semantic_el(&self) -> impl '_ + Iterator<Item = (TermNode, Structure, El)> {
        self.semantic_el.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `semantic_el(tm0, tm1) = tm2` hold.

    #[allow(dead_code)]
    pub fn insert_semantic_el(&mut self, mut tm0: TermNode, mut tm1: Structure, mut tm2: El) {
        tm0 = self.term_node_equalities.root(tm0);
        tm1 = self.structure_equalities.root(tm1);
        tm2 = self.el_equalities.root(tm2);
        if self.semantic_el.insert(SemanticEl(tm0, tm1, tm2)) {
            let weight0 = &mut self.term_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(SemanticElTable::WEIGHT);

            let weight1 = &mut self.structure_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(SemanticElTable::WEIGHT);

            let weight2 = &mut self.el_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(SemanticElTable::WEIGHT);
        }
    }

    /// Evaluates `semantic_els(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn semantic_els(&self, mut arg0: TermListNode, mut arg1: Structure) -> Option<ElList> {
        arg0 = self.root_term_list_node(arg0);
        arg1 = self.root_structure(arg1);
        self.semantic_els
            .iter_all_0_1(arg0, arg1)
            .next()
            .map(|t| t.2)
    }
    /// Returns an iterator over tuples in the graph of the `semantic_els` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_semantic_els(
        &self,
    ) -> impl '_ + Iterator<Item = (TermListNode, Structure, ElList)> {
        self.semantic_els.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `semantic_els(tm0, tm1) = tm2` hold.

    #[allow(dead_code)]
    pub fn insert_semantic_els(
        &mut self,
        mut tm0: TermListNode,
        mut tm1: Structure,
        mut tm2: ElList,
    ) {
        tm0 = self.term_list_node_equalities.root(tm0);
        tm1 = self.structure_equalities.root(tm1);
        tm2 = self.el_list_equalities.root(tm2);
        if self.semantic_els.insert(SemanticEls(tm0, tm1, tm2)) {
            let weight0 = &mut self.term_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(SemanticElsTable::WEIGHT);

            let weight1 = &mut self.structure_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(SemanticElsTable::WEIGHT);

            let weight2 = &mut self.el_list_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(SemanticElsTable::WEIGHT);
        }
    }

    /// Evaluates `wildcard_name(arg0)`.
    #[allow(dead_code)]
    pub fn wildcard_name(&self, mut arg0: TermNode) -> Option<ElName> {
        arg0 = self.root_term_node(arg0);
        self.wildcard_name.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `wildcard_name` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_wildcard_name(&self) -> impl '_ + Iterator<Item = (TermNode, ElName)> {
        self.wildcard_name.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `wildcard_name(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_wildcard_name(&mut self, mut tm0: TermNode, mut tm1: ElName) {
        tm0 = self.term_node_equalities.root(tm0);
        tm1 = self.el_name_equalities.root(tm1);
        if self.wildcard_name.insert(WildcardName(tm0, tm1)) {
            let weight0 = &mut self.term_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(WildcardNameTable::WEIGHT);

            let weight1 = &mut self.el_name_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(WildcardNameTable::WEIGHT);
        }
    }

    /// Evaluates `match_case_pattern_ctor(arg0)`.
    #[allow(dead_code)]
    pub fn match_case_pattern_ctor(&self, mut arg0: MatchCaseNode) -> Option<CtorDeclNode> {
        arg0 = self.root_match_case_node(arg0);
        self.match_case_pattern_ctor
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `match_case_pattern_ctor` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_match_case_pattern_ctor(
        &self,
    ) -> impl '_ + Iterator<Item = (MatchCaseNode, CtorDeclNode)> {
        self.match_case_pattern_ctor.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `match_case_pattern_ctor(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_match_case_pattern_ctor(
        &mut self,
        mut tm0: MatchCaseNode,
        mut tm1: CtorDeclNode,
    ) {
        tm0 = self.match_case_node_equalities.root(tm0);
        tm1 = self.ctor_decl_node_equalities.root(tm1);
        if self
            .match_case_pattern_ctor
            .insert(MatchCasePatternCtor(tm0, tm1))
        {
            let weight0 = &mut self.match_case_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(MatchCasePatternCtorTable::WEIGHT);

            let weight1 = &mut self.ctor_decl_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(MatchCasePatternCtorTable::WEIGHT);
        }
    }

    /// Evaluates `cases_determined_enum(arg0)`.
    #[allow(dead_code)]
    pub fn cases_determined_enum(&self, mut arg0: MatchCaseListNode) -> Option<EnumDeclNode> {
        arg0 = self.root_match_case_list_node(arg0);
        self.cases_determined_enum
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Returns an iterator over tuples in the graph of the `cases_determined_enum` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_cases_determined_enum(
        &self,
    ) -> impl '_ + Iterator<Item = (MatchCaseListNode, EnumDeclNode)> {
        self.cases_determined_enum.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `cases_determined_enum(tm0) = tm1` hold.

    #[allow(dead_code)]
    pub fn insert_cases_determined_enum(
        &mut self,
        mut tm0: MatchCaseListNode,
        mut tm1: EnumDeclNode,
    ) {
        tm0 = self.match_case_list_node_equalities.root(tm0);
        tm1 = self.enum_decl_node_equalities.root(tm1);
        if self
            .cases_determined_enum
            .insert(CasesDeterminedEnum(tm0, tm1))
        {
            let weight0 = &mut self.match_case_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(CasesDeterminedEnumTable::WEIGHT);

            let weight1 = &mut self.enum_decl_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(CasesDeterminedEnumTable::WEIGHT);
        }
    }

    /// Enforces that `real_virt_ident(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_real_virt_ident(&mut self, tm0: Ident) -> VirtIdent {
        match self.real_virt_ident(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_virt_ident_internal();
                self.insert_real_virt_ident(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `virt_real_ident(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_virt_real_ident(&mut self, tm0: VirtIdent) -> Ident {
        match self.virt_real_ident(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_ident_internal();
                self.insert_virt_real_ident(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `rule_name(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_name(&mut self, tm0: RuleDeclNode) -> Ident {
        match self.rule_name(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_ident_internal();
                self.insert_rule_name(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `type_decl_node_loc(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_type_decl_node_loc(&mut self, tm0: TypeDeclNode) -> Loc {
        match self.type_decl_node_loc(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_loc_internal();
                self.insert_type_decl_node_loc(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `arg_decl_node_loc(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_arg_decl_node_loc(&mut self, tm0: ArgDeclNode) -> Loc {
        match self.arg_decl_node_loc(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_loc_internal();
                self.insert_arg_decl_node_loc(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `arg_decl_list_node_loc(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_arg_decl_list_node_loc(&mut self, tm0: ArgDeclListNode) -> Loc {
        match self.arg_decl_list_node_loc(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_loc_internal();
                self.insert_arg_decl_list_node_loc(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `pred_decl_node_loc(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_pred_decl_node_loc(&mut self, tm0: PredDeclNode) -> Loc {
        match self.pred_decl_node_loc(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_loc_internal();
                self.insert_pred_decl_node_loc(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `func_decl_node_loc(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_func_decl_node_loc(&mut self, tm0: FuncDeclNode) -> Loc {
        match self.func_decl_node_loc(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_loc_internal();
                self.insert_func_decl_node_loc(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `ctor_decl_node_loc(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_ctor_decl_node_loc(&mut self, tm0: CtorDeclNode) -> Loc {
        match self.ctor_decl_node_loc(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_loc_internal();
                self.insert_ctor_decl_node_loc(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `enum_decl_node_loc(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_enum_decl_node_loc(&mut self, tm0: EnumDeclNode) -> Loc {
        match self.enum_decl_node_loc(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_loc_internal();
                self.insert_enum_decl_node_loc(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `term_node_loc(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_term_node_loc(&mut self, tm0: TermNode) -> Loc {
        match self.term_node_loc(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_loc_internal();
                self.insert_term_node_loc(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `term_list_node_loc(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_term_list_node_loc(&mut self, tm0: TermListNode) -> Loc {
        match self.term_list_node_loc(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_loc_internal();
                self.insert_term_list_node_loc(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `match_case_node_loc(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_match_case_node_loc(&mut self, tm0: MatchCaseNode) -> Loc {
        match self.match_case_node_loc(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_loc_internal();
                self.insert_match_case_node_loc(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `opt_term_node_loc(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_opt_term_node_loc(&mut self, tm0: OptTermNode) -> Loc {
        match self.opt_term_node_loc(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_loc_internal();
                self.insert_opt_term_node_loc(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `if_atom_node_loc(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_if_atom_node_loc(&mut self, tm0: IfAtomNode) -> Loc {
        match self.if_atom_node_loc(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_loc_internal();
                self.insert_if_atom_node_loc(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `then_atom_node_loc(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_then_atom_node_loc(&mut self, tm0: ThenAtomNode) -> Loc {
        match self.then_atom_node_loc(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_loc_internal();
                self.insert_then_atom_node_loc(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `stmt_node_loc(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_stmt_node_loc(&mut self, tm0: StmtNode) -> Loc {
        match self.stmt_node_loc(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_loc_internal();
                self.insert_stmt_node_loc(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `stmt_list_node_loc(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_stmt_list_node_loc(&mut self, tm0: StmtListNode) -> Loc {
        match self.stmt_list_node_loc(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_loc_internal();
                self.insert_stmt_list_node_loc(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `rule_decl_node_loc(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_decl_node_loc(&mut self, tm0: RuleDeclNode) -> Loc {
        match self.rule_decl_node_loc(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_loc_internal();
                self.insert_rule_decl_node_loc(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `decl_node_loc(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_decl_node_loc(&mut self, tm0: DeclNode) -> Loc {
        match self.decl_node_loc(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_loc_internal();
                self.insert_decl_node_loc(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `decl_list_node_loc(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_decl_list_node_loc(&mut self, tm0: DeclListNode) -> Loc {
        match self.decl_list_node_loc(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_loc_internal();
                self.insert_decl_list_node_loc(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `module_node_loc(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_module_node_loc(&mut self, tm0: ModuleNode) -> Loc {
        match self.module_node_loc(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_loc_internal();
                self.insert_module_node_loc(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `rule_descendant_rule(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_descendant_rule(&mut self, tm0: RuleDeclNode) -> RuleDescendantNode {
        match self.rule_descendant_rule(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_rule_descendant_node_internal();
                self.insert_rule_descendant_rule(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `rule_descendant_term(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_descendant_term(&mut self, tm0: TermNode) -> RuleDescendantNode {
        match self.rule_descendant_term(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_rule_descendant_node_internal();
                self.insert_rule_descendant_term(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `rule_descendant_term_list(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_descendant_term_list(&mut self, tm0: TermListNode) -> RuleDescendantNode {
        match self.rule_descendant_term_list(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_rule_descendant_node_internal();
                self.insert_rule_descendant_term_list(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `rule_descendant_opt_term(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_descendant_opt_term(&mut self, tm0: OptTermNode) -> RuleDescendantNode {
        match self.rule_descendant_opt_term(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_rule_descendant_node_internal();
                self.insert_rule_descendant_opt_term(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `rule_descendant_if_atom(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_descendant_if_atom(&mut self, tm0: IfAtomNode) -> RuleDescendantNode {
        match self.rule_descendant_if_atom(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_rule_descendant_node_internal();
                self.insert_rule_descendant_if_atom(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `rule_descendant_then_atom(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_descendant_then_atom(&mut self, tm0: ThenAtomNode) -> RuleDescendantNode {
        match self.rule_descendant_then_atom(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_rule_descendant_node_internal();
                self.insert_rule_descendant_then_atom(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `rule_descendant_match_case(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_descendant_match_case(&mut self, tm0: MatchCaseNode) -> RuleDescendantNode {
        match self.rule_descendant_match_case(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_rule_descendant_node_internal();
                self.insert_rule_descendant_match_case(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `rule_descendant_match_case_list(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_descendant_match_case_list(
        &mut self,
        tm0: MatchCaseListNode,
    ) -> RuleDescendantNode {
        match self.rule_descendant_match_case_list(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_rule_descendant_node_internal();
                self.insert_rule_descendant_match_case_list(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `rule_descendant_stmt(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_descendant_stmt(&mut self, tm0: StmtNode) -> RuleDescendantNode {
        match self.rule_descendant_stmt(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_rule_descendant_node_internal();
                self.insert_rule_descendant_stmt(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `rule_descendant_stmt_list(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_descendant_stmt_list(&mut self, tm0: StmtListNode) -> RuleDescendantNode {
        match self.rule_descendant_stmt_list(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_rule_descendant_node_internal();
                self.insert_rule_descendant_stmt_list(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `rule_descendant_stmt_block_list(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_descendant_stmt_block_list(
        &mut self,
        tm0: StmtBlockListNode,
    ) -> RuleDescendantNode {
        match self.rule_descendant_stmt_block_list(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_rule_descendant_node_internal();
                self.insert_rule_descendant_stmt_block_list(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `entry_scope(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_entry_scope(&mut self, tm0: RuleDescendantNode) -> Scope {
        match self.entry_scope(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_scope_internal();
                self.insert_entry_scope(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `exit_scope(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_exit_scope(&mut self, tm0: RuleDescendantNode) -> Scope {
        match self.exit_scope(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_scope_internal();
                self.insert_exit_scope(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `ctor_enum(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_ctor_enum(&mut self, tm0: CtorDeclNode) -> EnumDeclNode {
        match self.ctor_enum(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_enum_decl_node_internal();
                self.insert_ctor_enum(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `ctors_enum(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_ctors_enum(&mut self, tm0: CtorDeclListNode) -> EnumDeclNode {
        match self.ctors_enum(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_enum_decl_node_internal();
                self.insert_ctors_enum(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `cases_discriminee(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_cases_discriminee(&mut self, tm0: MatchCaseListNode) -> TermNode {
        match self.cases_discriminee(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_term_node_internal();
                self.insert_cases_discriminee(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `case_discriminee(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_case_discriminee(&mut self, tm0: MatchCaseNode) -> TermNode {
        match self.case_discriminee(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_term_node_internal();
                self.insert_case_discriminee(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `desugared_case_equality_atom(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_desugared_case_equality_atom(&mut self, tm0: MatchCaseNode) -> IfAtomNode {
        match self.desugared_case_equality_atom(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_if_atom_node_internal();
                self.insert_desugared_case_equality_atom(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `desugared_case_equality_stmt(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_desugared_case_equality_stmt(&mut self, tm0: MatchCaseNode) -> StmtNode {
        match self.desugared_case_equality_stmt(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_stmt_node_internal();
                self.insert_desugared_case_equality_stmt(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `desugared_case_block(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_desugared_case_block(&mut self, tm0: MatchCaseNode) -> StmtListNode {
        match self.desugared_case_block(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_stmt_list_node_internal();
                self.insert_desugared_case_block(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `desugared_case_block_list(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_desugared_case_block_list(
        &mut self,
        tm0: MatchCaseListNode,
    ) -> StmtBlockListNode {
        match self.desugared_case_block_list(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_stmt_block_list_node_internal();
                self.insert_desugared_case_block_list(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `semantic_type(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_semantic_type(&mut self, tm0: Ident) -> Type {
        match self.semantic_type(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_type_internal();
                self.insert_semantic_type(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `semantic_pred(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_semantic_pred(&mut self, tm0: Ident) -> Pred {
        match self.semantic_pred(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_pred_internal();
                self.insert_semantic_pred(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `semantic_func(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_semantic_func(&mut self, tm0: Ident) -> Func {
        match self.semantic_func(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_func_internal();
                self.insert_semantic_func(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `codomain(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_codomain(&mut self, tm0: Func) -> Type {
        match self.codomain(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_type_internal();
                self.insert_codomain(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `var(tm0, tm1)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_var(&mut self, tm0: Structure, tm1: ElName) -> El {
        match self.var(tm0, tm1) {
            Some(result) => result,
            None => {
                let tm2 = self.new_el_internal();
                self.insert_var(tm0, tm1, tm2);
                tm2
            }
        }
    }
    /// Enforces that `el_structure(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_el_structure(&mut self, tm0: El) -> Structure {
        match self.el_structure(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_structure_internal();
                self.insert_el_structure(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `els_structure(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_els_structure(&mut self, tm0: ElList) -> Structure {
        match self.els_structure(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_structure_internal();
                self.insert_els_structure(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `func_app(tm0, tm1)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_func_app(&mut self, tm0: Func, tm1: ElList) -> El {
        match self.func_app(tm0, tm1) {
            Some(result) => result,
            None => {
                let tm2 = self.new_el_internal();
                self.insert_func_app(tm0, tm1, tm2);
                tm2
            }
        }
    }
    /// Enforces that `dom(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_dom(&mut self, tm0: Morphism) -> Structure {
        match self.dom(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_structure_internal();
                self.insert_dom(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `cod(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_cod(&mut self, tm0: Morphism) -> Structure {
        match self.cod(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_structure_internal();
                self.insert_cod(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `map_el(tm0, tm1)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_map_el(&mut self, tm0: Morphism, tm1: El) -> El {
        match self.map_el(tm0, tm1) {
            Some(result) => result,
            None => {
                let tm2 = self.new_el_internal();
                self.insert_map_el(tm0, tm1, tm2);
                tm2
            }
        }
    }
    /// Enforces that `type_symbol()` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_type_symbol(&mut self) -> SymbolKind {
        match self.type_symbol() {
            Some(result) => result,
            None => {
                let tm0 = self.new_symbol_kind_internal();
                self.insert_type_symbol(tm0);
                tm0
            }
        }
    }
    /// Enforces that `pred_symbol()` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_pred_symbol(&mut self) -> SymbolKind {
        match self.pred_symbol() {
            Some(result) => result,
            None => {
                let tm0 = self.new_symbol_kind_internal();
                self.insert_pred_symbol(tm0);
                tm0
            }
        }
    }
    /// Enforces that `func_symbol()` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_func_symbol(&mut self) -> SymbolKind {
        match self.func_symbol() {
            Some(result) => result,
            None => {
                let tm0 = self.new_symbol_kind_internal();
                self.insert_func_symbol(tm0);
                tm0
            }
        }
    }
    /// Enforces that `rule_symbol()` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_symbol(&mut self) -> SymbolKind {
        match self.rule_symbol() {
            Some(result) => result,
            None => {
                let tm0 = self.new_symbol_kind_internal();
                self.insert_rule_symbol(tm0);
                tm0
            }
        }
    }
    /// Enforces that `enum_symbol()` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_enum_symbol(&mut self) -> SymbolKind {
        match self.enum_symbol() {
            Some(result) => result,
            None => {
                let tm0 = self.new_symbol_kind_internal();
                self.insert_enum_symbol(tm0);
                tm0
            }
        }
    }
    /// Enforces that `ctor_symbol()` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_ctor_symbol(&mut self) -> SymbolKind {
        match self.ctor_symbol() {
            Some(result) => result,
            None => {
                let tm0 = self.new_symbol_kind_internal();
                self.insert_ctor_symbol(tm0);
                tm0
            }
        }
    }
    /// Enforces that `zero()` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_zero(&mut self) -> Nat {
        match self.zero() {
            Some(result) => result,
            None => {
                let tm0 = self.new_nat_internal();
                self.insert_zero(tm0);
                tm0
            }
        }
    }
    /// Enforces that `succ(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_succ(&mut self, tm0: Nat) -> Nat {
        match self.succ(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_nat_internal();
                self.insert_succ(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `type_list_len(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_type_list_len(&mut self, tm0: TypeList) -> Nat {
        match self.type_list_len(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_nat_internal();
                self.insert_type_list_len(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `term_list_len(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_term_list_len(&mut self, tm0: TermListNode) -> Nat {
        match self.term_list_len(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_nat_internal();
                self.insert_term_list_len(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `before_rule_structure(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_before_rule_structure(&mut self, tm0: RuleDeclNode) -> Structure {
        match self.before_rule_structure(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_structure_internal();
                self.insert_before_rule_structure(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `if_atom_morphism(tm0, tm1)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_if_atom_morphism(&mut self, tm0: IfAtomNode, tm1: Structure) -> Morphism {
        match self.if_atom_morphism(tm0, tm1) {
            Some(result) => result,
            None => {
                let tm2 = self.new_morphism_internal();
                self.insert_if_atom_morphism(tm0, tm1, tm2);
                tm2
            }
        }
    }
    /// Enforces that `then_atom_morphism(tm0, tm1)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_then_atom_morphism(&mut self, tm0: ThenAtomNode, tm1: Structure) -> Morphism {
        match self.then_atom_morphism(tm0, tm1) {
            Some(result) => result,
            None => {
                let tm2 = self.new_morphism_internal();
                self.insert_then_atom_morphism(tm0, tm1, tm2);
                tm2
            }
        }
    }
    /// Enforces that `branch_stmt_morphism(tm0, tm1)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_branch_stmt_morphism(&mut self, tm0: StmtNode, tm1: Structure) -> Morphism {
        match self.branch_stmt_morphism(tm0, tm1) {
            Some(result) => result,
            None => {
                let tm2 = self.new_morphism_internal();
                self.insert_branch_stmt_morphism(tm0, tm1, tm2);
                tm2
            }
        }
    }
    /// Enforces that `match_stmt_morphism(tm0, tm1)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_match_stmt_morphism(&mut self, tm0: StmtNode, tm1: Structure) -> Morphism {
        match self.match_stmt_morphism(tm0, tm1) {
            Some(result) => result,
            None => {
                let tm2 = self.new_morphism_internal();
                self.insert_match_stmt_morphism(tm0, tm1, tm2);
                tm2
            }
        }
    }
    /// Enforces that `semantic_name(tm0, tm1)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_semantic_name(&mut self, tm0: VirtIdent, tm1: Scope) -> ElName {
        match self.semantic_name(tm0, tm1) {
            Some(result) => result,
            None => {
                let tm2 = self.new_el_name_internal();
                self.insert_semantic_name(tm0, tm1, tm2);
                tm2
            }
        }
    }
    /// Enforces that `semantic_el(tm0, tm1)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_semantic_el(&mut self, tm0: TermNode, tm1: Structure) -> El {
        match self.semantic_el(tm0, tm1) {
            Some(result) => result,
            None => {
                let tm2 = self.new_el_internal();
                self.insert_semantic_el(tm0, tm1, tm2);
                tm2
            }
        }
    }
    /// Enforces that `wildcard_name(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_wildcard_name(&mut self, tm0: TermNode) -> ElName {
        match self.wildcard_name(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_el_name_internal();
                self.insert_wildcard_name(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `match_case_pattern_ctor(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_match_case_pattern_ctor(&mut self, tm0: MatchCaseNode) -> CtorDeclNode {
        match self.match_case_pattern_ctor(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_ctor_decl_node_internal();
                self.insert_match_case_pattern_ctor(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `cases_determined_enum(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_cases_determined_enum(&mut self, tm0: MatchCaseListNode) -> EnumDeclNode {
        match self.cases_determined_enum(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_enum_decl_node_internal();
                self.insert_cases_determined_enum(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `nil_type_list()` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_nil_type_list(&mut self) -> TypeList {
        match self.nil_type_list() {
            Some(result) => result,
            None => {
                let tm0 = self.new_type_list_internal();
                self.insert_nil_type_list(tm0);
                tm0
            }
        }
    }
    /// Enforces that `cons_type_list(tm0, tm1)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_cons_type_list(&mut self, tm0: Type, tm1: TypeList) -> TypeList {
        match self.cons_type_list(tm0, tm1) {
            Some(result) => result,
            None => {
                let tm2 = self.new_type_list_internal();
                self.insert_cons_type_list(tm0, tm1, tm2);
                tm2
            }
        }
    }
    /// Enforces that `snoc_type_list(tm0, tm1)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_snoc_type_list(&mut self, tm0: TypeList, tm1: Type) -> TypeList {
        match self.snoc_type_list(tm0, tm1) {
            Some(result) => result,
            None => {
                let tm2 = self.new_type_list_internal();
                self.insert_snoc_type_list(tm0, tm1, tm2);
                tm2
            }
        }
    }
    /// Enforces that `pred_rel(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_pred_rel(&mut self, tm0: Pred) -> Rel {
        match self.pred_rel(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_rel_internal();
                self.insert_pred_rel(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `func_rel(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_func_rel(&mut self, tm0: Func) -> Rel {
        match self.func_rel(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_rel_internal();
                self.insert_func_rel(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `nil_el_list(tm0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_nil_el_list(&mut self, tm0: Structure) -> ElList {
        match self.nil_el_list(tm0) {
            Some(result) => result,
            None => {
                let tm1 = self.new_el_list_internal();
                self.insert_nil_el_list(tm0, tm1);
                tm1
            }
        }
    }
    /// Enforces that `cons_el_list(tm0, tm1)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_cons_el_list(&mut self, tm0: El, tm1: ElList) -> ElList {
        match self.cons_el_list(tm0, tm1) {
            Some(result) => result,
            None => {
                let tm2 = self.new_el_list_internal();
                self.insert_cons_el_list(tm0, tm1, tm2);
                tm2
            }
        }
    }
    /// Enforces that `snoc_el_list(tm0, tm1)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_snoc_el_list(&mut self, tm0: ElList, tm1: El) -> ElList {
        match self.snoc_el_list(tm0, tm1) {
            Some(result) => result,
            None => {
                let tm2 = self.new_el_list_internal();
                self.insert_snoc_el_list(tm0, tm1, tm2);
                tm2
            }
        }
    }
    /// Returns `true` if `absurd()` holds.
    #[allow(dead_code)]
    pub fn absurd(&self) -> bool {
        self.absurd.contains(Absurd())
    }
    /// Makes `absurd()` hold.

    #[allow(dead_code)]
    pub fn insert_absurd(&mut self) {
        if self.absurd.insert(Absurd()) {}
    }

    /// Returns `true` if `type_decl(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn type_decl(&self, mut arg0: TypeDeclNode, mut arg1: Ident) -> bool {
        arg0 = self.root_type_decl_node(arg0);
        arg1 = self.root_ident(arg1);
        self.type_decl.contains(TypeDecl(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `type_decl` predicate.

    #[allow(dead_code)]
    pub fn iter_type_decl(&self) -> impl '_ + Iterator<Item = (TypeDeclNode, Ident)> {
        self.type_decl.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `type_decl(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_type_decl(&mut self, mut tm0: TypeDeclNode, mut tm1: Ident) {
        tm0 = self.type_decl_node_equalities.root(tm0);
        tm1 = self.ident_equalities.root(tm1);
        if self.type_decl.insert(TypeDecl(tm0, tm1)) {
            let weight0 = &mut self.type_decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(TypeDeclTable::WEIGHT);

            let weight1 = &mut self.ident_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(TypeDeclTable::WEIGHT);
        }
    }

    /// Returns `true` if `arg_decl_node_name(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn arg_decl_node_name(&self, mut arg0: ArgDeclNode, mut arg1: Ident) -> bool {
        arg0 = self.root_arg_decl_node(arg0);
        arg1 = self.root_ident(arg1);
        self.arg_decl_node_name
            .contains(ArgDeclNodeName(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `arg_decl_node_name` predicate.

    #[allow(dead_code)]
    pub fn iter_arg_decl_node_name(&self) -> impl '_ + Iterator<Item = (ArgDeclNode, Ident)> {
        self.arg_decl_node_name.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `arg_decl_node_name(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_arg_decl_node_name(&mut self, mut tm0: ArgDeclNode, mut tm1: Ident) {
        tm0 = self.arg_decl_node_equalities.root(tm0);
        tm1 = self.ident_equalities.root(tm1);
        if self.arg_decl_node_name.insert(ArgDeclNodeName(tm0, tm1)) {
            let weight0 = &mut self.arg_decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ArgDeclNodeNameTable::WEIGHT);

            let weight1 = &mut self.ident_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ArgDeclNodeNameTable::WEIGHT);
        }
    }

    /// Returns `true` if `arg_decl_node_type(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn arg_decl_node_type(&self, mut arg0: ArgDeclNode, mut arg1: Ident) -> bool {
        arg0 = self.root_arg_decl_node(arg0);
        arg1 = self.root_ident(arg1);
        self.arg_decl_node_type
            .contains(ArgDeclNodeType(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `arg_decl_node_type` predicate.

    #[allow(dead_code)]
    pub fn iter_arg_decl_node_type(&self) -> impl '_ + Iterator<Item = (ArgDeclNode, Ident)> {
        self.arg_decl_node_type.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `arg_decl_node_type(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_arg_decl_node_type(&mut self, mut tm0: ArgDeclNode, mut tm1: Ident) {
        tm0 = self.arg_decl_node_equalities.root(tm0);
        tm1 = self.ident_equalities.root(tm1);
        if self.arg_decl_node_type.insert(ArgDeclNodeType(tm0, tm1)) {
            let weight0 = &mut self.arg_decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ArgDeclNodeTypeTable::WEIGHT);

            let weight1 = &mut self.ident_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ArgDeclNodeTypeTable::WEIGHT);
        }
    }

    /// Returns `true` if `nil_arg_decl_list_node(arg0)` holds.
    #[allow(dead_code)]
    pub fn nil_arg_decl_list_node(&self, mut arg0: ArgDeclListNode) -> bool {
        arg0 = self.root_arg_decl_list_node(arg0);
        self.nil_arg_decl_list_node
            .contains(NilArgDeclListNode(arg0))
    }
    /// Returns an iterator over elements satisfying the `nil_arg_decl_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_nil_arg_decl_list_node(&self) -> impl '_ + Iterator<Item = ArgDeclListNode> {
        self.nil_arg_decl_list_node.iter_all().map(|t| t.0)
    }
    /// Makes `nil_arg_decl_list_node(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_nil_arg_decl_list_node(&mut self, mut tm0: ArgDeclListNode) {
        tm0 = self.arg_decl_list_node_equalities.root(tm0);
        if self.nil_arg_decl_list_node.insert(NilArgDeclListNode(tm0)) {
            let weight0 = &mut self.arg_decl_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(NilArgDeclListNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `cons_arg_decl_list_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn cons_arg_decl_list_node(
        &self,
        mut arg0: ArgDeclListNode,
        mut arg1: ArgDeclNode,
        mut arg2: ArgDeclListNode,
    ) -> bool {
        arg0 = self.root_arg_decl_list_node(arg0);
        arg1 = self.root_arg_decl_node(arg1);
        arg2 = self.root_arg_decl_list_node(arg2);
        self.cons_arg_decl_list_node
            .contains(ConsArgDeclListNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `cons_arg_decl_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_cons_arg_decl_list_node(
        &self,
    ) -> impl '_ + Iterator<Item = (ArgDeclListNode, ArgDeclNode, ArgDeclListNode)> {
        self.cons_arg_decl_list_node
            .iter_all()
            .map(|t| (t.0, t.1, t.2))
    }
    /// Makes `cons_arg_decl_list_node(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_cons_arg_decl_list_node(
        &mut self,
        mut tm0: ArgDeclListNode,
        mut tm1: ArgDeclNode,
        mut tm2: ArgDeclListNode,
    ) {
        tm0 = self.arg_decl_list_node_equalities.root(tm0);
        tm1 = self.arg_decl_node_equalities.root(tm1);
        tm2 = self.arg_decl_list_node_equalities.root(tm2);
        if self
            .cons_arg_decl_list_node
            .insert(ConsArgDeclListNode(tm0, tm1, tm2))
        {
            let weight0 = &mut self.arg_decl_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ConsArgDeclListNodeTable::WEIGHT);

            let weight1 = &mut self.arg_decl_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ConsArgDeclListNodeTable::WEIGHT);

            let weight2 = &mut self.arg_decl_list_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(ConsArgDeclListNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `pred_decl(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn pred_decl(
        &self,
        mut arg0: PredDeclNode,
        mut arg1: Ident,
        mut arg2: ArgDeclListNode,
    ) -> bool {
        arg0 = self.root_pred_decl_node(arg0);
        arg1 = self.root_ident(arg1);
        arg2 = self.root_arg_decl_list_node(arg2);
        self.pred_decl.contains(PredDecl(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `pred_decl` predicate.

    #[allow(dead_code)]
    pub fn iter_pred_decl(
        &self,
    ) -> impl '_ + Iterator<Item = (PredDeclNode, Ident, ArgDeclListNode)> {
        self.pred_decl.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `pred_decl(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_pred_decl(
        &mut self,
        mut tm0: PredDeclNode,
        mut tm1: Ident,
        mut tm2: ArgDeclListNode,
    ) {
        tm0 = self.pred_decl_node_equalities.root(tm0);
        tm1 = self.ident_equalities.root(tm1);
        tm2 = self.arg_decl_list_node_equalities.root(tm2);
        if self.pred_decl.insert(PredDecl(tm0, tm1, tm2)) {
            let weight0 = &mut self.pred_decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(PredDeclTable::WEIGHT);

            let weight1 = &mut self.ident_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(PredDeclTable::WEIGHT);

            let weight2 = &mut self.arg_decl_list_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(PredDeclTable::WEIGHT);
        }
    }

    /// Returns `true` if `func_decl(arg0, arg1, arg2, arg3)` holds.
    #[allow(dead_code)]
    pub fn func_decl(
        &self,
        mut arg0: FuncDeclNode,
        mut arg1: Ident,
        mut arg2: ArgDeclListNode,
        mut arg3: Ident,
    ) -> bool {
        arg0 = self.root_func_decl_node(arg0);
        arg1 = self.root_ident(arg1);
        arg2 = self.root_arg_decl_list_node(arg2);
        arg3 = self.root_ident(arg3);
        self.func_decl.contains(FuncDecl(arg0, arg1, arg2, arg3))
    }
    /// Returns an iterator over tuples of elements satisfying the `func_decl` predicate.

    #[allow(dead_code)]
    pub fn iter_func_decl(
        &self,
    ) -> impl '_ + Iterator<Item = (FuncDeclNode, Ident, ArgDeclListNode, Ident)> {
        self.func_decl.iter_all().map(|t| (t.0, t.1, t.2, t.3))
    }
    /// Makes `func_decl(tm0, tm1, tm2, tm3)` hold.

    #[allow(dead_code)]
    pub fn insert_func_decl(
        &mut self,
        mut tm0: FuncDeclNode,
        mut tm1: Ident,
        mut tm2: ArgDeclListNode,
        mut tm3: Ident,
    ) {
        tm0 = self.func_decl_node_equalities.root(tm0);
        tm1 = self.ident_equalities.root(tm1);
        tm2 = self.arg_decl_list_node_equalities.root(tm2);
        tm3 = self.ident_equalities.root(tm3);
        if self.func_decl.insert(FuncDecl(tm0, tm1, tm2, tm3)) {
            let weight0 = &mut self.func_decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(FuncDeclTable::WEIGHT);

            let weight1 = &mut self.ident_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(FuncDeclTable::WEIGHT);

            let weight2 = &mut self.arg_decl_list_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(FuncDeclTable::WEIGHT);

            let weight3 = &mut self.ident_weights[tm3.0 as usize];
            *weight3 = weight3.saturating_add(FuncDeclTable::WEIGHT);
        }
    }

    /// Returns `true` if `ctor_decl(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn ctor_decl(
        &self,
        mut arg0: CtorDeclNode,
        mut arg1: Ident,
        mut arg2: ArgDeclListNode,
    ) -> bool {
        arg0 = self.root_ctor_decl_node(arg0);
        arg1 = self.root_ident(arg1);
        arg2 = self.root_arg_decl_list_node(arg2);
        self.ctor_decl.contains(CtorDecl(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `ctor_decl` predicate.

    #[allow(dead_code)]
    pub fn iter_ctor_decl(
        &self,
    ) -> impl '_ + Iterator<Item = (CtorDeclNode, Ident, ArgDeclListNode)> {
        self.ctor_decl.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `ctor_decl(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_ctor_decl(
        &mut self,
        mut tm0: CtorDeclNode,
        mut tm1: Ident,
        mut tm2: ArgDeclListNode,
    ) {
        tm0 = self.ctor_decl_node_equalities.root(tm0);
        tm1 = self.ident_equalities.root(tm1);
        tm2 = self.arg_decl_list_node_equalities.root(tm2);
        if self.ctor_decl.insert(CtorDecl(tm0, tm1, tm2)) {
            let weight0 = &mut self.ctor_decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(CtorDeclTable::WEIGHT);

            let weight1 = &mut self.ident_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(CtorDeclTable::WEIGHT);

            let weight2 = &mut self.arg_decl_list_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(CtorDeclTable::WEIGHT);
        }
    }

    /// Returns `true` if `nil_ctor_decl_list_node(arg0)` holds.
    #[allow(dead_code)]
    pub fn nil_ctor_decl_list_node(&self, mut arg0: CtorDeclListNode) -> bool {
        arg0 = self.root_ctor_decl_list_node(arg0);
        self.nil_ctor_decl_list_node
            .contains(NilCtorDeclListNode(arg0))
    }
    /// Returns an iterator over elements satisfying the `nil_ctor_decl_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_nil_ctor_decl_list_node(&self) -> impl '_ + Iterator<Item = CtorDeclListNode> {
        self.nil_ctor_decl_list_node.iter_all().map(|t| t.0)
    }
    /// Makes `nil_ctor_decl_list_node(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_nil_ctor_decl_list_node(&mut self, mut tm0: CtorDeclListNode) {
        tm0 = self.ctor_decl_list_node_equalities.root(tm0);
        if self
            .nil_ctor_decl_list_node
            .insert(NilCtorDeclListNode(tm0))
        {
            let weight0 = &mut self.ctor_decl_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(NilCtorDeclListNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `cons_ctor_decl_list_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn cons_ctor_decl_list_node(
        &self,
        mut arg0: CtorDeclListNode,
        mut arg1: CtorDeclNode,
        mut arg2: CtorDeclListNode,
    ) -> bool {
        arg0 = self.root_ctor_decl_list_node(arg0);
        arg1 = self.root_ctor_decl_node(arg1);
        arg2 = self.root_ctor_decl_list_node(arg2);
        self.cons_ctor_decl_list_node
            .contains(ConsCtorDeclListNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `cons_ctor_decl_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_cons_ctor_decl_list_node(
        &self,
    ) -> impl '_ + Iterator<Item = (CtorDeclListNode, CtorDeclNode, CtorDeclListNode)> {
        self.cons_ctor_decl_list_node
            .iter_all()
            .map(|t| (t.0, t.1, t.2))
    }
    /// Makes `cons_ctor_decl_list_node(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_cons_ctor_decl_list_node(
        &mut self,
        mut tm0: CtorDeclListNode,
        mut tm1: CtorDeclNode,
        mut tm2: CtorDeclListNode,
    ) {
        tm0 = self.ctor_decl_list_node_equalities.root(tm0);
        tm1 = self.ctor_decl_node_equalities.root(tm1);
        tm2 = self.ctor_decl_list_node_equalities.root(tm2);
        if self
            .cons_ctor_decl_list_node
            .insert(ConsCtorDeclListNode(tm0, tm1, tm2))
        {
            let weight0 = &mut self.ctor_decl_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ConsCtorDeclListNodeTable::WEIGHT);

            let weight1 = &mut self.ctor_decl_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ConsCtorDeclListNodeTable::WEIGHT);

            let weight2 = &mut self.ctor_decl_list_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(ConsCtorDeclListNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `enum_decl(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn enum_decl(
        &self,
        mut arg0: EnumDeclNode,
        mut arg1: Ident,
        mut arg2: CtorDeclListNode,
    ) -> bool {
        arg0 = self.root_enum_decl_node(arg0);
        arg1 = self.root_ident(arg1);
        arg2 = self.root_ctor_decl_list_node(arg2);
        self.enum_decl.contains(EnumDecl(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `enum_decl` predicate.

    #[allow(dead_code)]
    pub fn iter_enum_decl(
        &self,
    ) -> impl '_ + Iterator<Item = (EnumDeclNode, Ident, CtorDeclListNode)> {
        self.enum_decl.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `enum_decl(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_enum_decl(
        &mut self,
        mut tm0: EnumDeclNode,
        mut tm1: Ident,
        mut tm2: CtorDeclListNode,
    ) {
        tm0 = self.enum_decl_node_equalities.root(tm0);
        tm1 = self.ident_equalities.root(tm1);
        tm2 = self.ctor_decl_list_node_equalities.root(tm2);
        if self.enum_decl.insert(EnumDecl(tm0, tm1, tm2)) {
            let weight0 = &mut self.enum_decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(EnumDeclTable::WEIGHT);

            let weight1 = &mut self.ident_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(EnumDeclTable::WEIGHT);

            let weight2 = &mut self.ctor_decl_list_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(EnumDeclTable::WEIGHT);
        }
    }

    /// Returns `true` if `nil_term_list_node(arg0)` holds.
    #[allow(dead_code)]
    pub fn nil_term_list_node(&self, mut arg0: TermListNode) -> bool {
        arg0 = self.root_term_list_node(arg0);
        self.nil_term_list_node.contains(NilTermListNode(arg0))
    }
    /// Returns an iterator over elements satisfying the `nil_term_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_nil_term_list_node(&self) -> impl '_ + Iterator<Item = TermListNode> {
        self.nil_term_list_node.iter_all().map(|t| t.0)
    }
    /// Makes `nil_term_list_node(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_nil_term_list_node(&mut self, mut tm0: TermListNode) {
        tm0 = self.term_list_node_equalities.root(tm0);
        if self.nil_term_list_node.insert(NilTermListNode(tm0)) {
            let weight0 = &mut self.term_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(NilTermListNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `cons_term_list_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn cons_term_list_node(
        &self,
        mut arg0: TermListNode,
        mut arg1: TermNode,
        mut arg2: TermListNode,
    ) -> bool {
        arg0 = self.root_term_list_node(arg0);
        arg1 = self.root_term_node(arg1);
        arg2 = self.root_term_list_node(arg2);
        self.cons_term_list_node
            .contains(ConsTermListNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `cons_term_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_cons_term_list_node(
        &self,
    ) -> impl '_ + Iterator<Item = (TermListNode, TermNode, TermListNode)> {
        self.cons_term_list_node.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `cons_term_list_node(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_cons_term_list_node(
        &mut self,
        mut tm0: TermListNode,
        mut tm1: TermNode,
        mut tm2: TermListNode,
    ) {
        tm0 = self.term_list_node_equalities.root(tm0);
        tm1 = self.term_node_equalities.root(tm1);
        tm2 = self.term_list_node_equalities.root(tm2);
        if self
            .cons_term_list_node
            .insert(ConsTermListNode(tm0, tm1, tm2))
        {
            let weight0 = &mut self.term_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ConsTermListNodeTable::WEIGHT);

            let weight1 = &mut self.term_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ConsTermListNodeTable::WEIGHT);

            let weight2 = &mut self.term_list_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(ConsTermListNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `none_term_node(arg0)` holds.
    #[allow(dead_code)]
    pub fn none_term_node(&self, mut arg0: OptTermNode) -> bool {
        arg0 = self.root_opt_term_node(arg0);
        self.none_term_node.contains(NoneTermNode(arg0))
    }
    /// Returns an iterator over elements satisfying the `none_term_node` predicate.

    #[allow(dead_code)]
    pub fn iter_none_term_node(&self) -> impl '_ + Iterator<Item = OptTermNode> {
        self.none_term_node.iter_all().map(|t| t.0)
    }
    /// Makes `none_term_node(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_none_term_node(&mut self, mut tm0: OptTermNode) {
        tm0 = self.opt_term_node_equalities.root(tm0);
        if self.none_term_node.insert(NoneTermNode(tm0)) {
            let weight0 = &mut self.opt_term_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(NoneTermNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `some_term_node(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn some_term_node(&self, mut arg0: OptTermNode, mut arg1: TermNode) -> bool {
        arg0 = self.root_opt_term_node(arg0);
        arg1 = self.root_term_node(arg1);
        self.some_term_node.contains(SomeTermNode(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `some_term_node` predicate.

    #[allow(dead_code)]
    pub fn iter_some_term_node(&self) -> impl '_ + Iterator<Item = (OptTermNode, TermNode)> {
        self.some_term_node.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `some_term_node(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_some_term_node(&mut self, mut tm0: OptTermNode, mut tm1: TermNode) {
        tm0 = self.opt_term_node_equalities.root(tm0);
        tm1 = self.term_node_equalities.root(tm1);
        if self.some_term_node.insert(SomeTermNode(tm0, tm1)) {
            let weight0 = &mut self.opt_term_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(SomeTermNodeTable::WEIGHT);

            let weight1 = &mut self.term_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(SomeTermNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `var_term_node(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn var_term_node(&self, mut arg0: TermNode, mut arg1: VirtIdent) -> bool {
        arg0 = self.root_term_node(arg0);
        arg1 = self.root_virt_ident(arg1);
        self.var_term_node.contains(VarTermNode(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `var_term_node` predicate.

    #[allow(dead_code)]
    pub fn iter_var_term_node(&self) -> impl '_ + Iterator<Item = (TermNode, VirtIdent)> {
        self.var_term_node.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `var_term_node(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_var_term_node(&mut self, mut tm0: TermNode, mut tm1: VirtIdent) {
        tm0 = self.term_node_equalities.root(tm0);
        tm1 = self.virt_ident_equalities.root(tm1);
        if self.var_term_node.insert(VarTermNode(tm0, tm1)) {
            let weight0 = &mut self.term_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(VarTermNodeTable::WEIGHT);

            let weight1 = &mut self.virt_ident_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(VarTermNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `wildcard_term_node(arg0)` holds.
    #[allow(dead_code)]
    pub fn wildcard_term_node(&self, mut arg0: TermNode) -> bool {
        arg0 = self.root_term_node(arg0);
        self.wildcard_term_node.contains(WildcardTermNode(arg0))
    }
    /// Returns an iterator over elements satisfying the `wildcard_term_node` predicate.

    #[allow(dead_code)]
    pub fn iter_wildcard_term_node(&self) -> impl '_ + Iterator<Item = TermNode> {
        self.wildcard_term_node.iter_all().map(|t| t.0)
    }
    /// Makes `wildcard_term_node(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_wildcard_term_node(&mut self, mut tm0: TermNode) {
        tm0 = self.term_node_equalities.root(tm0);
        if self.wildcard_term_node.insert(WildcardTermNode(tm0)) {
            let weight0 = &mut self.term_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(WildcardTermNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `app_term_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn app_term_node(
        &self,
        mut arg0: TermNode,
        mut arg1: Ident,
        mut arg2: TermListNode,
    ) -> bool {
        arg0 = self.root_term_node(arg0);
        arg1 = self.root_ident(arg1);
        arg2 = self.root_term_list_node(arg2);
        self.app_term_node.contains(AppTermNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `app_term_node` predicate.

    #[allow(dead_code)]
    pub fn iter_app_term_node(&self) -> impl '_ + Iterator<Item = (TermNode, Ident, TermListNode)> {
        self.app_term_node.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `app_term_node(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_app_term_node(
        &mut self,
        mut tm0: TermNode,
        mut tm1: Ident,
        mut tm2: TermListNode,
    ) {
        tm0 = self.term_node_equalities.root(tm0);
        tm1 = self.ident_equalities.root(tm1);
        tm2 = self.term_list_node_equalities.root(tm2);
        if self.app_term_node.insert(AppTermNode(tm0, tm1, tm2)) {
            let weight0 = &mut self.term_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(AppTermNodeTable::WEIGHT);

            let weight1 = &mut self.ident_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(AppTermNodeTable::WEIGHT);

            let weight2 = &mut self.term_list_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(AppTermNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `match_case(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn match_case(
        &self,
        mut arg0: MatchCaseNode,
        mut arg1: TermNode,
        mut arg2: StmtListNode,
    ) -> bool {
        arg0 = self.root_match_case_node(arg0);
        arg1 = self.root_term_node(arg1);
        arg2 = self.root_stmt_list_node(arg2);
        self.match_case.contains(MatchCase(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `match_case` predicate.

    #[allow(dead_code)]
    pub fn iter_match_case(
        &self,
    ) -> impl '_ + Iterator<Item = (MatchCaseNode, TermNode, StmtListNode)> {
        self.match_case.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `match_case(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_match_case(
        &mut self,
        mut tm0: MatchCaseNode,
        mut tm1: TermNode,
        mut tm2: StmtListNode,
    ) {
        tm0 = self.match_case_node_equalities.root(tm0);
        tm1 = self.term_node_equalities.root(tm1);
        tm2 = self.stmt_list_node_equalities.root(tm2);
        if self.match_case.insert(MatchCase(tm0, tm1, tm2)) {
            let weight0 = &mut self.match_case_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(MatchCaseTable::WEIGHT);

            let weight1 = &mut self.term_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(MatchCaseTable::WEIGHT);

            let weight2 = &mut self.stmt_list_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(MatchCaseTable::WEIGHT);
        }
    }

    /// Returns `true` if `nil_match_case_list_node(arg0)` holds.
    #[allow(dead_code)]
    pub fn nil_match_case_list_node(&self, mut arg0: MatchCaseListNode) -> bool {
        arg0 = self.root_match_case_list_node(arg0);
        self.nil_match_case_list_node
            .contains(NilMatchCaseListNode(arg0))
    }
    /// Returns an iterator over elements satisfying the `nil_match_case_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_nil_match_case_list_node(&self) -> impl '_ + Iterator<Item = MatchCaseListNode> {
        self.nil_match_case_list_node.iter_all().map(|t| t.0)
    }
    /// Makes `nil_match_case_list_node(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_nil_match_case_list_node(&mut self, mut tm0: MatchCaseListNode) {
        tm0 = self.match_case_list_node_equalities.root(tm0);
        if self
            .nil_match_case_list_node
            .insert(NilMatchCaseListNode(tm0))
        {
            let weight0 = &mut self.match_case_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(NilMatchCaseListNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `cons_match_case_list_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn cons_match_case_list_node(
        &self,
        mut arg0: MatchCaseListNode,
        mut arg1: MatchCaseNode,
        mut arg2: MatchCaseListNode,
    ) -> bool {
        arg0 = self.root_match_case_list_node(arg0);
        arg1 = self.root_match_case_node(arg1);
        arg2 = self.root_match_case_list_node(arg2);
        self.cons_match_case_list_node
            .contains(ConsMatchCaseListNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `cons_match_case_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_cons_match_case_list_node(
        &self,
    ) -> impl '_ + Iterator<Item = (MatchCaseListNode, MatchCaseNode, MatchCaseListNode)> {
        self.cons_match_case_list_node
            .iter_all()
            .map(|t| (t.0, t.1, t.2))
    }
    /// Makes `cons_match_case_list_node(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_cons_match_case_list_node(
        &mut self,
        mut tm0: MatchCaseListNode,
        mut tm1: MatchCaseNode,
        mut tm2: MatchCaseListNode,
    ) {
        tm0 = self.match_case_list_node_equalities.root(tm0);
        tm1 = self.match_case_node_equalities.root(tm1);
        tm2 = self.match_case_list_node_equalities.root(tm2);
        if self
            .cons_match_case_list_node
            .insert(ConsMatchCaseListNode(tm0, tm1, tm2))
        {
            let weight0 = &mut self.match_case_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ConsMatchCaseListNodeTable::WEIGHT);

            let weight1 = &mut self.match_case_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ConsMatchCaseListNodeTable::WEIGHT);

            let weight2 = &mut self.match_case_list_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(ConsMatchCaseListNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `equal_if_atom_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn equal_if_atom_node(
        &self,
        mut arg0: IfAtomNode,
        mut arg1: TermNode,
        mut arg2: TermNode,
    ) -> bool {
        arg0 = self.root_if_atom_node(arg0);
        arg1 = self.root_term_node(arg1);
        arg2 = self.root_term_node(arg2);
        self.equal_if_atom_node
            .contains(EqualIfAtomNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `equal_if_atom_node` predicate.

    #[allow(dead_code)]
    pub fn iter_equal_if_atom_node(
        &self,
    ) -> impl '_ + Iterator<Item = (IfAtomNode, TermNode, TermNode)> {
        self.equal_if_atom_node.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `equal_if_atom_node(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_equal_if_atom_node(
        &mut self,
        mut tm0: IfAtomNode,
        mut tm1: TermNode,
        mut tm2: TermNode,
    ) {
        tm0 = self.if_atom_node_equalities.root(tm0);
        tm1 = self.term_node_equalities.root(tm1);
        tm2 = self.term_node_equalities.root(tm2);
        if self
            .equal_if_atom_node
            .insert(EqualIfAtomNode(tm0, tm1, tm2))
        {
            let weight0 = &mut self.if_atom_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(EqualIfAtomNodeTable::WEIGHT);

            let weight1 = &mut self.term_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(EqualIfAtomNodeTable::WEIGHT);

            let weight2 = &mut self.term_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(EqualIfAtomNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `defined_if_atom_node(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn defined_if_atom_node(&self, mut arg0: IfAtomNode, mut arg1: TermNode) -> bool {
        arg0 = self.root_if_atom_node(arg0);
        arg1 = self.root_term_node(arg1);
        self.defined_if_atom_node
            .contains(DefinedIfAtomNode(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `defined_if_atom_node` predicate.

    #[allow(dead_code)]
    pub fn iter_defined_if_atom_node(&self) -> impl '_ + Iterator<Item = (IfAtomNode, TermNode)> {
        self.defined_if_atom_node.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `defined_if_atom_node(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_defined_if_atom_node(&mut self, mut tm0: IfAtomNode, mut tm1: TermNode) {
        tm0 = self.if_atom_node_equalities.root(tm0);
        tm1 = self.term_node_equalities.root(tm1);
        if self
            .defined_if_atom_node
            .insert(DefinedIfAtomNode(tm0, tm1))
        {
            let weight0 = &mut self.if_atom_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(DefinedIfAtomNodeTable::WEIGHT);

            let weight1 = &mut self.term_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(DefinedIfAtomNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `pred_if_atom_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn pred_if_atom_node(
        &self,
        mut arg0: IfAtomNode,
        mut arg1: Ident,
        mut arg2: TermListNode,
    ) -> bool {
        arg0 = self.root_if_atom_node(arg0);
        arg1 = self.root_ident(arg1);
        arg2 = self.root_term_list_node(arg2);
        self.pred_if_atom_node
            .contains(PredIfAtomNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `pred_if_atom_node` predicate.

    #[allow(dead_code)]
    pub fn iter_pred_if_atom_node(
        &self,
    ) -> impl '_ + Iterator<Item = (IfAtomNode, Ident, TermListNode)> {
        self.pred_if_atom_node.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `pred_if_atom_node(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_pred_if_atom_node(
        &mut self,
        mut tm0: IfAtomNode,
        mut tm1: Ident,
        mut tm2: TermListNode,
    ) {
        tm0 = self.if_atom_node_equalities.root(tm0);
        tm1 = self.ident_equalities.root(tm1);
        tm2 = self.term_list_node_equalities.root(tm2);
        if self.pred_if_atom_node.insert(PredIfAtomNode(tm0, tm1, tm2)) {
            let weight0 = &mut self.if_atom_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(PredIfAtomNodeTable::WEIGHT);

            let weight1 = &mut self.ident_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(PredIfAtomNodeTable::WEIGHT);

            let weight2 = &mut self.term_list_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(PredIfAtomNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `var_if_atom_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn var_if_atom_node(
        &self,
        mut arg0: IfAtomNode,
        mut arg1: TermNode,
        mut arg2: Ident,
    ) -> bool {
        arg0 = self.root_if_atom_node(arg0);
        arg1 = self.root_term_node(arg1);
        arg2 = self.root_ident(arg2);
        self.var_if_atom_node
            .contains(VarIfAtomNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `var_if_atom_node` predicate.

    #[allow(dead_code)]
    pub fn iter_var_if_atom_node(
        &self,
    ) -> impl '_ + Iterator<Item = (IfAtomNode, TermNode, Ident)> {
        self.var_if_atom_node.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `var_if_atom_node(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_var_if_atom_node(
        &mut self,
        mut tm0: IfAtomNode,
        mut tm1: TermNode,
        mut tm2: Ident,
    ) {
        tm0 = self.if_atom_node_equalities.root(tm0);
        tm1 = self.term_node_equalities.root(tm1);
        tm2 = self.ident_equalities.root(tm2);
        if self.var_if_atom_node.insert(VarIfAtomNode(tm0, tm1, tm2)) {
            let weight0 = &mut self.if_atom_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(VarIfAtomNodeTable::WEIGHT);

            let weight1 = &mut self.term_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(VarIfAtomNodeTable::WEIGHT);

            let weight2 = &mut self.ident_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(VarIfAtomNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `equal_then_atom_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn equal_then_atom_node(
        &self,
        mut arg0: ThenAtomNode,
        mut arg1: TermNode,
        mut arg2: TermNode,
    ) -> bool {
        arg0 = self.root_then_atom_node(arg0);
        arg1 = self.root_term_node(arg1);
        arg2 = self.root_term_node(arg2);
        self.equal_then_atom_node
            .contains(EqualThenAtomNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `equal_then_atom_node` predicate.

    #[allow(dead_code)]
    pub fn iter_equal_then_atom_node(
        &self,
    ) -> impl '_ + Iterator<Item = (ThenAtomNode, TermNode, TermNode)> {
        self.equal_then_atom_node
            .iter_all()
            .map(|t| (t.0, t.1, t.2))
    }
    /// Makes `equal_then_atom_node(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_equal_then_atom_node(
        &mut self,
        mut tm0: ThenAtomNode,
        mut tm1: TermNode,
        mut tm2: TermNode,
    ) {
        tm0 = self.then_atom_node_equalities.root(tm0);
        tm1 = self.term_node_equalities.root(tm1);
        tm2 = self.term_node_equalities.root(tm2);
        if self
            .equal_then_atom_node
            .insert(EqualThenAtomNode(tm0, tm1, tm2))
        {
            let weight0 = &mut self.then_atom_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(EqualThenAtomNodeTable::WEIGHT);

            let weight1 = &mut self.term_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(EqualThenAtomNodeTable::WEIGHT);

            let weight2 = &mut self.term_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(EqualThenAtomNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `defined_then_atom_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn defined_then_atom_node(
        &self,
        mut arg0: ThenAtomNode,
        mut arg1: OptTermNode,
        mut arg2: TermNode,
    ) -> bool {
        arg0 = self.root_then_atom_node(arg0);
        arg1 = self.root_opt_term_node(arg1);
        arg2 = self.root_term_node(arg2);
        self.defined_then_atom_node
            .contains(DefinedThenAtomNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `defined_then_atom_node` predicate.

    #[allow(dead_code)]
    pub fn iter_defined_then_atom_node(
        &self,
    ) -> impl '_ + Iterator<Item = (ThenAtomNode, OptTermNode, TermNode)> {
        self.defined_then_atom_node
            .iter_all()
            .map(|t| (t.0, t.1, t.2))
    }
    /// Makes `defined_then_atom_node(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_defined_then_atom_node(
        &mut self,
        mut tm0: ThenAtomNode,
        mut tm1: OptTermNode,
        mut tm2: TermNode,
    ) {
        tm0 = self.then_atom_node_equalities.root(tm0);
        tm1 = self.opt_term_node_equalities.root(tm1);
        tm2 = self.term_node_equalities.root(tm2);
        if self
            .defined_then_atom_node
            .insert(DefinedThenAtomNode(tm0, tm1, tm2))
        {
            let weight0 = &mut self.then_atom_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

            let weight1 = &mut self.opt_term_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

            let weight2 = &mut self.term_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(DefinedThenAtomNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `pred_then_atom_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn pred_then_atom_node(
        &self,
        mut arg0: ThenAtomNode,
        mut arg1: Ident,
        mut arg2: TermListNode,
    ) -> bool {
        arg0 = self.root_then_atom_node(arg0);
        arg1 = self.root_ident(arg1);
        arg2 = self.root_term_list_node(arg2);
        self.pred_then_atom_node
            .contains(PredThenAtomNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `pred_then_atom_node` predicate.

    #[allow(dead_code)]
    pub fn iter_pred_then_atom_node(
        &self,
    ) -> impl '_ + Iterator<Item = (ThenAtomNode, Ident, TermListNode)> {
        self.pred_then_atom_node.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `pred_then_atom_node(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_pred_then_atom_node(
        &mut self,
        mut tm0: ThenAtomNode,
        mut tm1: Ident,
        mut tm2: TermListNode,
    ) {
        tm0 = self.then_atom_node_equalities.root(tm0);
        tm1 = self.ident_equalities.root(tm1);
        tm2 = self.term_list_node_equalities.root(tm2);
        if self
            .pred_then_atom_node
            .insert(PredThenAtomNode(tm0, tm1, tm2))
        {
            let weight0 = &mut self.then_atom_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(PredThenAtomNodeTable::WEIGHT);

            let weight1 = &mut self.ident_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(PredThenAtomNodeTable::WEIGHT);

            let weight2 = &mut self.term_list_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(PredThenAtomNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `if_stmt_node(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn if_stmt_node(&self, mut arg0: StmtNode, mut arg1: IfAtomNode) -> bool {
        arg0 = self.root_stmt_node(arg0);
        arg1 = self.root_if_atom_node(arg1);
        self.if_stmt_node.contains(IfStmtNode(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `if_stmt_node` predicate.

    #[allow(dead_code)]
    pub fn iter_if_stmt_node(&self) -> impl '_ + Iterator<Item = (StmtNode, IfAtomNode)> {
        self.if_stmt_node.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `if_stmt_node(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_if_stmt_node(&mut self, mut tm0: StmtNode, mut tm1: IfAtomNode) {
        tm0 = self.stmt_node_equalities.root(tm0);
        tm1 = self.if_atom_node_equalities.root(tm1);
        if self.if_stmt_node.insert(IfStmtNode(tm0, tm1)) {
            let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(IfStmtNodeTable::WEIGHT);

            let weight1 = &mut self.if_atom_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(IfStmtNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `then_stmt_node(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn then_stmt_node(&self, mut arg0: StmtNode, mut arg1: ThenAtomNode) -> bool {
        arg0 = self.root_stmt_node(arg0);
        arg1 = self.root_then_atom_node(arg1);
        self.then_stmt_node.contains(ThenStmtNode(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `then_stmt_node` predicate.

    #[allow(dead_code)]
    pub fn iter_then_stmt_node(&self) -> impl '_ + Iterator<Item = (StmtNode, ThenAtomNode)> {
        self.then_stmt_node.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `then_stmt_node(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_then_stmt_node(&mut self, mut tm0: StmtNode, mut tm1: ThenAtomNode) {
        tm0 = self.stmt_node_equalities.root(tm0);
        tm1 = self.then_atom_node_equalities.root(tm1);
        if self.then_stmt_node.insert(ThenStmtNode(tm0, tm1)) {
            let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ThenStmtNodeTable::WEIGHT);

            let weight1 = &mut self.then_atom_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ThenStmtNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `branch_stmt_node(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn branch_stmt_node(&self, mut arg0: StmtNode, mut arg1: StmtBlockListNode) -> bool {
        arg0 = self.root_stmt_node(arg0);
        arg1 = self.root_stmt_block_list_node(arg1);
        self.branch_stmt_node.contains(BranchStmtNode(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `branch_stmt_node` predicate.

    #[allow(dead_code)]
    pub fn iter_branch_stmt_node(
        &self,
    ) -> impl '_ + Iterator<Item = (StmtNode, StmtBlockListNode)> {
        self.branch_stmt_node.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `branch_stmt_node(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_branch_stmt_node(&mut self, mut tm0: StmtNode, mut tm1: StmtBlockListNode) {
        tm0 = self.stmt_node_equalities.root(tm0);
        tm1 = self.stmt_block_list_node_equalities.root(tm1);
        if self.branch_stmt_node.insert(BranchStmtNode(tm0, tm1)) {
            let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(BranchStmtNodeTable::WEIGHT);

            let weight1 = &mut self.stmt_block_list_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(BranchStmtNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `match_stmt_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn match_stmt_node(
        &self,
        mut arg0: StmtNode,
        mut arg1: TermNode,
        mut arg2: MatchCaseListNode,
    ) -> bool {
        arg0 = self.root_stmt_node(arg0);
        arg1 = self.root_term_node(arg1);
        arg2 = self.root_match_case_list_node(arg2);
        self.match_stmt_node
            .contains(MatchStmtNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `match_stmt_node` predicate.

    #[allow(dead_code)]
    pub fn iter_match_stmt_node(
        &self,
    ) -> impl '_ + Iterator<Item = (StmtNode, TermNode, MatchCaseListNode)> {
        self.match_stmt_node.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `match_stmt_node(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_match_stmt_node(
        &mut self,
        mut tm0: StmtNode,
        mut tm1: TermNode,
        mut tm2: MatchCaseListNode,
    ) {
        tm0 = self.stmt_node_equalities.root(tm0);
        tm1 = self.term_node_equalities.root(tm1);
        tm2 = self.match_case_list_node_equalities.root(tm2);
        if self.match_stmt_node.insert(MatchStmtNode(tm0, tm1, tm2)) {
            let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(MatchStmtNodeTable::WEIGHT);

            let weight1 = &mut self.term_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(MatchStmtNodeTable::WEIGHT);

            let weight2 = &mut self.match_case_list_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(MatchStmtNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `nil_stmt_list_node(arg0)` holds.
    #[allow(dead_code)]
    pub fn nil_stmt_list_node(&self, mut arg0: StmtListNode) -> bool {
        arg0 = self.root_stmt_list_node(arg0);
        self.nil_stmt_list_node.contains(NilStmtListNode(arg0))
    }
    /// Returns an iterator over elements satisfying the `nil_stmt_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_nil_stmt_list_node(&self) -> impl '_ + Iterator<Item = StmtListNode> {
        self.nil_stmt_list_node.iter_all().map(|t| t.0)
    }
    /// Makes `nil_stmt_list_node(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_nil_stmt_list_node(&mut self, mut tm0: StmtListNode) {
        tm0 = self.stmt_list_node_equalities.root(tm0);
        if self.nil_stmt_list_node.insert(NilStmtListNode(tm0)) {
            let weight0 = &mut self.stmt_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(NilStmtListNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `cons_stmt_list_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn cons_stmt_list_node(
        &self,
        mut arg0: StmtListNode,
        mut arg1: StmtNode,
        mut arg2: StmtListNode,
    ) -> bool {
        arg0 = self.root_stmt_list_node(arg0);
        arg1 = self.root_stmt_node(arg1);
        arg2 = self.root_stmt_list_node(arg2);
        self.cons_stmt_list_node
            .contains(ConsStmtListNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `cons_stmt_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_cons_stmt_list_node(
        &self,
    ) -> impl '_ + Iterator<Item = (StmtListNode, StmtNode, StmtListNode)> {
        self.cons_stmt_list_node.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `cons_stmt_list_node(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_cons_stmt_list_node(
        &mut self,
        mut tm0: StmtListNode,
        mut tm1: StmtNode,
        mut tm2: StmtListNode,
    ) {
        tm0 = self.stmt_list_node_equalities.root(tm0);
        tm1 = self.stmt_node_equalities.root(tm1);
        tm2 = self.stmt_list_node_equalities.root(tm2);
        if self
            .cons_stmt_list_node
            .insert(ConsStmtListNode(tm0, tm1, tm2))
        {
            let weight0 = &mut self.stmt_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ConsStmtListNodeTable::WEIGHT);

            let weight1 = &mut self.stmt_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ConsStmtListNodeTable::WEIGHT);

            let weight2 = &mut self.stmt_list_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(ConsStmtListNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `nil_stmt_block_list_node(arg0)` holds.
    #[allow(dead_code)]
    pub fn nil_stmt_block_list_node(&self, mut arg0: StmtBlockListNode) -> bool {
        arg0 = self.root_stmt_block_list_node(arg0);
        self.nil_stmt_block_list_node
            .contains(NilStmtBlockListNode(arg0))
    }
    /// Returns an iterator over elements satisfying the `nil_stmt_block_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_nil_stmt_block_list_node(&self) -> impl '_ + Iterator<Item = StmtBlockListNode> {
        self.nil_stmt_block_list_node.iter_all().map(|t| t.0)
    }
    /// Makes `nil_stmt_block_list_node(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_nil_stmt_block_list_node(&mut self, mut tm0: StmtBlockListNode) {
        tm0 = self.stmt_block_list_node_equalities.root(tm0);
        if self
            .nil_stmt_block_list_node
            .insert(NilStmtBlockListNode(tm0))
        {
            let weight0 = &mut self.stmt_block_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(NilStmtBlockListNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `cons_stmt_block_list_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn cons_stmt_block_list_node(
        &self,
        mut arg0: StmtBlockListNode,
        mut arg1: StmtListNode,
        mut arg2: StmtBlockListNode,
    ) -> bool {
        arg0 = self.root_stmt_block_list_node(arg0);
        arg1 = self.root_stmt_list_node(arg1);
        arg2 = self.root_stmt_block_list_node(arg2);
        self.cons_stmt_block_list_node
            .contains(ConsStmtBlockListNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `cons_stmt_block_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_cons_stmt_block_list_node(
        &self,
    ) -> impl '_ + Iterator<Item = (StmtBlockListNode, StmtListNode, StmtBlockListNode)> {
        self.cons_stmt_block_list_node
            .iter_all()
            .map(|t| (t.0, t.1, t.2))
    }
    /// Makes `cons_stmt_block_list_node(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_cons_stmt_block_list_node(
        &mut self,
        mut tm0: StmtBlockListNode,
        mut tm1: StmtListNode,
        mut tm2: StmtBlockListNode,
    ) {
        tm0 = self.stmt_block_list_node_equalities.root(tm0);
        tm1 = self.stmt_list_node_equalities.root(tm1);
        tm2 = self.stmt_block_list_node_equalities.root(tm2);
        if self
            .cons_stmt_block_list_node
            .insert(ConsStmtBlockListNode(tm0, tm1, tm2))
        {
            let weight0 = &mut self.stmt_block_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ConsStmtBlockListNodeTable::WEIGHT);

            let weight1 = &mut self.stmt_list_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ConsStmtBlockListNodeTable::WEIGHT);

            let weight2 = &mut self.stmt_block_list_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(ConsStmtBlockListNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `rule_decl(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn rule_decl(&self, mut arg0: RuleDeclNode, mut arg1: StmtListNode) -> bool {
        arg0 = self.root_rule_decl_node(arg0);
        arg1 = self.root_stmt_list_node(arg1);
        self.rule_decl.contains(RuleDecl(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `rule_decl` predicate.

    #[allow(dead_code)]
    pub fn iter_rule_decl(&self) -> impl '_ + Iterator<Item = (RuleDeclNode, StmtListNode)> {
        self.rule_decl.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `rule_decl(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_rule_decl(&mut self, mut tm0: RuleDeclNode, mut tm1: StmtListNode) {
        tm0 = self.rule_decl_node_equalities.root(tm0);
        tm1 = self.stmt_list_node_equalities.root(tm1);
        if self.rule_decl.insert(RuleDecl(tm0, tm1)) {
            let weight0 = &mut self.rule_decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(RuleDeclTable::WEIGHT);

            let weight1 = &mut self.stmt_list_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(RuleDeclTable::WEIGHT);
        }
    }

    /// Returns `true` if `decl_node_type(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn decl_node_type(&self, mut arg0: DeclNode, mut arg1: TypeDeclNode) -> bool {
        arg0 = self.root_decl_node(arg0);
        arg1 = self.root_type_decl_node(arg1);
        self.decl_node_type.contains(DeclNodeType(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `decl_node_type` predicate.

    #[allow(dead_code)]
    pub fn iter_decl_node_type(&self) -> impl '_ + Iterator<Item = (DeclNode, TypeDeclNode)> {
        self.decl_node_type.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `decl_node_type(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_decl_node_type(&mut self, mut tm0: DeclNode, mut tm1: TypeDeclNode) {
        tm0 = self.decl_node_equalities.root(tm0);
        tm1 = self.type_decl_node_equalities.root(tm1);
        if self.decl_node_type.insert(DeclNodeType(tm0, tm1)) {
            let weight0 = &mut self.decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(DeclNodeTypeTable::WEIGHT);

            let weight1 = &mut self.type_decl_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(DeclNodeTypeTable::WEIGHT);
        }
    }

    /// Returns `true` if `decl_node_pred(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn decl_node_pred(&self, mut arg0: DeclNode, mut arg1: PredDeclNode) -> bool {
        arg0 = self.root_decl_node(arg0);
        arg1 = self.root_pred_decl_node(arg1);
        self.decl_node_pred.contains(DeclNodePred(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `decl_node_pred` predicate.

    #[allow(dead_code)]
    pub fn iter_decl_node_pred(&self) -> impl '_ + Iterator<Item = (DeclNode, PredDeclNode)> {
        self.decl_node_pred.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `decl_node_pred(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_decl_node_pred(&mut self, mut tm0: DeclNode, mut tm1: PredDeclNode) {
        tm0 = self.decl_node_equalities.root(tm0);
        tm1 = self.pred_decl_node_equalities.root(tm1);
        if self.decl_node_pred.insert(DeclNodePred(tm0, tm1)) {
            let weight0 = &mut self.decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(DeclNodePredTable::WEIGHT);

            let weight1 = &mut self.pred_decl_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(DeclNodePredTable::WEIGHT);
        }
    }

    /// Returns `true` if `decl_node_func(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn decl_node_func(&self, mut arg0: DeclNode, mut arg1: FuncDeclNode) -> bool {
        arg0 = self.root_decl_node(arg0);
        arg1 = self.root_func_decl_node(arg1);
        self.decl_node_func.contains(DeclNodeFunc(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `decl_node_func` predicate.

    #[allow(dead_code)]
    pub fn iter_decl_node_func(&self) -> impl '_ + Iterator<Item = (DeclNode, FuncDeclNode)> {
        self.decl_node_func.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `decl_node_func(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_decl_node_func(&mut self, mut tm0: DeclNode, mut tm1: FuncDeclNode) {
        tm0 = self.decl_node_equalities.root(tm0);
        tm1 = self.func_decl_node_equalities.root(tm1);
        if self.decl_node_func.insert(DeclNodeFunc(tm0, tm1)) {
            let weight0 = &mut self.decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(DeclNodeFuncTable::WEIGHT);

            let weight1 = &mut self.func_decl_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(DeclNodeFuncTable::WEIGHT);
        }
    }

    /// Returns `true` if `decl_node_rule(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn decl_node_rule(&self, mut arg0: DeclNode, mut arg1: RuleDeclNode) -> bool {
        arg0 = self.root_decl_node(arg0);
        arg1 = self.root_rule_decl_node(arg1);
        self.decl_node_rule.contains(DeclNodeRule(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `decl_node_rule` predicate.

    #[allow(dead_code)]
    pub fn iter_decl_node_rule(&self) -> impl '_ + Iterator<Item = (DeclNode, RuleDeclNode)> {
        self.decl_node_rule.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `decl_node_rule(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_decl_node_rule(&mut self, mut tm0: DeclNode, mut tm1: RuleDeclNode) {
        tm0 = self.decl_node_equalities.root(tm0);
        tm1 = self.rule_decl_node_equalities.root(tm1);
        if self.decl_node_rule.insert(DeclNodeRule(tm0, tm1)) {
            let weight0 = &mut self.decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(DeclNodeRuleTable::WEIGHT);

            let weight1 = &mut self.rule_decl_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(DeclNodeRuleTable::WEIGHT);
        }
    }

    /// Returns `true` if `decl_node_enum(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn decl_node_enum(&self, mut arg0: DeclNode, mut arg1: EnumDeclNode) -> bool {
        arg0 = self.root_decl_node(arg0);
        arg1 = self.root_enum_decl_node(arg1);
        self.decl_node_enum.contains(DeclNodeEnum(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `decl_node_enum` predicate.

    #[allow(dead_code)]
    pub fn iter_decl_node_enum(&self) -> impl '_ + Iterator<Item = (DeclNode, EnumDeclNode)> {
        self.decl_node_enum.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `decl_node_enum(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_decl_node_enum(&mut self, mut tm0: DeclNode, mut tm1: EnumDeclNode) {
        tm0 = self.decl_node_equalities.root(tm0);
        tm1 = self.enum_decl_node_equalities.root(tm1);
        if self.decl_node_enum.insert(DeclNodeEnum(tm0, tm1)) {
            let weight0 = &mut self.decl_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(DeclNodeEnumTable::WEIGHT);

            let weight1 = &mut self.enum_decl_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(DeclNodeEnumTable::WEIGHT);
        }
    }

    /// Returns `true` if `nil_decl_list_node(arg0)` holds.
    #[allow(dead_code)]
    pub fn nil_decl_list_node(&self, mut arg0: DeclListNode) -> bool {
        arg0 = self.root_decl_list_node(arg0);
        self.nil_decl_list_node.contains(NilDeclListNode(arg0))
    }
    /// Returns an iterator over elements satisfying the `nil_decl_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_nil_decl_list_node(&self) -> impl '_ + Iterator<Item = DeclListNode> {
        self.nil_decl_list_node.iter_all().map(|t| t.0)
    }
    /// Makes `nil_decl_list_node(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_nil_decl_list_node(&mut self, mut tm0: DeclListNode) {
        tm0 = self.decl_list_node_equalities.root(tm0);
        if self.nil_decl_list_node.insert(NilDeclListNode(tm0)) {
            let weight0 = &mut self.decl_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(NilDeclListNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `cons_decl_list_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn cons_decl_list_node(
        &self,
        mut arg0: DeclListNode,
        mut arg1: DeclNode,
        mut arg2: DeclListNode,
    ) -> bool {
        arg0 = self.root_decl_list_node(arg0);
        arg1 = self.root_decl_node(arg1);
        arg2 = self.root_decl_list_node(arg2);
        self.cons_decl_list_node
            .contains(ConsDeclListNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `cons_decl_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_cons_decl_list_node(
        &self,
    ) -> impl '_ + Iterator<Item = (DeclListNode, DeclNode, DeclListNode)> {
        self.cons_decl_list_node.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `cons_decl_list_node(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_cons_decl_list_node(
        &mut self,
        mut tm0: DeclListNode,
        mut tm1: DeclNode,
        mut tm2: DeclListNode,
    ) {
        tm0 = self.decl_list_node_equalities.root(tm0);
        tm1 = self.decl_node_equalities.root(tm1);
        tm2 = self.decl_list_node_equalities.root(tm2);
        if self
            .cons_decl_list_node
            .insert(ConsDeclListNode(tm0, tm1, tm2))
        {
            let weight0 = &mut self.decl_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ConsDeclListNodeTable::WEIGHT);

            let weight1 = &mut self.decl_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ConsDeclListNodeTable::WEIGHT);

            let weight2 = &mut self.decl_list_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(ConsDeclListNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `decls_module_node(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn decls_module_node(&self, mut arg0: ModuleNode, mut arg1: DeclListNode) -> bool {
        arg0 = self.root_module_node(arg0);
        arg1 = self.root_decl_list_node(arg1);
        self.decls_module_node.contains(DeclsModuleNode(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `decls_module_node` predicate.

    #[allow(dead_code)]
    pub fn iter_decls_module_node(&self) -> impl '_ + Iterator<Item = (ModuleNode, DeclListNode)> {
        self.decls_module_node.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `decls_module_node(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_decls_module_node(&mut self, mut tm0: ModuleNode, mut tm1: DeclListNode) {
        tm0 = self.module_node_equalities.root(tm0);
        tm1 = self.decl_list_node_equalities.root(tm1);
        if self.decls_module_node.insert(DeclsModuleNode(tm0, tm1)) {
            let weight0 = &mut self.module_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(DeclsModuleNodeTable::WEIGHT);

            let weight1 = &mut self.decl_list_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(DeclsModuleNodeTable::WEIGHT);
        }
    }

    /// Returns `true` if `var_in_scope(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn var_in_scope(&self, mut arg0: VirtIdent, mut arg1: Scope) -> bool {
        arg0 = self.root_virt_ident(arg0);
        arg1 = self.root_scope(arg1);
        self.var_in_scope.contains(VarInScope(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `var_in_scope` predicate.

    #[allow(dead_code)]
    pub fn iter_var_in_scope(&self) -> impl '_ + Iterator<Item = (VirtIdent, Scope)> {
        self.var_in_scope.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `var_in_scope(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_var_in_scope(&mut self, mut tm0: VirtIdent, mut tm1: Scope) {
        tm0 = self.virt_ident_equalities.root(tm0);
        tm1 = self.scope_equalities.root(tm1);
        if self.var_in_scope.insert(VarInScope(tm0, tm1)) {
            let weight0 = &mut self.virt_ident_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(VarInScopeTable::WEIGHT);

            let weight1 = &mut self.scope_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(VarInScopeTable::WEIGHT);
        }
    }

    /// Returns `true` if `scope_extension(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn scope_extension(&self, mut arg0: Scope, mut arg1: Scope) -> bool {
        arg0 = self.root_scope(arg0);
        arg1 = self.root_scope(arg1);
        self.scope_extension.contains(ScopeExtension(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `scope_extension` predicate.

    #[allow(dead_code)]
    pub fn iter_scope_extension(&self) -> impl '_ + Iterator<Item = (Scope, Scope)> {
        self.scope_extension.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `scope_extension(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_scope_extension(&mut self, mut tm0: Scope, mut tm1: Scope) {
        tm0 = self.scope_equalities.root(tm0);
        tm1 = self.scope_equalities.root(tm1);
        if self.scope_extension.insert(ScopeExtension(tm0, tm1)) {
            let weight0 = &mut self.scope_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ScopeExtensionTable::WEIGHT);

            let weight1 = &mut self.scope_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ScopeExtensionTable::WEIGHT);
        }
    }

    /// Returns `true` if `scope_single_child(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn scope_single_child(
        &self,
        mut arg0: RuleDescendantNode,
        mut arg1: RuleDescendantNode,
    ) -> bool {
        arg0 = self.root_rule_descendant_node(arg0);
        arg1 = self.root_rule_descendant_node(arg1);
        self.scope_single_child
            .contains(ScopeSingleChild(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `scope_single_child` predicate.

    #[allow(dead_code)]
    pub fn iter_scope_single_child(
        &self,
    ) -> impl '_ + Iterator<Item = (RuleDescendantNode, RuleDescendantNode)> {
        self.scope_single_child.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `scope_single_child(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_scope_single_child(
        &mut self,
        mut tm0: RuleDescendantNode,
        mut tm1: RuleDescendantNode,
    ) {
        tm0 = self.rule_descendant_node_equalities.root(tm0);
        tm1 = self.rule_descendant_node_equalities.root(tm1);
        if self.scope_single_child.insert(ScopeSingleChild(tm0, tm1)) {
            let weight0 = &mut self.rule_descendant_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ScopeSingleChildTable::WEIGHT);

            let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ScopeSingleChildTable::WEIGHT);
        }
    }

    /// Returns `true` if `scope_extension_siblings(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn scope_extension_siblings(
        &self,
        mut arg0: RuleDescendantNode,
        mut arg1: RuleDescendantNode,
        mut arg2: RuleDescendantNode,
    ) -> bool {
        arg0 = self.root_rule_descendant_node(arg0);
        arg1 = self.root_rule_descendant_node(arg1);
        arg2 = self.root_rule_descendant_node(arg2);
        self.scope_extension_siblings
            .contains(ScopeExtensionSiblings(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `scope_extension_siblings` predicate.

    #[allow(dead_code)]
    pub fn iter_scope_extension_siblings(
        &self,
    ) -> impl '_ + Iterator<Item = (RuleDescendantNode, RuleDescendantNode, RuleDescendantNode)>
    {
        self.scope_extension_siblings
            .iter_all()
            .map(|t| (t.0, t.1, t.2))
    }
    /// Makes `scope_extension_siblings(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_scope_extension_siblings(
        &mut self,
        mut tm0: RuleDescendantNode,
        mut tm1: RuleDescendantNode,
        mut tm2: RuleDescendantNode,
    ) {
        tm0 = self.rule_descendant_node_equalities.root(tm0);
        tm1 = self.rule_descendant_node_equalities.root(tm1);
        tm2 = self.rule_descendant_node_equalities.root(tm2);
        if self
            .scope_extension_siblings
            .insert(ScopeExtensionSiblings(tm0, tm1, tm2))
        {
            let weight0 = &mut self.rule_descendant_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ScopeExtensionSiblingsTable::WEIGHT);

            let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ScopeExtensionSiblingsTable::WEIGHT);

            let weight2 = &mut self.rule_descendant_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(ScopeExtensionSiblingsTable::WEIGHT);
        }
    }

    /// Returns `true` if `rel_app(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn rel_app(&self, mut arg0: Rel, mut arg1: ElList) -> bool {
        arg0 = self.root_rel(arg0);
        arg1 = self.root_el_list(arg1);
        self.rel_app.contains(RelApp(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `rel_app` predicate.

    #[allow(dead_code)]
    pub fn iter_rel_app(&self) -> impl '_ + Iterator<Item = (Rel, ElList)> {
        self.rel_app.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `rel_app(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_rel_app(&mut self, mut tm0: Rel, mut tm1: ElList) {
        tm0 = self.rel_equalities.root(tm0);
        tm1 = self.el_list_equalities.root(tm1);
        if self.rel_app.insert(RelApp(tm0, tm1)) {
            let weight0 = &mut self.rel_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(RelAppTable::WEIGHT);

            let weight1 = &mut self.el_list_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(RelAppTable::WEIGHT);
        }
    }

    /// Returns `true` if `el_type(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn el_type(&self, mut arg0: El, mut arg1: Type) -> bool {
        arg0 = self.root_el(arg0);
        arg1 = self.root_type(arg1);
        self.el_type.contains(ElType(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `el_type` predicate.

    #[allow(dead_code)]
    pub fn iter_el_type(&self) -> impl '_ + Iterator<Item = (El, Type)> {
        self.el_type.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `el_type(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_el_type(&mut self, mut tm0: El, mut tm1: Type) {
        tm0 = self.el_equalities.root(tm0);
        tm1 = self.type_equalities.root(tm1);
        if self.el_type.insert(ElType(tm0, tm1)) {
            let weight0 = &mut self.el_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ElTypeTable::WEIGHT);

            let weight1 = &mut self.type_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ElTypeTable::WEIGHT);
        }
    }

    /// Returns `true` if `el_types(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn el_types(&self, mut arg0: ElList, mut arg1: TypeList) -> bool {
        arg0 = self.root_el_list(arg0);
        arg1 = self.root_type_list(arg1);
        self.el_types.contains(ElTypes(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `el_types` predicate.

    #[allow(dead_code)]
    pub fn iter_el_types(&self) -> impl '_ + Iterator<Item = (ElList, TypeList)> {
        self.el_types.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `el_types(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_el_types(&mut self, mut tm0: ElList, mut tm1: TypeList) {
        tm0 = self.el_list_equalities.root(tm0);
        tm1 = self.type_list_equalities.root(tm1);
        if self.el_types.insert(ElTypes(tm0, tm1)) {
            let weight0 = &mut self.el_list_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ElTypesTable::WEIGHT);

            let weight1 = &mut self.type_list_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ElTypesTable::WEIGHT);
        }
    }

    /// Returns `true` if `constrained_el(arg0)` holds.
    #[allow(dead_code)]
    pub fn constrained_el(&self, mut arg0: El) -> bool {
        arg0 = self.root_el(arg0);
        self.constrained_el.contains(ConstrainedEl(arg0))
    }
    /// Returns an iterator over elements satisfying the `constrained_el` predicate.

    #[allow(dead_code)]
    pub fn iter_constrained_el(&self) -> impl '_ + Iterator<Item = El> {
        self.constrained_el.iter_all().map(|t| t.0)
    }
    /// Makes `constrained_el(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_constrained_el(&mut self, mut tm0: El) {
        tm0 = self.el_equalities.root(tm0);
        if self.constrained_el.insert(ConstrainedEl(tm0)) {
            let weight0 = &mut self.el_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ConstrainedElTable::WEIGHT);
        }
    }

    /// Returns `true` if `constrained_els(arg0)` holds.
    #[allow(dead_code)]
    pub fn constrained_els(&self, mut arg0: ElList) -> bool {
        arg0 = self.root_el_list(arg0);
        self.constrained_els.contains(ConstrainedEls(arg0))
    }
    /// Returns an iterator over elements satisfying the `constrained_els` predicate.

    #[allow(dead_code)]
    pub fn iter_constrained_els(&self) -> impl '_ + Iterator<Item = ElList> {
        self.constrained_els.iter_all().map(|t| t.0)
    }
    /// Makes `constrained_els(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_constrained_els(&mut self, mut tm0: ElList) {
        tm0 = self.el_list_equalities.root(tm0);
        if self.constrained_els.insert(ConstrainedEls(tm0)) {
            let weight0 = &mut self.el_list_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ConstrainedElsTable::WEIGHT);
        }
    }

    /// Returns `true` if `in_ker(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn in_ker(&self, mut arg0: Morphism, mut arg1: El, mut arg2: El) -> bool {
        arg0 = self.root_morphism(arg0);
        arg1 = self.root_el(arg1);
        arg2 = self.root_el(arg2);
        self.in_ker.contains(InKer(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `in_ker` predicate.

    #[allow(dead_code)]
    pub fn iter_in_ker(&self) -> impl '_ + Iterator<Item = (Morphism, El, El)> {
        self.in_ker.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `in_ker(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_in_ker(&mut self, mut tm0: Morphism, mut tm1: El, mut tm2: El) {
        tm0 = self.morphism_equalities.root(tm0);
        tm1 = self.el_equalities.root(tm1);
        tm2 = self.el_equalities.root(tm2);
        if self.in_ker.insert(InKer(tm0, tm1, tm2)) {
            let weight0 = &mut self.morphism_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(InKerTable::WEIGHT);

            let weight1 = &mut self.el_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(InKerTable::WEIGHT);

            let weight2 = &mut self.el_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(InKerTable::WEIGHT);
        }
    }

    /// Returns `true` if `el_in_img(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn el_in_img(&self, mut arg0: Morphism, mut arg1: El) -> bool {
        arg0 = self.root_morphism(arg0);
        arg1 = self.root_el(arg1);
        self.el_in_img.contains(ElInImg(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `el_in_img` predicate.

    #[allow(dead_code)]
    pub fn iter_el_in_img(&self) -> impl '_ + Iterator<Item = (Morphism, El)> {
        self.el_in_img.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `el_in_img(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_el_in_img(&mut self, mut tm0: Morphism, mut tm1: El) {
        tm0 = self.morphism_equalities.root(tm0);
        tm1 = self.el_equalities.root(tm1);
        if self.el_in_img.insert(ElInImg(tm0, tm1)) {
            let weight0 = &mut self.morphism_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ElInImgTable::WEIGHT);

            let weight1 = &mut self.el_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ElInImgTable::WEIGHT);
        }
    }

    /// Returns `true` if `rel_tuple_in_img(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn rel_tuple_in_img(&self, mut arg0: Morphism, mut arg1: Rel, mut arg2: ElList) -> bool {
        arg0 = self.root_morphism(arg0);
        arg1 = self.root_rel(arg1);
        arg2 = self.root_el_list(arg2);
        self.rel_tuple_in_img
            .contains(RelTupleInImg(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `rel_tuple_in_img` predicate.

    #[allow(dead_code)]
    pub fn iter_rel_tuple_in_img(&self) -> impl '_ + Iterator<Item = (Morphism, Rel, ElList)> {
        self.rel_tuple_in_img.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `rel_tuple_in_img(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_rel_tuple_in_img(&mut self, mut tm0: Morphism, mut tm1: Rel, mut tm2: ElList) {
        tm0 = self.morphism_equalities.root(tm0);
        tm1 = self.rel_equalities.root(tm1);
        tm2 = self.el_list_equalities.root(tm2);
        if self.rel_tuple_in_img.insert(RelTupleInImg(tm0, tm1, tm2)) {
            let weight0 = &mut self.morphism_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(RelTupleInImgTable::WEIGHT);

            let weight1 = &mut self.rel_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(RelTupleInImgTable::WEIGHT);

            let weight2 = &mut self.el_list_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(RelTupleInImgTable::WEIGHT);
        }
    }

    /// Returns `true` if `defined_symbol(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn defined_symbol(&self, mut arg0: Ident, mut arg1: SymbolKind, mut arg2: Loc) -> bool {
        arg0 = self.root_ident(arg0);
        arg1 = self.root_symbol_kind(arg1);
        arg2 = self.root_loc(arg2);
        self.defined_symbol
            .contains(DefinedSymbol(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `defined_symbol` predicate.

    #[allow(dead_code)]
    pub fn iter_defined_symbol(&self) -> impl '_ + Iterator<Item = (Ident, SymbolKind, Loc)> {
        self.defined_symbol.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `defined_symbol(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_defined_symbol(&mut self, mut tm0: Ident, mut tm1: SymbolKind, mut tm2: Loc) {
        tm0 = self.ident_equalities.root(tm0);
        tm1 = self.symbol_kind_equalities.root(tm1);
        tm2 = self.loc_equalities.root(tm2);
        if self.defined_symbol.insert(DefinedSymbol(tm0, tm1, tm2)) {
            let weight0 = &mut self.ident_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(DefinedSymbolTable::WEIGHT);

            let weight1 = &mut self.symbol_kind_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(DefinedSymbolTable::WEIGHT);

            let weight2 = &mut self.loc_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(DefinedSymbolTable::WEIGHT);
        }
    }

    /// Returns `true` if `should_be_symbol(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn should_be_symbol(&self, mut arg0: Ident, mut arg1: SymbolKind, mut arg2: Loc) -> bool {
        arg0 = self.root_ident(arg0);
        arg1 = self.root_symbol_kind(arg1);
        arg2 = self.root_loc(arg2);
        self.should_be_symbol
            .contains(ShouldBeSymbol(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `should_be_symbol` predicate.

    #[allow(dead_code)]
    pub fn iter_should_be_symbol(&self) -> impl '_ + Iterator<Item = (Ident, SymbolKind, Loc)> {
        self.should_be_symbol.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `should_be_symbol(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_should_be_symbol(&mut self, mut tm0: Ident, mut tm1: SymbolKind, mut tm2: Loc) {
        tm0 = self.ident_equalities.root(tm0);
        tm1 = self.symbol_kind_equalities.root(tm1);
        tm2 = self.loc_equalities.root(tm2);
        if self.should_be_symbol.insert(ShouldBeSymbol(tm0, tm1, tm2)) {
            let weight0 = &mut self.ident_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ShouldBeSymbolTable::WEIGHT);

            let weight1 = &mut self.symbol_kind_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ShouldBeSymbolTable::WEIGHT);

            let weight2 = &mut self.loc_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(ShouldBeSymbolTable::WEIGHT);
        }
    }

    /// Returns `true` if `should_be_symbol_2(arg0, arg1, arg2, arg3)` holds.
    #[allow(dead_code)]
    pub fn should_be_symbol_2(
        &self,
        mut arg0: Ident,
        mut arg1: SymbolKind,
        mut arg2: SymbolKind,
        mut arg3: Loc,
    ) -> bool {
        arg0 = self.root_ident(arg0);
        arg1 = self.root_symbol_kind(arg1);
        arg2 = self.root_symbol_kind(arg2);
        arg3 = self.root_loc(arg3);
        self.should_be_symbol_2
            .contains(ShouldBeSymbol2(arg0, arg1, arg2, arg3))
    }
    /// Returns an iterator over tuples of elements satisfying the `should_be_symbol_2` predicate.

    #[allow(dead_code)]
    pub fn iter_should_be_symbol_2(
        &self,
    ) -> impl '_ + Iterator<Item = (Ident, SymbolKind, SymbolKind, Loc)> {
        self.should_be_symbol_2
            .iter_all()
            .map(|t| (t.0, t.1, t.2, t.3))
    }
    /// Makes `should_be_symbol_2(tm0, tm1, tm2, tm3)` hold.

    #[allow(dead_code)]
    pub fn insert_should_be_symbol_2(
        &mut self,
        mut tm0: Ident,
        mut tm1: SymbolKind,
        mut tm2: SymbolKind,
        mut tm3: Loc,
    ) {
        tm0 = self.ident_equalities.root(tm0);
        tm1 = self.symbol_kind_equalities.root(tm1);
        tm2 = self.symbol_kind_equalities.root(tm2);
        tm3 = self.loc_equalities.root(tm3);
        if self
            .should_be_symbol_2
            .insert(ShouldBeSymbol2(tm0, tm1, tm2, tm3))
        {
            let weight0 = &mut self.ident_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ShouldBeSymbol2Table::WEIGHT);

            let weight1 = &mut self.symbol_kind_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ShouldBeSymbol2Table::WEIGHT);

            let weight2 = &mut self.symbol_kind_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(ShouldBeSymbol2Table::WEIGHT);

            let weight3 = &mut self.loc_weights[tm3.0 as usize];
            *weight3 = weight3.saturating_add(ShouldBeSymbol2Table::WEIGHT);
        }
    }

    /// Returns `true` if `pred_arg_num_should_match(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn pred_arg_num_should_match(&self, mut arg0: Nat, mut arg1: Nat, mut arg2: Loc) -> bool {
        arg0 = self.root_nat(arg0);
        arg1 = self.root_nat(arg1);
        arg2 = self.root_loc(arg2);
        self.pred_arg_num_should_match
            .contains(PredArgNumShouldMatch(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `pred_arg_num_should_match` predicate.

    #[allow(dead_code)]
    pub fn iter_pred_arg_num_should_match(&self) -> impl '_ + Iterator<Item = (Nat, Nat, Loc)> {
        self.pred_arg_num_should_match
            .iter_all()
            .map(|t| (t.0, t.1, t.2))
    }
    /// Makes `pred_arg_num_should_match(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_pred_arg_num_should_match(&mut self, mut tm0: Nat, mut tm1: Nat, mut tm2: Loc) {
        tm0 = self.nat_equalities.root(tm0);
        tm1 = self.nat_equalities.root(tm1);
        tm2 = self.loc_equalities.root(tm2);
        if self
            .pred_arg_num_should_match
            .insert(PredArgNumShouldMatch(tm0, tm1, tm2))
        {
            let weight0 = &mut self.nat_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(PredArgNumShouldMatchTable::WEIGHT);

            let weight1 = &mut self.nat_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(PredArgNumShouldMatchTable::WEIGHT);

            let weight2 = &mut self.loc_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(PredArgNumShouldMatchTable::WEIGHT);
        }
    }

    /// Returns `true` if `func_arg_num_should_match(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn func_arg_num_should_match(&self, mut arg0: Nat, mut arg1: Nat, mut arg2: Loc) -> bool {
        arg0 = self.root_nat(arg0);
        arg1 = self.root_nat(arg1);
        arg2 = self.root_loc(arg2);
        self.func_arg_num_should_match
            .contains(FuncArgNumShouldMatch(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `func_arg_num_should_match` predicate.

    #[allow(dead_code)]
    pub fn iter_func_arg_num_should_match(&self) -> impl '_ + Iterator<Item = (Nat, Nat, Loc)> {
        self.func_arg_num_should_match
            .iter_all()
            .map(|t| (t.0, t.1, t.2))
    }
    /// Makes `func_arg_num_should_match(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_func_arg_num_should_match(&mut self, mut tm0: Nat, mut tm1: Nat, mut tm2: Loc) {
        tm0 = self.nat_equalities.root(tm0);
        tm1 = self.nat_equalities.root(tm1);
        tm2 = self.loc_equalities.root(tm2);
        if self
            .func_arg_num_should_match
            .insert(FuncArgNumShouldMatch(tm0, tm1, tm2))
        {
            let weight0 = &mut self.nat_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(FuncArgNumShouldMatchTable::WEIGHT);

            let weight1 = &mut self.nat_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(FuncArgNumShouldMatchTable::WEIGHT);

            let weight2 = &mut self.loc_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(FuncArgNumShouldMatchTable::WEIGHT);
        }
    }

    /// Returns `true` if `cfg_edge(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn cfg_edge(&self, mut arg0: StmtNode, mut arg1: StmtNode) -> bool {
        arg0 = self.root_stmt_node(arg0);
        arg1 = self.root_stmt_node(arg1);
        self.cfg_edge.contains(CfgEdge(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `cfg_edge` predicate.

    #[allow(dead_code)]
    pub fn iter_cfg_edge(&self) -> impl '_ + Iterator<Item = (StmtNode, StmtNode)> {
        self.cfg_edge.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `cfg_edge(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_cfg_edge(&mut self, mut tm0: StmtNode, mut tm1: StmtNode) {
        tm0 = self.stmt_node_equalities.root(tm0);
        tm1 = self.stmt_node_equalities.root(tm1);
        if self.cfg_edge.insert(CfgEdge(tm0, tm1)) {
            let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(CfgEdgeTable::WEIGHT);

            let weight1 = &mut self.stmt_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(CfgEdgeTable::WEIGHT);
        }
    }

    /// Returns `true` if `cfg_edge_stmts_stmt(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn cfg_edge_stmts_stmt(&self, mut arg0: StmtListNode, mut arg1: StmtNode) -> bool {
        arg0 = self.root_stmt_list_node(arg0);
        arg1 = self.root_stmt_node(arg1);
        self.cfg_edge_stmts_stmt
            .contains(CfgEdgeStmtsStmt(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `cfg_edge_stmts_stmt` predicate.

    #[allow(dead_code)]
    pub fn iter_cfg_edge_stmts_stmt(&self) -> impl '_ + Iterator<Item = (StmtListNode, StmtNode)> {
        self.cfg_edge_stmts_stmt.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `cfg_edge_stmts_stmt(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_cfg_edge_stmts_stmt(&mut self, mut tm0: StmtListNode, mut tm1: StmtNode) {
        tm0 = self.stmt_list_node_equalities.root(tm0);
        tm1 = self.stmt_node_equalities.root(tm1);
        if self.cfg_edge_stmts_stmt.insert(CfgEdgeStmtsStmt(tm0, tm1)) {
            let weight0 = &mut self.stmt_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(CfgEdgeStmtsStmtTable::WEIGHT);

            let weight1 = &mut self.stmt_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(CfgEdgeStmtsStmtTable::WEIGHT);
        }
    }

    /// Returns `true` if `cfg_edge_stmt_stmts(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn cfg_edge_stmt_stmts(&self, mut arg0: StmtNode, mut arg1: StmtListNode) -> bool {
        arg0 = self.root_stmt_node(arg0);
        arg1 = self.root_stmt_list_node(arg1);
        self.cfg_edge_stmt_stmts
            .contains(CfgEdgeStmtStmts(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `cfg_edge_stmt_stmts` predicate.

    #[allow(dead_code)]
    pub fn iter_cfg_edge_stmt_stmts(&self) -> impl '_ + Iterator<Item = (StmtNode, StmtListNode)> {
        self.cfg_edge_stmt_stmts.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `cfg_edge_stmt_stmts(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_cfg_edge_stmt_stmts(&mut self, mut tm0: StmtNode, mut tm1: StmtListNode) {
        tm0 = self.stmt_node_equalities.root(tm0);
        tm1 = self.stmt_list_node_equalities.root(tm1);
        if self.cfg_edge_stmt_stmts.insert(CfgEdgeStmtStmts(tm0, tm1)) {
            let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(CfgEdgeStmtStmtsTable::WEIGHT);

            let weight1 = &mut self.stmt_list_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(CfgEdgeStmtStmtsTable::WEIGHT);
        }
    }

    /// Returns `true` if `cfg_edge_fork(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn cfg_edge_fork(&self, mut arg0: StmtNode, mut arg1: StmtBlockListNode) -> bool {
        arg0 = self.root_stmt_node(arg0);
        arg1 = self.root_stmt_block_list_node(arg1);
        self.cfg_edge_fork.contains(CfgEdgeFork(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `cfg_edge_fork` predicate.

    #[allow(dead_code)]
    pub fn iter_cfg_edge_fork(&self) -> impl '_ + Iterator<Item = (StmtNode, StmtBlockListNode)> {
        self.cfg_edge_fork.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `cfg_edge_fork(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_cfg_edge_fork(&mut self, mut tm0: StmtNode, mut tm1: StmtBlockListNode) {
        tm0 = self.stmt_node_equalities.root(tm0);
        tm1 = self.stmt_block_list_node_equalities.root(tm1);
        if self.cfg_edge_fork.insert(CfgEdgeFork(tm0, tm1)) {
            let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(CfgEdgeForkTable::WEIGHT);

            let weight1 = &mut self.stmt_block_list_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(CfgEdgeForkTable::WEIGHT);
        }
    }

    /// Returns `true` if `cfg_edge_join(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn cfg_edge_join(&self, mut arg0: StmtBlockListNode, mut arg1: StmtNode) -> bool {
        arg0 = self.root_stmt_block_list_node(arg0);
        arg1 = self.root_stmt_node(arg1);
        self.cfg_edge_join.contains(CfgEdgeJoin(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `cfg_edge_join` predicate.

    #[allow(dead_code)]
    pub fn iter_cfg_edge_join(&self) -> impl '_ + Iterator<Item = (StmtBlockListNode, StmtNode)> {
        self.cfg_edge_join.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `cfg_edge_join(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_cfg_edge_join(&mut self, mut tm0: StmtBlockListNode, mut tm1: StmtNode) {
        tm0 = self.stmt_block_list_node_equalities.root(tm0);
        tm1 = self.stmt_node_equalities.root(tm1);
        if self.cfg_edge_join.insert(CfgEdgeJoin(tm0, tm1)) {
            let weight0 = &mut self.stmt_block_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(CfgEdgeJoinTable::WEIGHT);

            let weight1 = &mut self.stmt_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(CfgEdgeJoinTable::WEIGHT);
        }
    }

    /// Returns `true` if `before_stmt_structure(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn before_stmt_structure(&self, mut arg0: StmtNode, mut arg1: Structure) -> bool {
        arg0 = self.root_stmt_node(arg0);
        arg1 = self.root_structure(arg1);
        self.before_stmt_structure
            .contains(BeforeStmtStructure(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `before_stmt_structure` predicate.

    #[allow(dead_code)]
    pub fn iter_before_stmt_structure(&self) -> impl '_ + Iterator<Item = (StmtNode, Structure)> {
        self.before_stmt_structure.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `before_stmt_structure(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_before_stmt_structure(&mut self, mut tm0: StmtNode, mut tm1: Structure) {
        tm0 = self.stmt_node_equalities.root(tm0);
        tm1 = self.structure_equalities.root(tm1);
        if self
            .before_stmt_structure
            .insert(BeforeStmtStructure(tm0, tm1))
        {
            let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(BeforeStmtStructureTable::WEIGHT);

            let weight1 = &mut self.structure_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(BeforeStmtStructureTable::WEIGHT);
        }
    }

    /// Returns `true` if `stmt_morphism(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn stmt_morphism(&self, mut arg0: StmtNode, mut arg1: Morphism) -> bool {
        arg0 = self.root_stmt_node(arg0);
        arg1 = self.root_morphism(arg1);
        self.stmt_morphism.contains(StmtMorphism(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `stmt_morphism` predicate.

    #[allow(dead_code)]
    pub fn iter_stmt_morphism(&self) -> impl '_ + Iterator<Item = (StmtNode, Morphism)> {
        self.stmt_morphism.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `stmt_morphism(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_stmt_morphism(&mut self, mut tm0: StmtNode, mut tm1: Morphism) {
        tm0 = self.stmt_node_equalities.root(tm0);
        tm1 = self.morphism_equalities.root(tm1);
        if self.stmt_morphism.insert(StmtMorphism(tm0, tm1)) {
            let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(StmtMorphismTable::WEIGHT);

            let weight1 = &mut self.morphism_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(StmtMorphismTable::WEIGHT);
        }
    }

    /// Returns `true` if `if_morphism(arg0)` holds.
    #[allow(dead_code)]
    pub fn if_morphism(&self, mut arg0: Morphism) -> bool {
        arg0 = self.root_morphism(arg0);
        self.if_morphism.contains(IfMorphism(arg0))
    }
    /// Returns an iterator over elements satisfying the `if_morphism` predicate.

    #[allow(dead_code)]
    pub fn iter_if_morphism(&self) -> impl '_ + Iterator<Item = Morphism> {
        self.if_morphism.iter_all().map(|t| t.0)
    }
    /// Makes `if_morphism(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_if_morphism(&mut self, mut tm0: Morphism) {
        tm0 = self.morphism_equalities.root(tm0);
        if self.if_morphism.insert(IfMorphism(tm0)) {
            let weight0 = &mut self.morphism_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(IfMorphismTable::WEIGHT);
        }
    }

    /// Returns `true` if `surj_then_morphism(arg0)` holds.
    #[allow(dead_code)]
    pub fn surj_then_morphism(&self, mut arg0: Morphism) -> bool {
        arg0 = self.root_morphism(arg0);
        self.surj_then_morphism.contains(SurjThenMorphism(arg0))
    }
    /// Returns an iterator over elements satisfying the `surj_then_morphism` predicate.

    #[allow(dead_code)]
    pub fn iter_surj_then_morphism(&self) -> impl '_ + Iterator<Item = Morphism> {
        self.surj_then_morphism.iter_all().map(|t| t.0)
    }
    /// Makes `surj_then_morphism(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_surj_then_morphism(&mut self, mut tm0: Morphism) {
        tm0 = self.morphism_equalities.root(tm0);
        if self.surj_then_morphism.insert(SurjThenMorphism(tm0)) {
            let weight0 = &mut self.morphism_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(SurjThenMorphismTable::WEIGHT);
        }
    }

    /// Returns `true` if `non_surj_then_morphism(arg0)` holds.
    #[allow(dead_code)]
    pub fn non_surj_then_morphism(&self, mut arg0: Morphism) -> bool {
        arg0 = self.root_morphism(arg0);
        self.non_surj_then_morphism
            .contains(NonSurjThenMorphism(arg0))
    }
    /// Returns an iterator over elements satisfying the `non_surj_then_morphism` predicate.

    #[allow(dead_code)]
    pub fn iter_non_surj_then_morphism(&self) -> impl '_ + Iterator<Item = Morphism> {
        self.non_surj_then_morphism.iter_all().map(|t| t.0)
    }
    /// Makes `non_surj_then_morphism(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_non_surj_then_morphism(&mut self, mut tm0: Morphism) {
        tm0 = self.morphism_equalities.root(tm0);
        if self.non_surj_then_morphism.insert(NonSurjThenMorphism(tm0)) {
            let weight0 = &mut self.morphism_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(NonSurjThenMorphismTable::WEIGHT);
        }
    }

    /// Returns `true` if `noop_morphism(arg0)` holds.
    #[allow(dead_code)]
    pub fn noop_morphism(&self, mut arg0: Morphism) -> bool {
        arg0 = self.root_morphism(arg0);
        self.noop_morphism.contains(NoopMorphism(arg0))
    }
    /// Returns an iterator over elements satisfying the `noop_morphism` predicate.

    #[allow(dead_code)]
    pub fn iter_noop_morphism(&self) -> impl '_ + Iterator<Item = Morphism> {
        self.noop_morphism.iter_all().map(|t| t.0)
    }
    /// Makes `noop_morphism(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_noop_morphism(&mut self, mut tm0: Morphism) {
        tm0 = self.morphism_equalities.root(tm0);
        if self.noop_morphism.insert(NoopMorphism(tm0)) {
            let weight0 = &mut self.morphism_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(NoopMorphismTable::WEIGHT);
        }
    }

    /// Returns `true` if `stmt_structure(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn stmt_structure(&self, mut arg0: StmtNode, mut arg1: Structure) -> bool {
        arg0 = self.root_stmt_node(arg0);
        arg1 = self.root_structure(arg1);
        self.stmt_structure.contains(StmtStructure(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `stmt_structure` predicate.

    #[allow(dead_code)]
    pub fn iter_stmt_structure(&self) -> impl '_ + Iterator<Item = (StmtNode, Structure)> {
        self.stmt_structure.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `stmt_structure(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_stmt_structure(&mut self, mut tm0: StmtNode, mut tm1: Structure) {
        tm0 = self.stmt_node_equalities.root(tm0);
        tm1 = self.structure_equalities.root(tm1);
        if self.stmt_structure.insert(StmtStructure(tm0, tm1)) {
            let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(StmtStructureTable::WEIGHT);

            let weight1 = &mut self.structure_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(StmtStructureTable::WEIGHT);
        }
    }

    /// Returns `true` if `if_atom_structure(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn if_atom_structure(&self, mut arg0: IfAtomNode, mut arg1: Structure) -> bool {
        arg0 = self.root_if_atom_node(arg0);
        arg1 = self.root_structure(arg1);
        self.if_atom_structure.contains(IfAtomStructure(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `if_atom_structure` predicate.

    #[allow(dead_code)]
    pub fn iter_if_atom_structure(&self) -> impl '_ + Iterator<Item = (IfAtomNode, Structure)> {
        self.if_atom_structure.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `if_atom_structure(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_if_atom_structure(&mut self, mut tm0: IfAtomNode, mut tm1: Structure) {
        tm0 = self.if_atom_node_equalities.root(tm0);
        tm1 = self.structure_equalities.root(tm1);
        if self.if_atom_structure.insert(IfAtomStructure(tm0, tm1)) {
            let weight0 = &mut self.if_atom_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(IfAtomStructureTable::WEIGHT);

            let weight1 = &mut self.structure_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(IfAtomStructureTable::WEIGHT);
        }
    }

    /// Returns `true` if `then_atom_structure(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn then_atom_structure(&self, mut arg0: ThenAtomNode, mut arg1: Structure) -> bool {
        arg0 = self.root_then_atom_node(arg0);
        arg1 = self.root_structure(arg1);
        self.then_atom_structure
            .contains(ThenAtomStructure(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `then_atom_structure` predicate.

    #[allow(dead_code)]
    pub fn iter_then_atom_structure(&self) -> impl '_ + Iterator<Item = (ThenAtomNode, Structure)> {
        self.then_atom_structure.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `then_atom_structure(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_then_atom_structure(&mut self, mut tm0: ThenAtomNode, mut tm1: Structure) {
        tm0 = self.then_atom_node_equalities.root(tm0);
        tm1 = self.structure_equalities.root(tm1);
        if self.then_atom_structure.insert(ThenAtomStructure(tm0, tm1)) {
            let weight0 = &mut self.then_atom_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ThenAtomStructureTable::WEIGHT);

            let weight1 = &mut self.structure_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ThenAtomStructureTable::WEIGHT);
        }
    }

    /// Returns `true` if `term_structure(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn term_structure(&self, mut arg0: TermNode, mut arg1: Structure) -> bool {
        arg0 = self.root_term_node(arg0);
        arg1 = self.root_structure(arg1);
        self.term_structure.contains(TermStructure(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `term_structure` predicate.

    #[allow(dead_code)]
    pub fn iter_term_structure(&self) -> impl '_ + Iterator<Item = (TermNode, Structure)> {
        self.term_structure.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `term_structure(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_term_structure(&mut self, mut tm0: TermNode, mut tm1: Structure) {
        tm0 = self.term_node_equalities.root(tm0);
        tm1 = self.structure_equalities.root(tm1);
        if self.term_structure.insert(TermStructure(tm0, tm1)) {
            let weight0 = &mut self.term_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(TermStructureTable::WEIGHT);

            let weight1 = &mut self.structure_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(TermStructureTable::WEIGHT);
        }
    }

    /// Returns `true` if `terms_structure(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn terms_structure(&self, mut arg0: TermListNode, mut arg1: Structure) -> bool {
        arg0 = self.root_term_list_node(arg0);
        arg1 = self.root_structure(arg1);
        self.terms_structure.contains(TermsStructure(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `terms_structure` predicate.

    #[allow(dead_code)]
    pub fn iter_terms_structure(&self) -> impl '_ + Iterator<Item = (TermListNode, Structure)> {
        self.terms_structure.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `terms_structure(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_terms_structure(&mut self, mut tm0: TermListNode, mut tm1: Structure) {
        tm0 = self.term_list_node_equalities.root(tm0);
        tm1 = self.structure_equalities.root(tm1);
        if self.terms_structure.insert(TermsStructure(tm0, tm1)) {
            let weight0 = &mut self.term_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(TermsStructureTable::WEIGHT);

            let weight1 = &mut self.structure_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(TermsStructureTable::WEIGHT);
        }
    }

    /// Returns `true` if `opt_term_structure(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn opt_term_structure(&self, mut arg0: OptTermNode, mut arg1: Structure) -> bool {
        arg0 = self.root_opt_term_node(arg0);
        arg1 = self.root_structure(arg1);
        self.opt_term_structure
            .contains(OptTermStructure(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `opt_term_structure` predicate.

    #[allow(dead_code)]
    pub fn iter_opt_term_structure(&self) -> impl '_ + Iterator<Item = (OptTermNode, Structure)> {
        self.opt_term_structure.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `opt_term_structure(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_opt_term_structure(&mut self, mut tm0: OptTermNode, mut tm1: Structure) {
        tm0 = self.opt_term_node_equalities.root(tm0);
        tm1 = self.structure_equalities.root(tm1);
        if self.opt_term_structure.insert(OptTermStructure(tm0, tm1)) {
            let weight0 = &mut self.opt_term_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(OptTermStructureTable::WEIGHT);

            let weight1 = &mut self.structure_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(OptTermStructureTable::WEIGHT);
        }
    }

    /// Returns `true` if `term_should_be_epic_ok(arg0)` holds.
    #[allow(dead_code)]
    pub fn term_should_be_epic_ok(&self, mut arg0: TermNode) -> bool {
        arg0 = self.root_term_node(arg0);
        self.term_should_be_epic_ok
            .contains(TermShouldBeEpicOk(arg0))
    }
    /// Returns an iterator over elements satisfying the `term_should_be_epic_ok` predicate.

    #[allow(dead_code)]
    pub fn iter_term_should_be_epic_ok(&self) -> impl '_ + Iterator<Item = TermNode> {
        self.term_should_be_epic_ok.iter_all().map(|t| t.0)
    }
    /// Makes `term_should_be_epic_ok(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_term_should_be_epic_ok(&mut self, mut tm0: TermNode) {
        tm0 = self.term_node_equalities.root(tm0);
        if self.term_should_be_epic_ok.insert(TermShouldBeEpicOk(tm0)) {
            let weight0 = &mut self.term_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(TermShouldBeEpicOkTable::WEIGHT);
        }
    }

    /// Returns `true` if `terms_should_be_epic_ok(arg0)` holds.
    #[allow(dead_code)]
    pub fn terms_should_be_epic_ok(&self, mut arg0: TermListNode) -> bool {
        arg0 = self.root_term_list_node(arg0);
        self.terms_should_be_epic_ok
            .contains(TermsShouldBeEpicOk(arg0))
    }
    /// Returns an iterator over elements satisfying the `terms_should_be_epic_ok` predicate.

    #[allow(dead_code)]
    pub fn iter_terms_should_be_epic_ok(&self) -> impl '_ + Iterator<Item = TermListNode> {
        self.terms_should_be_epic_ok.iter_all().map(|t| t.0)
    }
    /// Makes `terms_should_be_epic_ok(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_terms_should_be_epic_ok(&mut self, mut tm0: TermListNode) {
        tm0 = self.term_list_node_equalities.root(tm0);
        if self
            .terms_should_be_epic_ok
            .insert(TermsShouldBeEpicOk(tm0))
        {
            let weight0 = &mut self.term_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(TermsShouldBeEpicOkTable::WEIGHT);
        }
    }

    /// Returns `true` if `el_should_be_surjective_ok(arg0)` holds.
    #[allow(dead_code)]
    pub fn el_should_be_surjective_ok(&self, mut arg0: El) -> bool {
        arg0 = self.root_el(arg0);
        self.el_should_be_surjective_ok
            .contains(ElShouldBeSurjectiveOk(arg0))
    }
    /// Returns an iterator over elements satisfying the `el_should_be_surjective_ok` predicate.

    #[allow(dead_code)]
    pub fn iter_el_should_be_surjective_ok(&self) -> impl '_ + Iterator<Item = El> {
        self.el_should_be_surjective_ok.iter_all().map(|t| t.0)
    }
    /// Makes `el_should_be_surjective_ok(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_el_should_be_surjective_ok(&mut self, mut tm0: El) {
        tm0 = self.el_equalities.root(tm0);
        if self
            .el_should_be_surjective_ok
            .insert(ElShouldBeSurjectiveOk(tm0))
        {
            let weight0 = &mut self.el_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ElShouldBeSurjectiveOkTable::WEIGHT);
        }
    }

    /// Returns `true` if `el_is_surjective_ok(arg0)` holds.
    #[allow(dead_code)]
    pub fn el_is_surjective_ok(&self, mut arg0: El) -> bool {
        arg0 = self.root_el(arg0);
        self.el_is_surjective_ok.contains(ElIsSurjectiveOk(arg0))
    }
    /// Returns an iterator over elements satisfying the `el_is_surjective_ok` predicate.

    #[allow(dead_code)]
    pub fn iter_el_is_surjective_ok(&self) -> impl '_ + Iterator<Item = El> {
        self.el_is_surjective_ok.iter_all().map(|t| t.0)
    }
    /// Makes `el_is_surjective_ok(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_el_is_surjective_ok(&mut self, mut tm0: El) {
        tm0 = self.el_equalities.root(tm0);
        if self.el_is_surjective_ok.insert(ElIsSurjectiveOk(tm0)) {
            let weight0 = &mut self.el_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ElIsSurjectiveOkTable::WEIGHT);
        }
    }

    /// Returns `true` if `should_be_obtained_by_ctor(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn should_be_obtained_by_ctor(&self, mut arg0: TermNode, mut arg1: EnumDeclNode) -> bool {
        arg0 = self.root_term_node(arg0);
        arg1 = self.root_enum_decl_node(arg1);
        self.should_be_obtained_by_ctor
            .contains(ShouldBeObtainedByCtor(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `should_be_obtained_by_ctor` predicate.

    #[allow(dead_code)]
    pub fn iter_should_be_obtained_by_ctor(
        &self,
    ) -> impl '_ + Iterator<Item = (TermNode, EnumDeclNode)> {
        self.should_be_obtained_by_ctor
            .iter_all()
            .map(|t| (t.0, t.1))
    }
    /// Makes `should_be_obtained_by_ctor(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_should_be_obtained_by_ctor(&mut self, mut tm0: TermNode, mut tm1: EnumDeclNode) {
        tm0 = self.term_node_equalities.root(tm0);
        tm1 = self.enum_decl_node_equalities.root(tm1);
        if self
            .should_be_obtained_by_ctor
            .insert(ShouldBeObtainedByCtor(tm0, tm1))
        {
            let weight0 = &mut self.term_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ShouldBeObtainedByCtorTable::WEIGHT);

            let weight1 = &mut self.enum_decl_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(ShouldBeObtainedByCtorTable::WEIGHT);
        }
    }

    /// Returns `true` if `is_given_by_ctor(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn is_given_by_ctor(&self, mut arg0: TermNode, mut arg1: EnumDeclNode) -> bool {
        arg0 = self.root_term_node(arg0);
        arg1 = self.root_enum_decl_node(arg1);
        self.is_given_by_ctor.contains(IsGivenByCtor(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `is_given_by_ctor` predicate.

    #[allow(dead_code)]
    pub fn iter_is_given_by_ctor(&self) -> impl '_ + Iterator<Item = (TermNode, EnumDeclNode)> {
        self.is_given_by_ctor.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `is_given_by_ctor(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_is_given_by_ctor(&mut self, mut tm0: TermNode, mut tm1: EnumDeclNode) {
        tm0 = self.term_node_equalities.root(tm0);
        tm1 = self.enum_decl_node_equalities.root(tm1);
        if self.is_given_by_ctor.insert(IsGivenByCtor(tm0, tm1)) {
            let weight0 = &mut self.term_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(IsGivenByCtorTable::WEIGHT);

            let weight1 = &mut self.enum_decl_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(IsGivenByCtorTable::WEIGHT);
        }
    }

    /// Returns `true` if `function_can_be_made_defined(arg0)` holds.
    #[allow(dead_code)]
    pub fn function_can_be_made_defined(&self, mut arg0: Func) -> bool {
        arg0 = self.root_func(arg0);
        self.function_can_be_made_defined
            .contains(FunctionCanBeMadeDefined(arg0))
    }
    /// Returns an iterator over elements satisfying the `function_can_be_made_defined` predicate.

    #[allow(dead_code)]
    pub fn iter_function_can_be_made_defined(&self) -> impl '_ + Iterator<Item = Func> {
        self.function_can_be_made_defined.iter_all().map(|t| t.0)
    }
    /// Makes `function_can_be_made_defined(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_function_can_be_made_defined(&mut self, mut tm0: Func) {
        tm0 = self.func_equalities.root(tm0);
        if self
            .function_can_be_made_defined
            .insert(FunctionCanBeMadeDefined(tm0))
        {
            let weight0 = &mut self.func_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(FunctionCanBeMadeDefinedTable::WEIGHT);
        }
    }

    /// Returns `true` if `case_pattern_is_variable(arg0)` holds.
    #[allow(dead_code)]
    pub fn case_pattern_is_variable(&self, mut arg0: Loc) -> bool {
        arg0 = self.root_loc(arg0);
        self.case_pattern_is_variable
            .contains(CasePatternIsVariable(arg0))
    }
    /// Returns an iterator over elements satisfying the `case_pattern_is_variable` predicate.

    #[allow(dead_code)]
    pub fn iter_case_pattern_is_variable(&self) -> impl '_ + Iterator<Item = Loc> {
        self.case_pattern_is_variable.iter_all().map(|t| t.0)
    }
    /// Makes `case_pattern_is_variable(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_case_pattern_is_variable(&mut self, mut tm0: Loc) {
        tm0 = self.loc_equalities.root(tm0);
        if self
            .case_pattern_is_variable
            .insert(CasePatternIsVariable(tm0))
        {
            let weight0 = &mut self.loc_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(CasePatternIsVariableTable::WEIGHT);
        }
    }

    /// Returns `true` if `case_pattern_is_wildcard(arg0)` holds.
    #[allow(dead_code)]
    pub fn case_pattern_is_wildcard(&self, mut arg0: Loc) -> bool {
        arg0 = self.root_loc(arg0);
        self.case_pattern_is_wildcard
            .contains(CasePatternIsWildcard(arg0))
    }
    /// Returns an iterator over elements satisfying the `case_pattern_is_wildcard` predicate.

    #[allow(dead_code)]
    pub fn iter_case_pattern_is_wildcard(&self) -> impl '_ + Iterator<Item = Loc> {
        self.case_pattern_is_wildcard.iter_all().map(|t| t.0)
    }
    /// Makes `case_pattern_is_wildcard(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_case_pattern_is_wildcard(&mut self, mut tm0: Loc) {
        tm0 = self.loc_equalities.root(tm0);
        if self
            .case_pattern_is_wildcard
            .insert(CasePatternIsWildcard(tm0))
        {
            let weight0 = &mut self.loc_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(CasePatternIsWildcardTable::WEIGHT);
        }
    }

    /// Returns `true` if `is_pattern_ctor_arg(arg0)` holds.
    #[allow(dead_code)]
    pub fn is_pattern_ctor_arg(&self, mut arg0: TermNode) -> bool {
        arg0 = self.root_term_node(arg0);
        self.is_pattern_ctor_arg.contains(IsPatternCtorArg(arg0))
    }
    /// Returns an iterator over elements satisfying the `is_pattern_ctor_arg` predicate.

    #[allow(dead_code)]
    pub fn iter_is_pattern_ctor_arg(&self) -> impl '_ + Iterator<Item = TermNode> {
        self.is_pattern_ctor_arg.iter_all().map(|t| t.0)
    }
    /// Makes `is_pattern_ctor_arg(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_is_pattern_ctor_arg(&mut self, mut tm0: TermNode) {
        tm0 = self.term_node_equalities.root(tm0);
        if self.is_pattern_ctor_arg.insert(IsPatternCtorArg(tm0)) {
            let weight0 = &mut self.term_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(IsPatternCtorArgTable::WEIGHT);
        }
    }

    /// Returns `true` if `are_pattern_ctor_args(arg0)` holds.
    #[allow(dead_code)]
    pub fn are_pattern_ctor_args(&self, mut arg0: TermListNode) -> bool {
        arg0 = self.root_term_list_node(arg0);
        self.are_pattern_ctor_args
            .contains(ArePatternCtorArgs(arg0))
    }
    /// Returns an iterator over elements satisfying the `are_pattern_ctor_args` predicate.

    #[allow(dead_code)]
    pub fn iter_are_pattern_ctor_args(&self) -> impl '_ + Iterator<Item = TermListNode> {
        self.are_pattern_ctor_args.iter_all().map(|t| t.0)
    }
    /// Makes `are_pattern_ctor_args(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_are_pattern_ctor_args(&mut self, mut tm0: TermListNode) {
        tm0 = self.term_list_node_equalities.root(tm0);
        if self.are_pattern_ctor_args.insert(ArePatternCtorArgs(tm0)) {
            let weight0 = &mut self.term_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(ArePatternCtorArgsTable::WEIGHT);
        }
    }

    /// Returns `true` if `pattern_ctor_arg_is_app(arg0)` holds.
    #[allow(dead_code)]
    pub fn pattern_ctor_arg_is_app(&self, mut arg0: Loc) -> bool {
        arg0 = self.root_loc(arg0);
        self.pattern_ctor_arg_is_app
            .contains(PatternCtorArgIsApp(arg0))
    }
    /// Returns an iterator over elements satisfying the `pattern_ctor_arg_is_app` predicate.

    #[allow(dead_code)]
    pub fn iter_pattern_ctor_arg_is_app(&self) -> impl '_ + Iterator<Item = Loc> {
        self.pattern_ctor_arg_is_app.iter_all().map(|t| t.0)
    }
    /// Makes `pattern_ctor_arg_is_app(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_pattern_ctor_arg_is_app(&mut self, mut tm0: Loc) {
        tm0 = self.loc_equalities.root(tm0);
        if self
            .pattern_ctor_arg_is_app
            .insert(PatternCtorArgIsApp(tm0))
        {
            let weight0 = &mut self.loc_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(PatternCtorArgIsAppTable::WEIGHT);
        }
    }

    /// Returns `true` if `pattern_ctor_arg_var_is_not_fresh(arg0)` holds.
    #[allow(dead_code)]
    pub fn pattern_ctor_arg_var_is_not_fresh(&self, mut arg0: Loc) -> bool {
        arg0 = self.root_loc(arg0);
        self.pattern_ctor_arg_var_is_not_fresh
            .contains(PatternCtorArgVarIsNotFresh(arg0))
    }
    /// Returns an iterator over elements satisfying the `pattern_ctor_arg_var_is_not_fresh` predicate.

    #[allow(dead_code)]
    pub fn iter_pattern_ctor_arg_var_is_not_fresh(&self) -> impl '_ + Iterator<Item = Loc> {
        self.pattern_ctor_arg_var_is_not_fresh
            .iter_all()
            .map(|t| t.0)
    }
    /// Makes `pattern_ctor_arg_var_is_not_fresh(tm0)` hold.

    #[allow(dead_code)]
    pub fn insert_pattern_ctor_arg_var_is_not_fresh(&mut self, mut tm0: Loc) {
        tm0 = self.loc_equalities.root(tm0);
        if self
            .pattern_ctor_arg_var_is_not_fresh
            .insert(PatternCtorArgVarIsNotFresh(tm0))
        {
            let weight0 = &mut self.loc_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(PatternCtorArgVarIsNotFreshTable::WEIGHT);
        }
    }

    /// Returns `true` if `cases_contain_ctor(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn cases_contain_ctor(&self, mut arg0: MatchCaseListNode, mut arg1: CtorDeclNode) -> bool {
        arg0 = self.root_match_case_list_node(arg0);
        arg1 = self.root_ctor_decl_node(arg1);
        self.cases_contain_ctor
            .contains(CasesContainCtor(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `cases_contain_ctor` predicate.

    #[allow(dead_code)]
    pub fn iter_cases_contain_ctor(
        &self,
    ) -> impl '_ + Iterator<Item = (MatchCaseListNode, CtorDeclNode)> {
        self.cases_contain_ctor.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `cases_contain_ctor(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_cases_contain_ctor(&mut self, mut tm0: MatchCaseListNode, mut tm1: CtorDeclNode) {
        tm0 = self.match_case_list_node_equalities.root(tm0);
        tm1 = self.ctor_decl_node_equalities.root(tm1);
        if self.cases_contain_ctor.insert(CasesContainCtor(tm0, tm1)) {
            let weight0 = &mut self.match_case_list_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(CasesContainCtorTable::WEIGHT);

            let weight1 = &mut self.ctor_decl_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(CasesContainCtorTable::WEIGHT);
        }
    }

    /// Returns `true` if `match_stmt_contains_ctor_of_enum(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn match_stmt_contains_ctor_of_enum(
        &self,
        mut arg0: StmtNode,
        mut arg1: CtorDeclNode,
        mut arg2: EnumDeclNode,
    ) -> bool {
        arg0 = self.root_stmt_node(arg0);
        arg1 = self.root_ctor_decl_node(arg1);
        arg2 = self.root_enum_decl_node(arg2);
        self.match_stmt_contains_ctor_of_enum
            .contains(MatchStmtContainsCtorOfEnum(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `match_stmt_contains_ctor_of_enum` predicate.

    #[allow(dead_code)]
    pub fn iter_match_stmt_contains_ctor_of_enum(
        &self,
    ) -> impl '_ + Iterator<Item = (StmtNode, CtorDeclNode, EnumDeclNode)> {
        self.match_stmt_contains_ctor_of_enum
            .iter_all()
            .map(|t| (t.0, t.1, t.2))
    }
    /// Makes `match_stmt_contains_ctor_of_enum(tm0, tm1, tm2)` hold.

    #[allow(dead_code)]
    pub fn insert_match_stmt_contains_ctor_of_enum(
        &mut self,
        mut tm0: StmtNode,
        mut tm1: CtorDeclNode,
        mut tm2: EnumDeclNode,
    ) {
        tm0 = self.stmt_node_equalities.root(tm0);
        tm1 = self.ctor_decl_node_equalities.root(tm1);
        tm2 = self.enum_decl_node_equalities.root(tm2);
        if self
            .match_stmt_contains_ctor_of_enum
            .insert(MatchStmtContainsCtorOfEnum(tm0, tm1, tm2))
        {
            let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

            let weight1 = &mut self.ctor_decl_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

            let weight2 = &mut self.enum_decl_node_weights[tm2.0 as usize];
            *weight2 = weight2.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);
        }
    }

    /// Returns `true` if `match_stmt_should_contain_ctor(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn match_stmt_should_contain_ctor(
        &self,
        mut arg0: StmtNode,
        mut arg1: CtorDeclNode,
    ) -> bool {
        arg0 = self.root_stmt_node(arg0);
        arg1 = self.root_ctor_decl_node(arg1);
        self.match_stmt_should_contain_ctor
            .contains(MatchStmtShouldContainCtor(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `match_stmt_should_contain_ctor` predicate.

    #[allow(dead_code)]
    pub fn iter_match_stmt_should_contain_ctor(
        &self,
    ) -> impl '_ + Iterator<Item = (StmtNode, CtorDeclNode)> {
        self.match_stmt_should_contain_ctor
            .iter_all()
            .map(|t| (t.0, t.1))
    }
    /// Makes `match_stmt_should_contain_ctor(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_match_stmt_should_contain_ctor(
        &mut self,
        mut tm0: StmtNode,
        mut tm1: CtorDeclNode,
    ) {
        tm0 = self.stmt_node_equalities.root(tm0);
        tm1 = self.ctor_decl_node_equalities.root(tm1);
        if self
            .match_stmt_should_contain_ctor
            .insert(MatchStmtShouldContainCtor(tm0, tm1))
        {
            let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(MatchStmtShouldContainCtorTable::WEIGHT);

            let weight1 = &mut self.ctor_decl_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(MatchStmtShouldContainCtorTable::WEIGHT);
        }
    }

    /// Returns `true` if `match_stmt_contains_ctor(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn match_stmt_contains_ctor(&self, mut arg0: StmtNode, mut arg1: CtorDeclNode) -> bool {
        arg0 = self.root_stmt_node(arg0);
        arg1 = self.root_ctor_decl_node(arg1);
        self.match_stmt_contains_ctor
            .contains(MatchStmtContainsCtor(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `match_stmt_contains_ctor` predicate.

    #[allow(dead_code)]
    pub fn iter_match_stmt_contains_ctor(
        &self,
    ) -> impl '_ + Iterator<Item = (StmtNode, CtorDeclNode)> {
        self.match_stmt_contains_ctor.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `match_stmt_contains_ctor(tm0, tm1)` hold.

    #[allow(dead_code)]
    pub fn insert_match_stmt_contains_ctor(&mut self, mut tm0: StmtNode, mut tm1: CtorDeclNode) {
        tm0 = self.stmt_node_equalities.root(tm0);
        tm1 = self.ctor_decl_node_equalities.root(tm1);
        if self
            .match_stmt_contains_ctor
            .insert(MatchStmtContainsCtor(tm0, tm1))
        {
            let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
            *weight0 = weight0.saturating_add(MatchStmtContainsCtorTable::WEIGHT);

            let weight1 = &mut self.ctor_decl_node_weights[tm1.0 as usize];
            *weight1 = weight1.saturating_add(MatchStmtContainsCtorTable::WEIGHT);
        }
    }

    fn canonicalize(&mut self) {
        for el in self.ident_uprooted.iter().copied() {
            let ts = self.type_decl.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.type_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(TypeDeclTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(TypeDeclTable::WEIGHT);

                t.0 = self.root_type_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                if self.type_decl.insert(t) {
                    let weight0 = &mut self.type_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(TypeDeclTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(TypeDeclTable::WEIGHT);
                }
            }
        }
        for el in self.type_decl_node_uprooted.iter().copied() {
            let ts = self.type_decl.drain_with_element_type_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.type_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(TypeDeclTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(TypeDeclTable::WEIGHT);

                t.0 = self.root_type_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                if self.type_decl.insert(t) {
                    let weight0 = &mut self.type_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(TypeDeclTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(TypeDeclTable::WEIGHT);
                }
            }
        }

        for el in self.arg_decl_node_uprooted.iter().copied() {
            let ts = self.arg_decl_node_name.drain_with_element_arg_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.arg_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ArgDeclNodeNameTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ArgDeclNodeNameTable::WEIGHT);

                t.0 = self.root_arg_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                if self.arg_decl_node_name.insert(t) {
                    let weight0 = &mut self.arg_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ArgDeclNodeNameTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ArgDeclNodeNameTable::WEIGHT);
                }
            }
        }
        for el in self.ident_uprooted.iter().copied() {
            let ts = self.arg_decl_node_name.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.arg_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ArgDeclNodeNameTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ArgDeclNodeNameTable::WEIGHT);

                t.0 = self.root_arg_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                if self.arg_decl_node_name.insert(t) {
                    let weight0 = &mut self.arg_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ArgDeclNodeNameTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ArgDeclNodeNameTable::WEIGHT);
                }
            }
        }

        for el in self.arg_decl_node_uprooted.iter().copied() {
            let ts = self.arg_decl_node_type.drain_with_element_arg_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.arg_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ArgDeclNodeTypeTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ArgDeclNodeTypeTable::WEIGHT);

                t.0 = self.root_arg_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                if self.arg_decl_node_type.insert(t) {
                    let weight0 = &mut self.arg_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ArgDeclNodeTypeTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ArgDeclNodeTypeTable::WEIGHT);
                }
            }
        }
        for el in self.ident_uprooted.iter().copied() {
            let ts = self.arg_decl_node_type.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.arg_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ArgDeclNodeTypeTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ArgDeclNodeTypeTable::WEIGHT);

                t.0 = self.root_arg_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                if self.arg_decl_node_type.insert(t) {
                    let weight0 = &mut self.arg_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ArgDeclNodeTypeTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ArgDeclNodeTypeTable::WEIGHT);
                }
            }
        }

        for el in self.arg_decl_list_node_uprooted.iter().copied() {
            let ts = self
                .nil_arg_decl_list_node
                .drain_with_element_arg_decl_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.arg_decl_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(NilArgDeclListNodeTable::WEIGHT);

                t.0 = self.root_arg_decl_list_node(t.0);
                if self.nil_arg_decl_list_node.insert(t) {
                    let weight0 = &mut self.arg_decl_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(NilArgDeclListNodeTable::WEIGHT);
                }
            }
        }

        for el in self.arg_decl_list_node_uprooted.iter().copied() {
            let ts = self
                .cons_arg_decl_list_node
                .drain_with_element_arg_decl_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.arg_decl_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConsArgDeclListNodeTable::WEIGHT);

                let weight1 = &mut self.arg_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ConsArgDeclListNodeTable::WEIGHT);

                let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ConsArgDeclListNodeTable::WEIGHT);

                t.0 = self.root_arg_decl_list_node(t.0);
                t.1 = self.root_arg_decl_node(t.1);
                t.2 = self.root_arg_decl_list_node(t.2);
                if self.cons_arg_decl_list_node.insert(t) {
                    let weight0 = &mut self.arg_decl_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConsArgDeclListNodeTable::WEIGHT);

                    let weight1 = &mut self.arg_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ConsArgDeclListNodeTable::WEIGHT);

                    let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ConsArgDeclListNodeTable::WEIGHT);
                }
            }
        }
        for el in self.arg_decl_node_uprooted.iter().copied() {
            let ts = self
                .cons_arg_decl_list_node
                .drain_with_element_arg_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.arg_decl_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConsArgDeclListNodeTable::WEIGHT);

                let weight1 = &mut self.arg_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ConsArgDeclListNodeTable::WEIGHT);

                let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ConsArgDeclListNodeTable::WEIGHT);

                t.0 = self.root_arg_decl_list_node(t.0);
                t.1 = self.root_arg_decl_node(t.1);
                t.2 = self.root_arg_decl_list_node(t.2);
                if self.cons_arg_decl_list_node.insert(t) {
                    let weight0 = &mut self.arg_decl_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConsArgDeclListNodeTable::WEIGHT);

                    let weight1 = &mut self.arg_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ConsArgDeclListNodeTable::WEIGHT);

                    let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ConsArgDeclListNodeTable::WEIGHT);
                }
            }
        }

        for el in self.arg_decl_list_node_uprooted.iter().copied() {
            let ts = self.pred_decl.drain_with_element_arg_decl_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.pred_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PredDeclTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(PredDeclTable::WEIGHT);

                let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(PredDeclTable::WEIGHT);

                t.0 = self.root_pred_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_arg_decl_list_node(t.2);
                if self.pred_decl.insert(t) {
                    let weight0 = &mut self.pred_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PredDeclTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(PredDeclTable::WEIGHT);

                    let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(PredDeclTable::WEIGHT);
                }
            }
        }
        for el in self.ident_uprooted.iter().copied() {
            let ts = self.pred_decl.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.pred_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PredDeclTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(PredDeclTable::WEIGHT);

                let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(PredDeclTable::WEIGHT);

                t.0 = self.root_pred_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_arg_decl_list_node(t.2);
                if self.pred_decl.insert(t) {
                    let weight0 = &mut self.pred_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PredDeclTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(PredDeclTable::WEIGHT);

                    let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(PredDeclTable::WEIGHT);
                }
            }
        }
        for el in self.pred_decl_node_uprooted.iter().copied() {
            let ts = self.pred_decl.drain_with_element_pred_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.pred_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PredDeclTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(PredDeclTable::WEIGHT);

                let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(PredDeclTable::WEIGHT);

                t.0 = self.root_pred_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_arg_decl_list_node(t.2);
                if self.pred_decl.insert(t) {
                    let weight0 = &mut self.pred_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PredDeclTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(PredDeclTable::WEIGHT);

                    let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(PredDeclTable::WEIGHT);
                }
            }
        }

        for el in self.arg_decl_list_node_uprooted.iter().copied() {
            let ts = self.func_decl.drain_with_element_arg_decl_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.func_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(FuncDeclTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(FuncDeclTable::WEIGHT);

                let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(FuncDeclTable::WEIGHT);

                let weight3 = &mut self.ident_weights[t.3 .0 as usize];
                *weight3 = weight3.saturating_sub(FuncDeclTable::WEIGHT);

                t.0 = self.root_func_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_arg_decl_list_node(t.2);
                t.3 = self.root_ident(t.3);
                if self.func_decl.insert(t) {
                    let weight0 = &mut self.func_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(FuncDeclTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(FuncDeclTable::WEIGHT);

                    let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(FuncDeclTable::WEIGHT);

                    let weight3 = &mut self.ident_weights[t.3 .0 as usize];
                    *weight3 = weight3.saturating_add(FuncDeclTable::WEIGHT);
                }
            }
        }
        for el in self.func_decl_node_uprooted.iter().copied() {
            let ts = self.func_decl.drain_with_element_func_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.func_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(FuncDeclTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(FuncDeclTable::WEIGHT);

                let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(FuncDeclTable::WEIGHT);

                let weight3 = &mut self.ident_weights[t.3 .0 as usize];
                *weight3 = weight3.saturating_sub(FuncDeclTable::WEIGHT);

                t.0 = self.root_func_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_arg_decl_list_node(t.2);
                t.3 = self.root_ident(t.3);
                if self.func_decl.insert(t) {
                    let weight0 = &mut self.func_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(FuncDeclTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(FuncDeclTable::WEIGHT);

                    let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(FuncDeclTable::WEIGHT);

                    let weight3 = &mut self.ident_weights[t.3 .0 as usize];
                    *weight3 = weight3.saturating_add(FuncDeclTable::WEIGHT);
                }
            }
        }
        for el in self.ident_uprooted.iter().copied() {
            let ts = self.func_decl.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.func_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(FuncDeclTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(FuncDeclTable::WEIGHT);

                let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(FuncDeclTable::WEIGHT);

                let weight3 = &mut self.ident_weights[t.3 .0 as usize];
                *weight3 = weight3.saturating_sub(FuncDeclTable::WEIGHT);

                t.0 = self.root_func_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_arg_decl_list_node(t.2);
                t.3 = self.root_ident(t.3);
                if self.func_decl.insert(t) {
                    let weight0 = &mut self.func_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(FuncDeclTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(FuncDeclTable::WEIGHT);

                    let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(FuncDeclTable::WEIGHT);

                    let weight3 = &mut self.ident_weights[t.3 .0 as usize];
                    *weight3 = weight3.saturating_add(FuncDeclTable::WEIGHT);
                }
            }
        }

        for el in self.arg_decl_list_node_uprooted.iter().copied() {
            let ts = self.ctor_decl.drain_with_element_arg_decl_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.ctor_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CtorDeclTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CtorDeclTable::WEIGHT);

                let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(CtorDeclTable::WEIGHT);

                t.0 = self.root_ctor_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_arg_decl_list_node(t.2);
                if self.ctor_decl.insert(t) {
                    let weight0 = &mut self.ctor_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CtorDeclTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CtorDeclTable::WEIGHT);

                    let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(CtorDeclTable::WEIGHT);
                }
            }
        }
        for el in self.ctor_decl_node_uprooted.iter().copied() {
            let ts = self.ctor_decl.drain_with_element_ctor_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.ctor_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CtorDeclTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CtorDeclTable::WEIGHT);

                let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(CtorDeclTable::WEIGHT);

                t.0 = self.root_ctor_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_arg_decl_list_node(t.2);
                if self.ctor_decl.insert(t) {
                    let weight0 = &mut self.ctor_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CtorDeclTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CtorDeclTable::WEIGHT);

                    let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(CtorDeclTable::WEIGHT);
                }
            }
        }
        for el in self.ident_uprooted.iter().copied() {
            let ts = self.ctor_decl.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.ctor_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CtorDeclTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CtorDeclTable::WEIGHT);

                let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(CtorDeclTable::WEIGHT);

                t.0 = self.root_ctor_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_arg_decl_list_node(t.2);
                if self.ctor_decl.insert(t) {
                    let weight0 = &mut self.ctor_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CtorDeclTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CtorDeclTable::WEIGHT);

                    let weight2 = &mut self.arg_decl_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(CtorDeclTable::WEIGHT);
                }
            }
        }

        for el in self.ctor_decl_list_node_uprooted.iter().copied() {
            let ts = self
                .nil_ctor_decl_list_node
                .drain_with_element_ctor_decl_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.ctor_decl_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(NilCtorDeclListNodeTable::WEIGHT);

                t.0 = self.root_ctor_decl_list_node(t.0);
                if self.nil_ctor_decl_list_node.insert(t) {
                    let weight0 = &mut self.ctor_decl_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(NilCtorDeclListNodeTable::WEIGHT);
                }
            }
        }

        for el in self.ctor_decl_list_node_uprooted.iter().copied() {
            let ts = self
                .cons_ctor_decl_list_node
                .drain_with_element_ctor_decl_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.ctor_decl_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConsCtorDeclListNodeTable::WEIGHT);

                let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ConsCtorDeclListNodeTable::WEIGHT);

                let weight2 = &mut self.ctor_decl_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ConsCtorDeclListNodeTable::WEIGHT);

                t.0 = self.root_ctor_decl_list_node(t.0);
                t.1 = self.root_ctor_decl_node(t.1);
                t.2 = self.root_ctor_decl_list_node(t.2);
                if self.cons_ctor_decl_list_node.insert(t) {
                    let weight0 = &mut self.ctor_decl_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConsCtorDeclListNodeTable::WEIGHT);

                    let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ConsCtorDeclListNodeTable::WEIGHT);

                    let weight2 = &mut self.ctor_decl_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ConsCtorDeclListNodeTable::WEIGHT);
                }
            }
        }
        for el in self.ctor_decl_node_uprooted.iter().copied() {
            let ts = self
                .cons_ctor_decl_list_node
                .drain_with_element_ctor_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.ctor_decl_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConsCtorDeclListNodeTable::WEIGHT);

                let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ConsCtorDeclListNodeTable::WEIGHT);

                let weight2 = &mut self.ctor_decl_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ConsCtorDeclListNodeTable::WEIGHT);

                t.0 = self.root_ctor_decl_list_node(t.0);
                t.1 = self.root_ctor_decl_node(t.1);
                t.2 = self.root_ctor_decl_list_node(t.2);
                if self.cons_ctor_decl_list_node.insert(t) {
                    let weight0 = &mut self.ctor_decl_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConsCtorDeclListNodeTable::WEIGHT);

                    let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ConsCtorDeclListNodeTable::WEIGHT);

                    let weight2 = &mut self.ctor_decl_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ConsCtorDeclListNodeTable::WEIGHT);
                }
            }
        }

        for el in self.ctor_decl_list_node_uprooted.iter().copied() {
            let ts = self.enum_decl.drain_with_element_ctor_decl_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.enum_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(EnumDeclTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(EnumDeclTable::WEIGHT);

                let weight2 = &mut self.ctor_decl_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(EnumDeclTable::WEIGHT);

                t.0 = self.root_enum_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_ctor_decl_list_node(t.2);
                if self.enum_decl.insert(t) {
                    let weight0 = &mut self.enum_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(EnumDeclTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(EnumDeclTable::WEIGHT);

                    let weight2 = &mut self.ctor_decl_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(EnumDeclTable::WEIGHT);
                }
            }
        }
        for el in self.enum_decl_node_uprooted.iter().copied() {
            let ts = self.enum_decl.drain_with_element_enum_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.enum_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(EnumDeclTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(EnumDeclTable::WEIGHT);

                let weight2 = &mut self.ctor_decl_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(EnumDeclTable::WEIGHT);

                t.0 = self.root_enum_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_ctor_decl_list_node(t.2);
                if self.enum_decl.insert(t) {
                    let weight0 = &mut self.enum_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(EnumDeclTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(EnumDeclTable::WEIGHT);

                    let weight2 = &mut self.ctor_decl_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(EnumDeclTable::WEIGHT);
                }
            }
        }
        for el in self.ident_uprooted.iter().copied() {
            let ts = self.enum_decl.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.enum_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(EnumDeclTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(EnumDeclTable::WEIGHT);

                let weight2 = &mut self.ctor_decl_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(EnumDeclTable::WEIGHT);

                t.0 = self.root_enum_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_ctor_decl_list_node(t.2);
                if self.enum_decl.insert(t) {
                    let weight0 = &mut self.enum_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(EnumDeclTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(EnumDeclTable::WEIGHT);

                    let weight2 = &mut self.ctor_decl_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(EnumDeclTable::WEIGHT);
                }
            }
        }

        for el in self.term_list_node_uprooted.iter().copied() {
            let ts = self
                .nil_term_list_node
                .drain_with_element_term_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(NilTermListNodeTable::WEIGHT);

                t.0 = self.root_term_list_node(t.0);
                if self.nil_term_list_node.insert(t) {
                    let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(NilTermListNodeTable::WEIGHT);
                }
            }
        }

        for el in self.term_list_node_uprooted.iter().copied() {
            let ts = self
                .cons_term_list_node
                .drain_with_element_term_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConsTermListNodeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ConsTermListNodeTable::WEIGHT);

                let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ConsTermListNodeTable::WEIGHT);

                t.0 = self.root_term_list_node(t.0);
                t.1 = self.root_term_node(t.1);
                t.2 = self.root_term_list_node(t.2);
                if self.cons_term_list_node.insert(t) {
                    let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConsTermListNodeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ConsTermListNodeTable::WEIGHT);

                    let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ConsTermListNodeTable::WEIGHT);
                }
            }
        }
        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.cons_term_list_node.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConsTermListNodeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ConsTermListNodeTable::WEIGHT);

                let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ConsTermListNodeTable::WEIGHT);

                t.0 = self.root_term_list_node(t.0);
                t.1 = self.root_term_node(t.1);
                t.2 = self.root_term_list_node(t.2);
                if self.cons_term_list_node.insert(t) {
                    let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConsTermListNodeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ConsTermListNodeTable::WEIGHT);

                    let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ConsTermListNodeTable::WEIGHT);
                }
            }
        }

        for el in self.opt_term_node_uprooted.iter().copied() {
            let ts = self.none_term_node.drain_with_element_opt_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.opt_term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(NoneTermNodeTable::WEIGHT);

                t.0 = self.root_opt_term_node(t.0);
                if self.none_term_node.insert(t) {
                    let weight0 = &mut self.opt_term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(NoneTermNodeTable::WEIGHT);
                }
            }
        }

        for el in self.opt_term_node_uprooted.iter().copied() {
            let ts = self.some_term_node.drain_with_element_opt_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.opt_term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SomeTermNodeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SomeTermNodeTable::WEIGHT);

                t.0 = self.root_opt_term_node(t.0);
                t.1 = self.root_term_node(t.1);
                if self.some_term_node.insert(t) {
                    let weight0 = &mut self.opt_term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SomeTermNodeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SomeTermNodeTable::WEIGHT);
                }
            }
        }
        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.some_term_node.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.opt_term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SomeTermNodeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SomeTermNodeTable::WEIGHT);

                t.0 = self.root_opt_term_node(t.0);
                t.1 = self.root_term_node(t.1);
                if self.some_term_node.insert(t) {
                    let weight0 = &mut self.opt_term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SomeTermNodeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SomeTermNodeTable::WEIGHT);
                }
            }
        }

        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.var_term_node.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(VarTermNodeTable::WEIGHT);

                let weight1 = &mut self.virt_ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(VarTermNodeTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_virt_ident(t.1);
                if self.var_term_node.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(VarTermNodeTable::WEIGHT);

                    let weight1 = &mut self.virt_ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(VarTermNodeTable::WEIGHT);
                }
            }
        }
        for el in self.virt_ident_uprooted.iter().copied() {
            let ts = self.var_term_node.drain_with_element_virt_ident(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(VarTermNodeTable::WEIGHT);

                let weight1 = &mut self.virt_ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(VarTermNodeTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_virt_ident(t.1);
                if self.var_term_node.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(VarTermNodeTable::WEIGHT);

                    let weight1 = &mut self.virt_ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(VarTermNodeTable::WEIGHT);
                }
            }
        }

        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.wildcard_term_node.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(WildcardTermNodeTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                if self.wildcard_term_node.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(WildcardTermNodeTable::WEIGHT);
                }
            }
        }

        for el in self.ident_uprooted.iter().copied() {
            let ts = self.app_term_node.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(AppTermNodeTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(AppTermNodeTable::WEIGHT);

                let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(AppTermNodeTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_term_list_node(t.2);
                if self.app_term_node.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(AppTermNodeTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(AppTermNodeTable::WEIGHT);

                    let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(AppTermNodeTable::WEIGHT);
                }
            }
        }
        for el in self.term_list_node_uprooted.iter().copied() {
            let ts = self.app_term_node.drain_with_element_term_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(AppTermNodeTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(AppTermNodeTable::WEIGHT);

                let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(AppTermNodeTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_term_list_node(t.2);
                if self.app_term_node.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(AppTermNodeTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(AppTermNodeTable::WEIGHT);

                    let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(AppTermNodeTable::WEIGHT);
                }
            }
        }
        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.app_term_node.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(AppTermNodeTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(AppTermNodeTable::WEIGHT);

                let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(AppTermNodeTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_term_list_node(t.2);
                if self.app_term_node.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(AppTermNodeTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(AppTermNodeTable::WEIGHT);

                    let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(AppTermNodeTable::WEIGHT);
                }
            }
        }

        for el in self.match_case_node_uprooted.iter().copied() {
            let ts = self.match_case.drain_with_element_match_case_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchCaseTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchCaseTable::WEIGHT);

                let weight2 = &mut self.stmt_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(MatchCaseTable::WEIGHT);

                t.0 = self.root_match_case_node(t.0);
                t.1 = self.root_term_node(t.1);
                t.2 = self.root_stmt_list_node(t.2);
                if self.match_case.insert(t) {
                    let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchCaseTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchCaseTable::WEIGHT);

                    let weight2 = &mut self.stmt_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(MatchCaseTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_list_node_uprooted.iter().copied() {
            let ts = self.match_case.drain_with_element_stmt_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchCaseTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchCaseTable::WEIGHT);

                let weight2 = &mut self.stmt_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(MatchCaseTable::WEIGHT);

                t.0 = self.root_match_case_node(t.0);
                t.1 = self.root_term_node(t.1);
                t.2 = self.root_stmt_list_node(t.2);
                if self.match_case.insert(t) {
                    let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchCaseTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchCaseTable::WEIGHT);

                    let weight2 = &mut self.stmt_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(MatchCaseTable::WEIGHT);
                }
            }
        }
        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.match_case.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchCaseTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchCaseTable::WEIGHT);

                let weight2 = &mut self.stmt_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(MatchCaseTable::WEIGHT);

                t.0 = self.root_match_case_node(t.0);
                t.1 = self.root_term_node(t.1);
                t.2 = self.root_stmt_list_node(t.2);
                if self.match_case.insert(t) {
                    let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchCaseTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchCaseTable::WEIGHT);

                    let weight2 = &mut self.stmt_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(MatchCaseTable::WEIGHT);
                }
            }
        }

        for el in self.match_case_list_node_uprooted.iter().copied() {
            let ts = self
                .nil_match_case_list_node
                .drain_with_element_match_case_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(NilMatchCaseListNodeTable::WEIGHT);

                t.0 = self.root_match_case_list_node(t.0);
                if self.nil_match_case_list_node.insert(t) {
                    let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(NilMatchCaseListNodeTable::WEIGHT);
                }
            }
        }

        for el in self.match_case_list_node_uprooted.iter().copied() {
            let ts = self
                .cons_match_case_list_node
                .drain_with_element_match_case_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConsMatchCaseListNodeTable::WEIGHT);

                let weight1 = &mut self.match_case_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ConsMatchCaseListNodeTable::WEIGHT);

                let weight2 = &mut self.match_case_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ConsMatchCaseListNodeTable::WEIGHT);

                t.0 = self.root_match_case_list_node(t.0);
                t.1 = self.root_match_case_node(t.1);
                t.2 = self.root_match_case_list_node(t.2);
                if self.cons_match_case_list_node.insert(t) {
                    let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConsMatchCaseListNodeTable::WEIGHT);

                    let weight1 = &mut self.match_case_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ConsMatchCaseListNodeTable::WEIGHT);

                    let weight2 = &mut self.match_case_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ConsMatchCaseListNodeTable::WEIGHT);
                }
            }
        }
        for el in self.match_case_node_uprooted.iter().copied() {
            let ts = self
                .cons_match_case_list_node
                .drain_with_element_match_case_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConsMatchCaseListNodeTable::WEIGHT);

                let weight1 = &mut self.match_case_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ConsMatchCaseListNodeTable::WEIGHT);

                let weight2 = &mut self.match_case_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ConsMatchCaseListNodeTable::WEIGHT);

                t.0 = self.root_match_case_list_node(t.0);
                t.1 = self.root_match_case_node(t.1);
                t.2 = self.root_match_case_list_node(t.2);
                if self.cons_match_case_list_node.insert(t) {
                    let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConsMatchCaseListNodeTable::WEIGHT);

                    let weight1 = &mut self.match_case_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ConsMatchCaseListNodeTable::WEIGHT);

                    let weight2 = &mut self.match_case_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ConsMatchCaseListNodeTable::WEIGHT);
                }
            }
        }

        for el in self.if_atom_node_uprooted.iter().copied() {
            let ts = self.equal_if_atom_node.drain_with_element_if_atom_node(el);
            for mut t in ts {
                let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(EqualIfAtomNodeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(EqualIfAtomNodeTable::WEIGHT);

                let weight2 = &mut self.term_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(EqualIfAtomNodeTable::WEIGHT);

                t.0 = self.root_if_atom_node(t.0);
                t.1 = self.root_term_node(t.1);
                t.2 = self.root_term_node(t.2);
                if self.equal_if_atom_node.insert(t) {
                    let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(EqualIfAtomNodeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(EqualIfAtomNodeTable::WEIGHT);

                    let weight2 = &mut self.term_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(EqualIfAtomNodeTable::WEIGHT);
                }
            }
        }
        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.equal_if_atom_node.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(EqualIfAtomNodeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(EqualIfAtomNodeTable::WEIGHT);

                let weight2 = &mut self.term_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(EqualIfAtomNodeTable::WEIGHT);

                t.0 = self.root_if_atom_node(t.0);
                t.1 = self.root_term_node(t.1);
                t.2 = self.root_term_node(t.2);
                if self.equal_if_atom_node.insert(t) {
                    let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(EqualIfAtomNodeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(EqualIfAtomNodeTable::WEIGHT);

                    let weight2 = &mut self.term_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(EqualIfAtomNodeTable::WEIGHT);
                }
            }
        }

        for el in self.if_atom_node_uprooted.iter().copied() {
            let ts = self
                .defined_if_atom_node
                .drain_with_element_if_atom_node(el);
            for mut t in ts {
                let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DefinedIfAtomNodeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DefinedIfAtomNodeTable::WEIGHT);

                t.0 = self.root_if_atom_node(t.0);
                t.1 = self.root_term_node(t.1);
                if self.defined_if_atom_node.insert(t) {
                    let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DefinedIfAtomNodeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DefinedIfAtomNodeTable::WEIGHT);
                }
            }
        }
        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.defined_if_atom_node.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DefinedIfAtomNodeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DefinedIfAtomNodeTable::WEIGHT);

                t.0 = self.root_if_atom_node(t.0);
                t.1 = self.root_term_node(t.1);
                if self.defined_if_atom_node.insert(t) {
                    let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DefinedIfAtomNodeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DefinedIfAtomNodeTable::WEIGHT);
                }
            }
        }

        for el in self.ident_uprooted.iter().copied() {
            let ts = self.pred_if_atom_node.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PredIfAtomNodeTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(PredIfAtomNodeTable::WEIGHT);

                let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(PredIfAtomNodeTable::WEIGHT);

                t.0 = self.root_if_atom_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_term_list_node(t.2);
                if self.pred_if_atom_node.insert(t) {
                    let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PredIfAtomNodeTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(PredIfAtomNodeTable::WEIGHT);

                    let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(PredIfAtomNodeTable::WEIGHT);
                }
            }
        }
        for el in self.if_atom_node_uprooted.iter().copied() {
            let ts = self.pred_if_atom_node.drain_with_element_if_atom_node(el);
            for mut t in ts {
                let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PredIfAtomNodeTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(PredIfAtomNodeTable::WEIGHT);

                let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(PredIfAtomNodeTable::WEIGHT);

                t.0 = self.root_if_atom_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_term_list_node(t.2);
                if self.pred_if_atom_node.insert(t) {
                    let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PredIfAtomNodeTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(PredIfAtomNodeTable::WEIGHT);

                    let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(PredIfAtomNodeTable::WEIGHT);
                }
            }
        }
        for el in self.term_list_node_uprooted.iter().copied() {
            let ts = self.pred_if_atom_node.drain_with_element_term_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PredIfAtomNodeTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(PredIfAtomNodeTable::WEIGHT);

                let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(PredIfAtomNodeTable::WEIGHT);

                t.0 = self.root_if_atom_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_term_list_node(t.2);
                if self.pred_if_atom_node.insert(t) {
                    let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PredIfAtomNodeTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(PredIfAtomNodeTable::WEIGHT);

                    let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(PredIfAtomNodeTable::WEIGHT);
                }
            }
        }

        for el in self.ident_uprooted.iter().copied() {
            let ts = self.var_if_atom_node.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(VarIfAtomNodeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(VarIfAtomNodeTable::WEIGHT);

                let weight2 = &mut self.ident_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(VarIfAtomNodeTable::WEIGHT);

                t.0 = self.root_if_atom_node(t.0);
                t.1 = self.root_term_node(t.1);
                t.2 = self.root_ident(t.2);
                if self.var_if_atom_node.insert(t) {
                    let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(VarIfAtomNodeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(VarIfAtomNodeTable::WEIGHT);

                    let weight2 = &mut self.ident_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(VarIfAtomNodeTable::WEIGHT);
                }
            }
        }
        for el in self.if_atom_node_uprooted.iter().copied() {
            let ts = self.var_if_atom_node.drain_with_element_if_atom_node(el);
            for mut t in ts {
                let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(VarIfAtomNodeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(VarIfAtomNodeTable::WEIGHT);

                let weight2 = &mut self.ident_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(VarIfAtomNodeTable::WEIGHT);

                t.0 = self.root_if_atom_node(t.0);
                t.1 = self.root_term_node(t.1);
                t.2 = self.root_ident(t.2);
                if self.var_if_atom_node.insert(t) {
                    let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(VarIfAtomNodeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(VarIfAtomNodeTable::WEIGHT);

                    let weight2 = &mut self.ident_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(VarIfAtomNodeTable::WEIGHT);
                }
            }
        }
        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.var_if_atom_node.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(VarIfAtomNodeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(VarIfAtomNodeTable::WEIGHT);

                let weight2 = &mut self.ident_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(VarIfAtomNodeTable::WEIGHT);

                t.0 = self.root_if_atom_node(t.0);
                t.1 = self.root_term_node(t.1);
                t.2 = self.root_ident(t.2);
                if self.var_if_atom_node.insert(t) {
                    let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(VarIfAtomNodeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(VarIfAtomNodeTable::WEIGHT);

                    let weight2 = &mut self.ident_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(VarIfAtomNodeTable::WEIGHT);
                }
            }
        }

        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.equal_then_atom_node.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(EqualThenAtomNodeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(EqualThenAtomNodeTable::WEIGHT);

                let weight2 = &mut self.term_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(EqualThenAtomNodeTable::WEIGHT);

                t.0 = self.root_then_atom_node(t.0);
                t.1 = self.root_term_node(t.1);
                t.2 = self.root_term_node(t.2);
                if self.equal_then_atom_node.insert(t) {
                    let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(EqualThenAtomNodeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(EqualThenAtomNodeTable::WEIGHT);

                    let weight2 = &mut self.term_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(EqualThenAtomNodeTable::WEIGHT);
                }
            }
        }
        for el in self.then_atom_node_uprooted.iter().copied() {
            let ts = self
                .equal_then_atom_node
                .drain_with_element_then_atom_node(el);
            for mut t in ts {
                let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(EqualThenAtomNodeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(EqualThenAtomNodeTable::WEIGHT);

                let weight2 = &mut self.term_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(EqualThenAtomNodeTable::WEIGHT);

                t.0 = self.root_then_atom_node(t.0);
                t.1 = self.root_term_node(t.1);
                t.2 = self.root_term_node(t.2);
                if self.equal_then_atom_node.insert(t) {
                    let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(EqualThenAtomNodeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(EqualThenAtomNodeTable::WEIGHT);

                    let weight2 = &mut self.term_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(EqualThenAtomNodeTable::WEIGHT);
                }
            }
        }

        for el in self.opt_term_node_uprooted.iter().copied() {
            let ts = self
                .defined_then_atom_node
                .drain_with_element_opt_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DefinedThenAtomNodeTable::WEIGHT);

                let weight1 = &mut self.opt_term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DefinedThenAtomNodeTable::WEIGHT);

                let weight2 = &mut self.term_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(DefinedThenAtomNodeTable::WEIGHT);

                t.0 = self.root_then_atom_node(t.0);
                t.1 = self.root_opt_term_node(t.1);
                t.2 = self.root_term_node(t.2);
                if self.defined_then_atom_node.insert(t) {
                    let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

                    let weight1 = &mut self.opt_term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

                    let weight2 = &mut self.term_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(DefinedThenAtomNodeTable::WEIGHT);
                }
            }
        }
        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.defined_then_atom_node.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DefinedThenAtomNodeTable::WEIGHT);

                let weight1 = &mut self.opt_term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DefinedThenAtomNodeTable::WEIGHT);

                let weight2 = &mut self.term_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(DefinedThenAtomNodeTable::WEIGHT);

                t.0 = self.root_then_atom_node(t.0);
                t.1 = self.root_opt_term_node(t.1);
                t.2 = self.root_term_node(t.2);
                if self.defined_then_atom_node.insert(t) {
                    let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

                    let weight1 = &mut self.opt_term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

                    let weight2 = &mut self.term_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(DefinedThenAtomNodeTable::WEIGHT);
                }
            }
        }
        for el in self.then_atom_node_uprooted.iter().copied() {
            let ts = self
                .defined_then_atom_node
                .drain_with_element_then_atom_node(el);
            for mut t in ts {
                let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DefinedThenAtomNodeTable::WEIGHT);

                let weight1 = &mut self.opt_term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DefinedThenAtomNodeTable::WEIGHT);

                let weight2 = &mut self.term_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(DefinedThenAtomNodeTable::WEIGHT);

                t.0 = self.root_then_atom_node(t.0);
                t.1 = self.root_opt_term_node(t.1);
                t.2 = self.root_term_node(t.2);
                if self.defined_then_atom_node.insert(t) {
                    let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

                    let weight1 = &mut self.opt_term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

                    let weight2 = &mut self.term_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(DefinedThenAtomNodeTable::WEIGHT);
                }
            }
        }

        for el in self.ident_uprooted.iter().copied() {
            let ts = self.pred_then_atom_node.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PredThenAtomNodeTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(PredThenAtomNodeTable::WEIGHT);

                let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(PredThenAtomNodeTable::WEIGHT);

                t.0 = self.root_then_atom_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_term_list_node(t.2);
                if self.pred_then_atom_node.insert(t) {
                    let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PredThenAtomNodeTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(PredThenAtomNodeTable::WEIGHT);

                    let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(PredThenAtomNodeTable::WEIGHT);
                }
            }
        }
        for el in self.term_list_node_uprooted.iter().copied() {
            let ts = self
                .pred_then_atom_node
                .drain_with_element_term_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PredThenAtomNodeTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(PredThenAtomNodeTable::WEIGHT);

                let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(PredThenAtomNodeTable::WEIGHT);

                t.0 = self.root_then_atom_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_term_list_node(t.2);
                if self.pred_then_atom_node.insert(t) {
                    let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PredThenAtomNodeTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(PredThenAtomNodeTable::WEIGHT);

                    let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(PredThenAtomNodeTable::WEIGHT);
                }
            }
        }
        for el in self.then_atom_node_uprooted.iter().copied() {
            let ts = self
                .pred_then_atom_node
                .drain_with_element_then_atom_node(el);
            for mut t in ts {
                let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PredThenAtomNodeTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(PredThenAtomNodeTable::WEIGHT);

                let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(PredThenAtomNodeTable::WEIGHT);

                t.0 = self.root_then_atom_node(t.0);
                t.1 = self.root_ident(t.1);
                t.2 = self.root_term_list_node(t.2);
                if self.pred_then_atom_node.insert(t) {
                    let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PredThenAtomNodeTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(PredThenAtomNodeTable::WEIGHT);

                    let weight2 = &mut self.term_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(PredThenAtomNodeTable::WEIGHT);
                }
            }
        }

        for el in self.if_atom_node_uprooted.iter().copied() {
            let ts = self.if_stmt_node.drain_with_element_if_atom_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(IfStmtNodeTable::WEIGHT);

                let weight1 = &mut self.if_atom_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(IfStmtNodeTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_if_atom_node(t.1);
                if self.if_stmt_node.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(IfStmtNodeTable::WEIGHT);

                    let weight1 = &mut self.if_atom_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(IfStmtNodeTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self.if_stmt_node.drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(IfStmtNodeTable::WEIGHT);

                let weight1 = &mut self.if_atom_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(IfStmtNodeTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_if_atom_node(t.1);
                if self.if_stmt_node.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(IfStmtNodeTable::WEIGHT);

                    let weight1 = &mut self.if_atom_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(IfStmtNodeTable::WEIGHT);
                }
            }
        }

        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self.then_stmt_node.drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ThenStmtNodeTable::WEIGHT);

                let weight1 = &mut self.then_atom_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ThenStmtNodeTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_then_atom_node(t.1);
                if self.then_stmt_node.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ThenStmtNodeTable::WEIGHT);

                    let weight1 = &mut self.then_atom_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ThenStmtNodeTable::WEIGHT);
                }
            }
        }
        for el in self.then_atom_node_uprooted.iter().copied() {
            let ts = self.then_stmt_node.drain_with_element_then_atom_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ThenStmtNodeTable::WEIGHT);

                let weight1 = &mut self.then_atom_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ThenStmtNodeTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_then_atom_node(t.1);
                if self.then_stmt_node.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ThenStmtNodeTable::WEIGHT);

                    let weight1 = &mut self.then_atom_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ThenStmtNodeTable::WEIGHT);
                }
            }
        }

        for el in self.stmt_block_list_node_uprooted.iter().copied() {
            let ts = self
                .branch_stmt_node
                .drain_with_element_stmt_block_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(BranchStmtNodeTable::WEIGHT);

                let weight1 = &mut self.stmt_block_list_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(BranchStmtNodeTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_stmt_block_list_node(t.1);
                if self.branch_stmt_node.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(BranchStmtNodeTable::WEIGHT);

                    let weight1 = &mut self.stmt_block_list_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(BranchStmtNodeTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self.branch_stmt_node.drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(BranchStmtNodeTable::WEIGHT);

                let weight1 = &mut self.stmt_block_list_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(BranchStmtNodeTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_stmt_block_list_node(t.1);
                if self.branch_stmt_node.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(BranchStmtNodeTable::WEIGHT);

                    let weight1 = &mut self.stmt_block_list_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(BranchStmtNodeTable::WEIGHT);
                }
            }
        }

        for el in self.match_case_list_node_uprooted.iter().copied() {
            let ts = self
                .match_stmt_node
                .drain_with_element_match_case_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchStmtNodeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchStmtNodeTable::WEIGHT);

                let weight2 = &mut self.match_case_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(MatchStmtNodeTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_term_node(t.1);
                t.2 = self.root_match_case_list_node(t.2);
                if self.match_stmt_node.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchStmtNodeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchStmtNodeTable::WEIGHT);

                    let weight2 = &mut self.match_case_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(MatchStmtNodeTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self.match_stmt_node.drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchStmtNodeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchStmtNodeTable::WEIGHT);

                let weight2 = &mut self.match_case_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(MatchStmtNodeTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_term_node(t.1);
                t.2 = self.root_match_case_list_node(t.2);
                if self.match_stmt_node.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchStmtNodeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchStmtNodeTable::WEIGHT);

                    let weight2 = &mut self.match_case_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(MatchStmtNodeTable::WEIGHT);
                }
            }
        }
        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.match_stmt_node.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchStmtNodeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchStmtNodeTable::WEIGHT);

                let weight2 = &mut self.match_case_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(MatchStmtNodeTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_term_node(t.1);
                t.2 = self.root_match_case_list_node(t.2);
                if self.match_stmt_node.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchStmtNodeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchStmtNodeTable::WEIGHT);

                    let weight2 = &mut self.match_case_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(MatchStmtNodeTable::WEIGHT);
                }
            }
        }

        for el in self.stmt_list_node_uprooted.iter().copied() {
            let ts = self
                .nil_stmt_list_node
                .drain_with_element_stmt_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(NilStmtListNodeTable::WEIGHT);

                t.0 = self.root_stmt_list_node(t.0);
                if self.nil_stmt_list_node.insert(t) {
                    let weight0 = &mut self.stmt_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(NilStmtListNodeTable::WEIGHT);
                }
            }
        }

        for el in self.stmt_list_node_uprooted.iter().copied() {
            let ts = self
                .cons_stmt_list_node
                .drain_with_element_stmt_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConsStmtListNodeTable::WEIGHT);

                let weight1 = &mut self.stmt_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ConsStmtListNodeTable::WEIGHT);

                let weight2 = &mut self.stmt_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ConsStmtListNodeTable::WEIGHT);

                t.0 = self.root_stmt_list_node(t.0);
                t.1 = self.root_stmt_node(t.1);
                t.2 = self.root_stmt_list_node(t.2);
                if self.cons_stmt_list_node.insert(t) {
                    let weight0 = &mut self.stmt_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConsStmtListNodeTable::WEIGHT);

                    let weight1 = &mut self.stmt_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ConsStmtListNodeTable::WEIGHT);

                    let weight2 = &mut self.stmt_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ConsStmtListNodeTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self.cons_stmt_list_node.drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConsStmtListNodeTable::WEIGHT);

                let weight1 = &mut self.stmt_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ConsStmtListNodeTable::WEIGHT);

                let weight2 = &mut self.stmt_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ConsStmtListNodeTable::WEIGHT);

                t.0 = self.root_stmt_list_node(t.0);
                t.1 = self.root_stmt_node(t.1);
                t.2 = self.root_stmt_list_node(t.2);
                if self.cons_stmt_list_node.insert(t) {
                    let weight0 = &mut self.stmt_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConsStmtListNodeTable::WEIGHT);

                    let weight1 = &mut self.stmt_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ConsStmtListNodeTable::WEIGHT);

                    let weight2 = &mut self.stmt_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ConsStmtListNodeTable::WEIGHT);
                }
            }
        }

        for el in self.stmt_block_list_node_uprooted.iter().copied() {
            let ts = self
                .nil_stmt_block_list_node
                .drain_with_element_stmt_block_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_block_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(NilStmtBlockListNodeTable::WEIGHT);

                t.0 = self.root_stmt_block_list_node(t.0);
                if self.nil_stmt_block_list_node.insert(t) {
                    let weight0 = &mut self.stmt_block_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(NilStmtBlockListNodeTable::WEIGHT);
                }
            }
        }

        for el in self.stmt_block_list_node_uprooted.iter().copied() {
            let ts = self
                .cons_stmt_block_list_node
                .drain_with_element_stmt_block_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_block_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConsStmtBlockListNodeTable::WEIGHT);

                let weight1 = &mut self.stmt_list_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ConsStmtBlockListNodeTable::WEIGHT);

                let weight2 = &mut self.stmt_block_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ConsStmtBlockListNodeTable::WEIGHT);

                t.0 = self.root_stmt_block_list_node(t.0);
                t.1 = self.root_stmt_list_node(t.1);
                t.2 = self.root_stmt_block_list_node(t.2);
                if self.cons_stmt_block_list_node.insert(t) {
                    let weight0 = &mut self.stmt_block_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConsStmtBlockListNodeTable::WEIGHT);

                    let weight1 = &mut self.stmt_list_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ConsStmtBlockListNodeTable::WEIGHT);

                    let weight2 = &mut self.stmt_block_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ConsStmtBlockListNodeTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_list_node_uprooted.iter().copied() {
            let ts = self
                .cons_stmt_block_list_node
                .drain_with_element_stmt_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_block_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConsStmtBlockListNodeTable::WEIGHT);

                let weight1 = &mut self.stmt_list_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ConsStmtBlockListNodeTable::WEIGHT);

                let weight2 = &mut self.stmt_block_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ConsStmtBlockListNodeTable::WEIGHT);

                t.0 = self.root_stmt_block_list_node(t.0);
                t.1 = self.root_stmt_list_node(t.1);
                t.2 = self.root_stmt_block_list_node(t.2);
                if self.cons_stmt_block_list_node.insert(t) {
                    let weight0 = &mut self.stmt_block_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConsStmtBlockListNodeTable::WEIGHT);

                    let weight1 = &mut self.stmt_list_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ConsStmtBlockListNodeTable::WEIGHT);

                    let weight2 = &mut self.stmt_block_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ConsStmtBlockListNodeTable::WEIGHT);
                }
            }
        }

        for el in self.rule_decl_node_uprooted.iter().copied() {
            let ts = self.rule_decl.drain_with_element_rule_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDeclTable::WEIGHT);

                let weight1 = &mut self.stmt_list_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDeclTable::WEIGHT);

                t.0 = self.root_rule_decl_node(t.0);
                t.1 = self.root_stmt_list_node(t.1);
                if self.rule_decl.insert(t) {
                    let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDeclTable::WEIGHT);

                    let weight1 = &mut self.stmt_list_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDeclTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_list_node_uprooted.iter().copied() {
            let ts = self.rule_decl.drain_with_element_stmt_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDeclTable::WEIGHT);

                let weight1 = &mut self.stmt_list_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDeclTable::WEIGHT);

                t.0 = self.root_rule_decl_node(t.0);
                t.1 = self.root_stmt_list_node(t.1);
                if self.rule_decl.insert(t) {
                    let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDeclTable::WEIGHT);

                    let weight1 = &mut self.stmt_list_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDeclTable::WEIGHT);
                }
            }
        }

        for el in self.decl_node_uprooted.iter().copied() {
            let ts = self.decl_node_type.drain_with_element_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DeclNodeTypeTable::WEIGHT);

                let weight1 = &mut self.type_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DeclNodeTypeTable::WEIGHT);

                t.0 = self.root_decl_node(t.0);
                t.1 = self.root_type_decl_node(t.1);
                if self.decl_node_type.insert(t) {
                    let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DeclNodeTypeTable::WEIGHT);

                    let weight1 = &mut self.type_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DeclNodeTypeTable::WEIGHT);
                }
            }
        }
        for el in self.type_decl_node_uprooted.iter().copied() {
            let ts = self.decl_node_type.drain_with_element_type_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DeclNodeTypeTable::WEIGHT);

                let weight1 = &mut self.type_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DeclNodeTypeTable::WEIGHT);

                t.0 = self.root_decl_node(t.0);
                t.1 = self.root_type_decl_node(t.1);
                if self.decl_node_type.insert(t) {
                    let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DeclNodeTypeTable::WEIGHT);

                    let weight1 = &mut self.type_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DeclNodeTypeTable::WEIGHT);
                }
            }
        }

        for el in self.decl_node_uprooted.iter().copied() {
            let ts = self.decl_node_pred.drain_with_element_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DeclNodePredTable::WEIGHT);

                let weight1 = &mut self.pred_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DeclNodePredTable::WEIGHT);

                t.0 = self.root_decl_node(t.0);
                t.1 = self.root_pred_decl_node(t.1);
                if self.decl_node_pred.insert(t) {
                    let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DeclNodePredTable::WEIGHT);

                    let weight1 = &mut self.pred_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DeclNodePredTable::WEIGHT);
                }
            }
        }
        for el in self.pred_decl_node_uprooted.iter().copied() {
            let ts = self.decl_node_pred.drain_with_element_pred_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DeclNodePredTable::WEIGHT);

                let weight1 = &mut self.pred_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DeclNodePredTable::WEIGHT);

                t.0 = self.root_decl_node(t.0);
                t.1 = self.root_pred_decl_node(t.1);
                if self.decl_node_pred.insert(t) {
                    let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DeclNodePredTable::WEIGHT);

                    let weight1 = &mut self.pred_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DeclNodePredTable::WEIGHT);
                }
            }
        }

        for el in self.decl_node_uprooted.iter().copied() {
            let ts = self.decl_node_func.drain_with_element_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DeclNodeFuncTable::WEIGHT);

                let weight1 = &mut self.func_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DeclNodeFuncTable::WEIGHT);

                t.0 = self.root_decl_node(t.0);
                t.1 = self.root_func_decl_node(t.1);
                if self.decl_node_func.insert(t) {
                    let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DeclNodeFuncTable::WEIGHT);

                    let weight1 = &mut self.func_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DeclNodeFuncTable::WEIGHT);
                }
            }
        }
        for el in self.func_decl_node_uprooted.iter().copied() {
            let ts = self.decl_node_func.drain_with_element_func_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DeclNodeFuncTable::WEIGHT);

                let weight1 = &mut self.func_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DeclNodeFuncTable::WEIGHT);

                t.0 = self.root_decl_node(t.0);
                t.1 = self.root_func_decl_node(t.1);
                if self.decl_node_func.insert(t) {
                    let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DeclNodeFuncTable::WEIGHT);

                    let weight1 = &mut self.func_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DeclNodeFuncTable::WEIGHT);
                }
            }
        }

        for el in self.decl_node_uprooted.iter().copied() {
            let ts = self.decl_node_rule.drain_with_element_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DeclNodeRuleTable::WEIGHT);

                let weight1 = &mut self.rule_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DeclNodeRuleTable::WEIGHT);

                t.0 = self.root_decl_node(t.0);
                t.1 = self.root_rule_decl_node(t.1);
                if self.decl_node_rule.insert(t) {
                    let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DeclNodeRuleTable::WEIGHT);

                    let weight1 = &mut self.rule_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DeclNodeRuleTable::WEIGHT);
                }
            }
        }
        for el in self.rule_decl_node_uprooted.iter().copied() {
            let ts = self.decl_node_rule.drain_with_element_rule_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DeclNodeRuleTable::WEIGHT);

                let weight1 = &mut self.rule_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DeclNodeRuleTable::WEIGHT);

                t.0 = self.root_decl_node(t.0);
                t.1 = self.root_rule_decl_node(t.1);
                if self.decl_node_rule.insert(t) {
                    let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DeclNodeRuleTable::WEIGHT);

                    let weight1 = &mut self.rule_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DeclNodeRuleTable::WEIGHT);
                }
            }
        }

        for el in self.decl_node_uprooted.iter().copied() {
            let ts = self.decl_node_enum.drain_with_element_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DeclNodeEnumTable::WEIGHT);

                let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DeclNodeEnumTable::WEIGHT);

                t.0 = self.root_decl_node(t.0);
                t.1 = self.root_enum_decl_node(t.1);
                if self.decl_node_enum.insert(t) {
                    let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DeclNodeEnumTable::WEIGHT);

                    let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DeclNodeEnumTable::WEIGHT);
                }
            }
        }
        for el in self.enum_decl_node_uprooted.iter().copied() {
            let ts = self.decl_node_enum.drain_with_element_enum_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DeclNodeEnumTable::WEIGHT);

                let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DeclNodeEnumTable::WEIGHT);

                t.0 = self.root_decl_node(t.0);
                t.1 = self.root_enum_decl_node(t.1);
                if self.decl_node_enum.insert(t) {
                    let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DeclNodeEnumTable::WEIGHT);

                    let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DeclNodeEnumTable::WEIGHT);
                }
            }
        }

        for el in self.decl_list_node_uprooted.iter().copied() {
            let ts = self
                .nil_decl_list_node
                .drain_with_element_decl_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.decl_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(NilDeclListNodeTable::WEIGHT);

                t.0 = self.root_decl_list_node(t.0);
                if self.nil_decl_list_node.insert(t) {
                    let weight0 = &mut self.decl_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(NilDeclListNodeTable::WEIGHT);
                }
            }
        }

        for el in self.decl_list_node_uprooted.iter().copied() {
            let ts = self
                .cons_decl_list_node
                .drain_with_element_decl_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.decl_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConsDeclListNodeTable::WEIGHT);

                let weight1 = &mut self.decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ConsDeclListNodeTable::WEIGHT);

                let weight2 = &mut self.decl_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ConsDeclListNodeTable::WEIGHT);

                t.0 = self.root_decl_list_node(t.0);
                t.1 = self.root_decl_node(t.1);
                t.2 = self.root_decl_list_node(t.2);
                if self.cons_decl_list_node.insert(t) {
                    let weight0 = &mut self.decl_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConsDeclListNodeTable::WEIGHT);

                    let weight1 = &mut self.decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ConsDeclListNodeTable::WEIGHT);

                    let weight2 = &mut self.decl_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ConsDeclListNodeTable::WEIGHT);
                }
            }
        }
        for el in self.decl_node_uprooted.iter().copied() {
            let ts = self.cons_decl_list_node.drain_with_element_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.decl_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConsDeclListNodeTable::WEIGHT);

                let weight1 = &mut self.decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ConsDeclListNodeTable::WEIGHT);

                let weight2 = &mut self.decl_list_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ConsDeclListNodeTable::WEIGHT);

                t.0 = self.root_decl_list_node(t.0);
                t.1 = self.root_decl_node(t.1);
                t.2 = self.root_decl_list_node(t.2);
                if self.cons_decl_list_node.insert(t) {
                    let weight0 = &mut self.decl_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConsDeclListNodeTable::WEIGHT);

                    let weight1 = &mut self.decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ConsDeclListNodeTable::WEIGHT);

                    let weight2 = &mut self.decl_list_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ConsDeclListNodeTable::WEIGHT);
                }
            }
        }

        for el in self.decl_list_node_uprooted.iter().copied() {
            let ts = self.decls_module_node.drain_with_element_decl_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.module_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DeclsModuleNodeTable::WEIGHT);

                let weight1 = &mut self.decl_list_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DeclsModuleNodeTable::WEIGHT);

                t.0 = self.root_module_node(t.0);
                t.1 = self.root_decl_list_node(t.1);
                if self.decls_module_node.insert(t) {
                    let weight0 = &mut self.module_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DeclsModuleNodeTable::WEIGHT);

                    let weight1 = &mut self.decl_list_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DeclsModuleNodeTable::WEIGHT);
                }
            }
        }
        for el in self.module_node_uprooted.iter().copied() {
            let ts = self.decls_module_node.drain_with_element_module_node(el);
            for mut t in ts {
                let weight0 = &mut self.module_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DeclsModuleNodeTable::WEIGHT);

                let weight1 = &mut self.decl_list_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DeclsModuleNodeTable::WEIGHT);

                t.0 = self.root_module_node(t.0);
                t.1 = self.root_decl_list_node(t.1);
                if self.decls_module_node.insert(t) {
                    let weight0 = &mut self.module_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DeclsModuleNodeTable::WEIGHT);

                    let weight1 = &mut self.decl_list_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DeclsModuleNodeTable::WEIGHT);
                }
            }
        }

        for el in self.scope_uprooted.iter().copied() {
            let ts = self.var_in_scope.drain_with_element_scope(el);
            for mut t in ts {
                let weight0 = &mut self.virt_ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(VarInScopeTable::WEIGHT);

                let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(VarInScopeTable::WEIGHT);

                t.0 = self.root_virt_ident(t.0);
                t.1 = self.root_scope(t.1);
                if self.var_in_scope.insert(t) {
                    let weight0 = &mut self.virt_ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(VarInScopeTable::WEIGHT);

                    let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(VarInScopeTable::WEIGHT);
                }
            }
        }
        for el in self.virt_ident_uprooted.iter().copied() {
            let ts = self.var_in_scope.drain_with_element_virt_ident(el);
            for mut t in ts {
                let weight0 = &mut self.virt_ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(VarInScopeTable::WEIGHT);

                let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(VarInScopeTable::WEIGHT);

                t.0 = self.root_virt_ident(t.0);
                t.1 = self.root_scope(t.1);
                if self.var_in_scope.insert(t) {
                    let weight0 = &mut self.virt_ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(VarInScopeTable::WEIGHT);

                    let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(VarInScopeTable::WEIGHT);
                }
            }
        }

        for el in self.scope_uprooted.iter().copied() {
            let ts = self.scope_extension.drain_with_element_scope(el);
            for mut t in ts {
                let weight0 = &mut self.scope_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ScopeExtensionTable::WEIGHT);

                let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ScopeExtensionTable::WEIGHT);

                t.0 = self.root_scope(t.0);
                t.1 = self.root_scope(t.1);
                if self.scope_extension.insert(t) {
                    let weight0 = &mut self.scope_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ScopeExtensionTable::WEIGHT);

                    let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ScopeExtensionTable::WEIGHT);
                }
            }
        }

        for el in self.rule_descendant_node_uprooted.iter().copied() {
            let ts = self
                .scope_single_child
                .drain_with_element_rule_descendant_node(el);
            for mut t in ts {
                let weight0 = &mut self.rule_descendant_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ScopeSingleChildTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ScopeSingleChildTable::WEIGHT);

                t.0 = self.root_rule_descendant_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.scope_single_child.insert(t) {
                    let weight0 = &mut self.rule_descendant_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ScopeSingleChildTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ScopeSingleChildTable::WEIGHT);
                }
            }
        }

        for el in self.rule_descendant_node_uprooted.iter().copied() {
            let ts = self
                .scope_extension_siblings
                .drain_with_element_rule_descendant_node(el);
            for mut t in ts {
                let weight0 = &mut self.rule_descendant_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ScopeExtensionSiblingsTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ScopeExtensionSiblingsTable::WEIGHT);

                let weight2 = &mut self.rule_descendant_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ScopeExtensionSiblingsTable::WEIGHT);

                t.0 = self.root_rule_descendant_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                t.2 = self.root_rule_descendant_node(t.2);
                if self.scope_extension_siblings.insert(t) {
                    let weight0 = &mut self.rule_descendant_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ScopeExtensionSiblingsTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ScopeExtensionSiblingsTable::WEIGHT);

                    let weight2 = &mut self.rule_descendant_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ScopeExtensionSiblingsTable::WEIGHT);
                }
            }
        }

        for el in self.el_list_uprooted.iter().copied() {
            let ts = self.rel_app.drain_with_element_el_list(el);
            for mut t in ts {
                let weight0 = &mut self.rel_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RelAppTable::WEIGHT);

                let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RelAppTable::WEIGHT);

                t.0 = self.root_rel(t.0);
                t.1 = self.root_el_list(t.1);
                if self.rel_app.insert(t) {
                    let weight0 = &mut self.rel_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RelAppTable::WEIGHT);

                    let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RelAppTable::WEIGHT);
                }
            }
        }
        for el in self.rel_uprooted.iter().copied() {
            let ts = self.rel_app.drain_with_element_rel(el);
            for mut t in ts {
                let weight0 = &mut self.rel_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RelAppTable::WEIGHT);

                let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RelAppTable::WEIGHT);

                t.0 = self.root_rel(t.0);
                t.1 = self.root_el_list(t.1);
                if self.rel_app.insert(t) {
                    let weight0 = &mut self.rel_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RelAppTable::WEIGHT);

                    let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RelAppTable::WEIGHT);
                }
            }
        }

        for el in self.el_uprooted.iter().copied() {
            let ts = self.el_type.drain_with_element_el(el);
            for mut t in ts {
                let weight0 = &mut self.el_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ElTypeTable::WEIGHT);

                let weight1 = &mut self.type_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ElTypeTable::WEIGHT);

                t.0 = self.root_el(t.0);
                t.1 = self.root_type(t.1);
                if self.el_type.insert(t) {
                    let weight0 = &mut self.el_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ElTypeTable::WEIGHT);

                    let weight1 = &mut self.type_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ElTypeTable::WEIGHT);
                }
            }
        }
        for el in self.type_uprooted.iter().copied() {
            let ts = self.el_type.drain_with_element_type(el);
            for mut t in ts {
                let weight0 = &mut self.el_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ElTypeTable::WEIGHT);

                let weight1 = &mut self.type_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ElTypeTable::WEIGHT);

                t.0 = self.root_el(t.0);
                t.1 = self.root_type(t.1);
                if self.el_type.insert(t) {
                    let weight0 = &mut self.el_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ElTypeTable::WEIGHT);

                    let weight1 = &mut self.type_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ElTypeTable::WEIGHT);
                }
            }
        }

        for el in self.el_list_uprooted.iter().copied() {
            let ts = self.el_types.drain_with_element_el_list(el);
            for mut t in ts {
                let weight0 = &mut self.el_list_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ElTypesTable::WEIGHT);

                let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ElTypesTable::WEIGHT);

                t.0 = self.root_el_list(t.0);
                t.1 = self.root_type_list(t.1);
                if self.el_types.insert(t) {
                    let weight0 = &mut self.el_list_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ElTypesTable::WEIGHT);

                    let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ElTypesTable::WEIGHT);
                }
            }
        }
        for el in self.type_list_uprooted.iter().copied() {
            let ts = self.el_types.drain_with_element_type_list(el);
            for mut t in ts {
                let weight0 = &mut self.el_list_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ElTypesTable::WEIGHT);

                let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ElTypesTable::WEIGHT);

                t.0 = self.root_el_list(t.0);
                t.1 = self.root_type_list(t.1);
                if self.el_types.insert(t) {
                    let weight0 = &mut self.el_list_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ElTypesTable::WEIGHT);

                    let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ElTypesTable::WEIGHT);
                }
            }
        }

        for el in self.el_uprooted.iter().copied() {
            let ts = self.constrained_el.drain_with_element_el(el);
            for mut t in ts {
                let weight0 = &mut self.el_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConstrainedElTable::WEIGHT);

                t.0 = self.root_el(t.0);
                if self.constrained_el.insert(t) {
                    let weight0 = &mut self.el_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConstrainedElTable::WEIGHT);
                }
            }
        }

        for el in self.el_list_uprooted.iter().copied() {
            let ts = self.constrained_els.drain_with_element_el_list(el);
            for mut t in ts {
                let weight0 = &mut self.el_list_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConstrainedElsTable::WEIGHT);

                t.0 = self.root_el_list(t.0);
                if self.constrained_els.insert(t) {
                    let weight0 = &mut self.el_list_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConstrainedElsTable::WEIGHT);
                }
            }
        }

        for el in self.el_uprooted.iter().copied() {
            let ts = self.in_ker.drain_with_element_el(el);
            for mut t in ts {
                let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(InKerTable::WEIGHT);

                let weight1 = &mut self.el_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(InKerTable::WEIGHT);

                let weight2 = &mut self.el_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(InKerTable::WEIGHT);

                t.0 = self.root_morphism(t.0);
                t.1 = self.root_el(t.1);
                t.2 = self.root_el(t.2);
                if self.in_ker.insert(t) {
                    let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(InKerTable::WEIGHT);

                    let weight1 = &mut self.el_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(InKerTable::WEIGHT);

                    let weight2 = &mut self.el_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(InKerTable::WEIGHT);
                }
            }
        }
        for el in self.morphism_uprooted.iter().copied() {
            let ts = self.in_ker.drain_with_element_morphism(el);
            for mut t in ts {
                let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(InKerTable::WEIGHT);

                let weight1 = &mut self.el_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(InKerTable::WEIGHT);

                let weight2 = &mut self.el_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(InKerTable::WEIGHT);

                t.0 = self.root_morphism(t.0);
                t.1 = self.root_el(t.1);
                t.2 = self.root_el(t.2);
                if self.in_ker.insert(t) {
                    let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(InKerTable::WEIGHT);

                    let weight1 = &mut self.el_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(InKerTable::WEIGHT);

                    let weight2 = &mut self.el_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(InKerTable::WEIGHT);
                }
            }
        }

        for el in self.el_uprooted.iter().copied() {
            let ts = self.el_in_img.drain_with_element_el(el);
            for mut t in ts {
                let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ElInImgTable::WEIGHT);

                let weight1 = &mut self.el_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ElInImgTable::WEIGHT);

                t.0 = self.root_morphism(t.0);
                t.1 = self.root_el(t.1);
                if self.el_in_img.insert(t) {
                    let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ElInImgTable::WEIGHT);

                    let weight1 = &mut self.el_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ElInImgTable::WEIGHT);
                }
            }
        }
        for el in self.morphism_uprooted.iter().copied() {
            let ts = self.el_in_img.drain_with_element_morphism(el);
            for mut t in ts {
                let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ElInImgTable::WEIGHT);

                let weight1 = &mut self.el_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ElInImgTable::WEIGHT);

                t.0 = self.root_morphism(t.0);
                t.1 = self.root_el(t.1);
                if self.el_in_img.insert(t) {
                    let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ElInImgTable::WEIGHT);

                    let weight1 = &mut self.el_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ElInImgTable::WEIGHT);
                }
            }
        }

        for el in self.el_list_uprooted.iter().copied() {
            let ts = self.rel_tuple_in_img.drain_with_element_el_list(el);
            for mut t in ts {
                let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RelTupleInImgTable::WEIGHT);

                let weight1 = &mut self.rel_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RelTupleInImgTable::WEIGHT);

                let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(RelTupleInImgTable::WEIGHT);

                t.0 = self.root_morphism(t.0);
                t.1 = self.root_rel(t.1);
                t.2 = self.root_el_list(t.2);
                if self.rel_tuple_in_img.insert(t) {
                    let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RelTupleInImgTable::WEIGHT);

                    let weight1 = &mut self.rel_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RelTupleInImgTable::WEIGHT);

                    let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(RelTupleInImgTable::WEIGHT);
                }
            }
        }
        for el in self.morphism_uprooted.iter().copied() {
            let ts = self.rel_tuple_in_img.drain_with_element_morphism(el);
            for mut t in ts {
                let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RelTupleInImgTable::WEIGHT);

                let weight1 = &mut self.rel_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RelTupleInImgTable::WEIGHT);

                let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(RelTupleInImgTable::WEIGHT);

                t.0 = self.root_morphism(t.0);
                t.1 = self.root_rel(t.1);
                t.2 = self.root_el_list(t.2);
                if self.rel_tuple_in_img.insert(t) {
                    let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RelTupleInImgTable::WEIGHT);

                    let weight1 = &mut self.rel_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RelTupleInImgTable::WEIGHT);

                    let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(RelTupleInImgTable::WEIGHT);
                }
            }
        }
        for el in self.rel_uprooted.iter().copied() {
            let ts = self.rel_tuple_in_img.drain_with_element_rel(el);
            for mut t in ts {
                let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RelTupleInImgTable::WEIGHT);

                let weight1 = &mut self.rel_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RelTupleInImgTable::WEIGHT);

                let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(RelTupleInImgTable::WEIGHT);

                t.0 = self.root_morphism(t.0);
                t.1 = self.root_rel(t.1);
                t.2 = self.root_el_list(t.2);
                if self.rel_tuple_in_img.insert(t) {
                    let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RelTupleInImgTable::WEIGHT);

                    let weight1 = &mut self.rel_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RelTupleInImgTable::WEIGHT);

                    let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(RelTupleInImgTable::WEIGHT);
                }
            }
        }

        for el in self.ident_uprooted.iter().copied() {
            let ts = self.defined_symbol.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DefinedSymbolTable::WEIGHT);

                let weight1 = &mut self.symbol_kind_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DefinedSymbolTable::WEIGHT);

                let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(DefinedSymbolTable::WEIGHT);

                t.0 = self.root_ident(t.0);
                t.1 = self.root_symbol_kind(t.1);
                t.2 = self.root_loc(t.2);
                if self.defined_symbol.insert(t) {
                    let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DefinedSymbolTable::WEIGHT);

                    let weight1 = &mut self.symbol_kind_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DefinedSymbolTable::WEIGHT);

                    let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(DefinedSymbolTable::WEIGHT);
                }
            }
        }
        for el in self.loc_uprooted.iter().copied() {
            let ts = self.defined_symbol.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DefinedSymbolTable::WEIGHT);

                let weight1 = &mut self.symbol_kind_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DefinedSymbolTable::WEIGHT);

                let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(DefinedSymbolTable::WEIGHT);

                t.0 = self.root_ident(t.0);
                t.1 = self.root_symbol_kind(t.1);
                t.2 = self.root_loc(t.2);
                if self.defined_symbol.insert(t) {
                    let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DefinedSymbolTable::WEIGHT);

                    let weight1 = &mut self.symbol_kind_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DefinedSymbolTable::WEIGHT);

                    let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(DefinedSymbolTable::WEIGHT);
                }
            }
        }
        for el in self.symbol_kind_uprooted.iter().copied() {
            let ts = self.defined_symbol.drain_with_element_symbol_kind(el);
            for mut t in ts {
                let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DefinedSymbolTable::WEIGHT);

                let weight1 = &mut self.symbol_kind_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DefinedSymbolTable::WEIGHT);

                let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(DefinedSymbolTable::WEIGHT);

                t.0 = self.root_ident(t.0);
                t.1 = self.root_symbol_kind(t.1);
                t.2 = self.root_loc(t.2);
                if self.defined_symbol.insert(t) {
                    let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DefinedSymbolTable::WEIGHT);

                    let weight1 = &mut self.symbol_kind_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DefinedSymbolTable::WEIGHT);

                    let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(DefinedSymbolTable::WEIGHT);
                }
            }
        }

        for el in self.ident_uprooted.iter().copied() {
            let ts = self.should_be_symbol.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ShouldBeSymbolTable::WEIGHT);

                let weight1 = &mut self.symbol_kind_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ShouldBeSymbolTable::WEIGHT);

                let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ShouldBeSymbolTable::WEIGHT);

                t.0 = self.root_ident(t.0);
                t.1 = self.root_symbol_kind(t.1);
                t.2 = self.root_loc(t.2);
                if self.should_be_symbol.insert(t) {
                    let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ShouldBeSymbolTable::WEIGHT);

                    let weight1 = &mut self.symbol_kind_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ShouldBeSymbolTable::WEIGHT);

                    let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ShouldBeSymbolTable::WEIGHT);
                }
            }
        }
        for el in self.loc_uprooted.iter().copied() {
            let ts = self.should_be_symbol.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ShouldBeSymbolTable::WEIGHT);

                let weight1 = &mut self.symbol_kind_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ShouldBeSymbolTable::WEIGHT);

                let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ShouldBeSymbolTable::WEIGHT);

                t.0 = self.root_ident(t.0);
                t.1 = self.root_symbol_kind(t.1);
                t.2 = self.root_loc(t.2);
                if self.should_be_symbol.insert(t) {
                    let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ShouldBeSymbolTable::WEIGHT);

                    let weight1 = &mut self.symbol_kind_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ShouldBeSymbolTable::WEIGHT);

                    let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ShouldBeSymbolTable::WEIGHT);
                }
            }
        }
        for el in self.symbol_kind_uprooted.iter().copied() {
            let ts = self.should_be_symbol.drain_with_element_symbol_kind(el);
            for mut t in ts {
                let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ShouldBeSymbolTable::WEIGHT);

                let weight1 = &mut self.symbol_kind_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ShouldBeSymbolTable::WEIGHT);

                let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ShouldBeSymbolTable::WEIGHT);

                t.0 = self.root_ident(t.0);
                t.1 = self.root_symbol_kind(t.1);
                t.2 = self.root_loc(t.2);
                if self.should_be_symbol.insert(t) {
                    let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ShouldBeSymbolTable::WEIGHT);

                    let weight1 = &mut self.symbol_kind_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ShouldBeSymbolTable::WEIGHT);

                    let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ShouldBeSymbolTable::WEIGHT);
                }
            }
        }

        for el in self.ident_uprooted.iter().copied() {
            let ts = self.should_be_symbol_2.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

                let weight1 = &mut self.symbol_kind_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

                let weight2 = &mut self.symbol_kind_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

                let weight3 = &mut self.loc_weights[t.3 .0 as usize];
                *weight3 = weight3.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

                t.0 = self.root_ident(t.0);
                t.1 = self.root_symbol_kind(t.1);
                t.2 = self.root_symbol_kind(t.2);
                t.3 = self.root_loc(t.3);
                if self.should_be_symbol_2.insert(t) {
                    let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ShouldBeSymbol2Table::WEIGHT);

                    let weight1 = &mut self.symbol_kind_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ShouldBeSymbol2Table::WEIGHT);

                    let weight2 = &mut self.symbol_kind_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ShouldBeSymbol2Table::WEIGHT);

                    let weight3 = &mut self.loc_weights[t.3 .0 as usize];
                    *weight3 = weight3.saturating_add(ShouldBeSymbol2Table::WEIGHT);
                }
            }
        }
        for el in self.loc_uprooted.iter().copied() {
            let ts = self.should_be_symbol_2.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

                let weight1 = &mut self.symbol_kind_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

                let weight2 = &mut self.symbol_kind_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

                let weight3 = &mut self.loc_weights[t.3 .0 as usize];
                *weight3 = weight3.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

                t.0 = self.root_ident(t.0);
                t.1 = self.root_symbol_kind(t.1);
                t.2 = self.root_symbol_kind(t.2);
                t.3 = self.root_loc(t.3);
                if self.should_be_symbol_2.insert(t) {
                    let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ShouldBeSymbol2Table::WEIGHT);

                    let weight1 = &mut self.symbol_kind_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ShouldBeSymbol2Table::WEIGHT);

                    let weight2 = &mut self.symbol_kind_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ShouldBeSymbol2Table::WEIGHT);

                    let weight3 = &mut self.loc_weights[t.3 .0 as usize];
                    *weight3 = weight3.saturating_add(ShouldBeSymbol2Table::WEIGHT);
                }
            }
        }
        for el in self.symbol_kind_uprooted.iter().copied() {
            let ts = self.should_be_symbol_2.drain_with_element_symbol_kind(el);
            for mut t in ts {
                let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

                let weight1 = &mut self.symbol_kind_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

                let weight2 = &mut self.symbol_kind_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

                let weight3 = &mut self.loc_weights[t.3 .0 as usize];
                *weight3 = weight3.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

                t.0 = self.root_ident(t.0);
                t.1 = self.root_symbol_kind(t.1);
                t.2 = self.root_symbol_kind(t.2);
                t.3 = self.root_loc(t.3);
                if self.should_be_symbol_2.insert(t) {
                    let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ShouldBeSymbol2Table::WEIGHT);

                    let weight1 = &mut self.symbol_kind_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ShouldBeSymbol2Table::WEIGHT);

                    let weight2 = &mut self.symbol_kind_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ShouldBeSymbol2Table::WEIGHT);

                    let weight3 = &mut self.loc_weights[t.3 .0 as usize];
                    *weight3 = weight3.saturating_add(ShouldBeSymbol2Table::WEIGHT);
                }
            }
        }

        for el in self.loc_uprooted.iter().copied() {
            let ts = self.pred_arg_num_should_match.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.nat_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PredArgNumShouldMatchTable::WEIGHT);

                let weight1 = &mut self.nat_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(PredArgNumShouldMatchTable::WEIGHT);

                let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(PredArgNumShouldMatchTable::WEIGHT);

                t.0 = self.root_nat(t.0);
                t.1 = self.root_nat(t.1);
                t.2 = self.root_loc(t.2);
                if self.pred_arg_num_should_match.insert(t) {
                    let weight0 = &mut self.nat_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PredArgNumShouldMatchTable::WEIGHT);

                    let weight1 = &mut self.nat_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(PredArgNumShouldMatchTable::WEIGHT);

                    let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(PredArgNumShouldMatchTable::WEIGHT);
                }
            }
        }
        for el in self.nat_uprooted.iter().copied() {
            let ts = self.pred_arg_num_should_match.drain_with_element_nat(el);
            for mut t in ts {
                let weight0 = &mut self.nat_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PredArgNumShouldMatchTable::WEIGHT);

                let weight1 = &mut self.nat_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(PredArgNumShouldMatchTable::WEIGHT);

                let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(PredArgNumShouldMatchTable::WEIGHT);

                t.0 = self.root_nat(t.0);
                t.1 = self.root_nat(t.1);
                t.2 = self.root_loc(t.2);
                if self.pred_arg_num_should_match.insert(t) {
                    let weight0 = &mut self.nat_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PredArgNumShouldMatchTable::WEIGHT);

                    let weight1 = &mut self.nat_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(PredArgNumShouldMatchTable::WEIGHT);

                    let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(PredArgNumShouldMatchTable::WEIGHT);
                }
            }
        }

        for el in self.loc_uprooted.iter().copied() {
            let ts = self.func_arg_num_should_match.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.nat_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(FuncArgNumShouldMatchTable::WEIGHT);

                let weight1 = &mut self.nat_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(FuncArgNumShouldMatchTable::WEIGHT);

                let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(FuncArgNumShouldMatchTable::WEIGHT);

                t.0 = self.root_nat(t.0);
                t.1 = self.root_nat(t.1);
                t.2 = self.root_loc(t.2);
                if self.func_arg_num_should_match.insert(t) {
                    let weight0 = &mut self.nat_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(FuncArgNumShouldMatchTable::WEIGHT);

                    let weight1 = &mut self.nat_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(FuncArgNumShouldMatchTable::WEIGHT);

                    let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(FuncArgNumShouldMatchTable::WEIGHT);
                }
            }
        }
        for el in self.nat_uprooted.iter().copied() {
            let ts = self.func_arg_num_should_match.drain_with_element_nat(el);
            for mut t in ts {
                let weight0 = &mut self.nat_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(FuncArgNumShouldMatchTable::WEIGHT);

                let weight1 = &mut self.nat_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(FuncArgNumShouldMatchTable::WEIGHT);

                let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(FuncArgNumShouldMatchTable::WEIGHT);

                t.0 = self.root_nat(t.0);
                t.1 = self.root_nat(t.1);
                t.2 = self.root_loc(t.2);
                if self.func_arg_num_should_match.insert(t) {
                    let weight0 = &mut self.nat_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(FuncArgNumShouldMatchTable::WEIGHT);

                    let weight1 = &mut self.nat_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(FuncArgNumShouldMatchTable::WEIGHT);

                    let weight2 = &mut self.loc_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(FuncArgNumShouldMatchTable::WEIGHT);
                }
            }
        }

        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self.cfg_edge.drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CfgEdgeTable::WEIGHT);

                let weight1 = &mut self.stmt_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CfgEdgeTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_stmt_node(t.1);
                if self.cfg_edge.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CfgEdgeTable::WEIGHT);

                    let weight1 = &mut self.stmt_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CfgEdgeTable::WEIGHT);
                }
            }
        }

        for el in self.stmt_list_node_uprooted.iter().copied() {
            let ts = self
                .cfg_edge_stmts_stmt
                .drain_with_element_stmt_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CfgEdgeStmtsStmtTable::WEIGHT);

                let weight1 = &mut self.stmt_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CfgEdgeStmtsStmtTable::WEIGHT);

                t.0 = self.root_stmt_list_node(t.0);
                t.1 = self.root_stmt_node(t.1);
                if self.cfg_edge_stmts_stmt.insert(t) {
                    let weight0 = &mut self.stmt_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CfgEdgeStmtsStmtTable::WEIGHT);

                    let weight1 = &mut self.stmt_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CfgEdgeStmtsStmtTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self.cfg_edge_stmts_stmt.drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CfgEdgeStmtsStmtTable::WEIGHT);

                let weight1 = &mut self.stmt_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CfgEdgeStmtsStmtTable::WEIGHT);

                t.0 = self.root_stmt_list_node(t.0);
                t.1 = self.root_stmt_node(t.1);
                if self.cfg_edge_stmts_stmt.insert(t) {
                    let weight0 = &mut self.stmt_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CfgEdgeStmtsStmtTable::WEIGHT);

                    let weight1 = &mut self.stmt_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CfgEdgeStmtsStmtTable::WEIGHT);
                }
            }
        }

        for el in self.stmt_list_node_uprooted.iter().copied() {
            let ts = self
                .cfg_edge_stmt_stmts
                .drain_with_element_stmt_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CfgEdgeStmtStmtsTable::WEIGHT);

                let weight1 = &mut self.stmt_list_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CfgEdgeStmtStmtsTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_stmt_list_node(t.1);
                if self.cfg_edge_stmt_stmts.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CfgEdgeStmtStmtsTable::WEIGHT);

                    let weight1 = &mut self.stmt_list_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CfgEdgeStmtStmtsTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self.cfg_edge_stmt_stmts.drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CfgEdgeStmtStmtsTable::WEIGHT);

                let weight1 = &mut self.stmt_list_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CfgEdgeStmtStmtsTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_stmt_list_node(t.1);
                if self.cfg_edge_stmt_stmts.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CfgEdgeStmtStmtsTable::WEIGHT);

                    let weight1 = &mut self.stmt_list_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CfgEdgeStmtStmtsTable::WEIGHT);
                }
            }
        }

        for el in self.stmt_block_list_node_uprooted.iter().copied() {
            let ts = self
                .cfg_edge_fork
                .drain_with_element_stmt_block_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CfgEdgeForkTable::WEIGHT);

                let weight1 = &mut self.stmt_block_list_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CfgEdgeForkTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_stmt_block_list_node(t.1);
                if self.cfg_edge_fork.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CfgEdgeForkTable::WEIGHT);

                    let weight1 = &mut self.stmt_block_list_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CfgEdgeForkTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self.cfg_edge_fork.drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CfgEdgeForkTable::WEIGHT);

                let weight1 = &mut self.stmt_block_list_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CfgEdgeForkTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_stmt_block_list_node(t.1);
                if self.cfg_edge_fork.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CfgEdgeForkTable::WEIGHT);

                    let weight1 = &mut self.stmt_block_list_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CfgEdgeForkTable::WEIGHT);
                }
            }
        }

        for el in self.stmt_block_list_node_uprooted.iter().copied() {
            let ts = self
                .cfg_edge_join
                .drain_with_element_stmt_block_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_block_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CfgEdgeJoinTable::WEIGHT);

                let weight1 = &mut self.stmt_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CfgEdgeJoinTable::WEIGHT);

                t.0 = self.root_stmt_block_list_node(t.0);
                t.1 = self.root_stmt_node(t.1);
                if self.cfg_edge_join.insert(t) {
                    let weight0 = &mut self.stmt_block_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CfgEdgeJoinTable::WEIGHT);

                    let weight1 = &mut self.stmt_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CfgEdgeJoinTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self.cfg_edge_join.drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_block_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CfgEdgeJoinTable::WEIGHT);

                let weight1 = &mut self.stmt_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CfgEdgeJoinTable::WEIGHT);

                t.0 = self.root_stmt_block_list_node(t.0);
                t.1 = self.root_stmt_node(t.1);
                if self.cfg_edge_join.insert(t) {
                    let weight0 = &mut self.stmt_block_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CfgEdgeJoinTable::WEIGHT);

                    let weight1 = &mut self.stmt_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CfgEdgeJoinTable::WEIGHT);
                }
            }
        }

        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self.before_stmt_structure.drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(BeforeStmtStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(BeforeStmtStructureTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_structure(t.1);
                if self.before_stmt_structure.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(BeforeStmtStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(BeforeStmtStructureTable::WEIGHT);
                }
            }
        }
        for el in self.structure_uprooted.iter().copied() {
            let ts = self.before_stmt_structure.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(BeforeStmtStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(BeforeStmtStructureTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_structure(t.1);
                if self.before_stmt_structure.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(BeforeStmtStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(BeforeStmtStructureTable::WEIGHT);
                }
            }
        }

        for el in self.morphism_uprooted.iter().copied() {
            let ts = self.stmt_morphism.drain_with_element_morphism(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(StmtMorphismTable::WEIGHT);

                let weight1 = &mut self.morphism_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(StmtMorphismTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_morphism(t.1);
                if self.stmt_morphism.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(StmtMorphismTable::WEIGHT);

                    let weight1 = &mut self.morphism_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(StmtMorphismTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self.stmt_morphism.drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(StmtMorphismTable::WEIGHT);

                let weight1 = &mut self.morphism_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(StmtMorphismTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_morphism(t.1);
                if self.stmt_morphism.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(StmtMorphismTable::WEIGHT);

                    let weight1 = &mut self.morphism_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(StmtMorphismTable::WEIGHT);
                }
            }
        }

        for el in self.morphism_uprooted.iter().copied() {
            let ts = self.if_morphism.drain_with_element_morphism(el);
            for mut t in ts {
                let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(IfMorphismTable::WEIGHT);

                t.0 = self.root_morphism(t.0);
                if self.if_morphism.insert(t) {
                    let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(IfMorphismTable::WEIGHT);
                }
            }
        }

        for el in self.morphism_uprooted.iter().copied() {
            let ts = self.surj_then_morphism.drain_with_element_morphism(el);
            for mut t in ts {
                let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SurjThenMorphismTable::WEIGHT);

                t.0 = self.root_morphism(t.0);
                if self.surj_then_morphism.insert(t) {
                    let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SurjThenMorphismTable::WEIGHT);
                }
            }
        }

        for el in self.morphism_uprooted.iter().copied() {
            let ts = self.non_surj_then_morphism.drain_with_element_morphism(el);
            for mut t in ts {
                let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(NonSurjThenMorphismTable::WEIGHT);

                t.0 = self.root_morphism(t.0);
                if self.non_surj_then_morphism.insert(t) {
                    let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(NonSurjThenMorphismTable::WEIGHT);
                }
            }
        }

        for el in self.morphism_uprooted.iter().copied() {
            let ts = self.noop_morphism.drain_with_element_morphism(el);
            for mut t in ts {
                let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(NoopMorphismTable::WEIGHT);

                t.0 = self.root_morphism(t.0);
                if self.noop_morphism.insert(t) {
                    let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(NoopMorphismTable::WEIGHT);
                }
            }
        }

        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self.stmt_structure.drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(StmtStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(StmtStructureTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_structure(t.1);
                if self.stmt_structure.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(StmtStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(StmtStructureTable::WEIGHT);
                }
            }
        }
        for el in self.structure_uprooted.iter().copied() {
            let ts = self.stmt_structure.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(StmtStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(StmtStructureTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_structure(t.1);
                if self.stmt_structure.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(StmtStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(StmtStructureTable::WEIGHT);
                }
            }
        }

        for el in self.if_atom_node_uprooted.iter().copied() {
            let ts = self.if_atom_structure.drain_with_element_if_atom_node(el);
            for mut t in ts {
                let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(IfAtomStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(IfAtomStructureTable::WEIGHT);

                t.0 = self.root_if_atom_node(t.0);
                t.1 = self.root_structure(t.1);
                if self.if_atom_structure.insert(t) {
                    let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(IfAtomStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(IfAtomStructureTable::WEIGHT);
                }
            }
        }
        for el in self.structure_uprooted.iter().copied() {
            let ts = self.if_atom_structure.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(IfAtomStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(IfAtomStructureTable::WEIGHT);

                t.0 = self.root_if_atom_node(t.0);
                t.1 = self.root_structure(t.1);
                if self.if_atom_structure.insert(t) {
                    let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(IfAtomStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(IfAtomStructureTable::WEIGHT);
                }
            }
        }

        for el in self.structure_uprooted.iter().copied() {
            let ts = self.then_atom_structure.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ThenAtomStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ThenAtomStructureTable::WEIGHT);

                t.0 = self.root_then_atom_node(t.0);
                t.1 = self.root_structure(t.1);
                if self.then_atom_structure.insert(t) {
                    let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ThenAtomStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ThenAtomStructureTable::WEIGHT);
                }
            }
        }
        for el in self.then_atom_node_uprooted.iter().copied() {
            let ts = self
                .then_atom_structure
                .drain_with_element_then_atom_node(el);
            for mut t in ts {
                let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ThenAtomStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ThenAtomStructureTable::WEIGHT);

                t.0 = self.root_then_atom_node(t.0);
                t.1 = self.root_structure(t.1);
                if self.then_atom_structure.insert(t) {
                    let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ThenAtomStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ThenAtomStructureTable::WEIGHT);
                }
            }
        }

        for el in self.structure_uprooted.iter().copied() {
            let ts = self.term_structure.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(TermStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(TermStructureTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_structure(t.1);
                if self.term_structure.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(TermStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(TermStructureTable::WEIGHT);
                }
            }
        }
        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.term_structure.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(TermStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(TermStructureTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_structure(t.1);
                if self.term_structure.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(TermStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(TermStructureTable::WEIGHT);
                }
            }
        }

        for el in self.structure_uprooted.iter().copied() {
            let ts = self.terms_structure.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(TermsStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(TermsStructureTable::WEIGHT);

                t.0 = self.root_term_list_node(t.0);
                t.1 = self.root_structure(t.1);
                if self.terms_structure.insert(t) {
                    let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(TermsStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(TermsStructureTable::WEIGHT);
                }
            }
        }
        for el in self.term_list_node_uprooted.iter().copied() {
            let ts = self.terms_structure.drain_with_element_term_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(TermsStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(TermsStructureTable::WEIGHT);

                t.0 = self.root_term_list_node(t.0);
                t.1 = self.root_structure(t.1);
                if self.terms_structure.insert(t) {
                    let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(TermsStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(TermsStructureTable::WEIGHT);
                }
            }
        }

        for el in self.opt_term_node_uprooted.iter().copied() {
            let ts = self.opt_term_structure.drain_with_element_opt_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.opt_term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(OptTermStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(OptTermStructureTable::WEIGHT);

                t.0 = self.root_opt_term_node(t.0);
                t.1 = self.root_structure(t.1);
                if self.opt_term_structure.insert(t) {
                    let weight0 = &mut self.opt_term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(OptTermStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(OptTermStructureTable::WEIGHT);
                }
            }
        }
        for el in self.structure_uprooted.iter().copied() {
            let ts = self.opt_term_structure.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.opt_term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(OptTermStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(OptTermStructureTable::WEIGHT);

                t.0 = self.root_opt_term_node(t.0);
                t.1 = self.root_structure(t.1);
                if self.opt_term_structure.insert(t) {
                    let weight0 = &mut self.opt_term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(OptTermStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(OptTermStructureTable::WEIGHT);
                }
            }
        }

        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.term_should_be_epic_ok.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(TermShouldBeEpicOkTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                if self.term_should_be_epic_ok.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(TermShouldBeEpicOkTable::WEIGHT);
                }
            }
        }

        for el in self.term_list_node_uprooted.iter().copied() {
            let ts = self
                .terms_should_be_epic_ok
                .drain_with_element_term_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(TermsShouldBeEpicOkTable::WEIGHT);

                t.0 = self.root_term_list_node(t.0);
                if self.terms_should_be_epic_ok.insert(t) {
                    let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(TermsShouldBeEpicOkTable::WEIGHT);
                }
            }
        }

        for el in self.el_uprooted.iter().copied() {
            let ts = self.el_should_be_surjective_ok.drain_with_element_el(el);
            for mut t in ts {
                let weight0 = &mut self.el_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ElShouldBeSurjectiveOkTable::WEIGHT);

                t.0 = self.root_el(t.0);
                if self.el_should_be_surjective_ok.insert(t) {
                    let weight0 = &mut self.el_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ElShouldBeSurjectiveOkTable::WEIGHT);
                }
            }
        }

        for el in self.el_uprooted.iter().copied() {
            let ts = self.el_is_surjective_ok.drain_with_element_el(el);
            for mut t in ts {
                let weight0 = &mut self.el_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ElIsSurjectiveOkTable::WEIGHT);

                t.0 = self.root_el(t.0);
                if self.el_is_surjective_ok.insert(t) {
                    let weight0 = &mut self.el_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ElIsSurjectiveOkTable::WEIGHT);
                }
            }
        }

        for el in self.enum_decl_node_uprooted.iter().copied() {
            let ts = self
                .should_be_obtained_by_ctor
                .drain_with_element_enum_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ShouldBeObtainedByCtorTable::WEIGHT);

                let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ShouldBeObtainedByCtorTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_enum_decl_node(t.1);
                if self.should_be_obtained_by_ctor.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ShouldBeObtainedByCtorTable::WEIGHT);

                    let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ShouldBeObtainedByCtorTable::WEIGHT);
                }
            }
        }
        for el in self.term_node_uprooted.iter().copied() {
            let ts = self
                .should_be_obtained_by_ctor
                .drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ShouldBeObtainedByCtorTable::WEIGHT);

                let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ShouldBeObtainedByCtorTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_enum_decl_node(t.1);
                if self.should_be_obtained_by_ctor.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ShouldBeObtainedByCtorTable::WEIGHT);

                    let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ShouldBeObtainedByCtorTable::WEIGHT);
                }
            }
        }

        for el in self.enum_decl_node_uprooted.iter().copied() {
            let ts = self.is_given_by_ctor.drain_with_element_enum_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(IsGivenByCtorTable::WEIGHT);

                let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(IsGivenByCtorTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_enum_decl_node(t.1);
                if self.is_given_by_ctor.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(IsGivenByCtorTable::WEIGHT);

                    let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(IsGivenByCtorTable::WEIGHT);
                }
            }
        }
        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.is_given_by_ctor.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(IsGivenByCtorTable::WEIGHT);

                let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(IsGivenByCtorTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_enum_decl_node(t.1);
                if self.is_given_by_ctor.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(IsGivenByCtorTable::WEIGHT);

                    let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(IsGivenByCtorTable::WEIGHT);
                }
            }
        }

        for el in self.func_uprooted.iter().copied() {
            let ts = self
                .function_can_be_made_defined
                .drain_with_element_func(el);
            for mut t in ts {
                let weight0 = &mut self.func_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(FunctionCanBeMadeDefinedTable::WEIGHT);

                t.0 = self.root_func(t.0);
                if self.function_can_be_made_defined.insert(t) {
                    let weight0 = &mut self.func_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(FunctionCanBeMadeDefinedTable::WEIGHT);
                }
            }
        }

        for el in self.loc_uprooted.iter().copied() {
            let ts = self.case_pattern_is_variable.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.loc_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CasePatternIsVariableTable::WEIGHT);

                t.0 = self.root_loc(t.0);
                if self.case_pattern_is_variable.insert(t) {
                    let weight0 = &mut self.loc_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CasePatternIsVariableTable::WEIGHT);
                }
            }
        }

        for el in self.loc_uprooted.iter().copied() {
            let ts = self.case_pattern_is_wildcard.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.loc_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CasePatternIsWildcardTable::WEIGHT);

                t.0 = self.root_loc(t.0);
                if self.case_pattern_is_wildcard.insert(t) {
                    let weight0 = &mut self.loc_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CasePatternIsWildcardTable::WEIGHT);
                }
            }
        }

        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.is_pattern_ctor_arg.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(IsPatternCtorArgTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                if self.is_pattern_ctor_arg.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(IsPatternCtorArgTable::WEIGHT);
                }
            }
        }

        for el in self.term_list_node_uprooted.iter().copied() {
            let ts = self
                .are_pattern_ctor_args
                .drain_with_element_term_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ArePatternCtorArgsTable::WEIGHT);

                t.0 = self.root_term_list_node(t.0);
                if self.are_pattern_ctor_args.insert(t) {
                    let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ArePatternCtorArgsTable::WEIGHT);
                }
            }
        }

        for el in self.loc_uprooted.iter().copied() {
            let ts = self.pattern_ctor_arg_is_app.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.loc_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PatternCtorArgIsAppTable::WEIGHT);

                t.0 = self.root_loc(t.0);
                if self.pattern_ctor_arg_is_app.insert(t) {
                    let weight0 = &mut self.loc_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PatternCtorArgIsAppTable::WEIGHT);
                }
            }
        }

        for el in self.loc_uprooted.iter().copied() {
            let ts = self
                .pattern_ctor_arg_var_is_not_fresh
                .drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.loc_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PatternCtorArgVarIsNotFreshTable::WEIGHT);

                t.0 = self.root_loc(t.0);
                if self.pattern_ctor_arg_var_is_not_fresh.insert(t) {
                    let weight0 = &mut self.loc_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PatternCtorArgVarIsNotFreshTable::WEIGHT);
                }
            }
        }

        for el in self.ctor_decl_node_uprooted.iter().copied() {
            let ts = self
                .cases_contain_ctor
                .drain_with_element_ctor_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CasesContainCtorTable::WEIGHT);

                let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CasesContainCtorTable::WEIGHT);

                t.0 = self.root_match_case_list_node(t.0);
                t.1 = self.root_ctor_decl_node(t.1);
                if self.cases_contain_ctor.insert(t) {
                    let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CasesContainCtorTable::WEIGHT);

                    let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CasesContainCtorTable::WEIGHT);
                }
            }
        }
        for el in self.match_case_list_node_uprooted.iter().copied() {
            let ts = self
                .cases_contain_ctor
                .drain_with_element_match_case_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CasesContainCtorTable::WEIGHT);

                let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CasesContainCtorTable::WEIGHT);

                t.0 = self.root_match_case_list_node(t.0);
                t.1 = self.root_ctor_decl_node(t.1);
                if self.cases_contain_ctor.insert(t) {
                    let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CasesContainCtorTable::WEIGHT);

                    let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CasesContainCtorTable::WEIGHT);
                }
            }
        }

        for el in self.ctor_decl_node_uprooted.iter().copied() {
            let ts = self
                .match_stmt_contains_ctor_of_enum
                .drain_with_element_ctor_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchStmtContainsCtorOfEnumTable::WEIGHT);

                let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchStmtContainsCtorOfEnumTable::WEIGHT);

                let weight2 = &mut self.enum_decl_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(MatchStmtContainsCtorOfEnumTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_ctor_decl_node(t.1);
                t.2 = self.root_enum_decl_node(t.2);
                if self.match_stmt_contains_ctor_of_enum.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

                    let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

                    let weight2 = &mut self.enum_decl_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);
                }
            }
        }
        for el in self.enum_decl_node_uprooted.iter().copied() {
            let ts = self
                .match_stmt_contains_ctor_of_enum
                .drain_with_element_enum_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchStmtContainsCtorOfEnumTable::WEIGHT);

                let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchStmtContainsCtorOfEnumTable::WEIGHT);

                let weight2 = &mut self.enum_decl_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(MatchStmtContainsCtorOfEnumTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_ctor_decl_node(t.1);
                t.2 = self.root_enum_decl_node(t.2);
                if self.match_stmt_contains_ctor_of_enum.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

                    let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

                    let weight2 = &mut self.enum_decl_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self
                .match_stmt_contains_ctor_of_enum
                .drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchStmtContainsCtorOfEnumTable::WEIGHT);

                let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchStmtContainsCtorOfEnumTable::WEIGHT);

                let weight2 = &mut self.enum_decl_node_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(MatchStmtContainsCtorOfEnumTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_ctor_decl_node(t.1);
                t.2 = self.root_enum_decl_node(t.2);
                if self.match_stmt_contains_ctor_of_enum.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

                    let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

                    let weight2 = &mut self.enum_decl_node_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);
                }
            }
        }

        for el in self.ctor_decl_node_uprooted.iter().copied() {
            let ts = self
                .match_stmt_should_contain_ctor
                .drain_with_element_ctor_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchStmtShouldContainCtorTable::WEIGHT);

                let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchStmtShouldContainCtorTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_ctor_decl_node(t.1);
                if self.match_stmt_should_contain_ctor.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchStmtShouldContainCtorTable::WEIGHT);

                    let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchStmtShouldContainCtorTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self
                .match_stmt_should_contain_ctor
                .drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchStmtShouldContainCtorTable::WEIGHT);

                let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchStmtShouldContainCtorTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_ctor_decl_node(t.1);
                if self.match_stmt_should_contain_ctor.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchStmtShouldContainCtorTable::WEIGHT);

                    let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchStmtShouldContainCtorTable::WEIGHT);
                }
            }
        }

        for el in self.ctor_decl_node_uprooted.iter().copied() {
            let ts = self
                .match_stmt_contains_ctor
                .drain_with_element_ctor_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchStmtContainsCtorTable::WEIGHT);

                let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchStmtContainsCtorTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_ctor_decl_node(t.1);
                if self.match_stmt_contains_ctor.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchStmtContainsCtorTable::WEIGHT);

                    let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchStmtContainsCtorTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self
                .match_stmt_contains_ctor
                .drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchStmtContainsCtorTable::WEIGHT);

                let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchStmtContainsCtorTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_ctor_decl_node(t.1);
                if self.match_stmt_contains_ctor.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchStmtContainsCtorTable::WEIGHT);

                    let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchStmtContainsCtorTable::WEIGHT);
                }
            }
        }

        for el in self.ident_uprooted.iter().copied() {
            let ts = self.real_virt_ident.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RealVirtIdentTable::WEIGHT);

                let weight1 = &mut self.virt_ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RealVirtIdentTable::WEIGHT);

                t.0 = self.root_ident(t.0);
                t.1 = self.root_virt_ident(t.1);
                if self.real_virt_ident.insert(t) {
                    let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RealVirtIdentTable::WEIGHT);

                    let weight1 = &mut self.virt_ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RealVirtIdentTable::WEIGHT);
                }
            }
        }
        for el in self.virt_ident_uprooted.iter().copied() {
            let ts = self.real_virt_ident.drain_with_element_virt_ident(el);
            for mut t in ts {
                let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RealVirtIdentTable::WEIGHT);

                let weight1 = &mut self.virt_ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RealVirtIdentTable::WEIGHT);

                t.0 = self.root_ident(t.0);
                t.1 = self.root_virt_ident(t.1);
                if self.real_virt_ident.insert(t) {
                    let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RealVirtIdentTable::WEIGHT);

                    let weight1 = &mut self.virt_ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RealVirtIdentTable::WEIGHT);
                }
            }
        }

        for el in self.ident_uprooted.iter().copied() {
            let ts = self.virt_real_ident.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.virt_ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(VirtRealIdentTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(VirtRealIdentTable::WEIGHT);

                t.0 = self.root_virt_ident(t.0);
                t.1 = self.root_ident(t.1);
                if self.virt_real_ident.insert(t) {
                    let weight0 = &mut self.virt_ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(VirtRealIdentTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(VirtRealIdentTable::WEIGHT);
                }
            }
        }
        for el in self.virt_ident_uprooted.iter().copied() {
            let ts = self.virt_real_ident.drain_with_element_virt_ident(el);
            for mut t in ts {
                let weight0 = &mut self.virt_ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(VirtRealIdentTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(VirtRealIdentTable::WEIGHT);

                t.0 = self.root_virt_ident(t.0);
                t.1 = self.root_ident(t.1);
                if self.virt_real_ident.insert(t) {
                    let weight0 = &mut self.virt_ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(VirtRealIdentTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(VirtRealIdentTable::WEIGHT);
                }
            }
        }

        for el in self.el_uprooted.iter().copied() {
            let ts = self.var.drain_with_element_el(el);
            for mut t in ts {
                let weight0 = &mut self.structure_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(VarTable::WEIGHT);

                let weight1 = &mut self.el_name_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(VarTable::WEIGHT);

                let weight2 = &mut self.el_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(VarTable::WEIGHT);

                t.0 = self.root_structure(t.0);
                t.1 = self.root_el_name(t.1);
                t.2 = self.root_el(t.2);
                if self.var.insert(t) {
                    let weight0 = &mut self.structure_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(VarTable::WEIGHT);

                    let weight1 = &mut self.el_name_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(VarTable::WEIGHT);

                    let weight2 = &mut self.el_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(VarTable::WEIGHT);
                }
            }
        }
        for el in self.el_name_uprooted.iter().copied() {
            let ts = self.var.drain_with_element_el_name(el);
            for mut t in ts {
                let weight0 = &mut self.structure_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(VarTable::WEIGHT);

                let weight1 = &mut self.el_name_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(VarTable::WEIGHT);

                let weight2 = &mut self.el_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(VarTable::WEIGHT);

                t.0 = self.root_structure(t.0);
                t.1 = self.root_el_name(t.1);
                t.2 = self.root_el(t.2);
                if self.var.insert(t) {
                    let weight0 = &mut self.structure_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(VarTable::WEIGHT);

                    let weight1 = &mut self.el_name_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(VarTable::WEIGHT);

                    let weight2 = &mut self.el_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(VarTable::WEIGHT);
                }
            }
        }
        for el in self.structure_uprooted.iter().copied() {
            let ts = self.var.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.structure_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(VarTable::WEIGHT);

                let weight1 = &mut self.el_name_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(VarTable::WEIGHT);

                let weight2 = &mut self.el_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(VarTable::WEIGHT);

                t.0 = self.root_structure(t.0);
                t.1 = self.root_el_name(t.1);
                t.2 = self.root_el(t.2);
                if self.var.insert(t) {
                    let weight0 = &mut self.structure_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(VarTable::WEIGHT);

                    let weight1 = &mut self.el_name_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(VarTable::WEIGHT);

                    let weight2 = &mut self.el_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(VarTable::WEIGHT);
                }
            }
        }

        for el in self.ident_uprooted.iter().copied() {
            let ts = self.rule_name.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleNameTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleNameTable::WEIGHT);

                t.0 = self.root_rule_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                if self.rule_name.insert(t) {
                    let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleNameTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleNameTable::WEIGHT);
                }
            }
        }
        for el in self.rule_decl_node_uprooted.iter().copied() {
            let ts = self.rule_name.drain_with_element_rule_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleNameTable::WEIGHT);

                let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleNameTable::WEIGHT);

                t.0 = self.root_rule_decl_node(t.0);
                t.1 = self.root_ident(t.1);
                if self.rule_name.insert(t) {
                    let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleNameTable::WEIGHT);

                    let weight1 = &mut self.ident_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleNameTable::WEIGHT);
                }
            }
        }

        for el in self.loc_uprooted.iter().copied() {
            let ts = self.type_decl_node_loc.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.type_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(TypeDeclNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(TypeDeclNodeLocTable::WEIGHT);

                t.0 = self.root_type_decl_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.type_decl_node_loc.insert(t) {
                    let weight0 = &mut self.type_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(TypeDeclNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(TypeDeclNodeLocTable::WEIGHT);
                }
            }
        }
        for el in self.type_decl_node_uprooted.iter().copied() {
            let ts = self
                .type_decl_node_loc
                .drain_with_element_type_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.type_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(TypeDeclNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(TypeDeclNodeLocTable::WEIGHT);

                t.0 = self.root_type_decl_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.type_decl_node_loc.insert(t) {
                    let weight0 = &mut self.type_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(TypeDeclNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(TypeDeclNodeLocTable::WEIGHT);
                }
            }
        }

        for el in self.arg_decl_node_uprooted.iter().copied() {
            let ts = self.arg_decl_node_loc.drain_with_element_arg_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.arg_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ArgDeclNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ArgDeclNodeLocTable::WEIGHT);

                t.0 = self.root_arg_decl_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.arg_decl_node_loc.insert(t) {
                    let weight0 = &mut self.arg_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ArgDeclNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ArgDeclNodeLocTable::WEIGHT);
                }
            }
        }
        for el in self.loc_uprooted.iter().copied() {
            let ts = self.arg_decl_node_loc.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.arg_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ArgDeclNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ArgDeclNodeLocTable::WEIGHT);

                t.0 = self.root_arg_decl_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.arg_decl_node_loc.insert(t) {
                    let weight0 = &mut self.arg_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ArgDeclNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ArgDeclNodeLocTable::WEIGHT);
                }
            }
        }

        for el in self.arg_decl_list_node_uprooted.iter().copied() {
            let ts = self
                .arg_decl_list_node_loc
                .drain_with_element_arg_decl_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.arg_decl_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ArgDeclListNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ArgDeclListNodeLocTable::WEIGHT);

                t.0 = self.root_arg_decl_list_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.arg_decl_list_node_loc.insert(t) {
                    let weight0 = &mut self.arg_decl_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ArgDeclListNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ArgDeclListNodeLocTable::WEIGHT);
                }
            }
        }
        for el in self.loc_uprooted.iter().copied() {
            let ts = self.arg_decl_list_node_loc.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.arg_decl_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ArgDeclListNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ArgDeclListNodeLocTable::WEIGHT);

                t.0 = self.root_arg_decl_list_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.arg_decl_list_node_loc.insert(t) {
                    let weight0 = &mut self.arg_decl_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ArgDeclListNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ArgDeclListNodeLocTable::WEIGHT);
                }
            }
        }

        for el in self.loc_uprooted.iter().copied() {
            let ts = self.pred_decl_node_loc.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.pred_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PredDeclNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(PredDeclNodeLocTable::WEIGHT);

                t.0 = self.root_pred_decl_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.pred_decl_node_loc.insert(t) {
                    let weight0 = &mut self.pred_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PredDeclNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(PredDeclNodeLocTable::WEIGHT);
                }
            }
        }
        for el in self.pred_decl_node_uprooted.iter().copied() {
            let ts = self
                .pred_decl_node_loc
                .drain_with_element_pred_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.pred_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PredDeclNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(PredDeclNodeLocTable::WEIGHT);

                t.0 = self.root_pred_decl_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.pred_decl_node_loc.insert(t) {
                    let weight0 = &mut self.pred_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PredDeclNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(PredDeclNodeLocTable::WEIGHT);
                }
            }
        }

        for el in self.func_decl_node_uprooted.iter().copied() {
            let ts = self
                .func_decl_node_loc
                .drain_with_element_func_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.func_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(FuncDeclNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(FuncDeclNodeLocTable::WEIGHT);

                t.0 = self.root_func_decl_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.func_decl_node_loc.insert(t) {
                    let weight0 = &mut self.func_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(FuncDeclNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(FuncDeclNodeLocTable::WEIGHT);
                }
            }
        }
        for el in self.loc_uprooted.iter().copied() {
            let ts = self.func_decl_node_loc.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.func_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(FuncDeclNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(FuncDeclNodeLocTable::WEIGHT);

                t.0 = self.root_func_decl_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.func_decl_node_loc.insert(t) {
                    let weight0 = &mut self.func_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(FuncDeclNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(FuncDeclNodeLocTable::WEIGHT);
                }
            }
        }

        for el in self.ctor_decl_node_uprooted.iter().copied() {
            let ts = self
                .ctor_decl_node_loc
                .drain_with_element_ctor_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.ctor_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CtorDeclNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CtorDeclNodeLocTable::WEIGHT);

                t.0 = self.root_ctor_decl_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.ctor_decl_node_loc.insert(t) {
                    let weight0 = &mut self.ctor_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CtorDeclNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CtorDeclNodeLocTable::WEIGHT);
                }
            }
        }
        for el in self.loc_uprooted.iter().copied() {
            let ts = self.ctor_decl_node_loc.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.ctor_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CtorDeclNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CtorDeclNodeLocTable::WEIGHT);

                t.0 = self.root_ctor_decl_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.ctor_decl_node_loc.insert(t) {
                    let weight0 = &mut self.ctor_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CtorDeclNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CtorDeclNodeLocTable::WEIGHT);
                }
            }
        }

        for el in self.enum_decl_node_uprooted.iter().copied() {
            let ts = self
                .enum_decl_node_loc
                .drain_with_element_enum_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.enum_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(EnumDeclNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(EnumDeclNodeLocTable::WEIGHT);

                t.0 = self.root_enum_decl_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.enum_decl_node_loc.insert(t) {
                    let weight0 = &mut self.enum_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(EnumDeclNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(EnumDeclNodeLocTable::WEIGHT);
                }
            }
        }
        for el in self.loc_uprooted.iter().copied() {
            let ts = self.enum_decl_node_loc.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.enum_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(EnumDeclNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(EnumDeclNodeLocTable::WEIGHT);

                t.0 = self.root_enum_decl_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.enum_decl_node_loc.insert(t) {
                    let weight0 = &mut self.enum_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(EnumDeclNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(EnumDeclNodeLocTable::WEIGHT);
                }
            }
        }

        for el in self.loc_uprooted.iter().copied() {
            let ts = self.term_node_loc.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(TermNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(TermNodeLocTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.term_node_loc.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(TermNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(TermNodeLocTable::WEIGHT);
                }
            }
        }
        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.term_node_loc.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(TermNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(TermNodeLocTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.term_node_loc.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(TermNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(TermNodeLocTable::WEIGHT);
                }
            }
        }

        for el in self.loc_uprooted.iter().copied() {
            let ts = self.term_list_node_loc.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(TermListNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(TermListNodeLocTable::WEIGHT);

                t.0 = self.root_term_list_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.term_list_node_loc.insert(t) {
                    let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(TermListNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(TermListNodeLocTable::WEIGHT);
                }
            }
        }
        for el in self.term_list_node_uprooted.iter().copied() {
            let ts = self
                .term_list_node_loc
                .drain_with_element_term_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(TermListNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(TermListNodeLocTable::WEIGHT);

                t.0 = self.root_term_list_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.term_list_node_loc.insert(t) {
                    let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(TermListNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(TermListNodeLocTable::WEIGHT);
                }
            }
        }

        for el in self.loc_uprooted.iter().copied() {
            let ts = self.match_case_node_loc.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchCaseNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchCaseNodeLocTable::WEIGHT);

                t.0 = self.root_match_case_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.match_case_node_loc.insert(t) {
                    let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchCaseNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchCaseNodeLocTable::WEIGHT);
                }
            }
        }
        for el in self.match_case_node_uprooted.iter().copied() {
            let ts = self
                .match_case_node_loc
                .drain_with_element_match_case_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchCaseNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchCaseNodeLocTable::WEIGHT);

                t.0 = self.root_match_case_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.match_case_node_loc.insert(t) {
                    let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchCaseNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchCaseNodeLocTable::WEIGHT);
                }
            }
        }

        for el in self.loc_uprooted.iter().copied() {
            let ts = self.opt_term_node_loc.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.opt_term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(OptTermNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(OptTermNodeLocTable::WEIGHT);

                t.0 = self.root_opt_term_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.opt_term_node_loc.insert(t) {
                    let weight0 = &mut self.opt_term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(OptTermNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(OptTermNodeLocTable::WEIGHT);
                }
            }
        }
        for el in self.opt_term_node_uprooted.iter().copied() {
            let ts = self.opt_term_node_loc.drain_with_element_opt_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.opt_term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(OptTermNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(OptTermNodeLocTable::WEIGHT);

                t.0 = self.root_opt_term_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.opt_term_node_loc.insert(t) {
                    let weight0 = &mut self.opt_term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(OptTermNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(OptTermNodeLocTable::WEIGHT);
                }
            }
        }

        for el in self.if_atom_node_uprooted.iter().copied() {
            let ts = self.if_atom_node_loc.drain_with_element_if_atom_node(el);
            for mut t in ts {
                let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(IfAtomNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(IfAtomNodeLocTable::WEIGHT);

                t.0 = self.root_if_atom_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.if_atom_node_loc.insert(t) {
                    let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(IfAtomNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(IfAtomNodeLocTable::WEIGHT);
                }
            }
        }
        for el in self.loc_uprooted.iter().copied() {
            let ts = self.if_atom_node_loc.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(IfAtomNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(IfAtomNodeLocTable::WEIGHT);

                t.0 = self.root_if_atom_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.if_atom_node_loc.insert(t) {
                    let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(IfAtomNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(IfAtomNodeLocTable::WEIGHT);
                }
            }
        }

        for el in self.loc_uprooted.iter().copied() {
            let ts = self.then_atom_node_loc.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ThenAtomNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ThenAtomNodeLocTable::WEIGHT);

                t.0 = self.root_then_atom_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.then_atom_node_loc.insert(t) {
                    let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ThenAtomNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ThenAtomNodeLocTable::WEIGHT);
                }
            }
        }
        for el in self.then_atom_node_uprooted.iter().copied() {
            let ts = self
                .then_atom_node_loc
                .drain_with_element_then_atom_node(el);
            for mut t in ts {
                let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ThenAtomNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ThenAtomNodeLocTable::WEIGHT);

                t.0 = self.root_then_atom_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.then_atom_node_loc.insert(t) {
                    let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ThenAtomNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ThenAtomNodeLocTable::WEIGHT);
                }
            }
        }

        for el in self.loc_uprooted.iter().copied() {
            let ts = self.stmt_node_loc.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(StmtNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(StmtNodeLocTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.stmt_node_loc.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(StmtNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(StmtNodeLocTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self.stmt_node_loc.drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(StmtNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(StmtNodeLocTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.stmt_node_loc.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(StmtNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(StmtNodeLocTable::WEIGHT);
                }
            }
        }

        for el in self.loc_uprooted.iter().copied() {
            let ts = self.stmt_list_node_loc.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(StmtListNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(StmtListNodeLocTable::WEIGHT);

                t.0 = self.root_stmt_list_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.stmt_list_node_loc.insert(t) {
                    let weight0 = &mut self.stmt_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(StmtListNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(StmtListNodeLocTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_list_node_uprooted.iter().copied() {
            let ts = self
                .stmt_list_node_loc
                .drain_with_element_stmt_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(StmtListNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(StmtListNodeLocTable::WEIGHT);

                t.0 = self.root_stmt_list_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.stmt_list_node_loc.insert(t) {
                    let weight0 = &mut self.stmt_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(StmtListNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(StmtListNodeLocTable::WEIGHT);
                }
            }
        }

        for el in self.loc_uprooted.iter().copied() {
            let ts = self.rule_decl_node_loc.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDeclNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDeclNodeLocTable::WEIGHT);

                t.0 = self.root_rule_decl_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.rule_decl_node_loc.insert(t) {
                    let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDeclNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDeclNodeLocTable::WEIGHT);
                }
            }
        }
        for el in self.rule_decl_node_uprooted.iter().copied() {
            let ts = self
                .rule_decl_node_loc
                .drain_with_element_rule_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDeclNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDeclNodeLocTable::WEIGHT);

                t.0 = self.root_rule_decl_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.rule_decl_node_loc.insert(t) {
                    let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDeclNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDeclNodeLocTable::WEIGHT);
                }
            }
        }

        for el in self.decl_node_uprooted.iter().copied() {
            let ts = self.decl_node_loc.drain_with_element_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DeclNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DeclNodeLocTable::WEIGHT);

                t.0 = self.root_decl_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.decl_node_loc.insert(t) {
                    let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DeclNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DeclNodeLocTable::WEIGHT);
                }
            }
        }
        for el in self.loc_uprooted.iter().copied() {
            let ts = self.decl_node_loc.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DeclNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DeclNodeLocTable::WEIGHT);

                t.0 = self.root_decl_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.decl_node_loc.insert(t) {
                    let weight0 = &mut self.decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DeclNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DeclNodeLocTable::WEIGHT);
                }
            }
        }

        for el in self.decl_list_node_uprooted.iter().copied() {
            let ts = self
                .decl_list_node_loc
                .drain_with_element_decl_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.decl_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DeclListNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DeclListNodeLocTable::WEIGHT);

                t.0 = self.root_decl_list_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.decl_list_node_loc.insert(t) {
                    let weight0 = &mut self.decl_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DeclListNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DeclListNodeLocTable::WEIGHT);
                }
            }
        }
        for el in self.loc_uprooted.iter().copied() {
            let ts = self.decl_list_node_loc.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.decl_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DeclListNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DeclListNodeLocTable::WEIGHT);

                t.0 = self.root_decl_list_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.decl_list_node_loc.insert(t) {
                    let weight0 = &mut self.decl_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DeclListNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DeclListNodeLocTable::WEIGHT);
                }
            }
        }

        for el in self.loc_uprooted.iter().copied() {
            let ts = self.module_node_loc.drain_with_element_loc(el);
            for mut t in ts {
                let weight0 = &mut self.module_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ModuleNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ModuleNodeLocTable::WEIGHT);

                t.0 = self.root_module_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.module_node_loc.insert(t) {
                    let weight0 = &mut self.module_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ModuleNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ModuleNodeLocTable::WEIGHT);
                }
            }
        }
        for el in self.module_node_uprooted.iter().copied() {
            let ts = self.module_node_loc.drain_with_element_module_node(el);
            for mut t in ts {
                let weight0 = &mut self.module_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ModuleNodeLocTable::WEIGHT);

                let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ModuleNodeLocTable::WEIGHT);

                t.0 = self.root_module_node(t.0);
                t.1 = self.root_loc(t.1);
                if self.module_node_loc.insert(t) {
                    let weight0 = &mut self.module_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ModuleNodeLocTable::WEIGHT);

                    let weight1 = &mut self.loc_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ModuleNodeLocTable::WEIGHT);
                }
            }
        }

        for el in self.rule_decl_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_rule
                .drain_with_element_rule_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantRuleTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantRuleTable::WEIGHT);

                t.0 = self.root_rule_decl_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_rule.insert(t) {
                    let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantRuleTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantRuleTable::WEIGHT);
                }
            }
        }
        for el in self.rule_descendant_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_rule
                .drain_with_element_rule_descendant_node(el);
            for mut t in ts {
                let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantRuleTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantRuleTable::WEIGHT);

                t.0 = self.root_rule_decl_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_rule.insert(t) {
                    let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantRuleTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantRuleTable::WEIGHT);
                }
            }
        }

        for el in self.rule_descendant_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_term
                .drain_with_element_rule_descendant_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantTermTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantTermTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_term.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantTermTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantTermTable::WEIGHT);
                }
            }
        }
        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.rule_descendant_term.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantTermTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantTermTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_term.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantTermTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantTermTable::WEIGHT);
                }
            }
        }

        for el in self.rule_descendant_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_term_list
                .drain_with_element_rule_descendant_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantTermListTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantTermListTable::WEIGHT);

                t.0 = self.root_term_list_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_term_list.insert(t) {
                    let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantTermListTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantTermListTable::WEIGHT);
                }
            }
        }
        for el in self.term_list_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_term_list
                .drain_with_element_term_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantTermListTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantTermListTable::WEIGHT);

                t.0 = self.root_term_list_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_term_list.insert(t) {
                    let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantTermListTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantTermListTable::WEIGHT);
                }
            }
        }

        for el in self.opt_term_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_opt_term
                .drain_with_element_opt_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.opt_term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantOptTermTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantOptTermTable::WEIGHT);

                t.0 = self.root_opt_term_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_opt_term.insert(t) {
                    let weight0 = &mut self.opt_term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantOptTermTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantOptTermTable::WEIGHT);
                }
            }
        }
        for el in self.rule_descendant_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_opt_term
                .drain_with_element_rule_descendant_node(el);
            for mut t in ts {
                let weight0 = &mut self.opt_term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantOptTermTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantOptTermTable::WEIGHT);

                t.0 = self.root_opt_term_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_opt_term.insert(t) {
                    let weight0 = &mut self.opt_term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantOptTermTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantOptTermTable::WEIGHT);
                }
            }
        }

        for el in self.if_atom_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_if_atom
                .drain_with_element_if_atom_node(el);
            for mut t in ts {
                let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantIfAtomTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantIfAtomTable::WEIGHT);

                t.0 = self.root_if_atom_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_if_atom.insert(t) {
                    let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantIfAtomTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantIfAtomTable::WEIGHT);
                }
            }
        }
        for el in self.rule_descendant_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_if_atom
                .drain_with_element_rule_descendant_node(el);
            for mut t in ts {
                let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantIfAtomTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantIfAtomTable::WEIGHT);

                t.0 = self.root_if_atom_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_if_atom.insert(t) {
                    let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantIfAtomTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantIfAtomTable::WEIGHT);
                }
            }
        }

        for el in self.rule_descendant_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_then_atom
                .drain_with_element_rule_descendant_node(el);
            for mut t in ts {
                let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantThenAtomTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantThenAtomTable::WEIGHT);

                t.0 = self.root_then_atom_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_then_atom.insert(t) {
                    let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantThenAtomTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantThenAtomTable::WEIGHT);
                }
            }
        }
        for el in self.then_atom_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_then_atom
                .drain_with_element_then_atom_node(el);
            for mut t in ts {
                let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantThenAtomTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantThenAtomTable::WEIGHT);

                t.0 = self.root_then_atom_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_then_atom.insert(t) {
                    let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantThenAtomTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantThenAtomTable::WEIGHT);
                }
            }
        }

        for el in self.match_case_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_match_case
                .drain_with_element_match_case_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantMatchCaseTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantMatchCaseTable::WEIGHT);

                t.0 = self.root_match_case_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_match_case.insert(t) {
                    let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantMatchCaseTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantMatchCaseTable::WEIGHT);
                }
            }
        }
        for el in self.rule_descendant_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_match_case
                .drain_with_element_rule_descendant_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantMatchCaseTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantMatchCaseTable::WEIGHT);

                t.0 = self.root_match_case_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_match_case.insert(t) {
                    let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantMatchCaseTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantMatchCaseTable::WEIGHT);
                }
            }
        }

        for el in self.match_case_list_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_match_case_list
                .drain_with_element_match_case_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantMatchCaseListTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantMatchCaseListTable::WEIGHT);

                t.0 = self.root_match_case_list_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_match_case_list.insert(t) {
                    let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantMatchCaseListTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantMatchCaseListTable::WEIGHT);
                }
            }
        }
        for el in self.rule_descendant_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_match_case_list
                .drain_with_element_rule_descendant_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantMatchCaseListTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantMatchCaseListTable::WEIGHT);

                t.0 = self.root_match_case_list_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_match_case_list.insert(t) {
                    let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantMatchCaseListTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantMatchCaseListTable::WEIGHT);
                }
            }
        }

        for el in self.rule_descendant_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_stmt
                .drain_with_element_rule_descendant_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantStmtTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantStmtTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_stmt.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantStmtTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantStmtTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self.rule_descendant_stmt.drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantStmtTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantStmtTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_stmt.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantStmtTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantStmtTable::WEIGHT);
                }
            }
        }

        for el in self.rule_descendant_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_stmt_list
                .drain_with_element_rule_descendant_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantStmtListTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantStmtListTable::WEIGHT);

                t.0 = self.root_stmt_list_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_stmt_list.insert(t) {
                    let weight0 = &mut self.stmt_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantStmtListTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantStmtListTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_list_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_stmt_list
                .drain_with_element_stmt_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantStmtListTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantStmtListTable::WEIGHT);

                t.0 = self.root_stmt_list_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_stmt_list.insert(t) {
                    let weight0 = &mut self.stmt_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantStmtListTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantStmtListTable::WEIGHT);
                }
            }
        }

        for el in self.rule_descendant_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_stmt_block_list
                .drain_with_element_rule_descendant_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_block_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantStmtBlockListTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantStmtBlockListTable::WEIGHT);

                t.0 = self.root_stmt_block_list_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_stmt_block_list.insert(t) {
                    let weight0 = &mut self.stmt_block_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantStmtBlockListTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantStmtBlockListTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_block_list_node_uprooted.iter().copied() {
            let ts = self
                .rule_descendant_stmt_block_list
                .drain_with_element_stmt_block_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_block_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleDescendantStmtBlockListTable::WEIGHT);

                let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(RuleDescendantStmtBlockListTable::WEIGHT);

                t.0 = self.root_stmt_block_list_node(t.0);
                t.1 = self.root_rule_descendant_node(t.1);
                if self.rule_descendant_stmt_block_list.insert(t) {
                    let weight0 = &mut self.stmt_block_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleDescendantStmtBlockListTable::WEIGHT);

                    let weight1 = &mut self.rule_descendant_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(RuleDescendantStmtBlockListTable::WEIGHT);
                }
            }
        }

        for el in self.rule_descendant_node_uprooted.iter().copied() {
            let ts = self.entry_scope.drain_with_element_rule_descendant_node(el);
            for mut t in ts {
                let weight0 = &mut self.rule_descendant_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(EntryScopeTable::WEIGHT);

                let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(EntryScopeTable::WEIGHT);

                t.0 = self.root_rule_descendant_node(t.0);
                t.1 = self.root_scope(t.1);
                if self.entry_scope.insert(t) {
                    let weight0 = &mut self.rule_descendant_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(EntryScopeTable::WEIGHT);

                    let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(EntryScopeTable::WEIGHT);
                }
            }
        }
        for el in self.scope_uprooted.iter().copied() {
            let ts = self.entry_scope.drain_with_element_scope(el);
            for mut t in ts {
                let weight0 = &mut self.rule_descendant_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(EntryScopeTable::WEIGHT);

                let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(EntryScopeTable::WEIGHT);

                t.0 = self.root_rule_descendant_node(t.0);
                t.1 = self.root_scope(t.1);
                if self.entry_scope.insert(t) {
                    let weight0 = &mut self.rule_descendant_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(EntryScopeTable::WEIGHT);

                    let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(EntryScopeTable::WEIGHT);
                }
            }
        }

        for el in self.rule_descendant_node_uprooted.iter().copied() {
            let ts = self.exit_scope.drain_with_element_rule_descendant_node(el);
            for mut t in ts {
                let weight0 = &mut self.rule_descendant_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ExitScopeTable::WEIGHT);

                let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ExitScopeTable::WEIGHT);

                t.0 = self.root_rule_descendant_node(t.0);
                t.1 = self.root_scope(t.1);
                if self.exit_scope.insert(t) {
                    let weight0 = &mut self.rule_descendant_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ExitScopeTable::WEIGHT);

                    let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ExitScopeTable::WEIGHT);
                }
            }
        }
        for el in self.scope_uprooted.iter().copied() {
            let ts = self.exit_scope.drain_with_element_scope(el);
            for mut t in ts {
                let weight0 = &mut self.rule_descendant_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ExitScopeTable::WEIGHT);

                let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ExitScopeTable::WEIGHT);

                t.0 = self.root_rule_descendant_node(t.0);
                t.1 = self.root_scope(t.1);
                if self.exit_scope.insert(t) {
                    let weight0 = &mut self.rule_descendant_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ExitScopeTable::WEIGHT);

                    let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ExitScopeTable::WEIGHT);
                }
            }
        }

        for el in self.ctor_decl_node_uprooted.iter().copied() {
            let ts = self.ctor_enum.drain_with_element_ctor_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.ctor_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CtorEnumTable::WEIGHT);

                let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CtorEnumTable::WEIGHT);

                t.0 = self.root_ctor_decl_node(t.0);
                t.1 = self.root_enum_decl_node(t.1);
                if self.ctor_enum.insert(t) {
                    let weight0 = &mut self.ctor_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CtorEnumTable::WEIGHT);

                    let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CtorEnumTable::WEIGHT);
                }
            }
        }
        for el in self.enum_decl_node_uprooted.iter().copied() {
            let ts = self.ctor_enum.drain_with_element_enum_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.ctor_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CtorEnumTable::WEIGHT);

                let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CtorEnumTable::WEIGHT);

                t.0 = self.root_ctor_decl_node(t.0);
                t.1 = self.root_enum_decl_node(t.1);
                if self.ctor_enum.insert(t) {
                    let weight0 = &mut self.ctor_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CtorEnumTable::WEIGHT);

                    let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CtorEnumTable::WEIGHT);
                }
            }
        }

        for el in self.ctor_decl_list_node_uprooted.iter().copied() {
            let ts = self.ctors_enum.drain_with_element_ctor_decl_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.ctor_decl_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CtorsEnumTable::WEIGHT);

                let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CtorsEnumTable::WEIGHT);

                t.0 = self.root_ctor_decl_list_node(t.0);
                t.1 = self.root_enum_decl_node(t.1);
                if self.ctors_enum.insert(t) {
                    let weight0 = &mut self.ctor_decl_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CtorsEnumTable::WEIGHT);

                    let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CtorsEnumTable::WEIGHT);
                }
            }
        }
        for el in self.enum_decl_node_uprooted.iter().copied() {
            let ts = self.ctors_enum.drain_with_element_enum_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.ctor_decl_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CtorsEnumTable::WEIGHT);

                let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CtorsEnumTable::WEIGHT);

                t.0 = self.root_ctor_decl_list_node(t.0);
                t.1 = self.root_enum_decl_node(t.1);
                if self.ctors_enum.insert(t) {
                    let weight0 = &mut self.ctor_decl_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CtorsEnumTable::WEIGHT);

                    let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CtorsEnumTable::WEIGHT);
                }
            }
        }

        for el in self.match_case_list_node_uprooted.iter().copied() {
            let ts = self
                .cases_discriminee
                .drain_with_element_match_case_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CasesDiscrimineeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CasesDiscrimineeTable::WEIGHT);

                t.0 = self.root_match_case_list_node(t.0);
                t.1 = self.root_term_node(t.1);
                if self.cases_discriminee.insert(t) {
                    let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CasesDiscrimineeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CasesDiscrimineeTable::WEIGHT);
                }
            }
        }
        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.cases_discriminee.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CasesDiscrimineeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CasesDiscrimineeTable::WEIGHT);

                t.0 = self.root_match_case_list_node(t.0);
                t.1 = self.root_term_node(t.1);
                if self.cases_discriminee.insert(t) {
                    let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CasesDiscrimineeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CasesDiscrimineeTable::WEIGHT);
                }
            }
        }

        for el in self.match_case_node_uprooted.iter().copied() {
            let ts = self.case_discriminee.drain_with_element_match_case_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CaseDiscrimineeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CaseDiscrimineeTable::WEIGHT);

                t.0 = self.root_match_case_node(t.0);
                t.1 = self.root_term_node(t.1);
                if self.case_discriminee.insert(t) {
                    let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CaseDiscrimineeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CaseDiscrimineeTable::WEIGHT);
                }
            }
        }
        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.case_discriminee.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CaseDiscrimineeTable::WEIGHT);

                let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CaseDiscrimineeTable::WEIGHT);

                t.0 = self.root_match_case_node(t.0);
                t.1 = self.root_term_node(t.1);
                if self.case_discriminee.insert(t) {
                    let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CaseDiscrimineeTable::WEIGHT);

                    let weight1 = &mut self.term_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CaseDiscrimineeTable::WEIGHT);
                }
            }
        }

        for el in self.if_atom_node_uprooted.iter().copied() {
            let ts = self
                .desugared_case_equality_atom
                .drain_with_element_if_atom_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DesugaredCaseEqualityAtomTable::WEIGHT);

                let weight1 = &mut self.if_atom_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DesugaredCaseEqualityAtomTable::WEIGHT);

                t.0 = self.root_match_case_node(t.0);
                t.1 = self.root_if_atom_node(t.1);
                if self.desugared_case_equality_atom.insert(t) {
                    let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DesugaredCaseEqualityAtomTable::WEIGHT);

                    let weight1 = &mut self.if_atom_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DesugaredCaseEqualityAtomTable::WEIGHT);
                }
            }
        }
        for el in self.match_case_node_uprooted.iter().copied() {
            let ts = self
                .desugared_case_equality_atom
                .drain_with_element_match_case_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DesugaredCaseEqualityAtomTable::WEIGHT);

                let weight1 = &mut self.if_atom_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DesugaredCaseEqualityAtomTable::WEIGHT);

                t.0 = self.root_match_case_node(t.0);
                t.1 = self.root_if_atom_node(t.1);
                if self.desugared_case_equality_atom.insert(t) {
                    let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DesugaredCaseEqualityAtomTable::WEIGHT);

                    let weight1 = &mut self.if_atom_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DesugaredCaseEqualityAtomTable::WEIGHT);
                }
            }
        }

        for el in self.match_case_node_uprooted.iter().copied() {
            let ts = self
                .desugared_case_equality_stmt
                .drain_with_element_match_case_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DesugaredCaseEqualityStmtTable::WEIGHT);

                let weight1 = &mut self.stmt_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DesugaredCaseEqualityStmtTable::WEIGHT);

                t.0 = self.root_match_case_node(t.0);
                t.1 = self.root_stmt_node(t.1);
                if self.desugared_case_equality_stmt.insert(t) {
                    let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DesugaredCaseEqualityStmtTable::WEIGHT);

                    let weight1 = &mut self.stmt_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DesugaredCaseEqualityStmtTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self
                .desugared_case_equality_stmt
                .drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DesugaredCaseEqualityStmtTable::WEIGHT);

                let weight1 = &mut self.stmt_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DesugaredCaseEqualityStmtTable::WEIGHT);

                t.0 = self.root_match_case_node(t.0);
                t.1 = self.root_stmt_node(t.1);
                if self.desugared_case_equality_stmt.insert(t) {
                    let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DesugaredCaseEqualityStmtTable::WEIGHT);

                    let weight1 = &mut self.stmt_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DesugaredCaseEqualityStmtTable::WEIGHT);
                }
            }
        }

        for el in self.match_case_node_uprooted.iter().copied() {
            let ts = self
                .desugared_case_block
                .drain_with_element_match_case_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DesugaredCaseBlockTable::WEIGHT);

                let weight1 = &mut self.stmt_list_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DesugaredCaseBlockTable::WEIGHT);

                t.0 = self.root_match_case_node(t.0);
                t.1 = self.root_stmt_list_node(t.1);
                if self.desugared_case_block.insert(t) {
                    let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DesugaredCaseBlockTable::WEIGHT);

                    let weight1 = &mut self.stmt_list_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DesugaredCaseBlockTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_list_node_uprooted.iter().copied() {
            let ts = self
                .desugared_case_block
                .drain_with_element_stmt_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DesugaredCaseBlockTable::WEIGHT);

                let weight1 = &mut self.stmt_list_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DesugaredCaseBlockTable::WEIGHT);

                t.0 = self.root_match_case_node(t.0);
                t.1 = self.root_stmt_list_node(t.1);
                if self.desugared_case_block.insert(t) {
                    let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DesugaredCaseBlockTable::WEIGHT);

                    let weight1 = &mut self.stmt_list_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DesugaredCaseBlockTable::WEIGHT);
                }
            }
        }

        for el in self.match_case_list_node_uprooted.iter().copied() {
            let ts = self
                .desugared_case_block_list
                .drain_with_element_match_case_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DesugaredCaseBlockListTable::WEIGHT);

                let weight1 = &mut self.stmt_block_list_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DesugaredCaseBlockListTable::WEIGHT);

                t.0 = self.root_match_case_list_node(t.0);
                t.1 = self.root_stmt_block_list_node(t.1);
                if self.desugared_case_block_list.insert(t) {
                    let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DesugaredCaseBlockListTable::WEIGHT);

                    let weight1 = &mut self.stmt_block_list_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DesugaredCaseBlockListTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_block_list_node_uprooted.iter().copied() {
            let ts = self
                .desugared_case_block_list
                .drain_with_element_stmt_block_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DesugaredCaseBlockListTable::WEIGHT);

                let weight1 = &mut self.stmt_block_list_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DesugaredCaseBlockListTable::WEIGHT);

                t.0 = self.root_match_case_list_node(t.0);
                t.1 = self.root_stmt_block_list_node(t.1);
                if self.desugared_case_block_list.insert(t) {
                    let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DesugaredCaseBlockListTable::WEIGHT);

                    let weight1 = &mut self.stmt_block_list_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DesugaredCaseBlockListTable::WEIGHT);
                }
            }
        }

        for el in self.type_list_uprooted.iter().copied() {
            let ts = self.nil_type_list.drain_with_element_type_list(el);
            for mut t in ts {
                let weight0 = &mut self.type_list_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(NilTypeListTable::WEIGHT);

                t.0 = self.root_type_list(t.0);
                if self.nil_type_list.insert(t) {
                    let weight0 = &mut self.type_list_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(NilTypeListTable::WEIGHT);
                }
            }
        }

        for el in self.type_uprooted.iter().copied() {
            let ts = self.cons_type_list.drain_with_element_type(el);
            for mut t in ts {
                let weight0 = &mut self.type_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConsTypeListTable::WEIGHT);

                let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ConsTypeListTable::WEIGHT);

                let weight2 = &mut self.type_list_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ConsTypeListTable::WEIGHT);

                t.0 = self.root_type(t.0);
                t.1 = self.root_type_list(t.1);
                t.2 = self.root_type_list(t.2);
                if self.cons_type_list.insert(t) {
                    let weight0 = &mut self.type_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConsTypeListTable::WEIGHT);

                    let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ConsTypeListTable::WEIGHT);

                    let weight2 = &mut self.type_list_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ConsTypeListTable::WEIGHT);
                }
            }
        }
        for el in self.type_list_uprooted.iter().copied() {
            let ts = self.cons_type_list.drain_with_element_type_list(el);
            for mut t in ts {
                let weight0 = &mut self.type_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConsTypeListTable::WEIGHT);

                let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ConsTypeListTable::WEIGHT);

                let weight2 = &mut self.type_list_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ConsTypeListTable::WEIGHT);

                t.0 = self.root_type(t.0);
                t.1 = self.root_type_list(t.1);
                t.2 = self.root_type_list(t.2);
                if self.cons_type_list.insert(t) {
                    let weight0 = &mut self.type_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConsTypeListTable::WEIGHT);

                    let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ConsTypeListTable::WEIGHT);

                    let weight2 = &mut self.type_list_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ConsTypeListTable::WEIGHT);
                }
            }
        }

        for el in self.type_uprooted.iter().copied() {
            let ts = self.snoc_type_list.drain_with_element_type(el);
            for mut t in ts {
                let weight0 = &mut self.type_list_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SnocTypeListTable::WEIGHT);

                let weight1 = &mut self.type_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SnocTypeListTable::WEIGHT);

                let weight2 = &mut self.type_list_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(SnocTypeListTable::WEIGHT);

                t.0 = self.root_type_list(t.0);
                t.1 = self.root_type(t.1);
                t.2 = self.root_type_list(t.2);
                if self.snoc_type_list.insert(t) {
                    let weight0 = &mut self.type_list_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SnocTypeListTable::WEIGHT);

                    let weight1 = &mut self.type_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SnocTypeListTable::WEIGHT);

                    let weight2 = &mut self.type_list_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(SnocTypeListTable::WEIGHT);
                }
            }
        }
        for el in self.type_list_uprooted.iter().copied() {
            let ts = self.snoc_type_list.drain_with_element_type_list(el);
            for mut t in ts {
                let weight0 = &mut self.type_list_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SnocTypeListTable::WEIGHT);

                let weight1 = &mut self.type_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SnocTypeListTable::WEIGHT);

                let weight2 = &mut self.type_list_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(SnocTypeListTable::WEIGHT);

                t.0 = self.root_type_list(t.0);
                t.1 = self.root_type(t.1);
                t.2 = self.root_type_list(t.2);
                if self.snoc_type_list.insert(t) {
                    let weight0 = &mut self.type_list_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SnocTypeListTable::WEIGHT);

                    let weight1 = &mut self.type_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SnocTypeListTable::WEIGHT);

                    let weight2 = &mut self.type_list_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(SnocTypeListTable::WEIGHT);
                }
            }
        }

        for el in self.ident_uprooted.iter().copied() {
            let ts = self.semantic_type.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SemanticTypeTable::WEIGHT);

                let weight1 = &mut self.type_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SemanticTypeTable::WEIGHT);

                t.0 = self.root_ident(t.0);
                t.1 = self.root_type(t.1);
                if self.semantic_type.insert(t) {
                    let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SemanticTypeTable::WEIGHT);

                    let weight1 = &mut self.type_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SemanticTypeTable::WEIGHT);
                }
            }
        }
        for el in self.type_uprooted.iter().copied() {
            let ts = self.semantic_type.drain_with_element_type(el);
            for mut t in ts {
                let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SemanticTypeTable::WEIGHT);

                let weight1 = &mut self.type_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SemanticTypeTable::WEIGHT);

                t.0 = self.root_ident(t.0);
                t.1 = self.root_type(t.1);
                if self.semantic_type.insert(t) {
                    let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SemanticTypeTable::WEIGHT);

                    let weight1 = &mut self.type_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SemanticTypeTable::WEIGHT);
                }
            }
        }

        for el in self.arg_decl_list_node_uprooted.iter().copied() {
            let ts = self
                .semantic_arg_types
                .drain_with_element_arg_decl_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.arg_decl_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SemanticArgTypesTable::WEIGHT);

                let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SemanticArgTypesTable::WEIGHT);

                t.0 = self.root_arg_decl_list_node(t.0);
                t.1 = self.root_type_list(t.1);
                if self.semantic_arg_types.insert(t) {
                    let weight0 = &mut self.arg_decl_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SemanticArgTypesTable::WEIGHT);

                    let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SemanticArgTypesTable::WEIGHT);
                }
            }
        }
        for el in self.type_list_uprooted.iter().copied() {
            let ts = self.semantic_arg_types.drain_with_element_type_list(el);
            for mut t in ts {
                let weight0 = &mut self.arg_decl_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SemanticArgTypesTable::WEIGHT);

                let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SemanticArgTypesTable::WEIGHT);

                t.0 = self.root_arg_decl_list_node(t.0);
                t.1 = self.root_type_list(t.1);
                if self.semantic_arg_types.insert(t) {
                    let weight0 = &mut self.arg_decl_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SemanticArgTypesTable::WEIGHT);

                    let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SemanticArgTypesTable::WEIGHT);
                }
            }
        }

        for el in self.ident_uprooted.iter().copied() {
            let ts = self.semantic_pred.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SemanticPredTable::WEIGHT);

                let weight1 = &mut self.pred_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SemanticPredTable::WEIGHT);

                t.0 = self.root_ident(t.0);
                t.1 = self.root_pred(t.1);
                if self.semantic_pred.insert(t) {
                    let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SemanticPredTable::WEIGHT);

                    let weight1 = &mut self.pred_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SemanticPredTable::WEIGHT);
                }
            }
        }
        for el in self.pred_uprooted.iter().copied() {
            let ts = self.semantic_pred.drain_with_element_pred(el);
            for mut t in ts {
                let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SemanticPredTable::WEIGHT);

                let weight1 = &mut self.pred_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SemanticPredTable::WEIGHT);

                t.0 = self.root_ident(t.0);
                t.1 = self.root_pred(t.1);
                if self.semantic_pred.insert(t) {
                    let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SemanticPredTable::WEIGHT);

                    let weight1 = &mut self.pred_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SemanticPredTable::WEIGHT);
                }
            }
        }

        for el in self.pred_uprooted.iter().copied() {
            let ts = self.pred_arity.drain_with_element_pred(el);
            for mut t in ts {
                let weight0 = &mut self.pred_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PredArityTable::WEIGHT);

                let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(PredArityTable::WEIGHT);

                t.0 = self.root_pred(t.0);
                t.1 = self.root_type_list(t.1);
                if self.pred_arity.insert(t) {
                    let weight0 = &mut self.pred_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PredArityTable::WEIGHT);

                    let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(PredArityTable::WEIGHT);
                }
            }
        }
        for el in self.type_list_uprooted.iter().copied() {
            let ts = self.pred_arity.drain_with_element_type_list(el);
            for mut t in ts {
                let weight0 = &mut self.pred_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PredArityTable::WEIGHT);

                let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(PredArityTable::WEIGHT);

                t.0 = self.root_pred(t.0);
                t.1 = self.root_type_list(t.1);
                if self.pred_arity.insert(t) {
                    let weight0 = &mut self.pred_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PredArityTable::WEIGHT);

                    let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(PredArityTable::WEIGHT);
                }
            }
        }

        for el in self.func_uprooted.iter().copied() {
            let ts = self.semantic_func.drain_with_element_func(el);
            for mut t in ts {
                let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SemanticFuncTable::WEIGHT);

                let weight1 = &mut self.func_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SemanticFuncTable::WEIGHT);

                t.0 = self.root_ident(t.0);
                t.1 = self.root_func(t.1);
                if self.semantic_func.insert(t) {
                    let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SemanticFuncTable::WEIGHT);

                    let weight1 = &mut self.func_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SemanticFuncTable::WEIGHT);
                }
            }
        }
        for el in self.ident_uprooted.iter().copied() {
            let ts = self.semantic_func.drain_with_element_ident(el);
            for mut t in ts {
                let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SemanticFuncTable::WEIGHT);

                let weight1 = &mut self.func_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SemanticFuncTable::WEIGHT);

                t.0 = self.root_ident(t.0);
                t.1 = self.root_func(t.1);
                if self.semantic_func.insert(t) {
                    let weight0 = &mut self.ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SemanticFuncTable::WEIGHT);

                    let weight1 = &mut self.func_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SemanticFuncTable::WEIGHT);
                }
            }
        }

        for el in self.func_uprooted.iter().copied() {
            let ts = self.domain.drain_with_element_func(el);
            for mut t in ts {
                let weight0 = &mut self.func_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DomainTable::WEIGHT);

                let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DomainTable::WEIGHT);

                t.0 = self.root_func(t.0);
                t.1 = self.root_type_list(t.1);
                if self.domain.insert(t) {
                    let weight0 = &mut self.func_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DomainTable::WEIGHT);

                    let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DomainTable::WEIGHT);
                }
            }
        }
        for el in self.type_list_uprooted.iter().copied() {
            let ts = self.domain.drain_with_element_type_list(el);
            for mut t in ts {
                let weight0 = &mut self.func_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DomainTable::WEIGHT);

                let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DomainTable::WEIGHT);

                t.0 = self.root_func(t.0);
                t.1 = self.root_type_list(t.1);
                if self.domain.insert(t) {
                    let weight0 = &mut self.func_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DomainTable::WEIGHT);

                    let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DomainTable::WEIGHT);
                }
            }
        }

        for el in self.func_uprooted.iter().copied() {
            let ts = self.codomain.drain_with_element_func(el);
            for mut t in ts {
                let weight0 = &mut self.func_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CodomainTable::WEIGHT);

                let weight1 = &mut self.type_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CodomainTable::WEIGHT);

                t.0 = self.root_func(t.0);
                t.1 = self.root_type(t.1);
                if self.codomain.insert(t) {
                    let weight0 = &mut self.func_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CodomainTable::WEIGHT);

                    let weight1 = &mut self.type_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CodomainTable::WEIGHT);
                }
            }
        }
        for el in self.type_uprooted.iter().copied() {
            let ts = self.codomain.drain_with_element_type(el);
            for mut t in ts {
                let weight0 = &mut self.func_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CodomainTable::WEIGHT);

                let weight1 = &mut self.type_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CodomainTable::WEIGHT);

                t.0 = self.root_func(t.0);
                t.1 = self.root_type(t.1);
                if self.codomain.insert(t) {
                    let weight0 = &mut self.func_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CodomainTable::WEIGHT);

                    let weight1 = &mut self.type_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CodomainTable::WEIGHT);
                }
            }
        }

        for el in self.pred_uprooted.iter().copied() {
            let ts = self.pred_rel.drain_with_element_pred(el);
            for mut t in ts {
                let weight0 = &mut self.pred_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PredRelTable::WEIGHT);

                let weight1 = &mut self.rel_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(PredRelTable::WEIGHT);

                t.0 = self.root_pred(t.0);
                t.1 = self.root_rel(t.1);
                if self.pred_rel.insert(t) {
                    let weight0 = &mut self.pred_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PredRelTable::WEIGHT);

                    let weight1 = &mut self.rel_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(PredRelTable::WEIGHT);
                }
            }
        }
        for el in self.rel_uprooted.iter().copied() {
            let ts = self.pred_rel.drain_with_element_rel(el);
            for mut t in ts {
                let weight0 = &mut self.pred_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PredRelTable::WEIGHT);

                let weight1 = &mut self.rel_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(PredRelTable::WEIGHT);

                t.0 = self.root_pred(t.0);
                t.1 = self.root_rel(t.1);
                if self.pred_rel.insert(t) {
                    let weight0 = &mut self.pred_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PredRelTable::WEIGHT);

                    let weight1 = &mut self.rel_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(PredRelTable::WEIGHT);
                }
            }
        }

        for el in self.func_uprooted.iter().copied() {
            let ts = self.func_rel.drain_with_element_func(el);
            for mut t in ts {
                let weight0 = &mut self.func_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(FuncRelTable::WEIGHT);

                let weight1 = &mut self.rel_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(FuncRelTable::WEIGHT);

                t.0 = self.root_func(t.0);
                t.1 = self.root_rel(t.1);
                if self.func_rel.insert(t) {
                    let weight0 = &mut self.func_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(FuncRelTable::WEIGHT);

                    let weight1 = &mut self.rel_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(FuncRelTable::WEIGHT);
                }
            }
        }
        for el in self.rel_uprooted.iter().copied() {
            let ts = self.func_rel.drain_with_element_rel(el);
            for mut t in ts {
                let weight0 = &mut self.func_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(FuncRelTable::WEIGHT);

                let weight1 = &mut self.rel_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(FuncRelTable::WEIGHT);

                t.0 = self.root_func(t.0);
                t.1 = self.root_rel(t.1);
                if self.func_rel.insert(t) {
                    let weight0 = &mut self.func_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(FuncRelTable::WEIGHT);

                    let weight1 = &mut self.rel_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(FuncRelTable::WEIGHT);
                }
            }
        }

        for el in self.rel_uprooted.iter().copied() {
            let ts = self.arity.drain_with_element_rel(el);
            for mut t in ts {
                let weight0 = &mut self.rel_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ArityTable::WEIGHT);

                let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ArityTable::WEIGHT);

                t.0 = self.root_rel(t.0);
                t.1 = self.root_type_list(t.1);
                if self.arity.insert(t) {
                    let weight0 = &mut self.rel_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ArityTable::WEIGHT);

                    let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ArityTable::WEIGHT);
                }
            }
        }
        for el in self.type_list_uprooted.iter().copied() {
            let ts = self.arity.drain_with_element_type_list(el);
            for mut t in ts {
                let weight0 = &mut self.rel_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ArityTable::WEIGHT);

                let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ArityTable::WEIGHT);

                t.0 = self.root_rel(t.0);
                t.1 = self.root_type_list(t.1);
                if self.arity.insert(t) {
                    let weight0 = &mut self.rel_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ArityTable::WEIGHT);

                    let weight1 = &mut self.type_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ArityTable::WEIGHT);
                }
            }
        }

        for el in self.morphism_uprooted.iter().copied() {
            let ts = self.dom.drain_with_element_morphism(el);
            for mut t in ts {
                let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DomTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DomTable::WEIGHT);

                t.0 = self.root_morphism(t.0);
                t.1 = self.root_structure(t.1);
                if self.dom.insert(t) {
                    let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DomTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DomTable::WEIGHT);
                }
            }
        }
        for el in self.structure_uprooted.iter().copied() {
            let ts = self.dom.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(DomTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(DomTable::WEIGHT);

                t.0 = self.root_morphism(t.0);
                t.1 = self.root_structure(t.1);
                if self.dom.insert(t) {
                    let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(DomTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(DomTable::WEIGHT);
                }
            }
        }

        for el in self.morphism_uprooted.iter().copied() {
            let ts = self.cod.drain_with_element_morphism(el);
            for mut t in ts {
                let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CodTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CodTable::WEIGHT);

                t.0 = self.root_morphism(t.0);
                t.1 = self.root_structure(t.1);
                if self.cod.insert(t) {
                    let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CodTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CodTable::WEIGHT);
                }
            }
        }
        for el in self.structure_uprooted.iter().copied() {
            let ts = self.cod.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CodTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CodTable::WEIGHT);

                t.0 = self.root_morphism(t.0);
                t.1 = self.root_structure(t.1);
                if self.cod.insert(t) {
                    let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CodTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CodTable::WEIGHT);
                }
            }
        }

        for el in self.el_list_uprooted.iter().copied() {
            let ts = self.nil_el_list.drain_with_element_el_list(el);
            for mut t in ts {
                let weight0 = &mut self.structure_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(NilElListTable::WEIGHT);

                let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(NilElListTable::WEIGHT);

                t.0 = self.root_structure(t.0);
                t.1 = self.root_el_list(t.1);
                if self.nil_el_list.insert(t) {
                    let weight0 = &mut self.structure_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(NilElListTable::WEIGHT);

                    let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(NilElListTable::WEIGHT);
                }
            }
        }
        for el in self.structure_uprooted.iter().copied() {
            let ts = self.nil_el_list.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.structure_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(NilElListTable::WEIGHT);

                let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(NilElListTable::WEIGHT);

                t.0 = self.root_structure(t.0);
                t.1 = self.root_el_list(t.1);
                if self.nil_el_list.insert(t) {
                    let weight0 = &mut self.structure_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(NilElListTable::WEIGHT);

                    let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(NilElListTable::WEIGHT);
                }
            }
        }

        for el in self.el_uprooted.iter().copied() {
            let ts = self.cons_el_list.drain_with_element_el(el);
            for mut t in ts {
                let weight0 = &mut self.el_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConsElListTable::WEIGHT);

                let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ConsElListTable::WEIGHT);

                let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ConsElListTable::WEIGHT);

                t.0 = self.root_el(t.0);
                t.1 = self.root_el_list(t.1);
                t.2 = self.root_el_list(t.2);
                if self.cons_el_list.insert(t) {
                    let weight0 = &mut self.el_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConsElListTable::WEIGHT);

                    let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ConsElListTable::WEIGHT);

                    let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ConsElListTable::WEIGHT);
                }
            }
        }
        for el in self.el_list_uprooted.iter().copied() {
            let ts = self.cons_el_list.drain_with_element_el_list(el);
            for mut t in ts {
                let weight0 = &mut self.el_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ConsElListTable::WEIGHT);

                let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ConsElListTable::WEIGHT);

                let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ConsElListTable::WEIGHT);

                t.0 = self.root_el(t.0);
                t.1 = self.root_el_list(t.1);
                t.2 = self.root_el_list(t.2);
                if self.cons_el_list.insert(t) {
                    let weight0 = &mut self.el_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ConsElListTable::WEIGHT);

                    let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ConsElListTable::WEIGHT);

                    let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ConsElListTable::WEIGHT);
                }
            }
        }

        for el in self.el_uprooted.iter().copied() {
            let ts = self.snoc_el_list.drain_with_element_el(el);
            for mut t in ts {
                let weight0 = &mut self.el_list_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SnocElListTable::WEIGHT);

                let weight1 = &mut self.el_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SnocElListTable::WEIGHT);

                let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(SnocElListTable::WEIGHT);

                t.0 = self.root_el_list(t.0);
                t.1 = self.root_el(t.1);
                t.2 = self.root_el_list(t.2);
                if self.snoc_el_list.insert(t) {
                    let weight0 = &mut self.el_list_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SnocElListTable::WEIGHT);

                    let weight1 = &mut self.el_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SnocElListTable::WEIGHT);

                    let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(SnocElListTable::WEIGHT);
                }
            }
        }
        for el in self.el_list_uprooted.iter().copied() {
            let ts = self.snoc_el_list.drain_with_element_el_list(el);
            for mut t in ts {
                let weight0 = &mut self.el_list_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SnocElListTable::WEIGHT);

                let weight1 = &mut self.el_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SnocElListTable::WEIGHT);

                let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(SnocElListTable::WEIGHT);

                t.0 = self.root_el_list(t.0);
                t.1 = self.root_el(t.1);
                t.2 = self.root_el_list(t.2);
                if self.snoc_el_list.insert(t) {
                    let weight0 = &mut self.el_list_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SnocElListTable::WEIGHT);

                    let weight1 = &mut self.el_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SnocElListTable::WEIGHT);

                    let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(SnocElListTable::WEIGHT);
                }
            }
        }

        for el in self.el_uprooted.iter().copied() {
            let ts = self.el_structure.drain_with_element_el(el);
            for mut t in ts {
                let weight0 = &mut self.el_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ElStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ElStructureTable::WEIGHT);

                t.0 = self.root_el(t.0);
                t.1 = self.root_structure(t.1);
                if self.el_structure.insert(t) {
                    let weight0 = &mut self.el_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ElStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ElStructureTable::WEIGHT);
                }
            }
        }
        for el in self.structure_uprooted.iter().copied() {
            let ts = self.el_structure.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.el_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ElStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ElStructureTable::WEIGHT);

                t.0 = self.root_el(t.0);
                t.1 = self.root_structure(t.1);
                if self.el_structure.insert(t) {
                    let weight0 = &mut self.el_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ElStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ElStructureTable::WEIGHT);
                }
            }
        }

        for el in self.el_list_uprooted.iter().copied() {
            let ts = self.els_structure.drain_with_element_el_list(el);
            for mut t in ts {
                let weight0 = &mut self.el_list_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ElsStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ElsStructureTable::WEIGHT);

                t.0 = self.root_el_list(t.0);
                t.1 = self.root_structure(t.1);
                if self.els_structure.insert(t) {
                    let weight0 = &mut self.el_list_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ElsStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ElsStructureTable::WEIGHT);
                }
            }
        }
        for el in self.structure_uprooted.iter().copied() {
            let ts = self.els_structure.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.el_list_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ElsStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ElsStructureTable::WEIGHT);

                t.0 = self.root_el_list(t.0);
                t.1 = self.root_structure(t.1);
                if self.els_structure.insert(t) {
                    let weight0 = &mut self.el_list_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ElsStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ElsStructureTable::WEIGHT);
                }
            }
        }

        for el in self.el_uprooted.iter().copied() {
            let ts = self.func_app.drain_with_element_el(el);
            for mut t in ts {
                let weight0 = &mut self.func_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(FuncAppTable::WEIGHT);

                let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(FuncAppTable::WEIGHT);

                let weight2 = &mut self.el_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(FuncAppTable::WEIGHT);

                t.0 = self.root_func(t.0);
                t.1 = self.root_el_list(t.1);
                t.2 = self.root_el(t.2);
                if self.func_app.insert(t) {
                    let weight0 = &mut self.func_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(FuncAppTable::WEIGHT);

                    let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(FuncAppTable::WEIGHT);

                    let weight2 = &mut self.el_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(FuncAppTable::WEIGHT);
                }
            }
        }
        for el in self.el_list_uprooted.iter().copied() {
            let ts = self.func_app.drain_with_element_el_list(el);
            for mut t in ts {
                let weight0 = &mut self.func_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(FuncAppTable::WEIGHT);

                let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(FuncAppTable::WEIGHT);

                let weight2 = &mut self.el_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(FuncAppTable::WEIGHT);

                t.0 = self.root_func(t.0);
                t.1 = self.root_el_list(t.1);
                t.2 = self.root_el(t.2);
                if self.func_app.insert(t) {
                    let weight0 = &mut self.func_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(FuncAppTable::WEIGHT);

                    let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(FuncAppTable::WEIGHT);

                    let weight2 = &mut self.el_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(FuncAppTable::WEIGHT);
                }
            }
        }
        for el in self.func_uprooted.iter().copied() {
            let ts = self.func_app.drain_with_element_func(el);
            for mut t in ts {
                let weight0 = &mut self.func_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(FuncAppTable::WEIGHT);

                let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(FuncAppTable::WEIGHT);

                let weight2 = &mut self.el_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(FuncAppTable::WEIGHT);

                t.0 = self.root_func(t.0);
                t.1 = self.root_el_list(t.1);
                t.2 = self.root_el(t.2);
                if self.func_app.insert(t) {
                    let weight0 = &mut self.func_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(FuncAppTable::WEIGHT);

                    let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(FuncAppTable::WEIGHT);

                    let weight2 = &mut self.el_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(FuncAppTable::WEIGHT);
                }
            }
        }

        for el in self.el_uprooted.iter().copied() {
            let ts = self.map_el.drain_with_element_el(el);
            for mut t in ts {
                let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MapElTable::WEIGHT);

                let weight1 = &mut self.el_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MapElTable::WEIGHT);

                let weight2 = &mut self.el_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(MapElTable::WEIGHT);

                t.0 = self.root_morphism(t.0);
                t.1 = self.root_el(t.1);
                t.2 = self.root_el(t.2);
                if self.map_el.insert(t) {
                    let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MapElTable::WEIGHT);

                    let weight1 = &mut self.el_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MapElTable::WEIGHT);

                    let weight2 = &mut self.el_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(MapElTable::WEIGHT);
                }
            }
        }
        for el in self.morphism_uprooted.iter().copied() {
            let ts = self.map_el.drain_with_element_morphism(el);
            for mut t in ts {
                let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MapElTable::WEIGHT);

                let weight1 = &mut self.el_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MapElTable::WEIGHT);

                let weight2 = &mut self.el_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(MapElTable::WEIGHT);

                t.0 = self.root_morphism(t.0);
                t.1 = self.root_el(t.1);
                t.2 = self.root_el(t.2);
                if self.map_el.insert(t) {
                    let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MapElTable::WEIGHT);

                    let weight1 = &mut self.el_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MapElTable::WEIGHT);

                    let weight2 = &mut self.el_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(MapElTable::WEIGHT);
                }
            }
        }

        for el in self.el_list_uprooted.iter().copied() {
            let ts = self.map_els.drain_with_element_el_list(el);
            for mut t in ts {
                let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MapElsTable::WEIGHT);

                let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MapElsTable::WEIGHT);

                let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(MapElsTable::WEIGHT);

                t.0 = self.root_morphism(t.0);
                t.1 = self.root_el_list(t.1);
                t.2 = self.root_el_list(t.2);
                if self.map_els.insert(t) {
                    let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MapElsTable::WEIGHT);

                    let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MapElsTable::WEIGHT);

                    let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(MapElsTable::WEIGHT);
                }
            }
        }
        for el in self.morphism_uprooted.iter().copied() {
            let ts = self.map_els.drain_with_element_morphism(el);
            for mut t in ts {
                let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MapElsTable::WEIGHT);

                let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MapElsTable::WEIGHT);

                let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(MapElsTable::WEIGHT);

                t.0 = self.root_morphism(t.0);
                t.1 = self.root_el_list(t.1);
                t.2 = self.root_el_list(t.2);
                if self.map_els.insert(t) {
                    let weight0 = &mut self.morphism_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MapElsTable::WEIGHT);

                    let weight1 = &mut self.el_list_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MapElsTable::WEIGHT);

                    let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(MapElsTable::WEIGHT);
                }
            }
        }

        for el in self.symbol_kind_uprooted.iter().copied() {
            let ts = self.type_symbol.drain_with_element_symbol_kind(el);
            for mut t in ts {
                let weight0 = &mut self.symbol_kind_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(TypeSymbolTable::WEIGHT);

                t.0 = self.root_symbol_kind(t.0);
                if self.type_symbol.insert(t) {
                    let weight0 = &mut self.symbol_kind_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(TypeSymbolTable::WEIGHT);
                }
            }
        }

        for el in self.symbol_kind_uprooted.iter().copied() {
            let ts = self.pred_symbol.drain_with_element_symbol_kind(el);
            for mut t in ts {
                let weight0 = &mut self.symbol_kind_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(PredSymbolTable::WEIGHT);

                t.0 = self.root_symbol_kind(t.0);
                if self.pred_symbol.insert(t) {
                    let weight0 = &mut self.symbol_kind_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(PredSymbolTable::WEIGHT);
                }
            }
        }

        for el in self.symbol_kind_uprooted.iter().copied() {
            let ts = self.func_symbol.drain_with_element_symbol_kind(el);
            for mut t in ts {
                let weight0 = &mut self.symbol_kind_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(FuncSymbolTable::WEIGHT);

                t.0 = self.root_symbol_kind(t.0);
                if self.func_symbol.insert(t) {
                    let weight0 = &mut self.symbol_kind_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(FuncSymbolTable::WEIGHT);
                }
            }
        }

        for el in self.symbol_kind_uprooted.iter().copied() {
            let ts = self.rule_symbol.drain_with_element_symbol_kind(el);
            for mut t in ts {
                let weight0 = &mut self.symbol_kind_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(RuleSymbolTable::WEIGHT);

                t.0 = self.root_symbol_kind(t.0);
                if self.rule_symbol.insert(t) {
                    let weight0 = &mut self.symbol_kind_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(RuleSymbolTable::WEIGHT);
                }
            }
        }

        for el in self.symbol_kind_uprooted.iter().copied() {
            let ts = self.enum_symbol.drain_with_element_symbol_kind(el);
            for mut t in ts {
                let weight0 = &mut self.symbol_kind_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(EnumSymbolTable::WEIGHT);

                t.0 = self.root_symbol_kind(t.0);
                if self.enum_symbol.insert(t) {
                    let weight0 = &mut self.symbol_kind_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(EnumSymbolTable::WEIGHT);
                }
            }
        }

        for el in self.symbol_kind_uprooted.iter().copied() {
            let ts = self.ctor_symbol.drain_with_element_symbol_kind(el);
            for mut t in ts {
                let weight0 = &mut self.symbol_kind_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CtorSymbolTable::WEIGHT);

                t.0 = self.root_symbol_kind(t.0);
                if self.ctor_symbol.insert(t) {
                    let weight0 = &mut self.symbol_kind_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CtorSymbolTable::WEIGHT);
                }
            }
        }

        for el in self.nat_uprooted.iter().copied() {
            let ts = self.zero.drain_with_element_nat(el);
            for mut t in ts {
                let weight0 = &mut self.nat_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ZeroTable::WEIGHT);

                t.0 = self.root_nat(t.0);
                if self.zero.insert(t) {
                    let weight0 = &mut self.nat_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ZeroTable::WEIGHT);
                }
            }
        }

        for el in self.nat_uprooted.iter().copied() {
            let ts = self.succ.drain_with_element_nat(el);
            for mut t in ts {
                let weight0 = &mut self.nat_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SuccTable::WEIGHT);

                let weight1 = &mut self.nat_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SuccTable::WEIGHT);

                t.0 = self.root_nat(t.0);
                t.1 = self.root_nat(t.1);
                if self.succ.insert(t) {
                    let weight0 = &mut self.nat_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SuccTable::WEIGHT);

                    let weight1 = &mut self.nat_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SuccTable::WEIGHT);
                }
            }
        }

        for el in self.nat_uprooted.iter().copied() {
            let ts = self.type_list_len.drain_with_element_nat(el);
            for mut t in ts {
                let weight0 = &mut self.type_list_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(TypeListLenTable::WEIGHT);

                let weight1 = &mut self.nat_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(TypeListLenTable::WEIGHT);

                t.0 = self.root_type_list(t.0);
                t.1 = self.root_nat(t.1);
                if self.type_list_len.insert(t) {
                    let weight0 = &mut self.type_list_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(TypeListLenTable::WEIGHT);

                    let weight1 = &mut self.nat_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(TypeListLenTable::WEIGHT);
                }
            }
        }
        for el in self.type_list_uprooted.iter().copied() {
            let ts = self.type_list_len.drain_with_element_type_list(el);
            for mut t in ts {
                let weight0 = &mut self.type_list_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(TypeListLenTable::WEIGHT);

                let weight1 = &mut self.nat_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(TypeListLenTable::WEIGHT);

                t.0 = self.root_type_list(t.0);
                t.1 = self.root_nat(t.1);
                if self.type_list_len.insert(t) {
                    let weight0 = &mut self.type_list_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(TypeListLenTable::WEIGHT);

                    let weight1 = &mut self.nat_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(TypeListLenTable::WEIGHT);
                }
            }
        }

        for el in self.nat_uprooted.iter().copied() {
            let ts = self.term_list_len.drain_with_element_nat(el);
            for mut t in ts {
                let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(TermListLenTable::WEIGHT);

                let weight1 = &mut self.nat_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(TermListLenTable::WEIGHT);

                t.0 = self.root_term_list_node(t.0);
                t.1 = self.root_nat(t.1);
                if self.term_list_len.insert(t) {
                    let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(TermListLenTable::WEIGHT);

                    let weight1 = &mut self.nat_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(TermListLenTable::WEIGHT);
                }
            }
        }
        for el in self.term_list_node_uprooted.iter().copied() {
            let ts = self.term_list_len.drain_with_element_term_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(TermListLenTable::WEIGHT);

                let weight1 = &mut self.nat_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(TermListLenTable::WEIGHT);

                t.0 = self.root_term_list_node(t.0);
                t.1 = self.root_nat(t.1);
                if self.term_list_len.insert(t) {
                    let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(TermListLenTable::WEIGHT);

                    let weight1 = &mut self.nat_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(TermListLenTable::WEIGHT);
                }
            }
        }

        for el in self.rule_decl_node_uprooted.iter().copied() {
            let ts = self
                .before_rule_structure
                .drain_with_element_rule_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(BeforeRuleStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(BeforeRuleStructureTable::WEIGHT);

                t.0 = self.root_rule_decl_node(t.0);
                t.1 = self.root_structure(t.1);
                if self.before_rule_structure.insert(t) {
                    let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(BeforeRuleStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(BeforeRuleStructureTable::WEIGHT);
                }
            }
        }
        for el in self.structure_uprooted.iter().copied() {
            let ts = self.before_rule_structure.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(BeforeRuleStructureTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(BeforeRuleStructureTable::WEIGHT);

                t.0 = self.root_rule_decl_node(t.0);
                t.1 = self.root_structure(t.1);
                if self.before_rule_structure.insert(t) {
                    let weight0 = &mut self.rule_decl_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(BeforeRuleStructureTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(BeforeRuleStructureTable::WEIGHT);
                }
            }
        }

        for el in self.if_atom_node_uprooted.iter().copied() {
            let ts = self.if_atom_morphism.drain_with_element_if_atom_node(el);
            for mut t in ts {
                let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(IfAtomMorphismTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(IfAtomMorphismTable::WEIGHT);

                let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(IfAtomMorphismTable::WEIGHT);

                t.0 = self.root_if_atom_node(t.0);
                t.1 = self.root_structure(t.1);
                t.2 = self.root_morphism(t.2);
                if self.if_atom_morphism.insert(t) {
                    let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(IfAtomMorphismTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(IfAtomMorphismTable::WEIGHT);

                    let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(IfAtomMorphismTable::WEIGHT);
                }
            }
        }
        for el in self.morphism_uprooted.iter().copied() {
            let ts = self.if_atom_morphism.drain_with_element_morphism(el);
            for mut t in ts {
                let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(IfAtomMorphismTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(IfAtomMorphismTable::WEIGHT);

                let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(IfAtomMorphismTable::WEIGHT);

                t.0 = self.root_if_atom_node(t.0);
                t.1 = self.root_structure(t.1);
                t.2 = self.root_morphism(t.2);
                if self.if_atom_morphism.insert(t) {
                    let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(IfAtomMorphismTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(IfAtomMorphismTable::WEIGHT);

                    let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(IfAtomMorphismTable::WEIGHT);
                }
            }
        }
        for el in self.structure_uprooted.iter().copied() {
            let ts = self.if_atom_morphism.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(IfAtomMorphismTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(IfAtomMorphismTable::WEIGHT);

                let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(IfAtomMorphismTable::WEIGHT);

                t.0 = self.root_if_atom_node(t.0);
                t.1 = self.root_structure(t.1);
                t.2 = self.root_morphism(t.2);
                if self.if_atom_morphism.insert(t) {
                    let weight0 = &mut self.if_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(IfAtomMorphismTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(IfAtomMorphismTable::WEIGHT);

                    let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(IfAtomMorphismTable::WEIGHT);
                }
            }
        }

        for el in self.morphism_uprooted.iter().copied() {
            let ts = self.then_atom_morphism.drain_with_element_morphism(el);
            for mut t in ts {
                let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ThenAtomMorphismTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ThenAtomMorphismTable::WEIGHT);

                let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ThenAtomMorphismTable::WEIGHT);

                t.0 = self.root_then_atom_node(t.0);
                t.1 = self.root_structure(t.1);
                t.2 = self.root_morphism(t.2);
                if self.then_atom_morphism.insert(t) {
                    let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ThenAtomMorphismTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ThenAtomMorphismTable::WEIGHT);

                    let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ThenAtomMorphismTable::WEIGHT);
                }
            }
        }
        for el in self.structure_uprooted.iter().copied() {
            let ts = self.then_atom_morphism.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ThenAtomMorphismTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ThenAtomMorphismTable::WEIGHT);

                let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ThenAtomMorphismTable::WEIGHT);

                t.0 = self.root_then_atom_node(t.0);
                t.1 = self.root_structure(t.1);
                t.2 = self.root_morphism(t.2);
                if self.then_atom_morphism.insert(t) {
                    let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ThenAtomMorphismTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ThenAtomMorphismTable::WEIGHT);

                    let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ThenAtomMorphismTable::WEIGHT);
                }
            }
        }
        for el in self.then_atom_node_uprooted.iter().copied() {
            let ts = self
                .then_atom_morphism
                .drain_with_element_then_atom_node(el);
            for mut t in ts {
                let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(ThenAtomMorphismTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(ThenAtomMorphismTable::WEIGHT);

                let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(ThenAtomMorphismTable::WEIGHT);

                t.0 = self.root_then_atom_node(t.0);
                t.1 = self.root_structure(t.1);
                t.2 = self.root_morphism(t.2);
                if self.then_atom_morphism.insert(t) {
                    let weight0 = &mut self.then_atom_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(ThenAtomMorphismTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(ThenAtomMorphismTable::WEIGHT);

                    let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(ThenAtomMorphismTable::WEIGHT);
                }
            }
        }

        for el in self.morphism_uprooted.iter().copied() {
            let ts = self.branch_stmt_morphism.drain_with_element_morphism(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(BranchStmtMorphismTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(BranchStmtMorphismTable::WEIGHT);

                let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(BranchStmtMorphismTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_structure(t.1);
                t.2 = self.root_morphism(t.2);
                if self.branch_stmt_morphism.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(BranchStmtMorphismTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(BranchStmtMorphismTable::WEIGHT);

                    let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(BranchStmtMorphismTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self.branch_stmt_morphism.drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(BranchStmtMorphismTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(BranchStmtMorphismTable::WEIGHT);

                let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(BranchStmtMorphismTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_structure(t.1);
                t.2 = self.root_morphism(t.2);
                if self.branch_stmt_morphism.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(BranchStmtMorphismTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(BranchStmtMorphismTable::WEIGHT);

                    let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(BranchStmtMorphismTable::WEIGHT);
                }
            }
        }
        for el in self.structure_uprooted.iter().copied() {
            let ts = self.branch_stmt_morphism.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(BranchStmtMorphismTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(BranchStmtMorphismTable::WEIGHT);

                let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(BranchStmtMorphismTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_structure(t.1);
                t.2 = self.root_morphism(t.2);
                if self.branch_stmt_morphism.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(BranchStmtMorphismTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(BranchStmtMorphismTable::WEIGHT);

                    let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(BranchStmtMorphismTable::WEIGHT);
                }
            }
        }

        for el in self.morphism_uprooted.iter().copied() {
            let ts = self.match_stmt_morphism.drain_with_element_morphism(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchStmtMorphismTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchStmtMorphismTable::WEIGHT);

                let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(MatchStmtMorphismTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_structure(t.1);
                t.2 = self.root_morphism(t.2);
                if self.match_stmt_morphism.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchStmtMorphismTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchStmtMorphismTable::WEIGHT);

                    let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(MatchStmtMorphismTable::WEIGHT);
                }
            }
        }
        for el in self.stmt_node_uprooted.iter().copied() {
            let ts = self.match_stmt_morphism.drain_with_element_stmt_node(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchStmtMorphismTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchStmtMorphismTable::WEIGHT);

                let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(MatchStmtMorphismTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_structure(t.1);
                t.2 = self.root_morphism(t.2);
                if self.match_stmt_morphism.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchStmtMorphismTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchStmtMorphismTable::WEIGHT);

                    let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(MatchStmtMorphismTable::WEIGHT);
                }
            }
        }
        for el in self.structure_uprooted.iter().copied() {
            let ts = self.match_stmt_morphism.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchStmtMorphismTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchStmtMorphismTable::WEIGHT);

                let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(MatchStmtMorphismTable::WEIGHT);

                t.0 = self.root_stmt_node(t.0);
                t.1 = self.root_structure(t.1);
                t.2 = self.root_morphism(t.2);
                if self.match_stmt_morphism.insert(t) {
                    let weight0 = &mut self.stmt_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchStmtMorphismTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchStmtMorphismTable::WEIGHT);

                    let weight2 = &mut self.morphism_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(MatchStmtMorphismTable::WEIGHT);
                }
            }
        }

        for el in self.el_name_uprooted.iter().copied() {
            let ts = self.semantic_name.drain_with_element_el_name(el);
            for mut t in ts {
                let weight0 = &mut self.virt_ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SemanticNameTable::WEIGHT);

                let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SemanticNameTable::WEIGHT);

                let weight2 = &mut self.el_name_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(SemanticNameTable::WEIGHT);

                t.0 = self.root_virt_ident(t.0);
                t.1 = self.root_scope(t.1);
                t.2 = self.root_el_name(t.2);
                if self.semantic_name.insert(t) {
                    let weight0 = &mut self.virt_ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SemanticNameTable::WEIGHT);

                    let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SemanticNameTable::WEIGHT);

                    let weight2 = &mut self.el_name_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(SemanticNameTable::WEIGHT);
                }
            }
        }
        for el in self.scope_uprooted.iter().copied() {
            let ts = self.semantic_name.drain_with_element_scope(el);
            for mut t in ts {
                let weight0 = &mut self.virt_ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SemanticNameTable::WEIGHT);

                let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SemanticNameTable::WEIGHT);

                let weight2 = &mut self.el_name_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(SemanticNameTable::WEIGHT);

                t.0 = self.root_virt_ident(t.0);
                t.1 = self.root_scope(t.1);
                t.2 = self.root_el_name(t.2);
                if self.semantic_name.insert(t) {
                    let weight0 = &mut self.virt_ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SemanticNameTable::WEIGHT);

                    let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SemanticNameTable::WEIGHT);

                    let weight2 = &mut self.el_name_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(SemanticNameTable::WEIGHT);
                }
            }
        }
        for el in self.virt_ident_uprooted.iter().copied() {
            let ts = self.semantic_name.drain_with_element_virt_ident(el);
            for mut t in ts {
                let weight0 = &mut self.virt_ident_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SemanticNameTable::WEIGHT);

                let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SemanticNameTable::WEIGHT);

                let weight2 = &mut self.el_name_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(SemanticNameTable::WEIGHT);

                t.0 = self.root_virt_ident(t.0);
                t.1 = self.root_scope(t.1);
                t.2 = self.root_el_name(t.2);
                if self.semantic_name.insert(t) {
                    let weight0 = &mut self.virt_ident_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SemanticNameTable::WEIGHT);

                    let weight1 = &mut self.scope_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SemanticNameTable::WEIGHT);

                    let weight2 = &mut self.el_name_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(SemanticNameTable::WEIGHT);
                }
            }
        }

        for el in self.el_uprooted.iter().copied() {
            let ts = self.semantic_el.drain_with_element_el(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SemanticElTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SemanticElTable::WEIGHT);

                let weight2 = &mut self.el_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(SemanticElTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_structure(t.1);
                t.2 = self.root_el(t.2);
                if self.semantic_el.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SemanticElTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SemanticElTable::WEIGHT);

                    let weight2 = &mut self.el_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(SemanticElTable::WEIGHT);
                }
            }
        }
        for el in self.structure_uprooted.iter().copied() {
            let ts = self.semantic_el.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SemanticElTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SemanticElTable::WEIGHT);

                let weight2 = &mut self.el_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(SemanticElTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_structure(t.1);
                t.2 = self.root_el(t.2);
                if self.semantic_el.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SemanticElTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SemanticElTable::WEIGHT);

                    let weight2 = &mut self.el_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(SemanticElTable::WEIGHT);
                }
            }
        }
        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.semantic_el.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SemanticElTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SemanticElTable::WEIGHT);

                let weight2 = &mut self.el_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(SemanticElTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_structure(t.1);
                t.2 = self.root_el(t.2);
                if self.semantic_el.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SemanticElTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SemanticElTable::WEIGHT);

                    let weight2 = &mut self.el_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(SemanticElTable::WEIGHT);
                }
            }
        }

        for el in self.el_list_uprooted.iter().copied() {
            let ts = self.semantic_els.drain_with_element_el_list(el);
            for mut t in ts {
                let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SemanticElsTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SemanticElsTable::WEIGHT);

                let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(SemanticElsTable::WEIGHT);

                t.0 = self.root_term_list_node(t.0);
                t.1 = self.root_structure(t.1);
                t.2 = self.root_el_list(t.2);
                if self.semantic_els.insert(t) {
                    let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SemanticElsTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SemanticElsTable::WEIGHT);

                    let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(SemanticElsTable::WEIGHT);
                }
            }
        }
        for el in self.structure_uprooted.iter().copied() {
            let ts = self.semantic_els.drain_with_element_structure(el);
            for mut t in ts {
                let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SemanticElsTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SemanticElsTable::WEIGHT);

                let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(SemanticElsTable::WEIGHT);

                t.0 = self.root_term_list_node(t.0);
                t.1 = self.root_structure(t.1);
                t.2 = self.root_el_list(t.2);
                if self.semantic_els.insert(t) {
                    let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SemanticElsTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SemanticElsTable::WEIGHT);

                    let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(SemanticElsTable::WEIGHT);
                }
            }
        }
        for el in self.term_list_node_uprooted.iter().copied() {
            let ts = self.semantic_els.drain_with_element_term_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(SemanticElsTable::WEIGHT);

                let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(SemanticElsTable::WEIGHT);

                let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                *weight2 = weight2.saturating_sub(SemanticElsTable::WEIGHT);

                t.0 = self.root_term_list_node(t.0);
                t.1 = self.root_structure(t.1);
                t.2 = self.root_el_list(t.2);
                if self.semantic_els.insert(t) {
                    let weight0 = &mut self.term_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(SemanticElsTable::WEIGHT);

                    let weight1 = &mut self.structure_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(SemanticElsTable::WEIGHT);

                    let weight2 = &mut self.el_list_weights[t.2 .0 as usize];
                    *weight2 = weight2.saturating_add(SemanticElsTable::WEIGHT);
                }
            }
        }

        for el in self.el_name_uprooted.iter().copied() {
            let ts = self.wildcard_name.drain_with_element_el_name(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(WildcardNameTable::WEIGHT);

                let weight1 = &mut self.el_name_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(WildcardNameTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_el_name(t.1);
                if self.wildcard_name.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(WildcardNameTable::WEIGHT);

                    let weight1 = &mut self.el_name_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(WildcardNameTable::WEIGHT);
                }
            }
        }
        for el in self.term_node_uprooted.iter().copied() {
            let ts = self.wildcard_name.drain_with_element_term_node(el);
            for mut t in ts {
                let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(WildcardNameTable::WEIGHT);

                let weight1 = &mut self.el_name_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(WildcardNameTable::WEIGHT);

                t.0 = self.root_term_node(t.0);
                t.1 = self.root_el_name(t.1);
                if self.wildcard_name.insert(t) {
                    let weight0 = &mut self.term_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(WildcardNameTable::WEIGHT);

                    let weight1 = &mut self.el_name_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(WildcardNameTable::WEIGHT);
                }
            }
        }

        for el in self.ctor_decl_node_uprooted.iter().copied() {
            let ts = self
                .match_case_pattern_ctor
                .drain_with_element_ctor_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchCasePatternCtorTable::WEIGHT);

                let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchCasePatternCtorTable::WEIGHT);

                t.0 = self.root_match_case_node(t.0);
                t.1 = self.root_ctor_decl_node(t.1);
                if self.match_case_pattern_ctor.insert(t) {
                    let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchCasePatternCtorTable::WEIGHT);

                    let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchCasePatternCtorTable::WEIGHT);
                }
            }
        }
        for el in self.match_case_node_uprooted.iter().copied() {
            let ts = self
                .match_case_pattern_ctor
                .drain_with_element_match_case_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(MatchCasePatternCtorTable::WEIGHT);

                let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(MatchCasePatternCtorTable::WEIGHT);

                t.0 = self.root_match_case_node(t.0);
                t.1 = self.root_ctor_decl_node(t.1);
                if self.match_case_pattern_ctor.insert(t) {
                    let weight0 = &mut self.match_case_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(MatchCasePatternCtorTable::WEIGHT);

                    let weight1 = &mut self.ctor_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(MatchCasePatternCtorTable::WEIGHT);
                }
            }
        }

        for el in self.enum_decl_node_uprooted.iter().copied() {
            let ts = self
                .cases_determined_enum
                .drain_with_element_enum_decl_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CasesDeterminedEnumTable::WEIGHT);

                let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CasesDeterminedEnumTable::WEIGHT);

                t.0 = self.root_match_case_list_node(t.0);
                t.1 = self.root_enum_decl_node(t.1);
                if self.cases_determined_enum.insert(t) {
                    let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CasesDeterminedEnumTable::WEIGHT);

                    let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CasesDeterminedEnumTable::WEIGHT);
                }
            }
        }
        for el in self.match_case_list_node_uprooted.iter().copied() {
            let ts = self
                .cases_determined_enum
                .drain_with_element_match_case_list_node(el);
            for mut t in ts {
                let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                *weight0 = weight0.saturating_sub(CasesDeterminedEnumTable::WEIGHT);

                let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                *weight1 = weight1.saturating_sub(CasesDeterminedEnumTable::WEIGHT);

                t.0 = self.root_match_case_list_node(t.0);
                t.1 = self.root_enum_decl_node(t.1);
                if self.cases_determined_enum.insert(t) {
                    let weight0 = &mut self.match_case_list_node_weights[t.0 .0 as usize];
                    *weight0 = weight0.saturating_add(CasesDeterminedEnumTable::WEIGHT);

                    let weight1 = &mut self.enum_decl_node_weights[t.1 .0 as usize];
                    *weight1 = weight1.saturating_add(CasesDeterminedEnumTable::WEIGHT);
                }
            }
        }

        self.ident_uprooted.clear();
        self.virt_ident_uprooted.clear();
        self.type_decl_node_uprooted.clear();
        self.arg_decl_node_uprooted.clear();
        self.arg_decl_list_node_uprooted.clear();
        self.pred_decl_node_uprooted.clear();
        self.func_decl_node_uprooted.clear();
        self.ctor_decl_node_uprooted.clear();
        self.ctor_decl_list_node_uprooted.clear();
        self.enum_decl_node_uprooted.clear();
        self.term_node_uprooted.clear();
        self.term_list_node_uprooted.clear();
        self.opt_term_node_uprooted.clear();
        self.match_case_node_uprooted.clear();
        self.match_case_list_node_uprooted.clear();
        self.if_atom_node_uprooted.clear();
        self.then_atom_node_uprooted.clear();
        self.stmt_node_uprooted.clear();
        self.stmt_list_node_uprooted.clear();
        self.stmt_block_list_node_uprooted.clear();
        self.rule_decl_node_uprooted.clear();
        self.decl_node_uprooted.clear();
        self.decl_list_node_uprooted.clear();
        self.module_node_uprooted.clear();
        self.loc_uprooted.clear();
        self.rule_descendant_node_uprooted.clear();
        self.scope_uprooted.clear();
        self.type_uprooted.clear();
        self.pred_uprooted.clear();
        self.func_uprooted.clear();
        self.structure_uprooted.clear();
        self.el_uprooted.clear();
        self.el_name_uprooted.clear();
        self.morphism_uprooted.clear();
        self.symbol_kind_uprooted.clear();
        self.nat_uprooted.clear();
        self.type_list_uprooted.clear();
        self.rel_uprooted.clear();
        self.el_list_uprooted.clear();
    }
    fn is_dirty(&self) -> bool {
        self.empty_join_is_dirty
            || self.absurd.is_dirty()
            || self.type_decl.is_dirty()
            || self.arg_decl_node_name.is_dirty()
            || self.arg_decl_node_type.is_dirty()
            || self.nil_arg_decl_list_node.is_dirty()
            || self.cons_arg_decl_list_node.is_dirty()
            || self.pred_decl.is_dirty()
            || self.func_decl.is_dirty()
            || self.ctor_decl.is_dirty()
            || self.nil_ctor_decl_list_node.is_dirty()
            || self.cons_ctor_decl_list_node.is_dirty()
            || self.enum_decl.is_dirty()
            || self.nil_term_list_node.is_dirty()
            || self.cons_term_list_node.is_dirty()
            || self.none_term_node.is_dirty()
            || self.some_term_node.is_dirty()
            || self.var_term_node.is_dirty()
            || self.wildcard_term_node.is_dirty()
            || self.app_term_node.is_dirty()
            || self.match_case.is_dirty()
            || self.nil_match_case_list_node.is_dirty()
            || self.cons_match_case_list_node.is_dirty()
            || self.equal_if_atom_node.is_dirty()
            || self.defined_if_atom_node.is_dirty()
            || self.pred_if_atom_node.is_dirty()
            || self.var_if_atom_node.is_dirty()
            || self.equal_then_atom_node.is_dirty()
            || self.defined_then_atom_node.is_dirty()
            || self.pred_then_atom_node.is_dirty()
            || self.if_stmt_node.is_dirty()
            || self.then_stmt_node.is_dirty()
            || self.branch_stmt_node.is_dirty()
            || self.match_stmt_node.is_dirty()
            || self.nil_stmt_list_node.is_dirty()
            || self.cons_stmt_list_node.is_dirty()
            || self.nil_stmt_block_list_node.is_dirty()
            || self.cons_stmt_block_list_node.is_dirty()
            || self.rule_decl.is_dirty()
            || self.decl_node_type.is_dirty()
            || self.decl_node_pred.is_dirty()
            || self.decl_node_func.is_dirty()
            || self.decl_node_rule.is_dirty()
            || self.decl_node_enum.is_dirty()
            || self.nil_decl_list_node.is_dirty()
            || self.cons_decl_list_node.is_dirty()
            || self.decls_module_node.is_dirty()
            || self.var_in_scope.is_dirty()
            || self.scope_extension.is_dirty()
            || self.scope_single_child.is_dirty()
            || self.scope_extension_siblings.is_dirty()
            || self.rel_app.is_dirty()
            || self.el_type.is_dirty()
            || self.el_types.is_dirty()
            || self.constrained_el.is_dirty()
            || self.constrained_els.is_dirty()
            || self.in_ker.is_dirty()
            || self.el_in_img.is_dirty()
            || self.rel_tuple_in_img.is_dirty()
            || self.defined_symbol.is_dirty()
            || self.should_be_symbol.is_dirty()
            || self.should_be_symbol_2.is_dirty()
            || self.pred_arg_num_should_match.is_dirty()
            || self.func_arg_num_should_match.is_dirty()
            || self.cfg_edge.is_dirty()
            || self.cfg_edge_stmts_stmt.is_dirty()
            || self.cfg_edge_stmt_stmts.is_dirty()
            || self.cfg_edge_fork.is_dirty()
            || self.cfg_edge_join.is_dirty()
            || self.before_stmt_structure.is_dirty()
            || self.stmt_morphism.is_dirty()
            || self.if_morphism.is_dirty()
            || self.surj_then_morphism.is_dirty()
            || self.non_surj_then_morphism.is_dirty()
            || self.noop_morphism.is_dirty()
            || self.stmt_structure.is_dirty()
            || self.if_atom_structure.is_dirty()
            || self.then_atom_structure.is_dirty()
            || self.term_structure.is_dirty()
            || self.terms_structure.is_dirty()
            || self.opt_term_structure.is_dirty()
            || self.term_should_be_epic_ok.is_dirty()
            || self.terms_should_be_epic_ok.is_dirty()
            || self.el_should_be_surjective_ok.is_dirty()
            || self.el_is_surjective_ok.is_dirty()
            || self.should_be_obtained_by_ctor.is_dirty()
            || self.is_given_by_ctor.is_dirty()
            || self.function_can_be_made_defined.is_dirty()
            || self.case_pattern_is_variable.is_dirty()
            || self.case_pattern_is_wildcard.is_dirty()
            || self.is_pattern_ctor_arg.is_dirty()
            || self.are_pattern_ctor_args.is_dirty()
            || self.pattern_ctor_arg_is_app.is_dirty()
            || self.pattern_ctor_arg_var_is_not_fresh.is_dirty()
            || self.cases_contain_ctor.is_dirty()
            || self.match_stmt_contains_ctor_of_enum.is_dirty()
            || self.match_stmt_should_contain_ctor.is_dirty()
            || self.match_stmt_contains_ctor.is_dirty()
            || self.real_virt_ident.is_dirty()
            || self.virt_real_ident.is_dirty()
            || self.var.is_dirty()
            || self.rule_name.is_dirty()
            || self.type_decl_node_loc.is_dirty()
            || self.arg_decl_node_loc.is_dirty()
            || self.arg_decl_list_node_loc.is_dirty()
            || self.pred_decl_node_loc.is_dirty()
            || self.func_decl_node_loc.is_dirty()
            || self.ctor_decl_node_loc.is_dirty()
            || self.enum_decl_node_loc.is_dirty()
            || self.term_node_loc.is_dirty()
            || self.term_list_node_loc.is_dirty()
            || self.match_case_node_loc.is_dirty()
            || self.opt_term_node_loc.is_dirty()
            || self.if_atom_node_loc.is_dirty()
            || self.then_atom_node_loc.is_dirty()
            || self.stmt_node_loc.is_dirty()
            || self.stmt_list_node_loc.is_dirty()
            || self.rule_decl_node_loc.is_dirty()
            || self.decl_node_loc.is_dirty()
            || self.decl_list_node_loc.is_dirty()
            || self.module_node_loc.is_dirty()
            || self.rule_descendant_rule.is_dirty()
            || self.rule_descendant_term.is_dirty()
            || self.rule_descendant_term_list.is_dirty()
            || self.rule_descendant_opt_term.is_dirty()
            || self.rule_descendant_if_atom.is_dirty()
            || self.rule_descendant_then_atom.is_dirty()
            || self.rule_descendant_match_case.is_dirty()
            || self.rule_descendant_match_case_list.is_dirty()
            || self.rule_descendant_stmt.is_dirty()
            || self.rule_descendant_stmt_list.is_dirty()
            || self.rule_descendant_stmt_block_list.is_dirty()
            || self.entry_scope.is_dirty()
            || self.exit_scope.is_dirty()
            || self.ctor_enum.is_dirty()
            || self.ctors_enum.is_dirty()
            || self.cases_discriminee.is_dirty()
            || self.case_discriminee.is_dirty()
            || self.desugared_case_equality_atom.is_dirty()
            || self.desugared_case_equality_stmt.is_dirty()
            || self.desugared_case_block.is_dirty()
            || self.desugared_case_block_list.is_dirty()
            || self.nil_type_list.is_dirty()
            || self.cons_type_list.is_dirty()
            || self.snoc_type_list.is_dirty()
            || self.semantic_type.is_dirty()
            || self.semantic_arg_types.is_dirty()
            || self.semantic_pred.is_dirty()
            || self.pred_arity.is_dirty()
            || self.semantic_func.is_dirty()
            || self.domain.is_dirty()
            || self.codomain.is_dirty()
            || self.pred_rel.is_dirty()
            || self.func_rel.is_dirty()
            || self.arity.is_dirty()
            || self.dom.is_dirty()
            || self.cod.is_dirty()
            || self.nil_el_list.is_dirty()
            || self.cons_el_list.is_dirty()
            || self.snoc_el_list.is_dirty()
            || self.el_structure.is_dirty()
            || self.els_structure.is_dirty()
            || self.func_app.is_dirty()
            || self.map_el.is_dirty()
            || self.map_els.is_dirty()
            || self.type_symbol.is_dirty()
            || self.pred_symbol.is_dirty()
            || self.func_symbol.is_dirty()
            || self.rule_symbol.is_dirty()
            || self.enum_symbol.is_dirty()
            || self.ctor_symbol.is_dirty()
            || self.zero.is_dirty()
            || self.succ.is_dirty()
            || self.type_list_len.is_dirty()
            || self.term_list_len.is_dirty()
            || self.before_rule_structure.is_dirty()
            || self.if_atom_morphism.is_dirty()
            || self.then_atom_morphism.is_dirty()
            || self.branch_stmt_morphism.is_dirty()
            || self.match_stmt_morphism.is_dirty()
            || self.semantic_name.is_dirty()
            || self.semantic_el.is_dirty()
            || self.semantic_els.is_dirty()
            || self.wildcard_name.is_dirty()
            || self.match_case_pattern_ctor.is_dirty()
            || self.cases_determined_enum.is_dirty()
            || !self.ident_dirty.is_empty()
            || !self.virt_ident_dirty.is_empty()
            || !self.type_decl_node_dirty.is_empty()
            || !self.arg_decl_node_dirty.is_empty()
            || !self.arg_decl_list_node_dirty.is_empty()
            || !self.pred_decl_node_dirty.is_empty()
            || !self.func_decl_node_dirty.is_empty()
            || !self.ctor_decl_node_dirty.is_empty()
            || !self.ctor_decl_list_node_dirty.is_empty()
            || !self.enum_decl_node_dirty.is_empty()
            || !self.term_node_dirty.is_empty()
            || !self.term_list_node_dirty.is_empty()
            || !self.opt_term_node_dirty.is_empty()
            || !self.match_case_node_dirty.is_empty()
            || !self.stmt_list_node_dirty.is_empty()
            || !self.match_case_list_node_dirty.is_empty()
            || !self.if_atom_node_dirty.is_empty()
            || !self.then_atom_node_dirty.is_empty()
            || !self.stmt_node_dirty.is_empty()
            || !self.stmt_block_list_node_dirty.is_empty()
            || !self.rule_decl_node_dirty.is_empty()
            || !self.decl_node_dirty.is_empty()
            || !self.decl_list_node_dirty.is_empty()
            || !self.module_node_dirty.is_empty()
            || !self.loc_dirty.is_empty()
            || !self.rule_descendant_node_dirty.is_empty()
            || !self.scope_dirty.is_empty()
            || !self.type_dirty.is_empty()
            || !self.type_list_dirty.is_empty()
            || !self.pred_dirty.is_empty()
            || !self.func_dirty.is_empty()
            || !self.rel_dirty.is_empty()
            || !self.structure_dirty.is_empty()
            || !self.el_dirty.is_empty()
            || !self.el_list_dirty.is_empty()
            || !self.el_name_dirty.is_empty()
            || !self.morphism_dirty.is_empty()
            || !self.symbol_kind_dirty.is_empty()
            || !self.nat_dirty.is_empty()
            || !self.ident_uprooted.is_empty()
            || !self.virt_ident_uprooted.is_empty()
            || !self.type_decl_node_uprooted.is_empty()
            || !self.arg_decl_node_uprooted.is_empty()
            || !self.arg_decl_list_node_uprooted.is_empty()
            || !self.pred_decl_node_uprooted.is_empty()
            || !self.func_decl_node_uprooted.is_empty()
            || !self.ctor_decl_node_uprooted.is_empty()
            || !self.ctor_decl_list_node_uprooted.is_empty()
            || !self.enum_decl_node_uprooted.is_empty()
            || !self.term_node_uprooted.is_empty()
            || !self.term_list_node_uprooted.is_empty()
            || !self.opt_term_node_uprooted.is_empty()
            || !self.match_case_node_uprooted.is_empty()
            || !self.stmt_list_node_uprooted.is_empty()
            || !self.match_case_list_node_uprooted.is_empty()
            || !self.if_atom_node_uprooted.is_empty()
            || !self.then_atom_node_uprooted.is_empty()
            || !self.stmt_node_uprooted.is_empty()
            || !self.stmt_block_list_node_uprooted.is_empty()
            || !self.rule_decl_node_uprooted.is_empty()
            || !self.decl_node_uprooted.is_empty()
            || !self.decl_list_node_uprooted.is_empty()
            || !self.module_node_uprooted.is_empty()
            || !self.loc_uprooted.is_empty()
            || !self.rule_descendant_node_uprooted.is_empty()
            || !self.scope_uprooted.is_empty()
            || !self.type_uprooted.is_empty()
            || !self.type_list_uprooted.is_empty()
            || !self.pred_uprooted.is_empty()
            || !self.func_uprooted.is_empty()
            || !self.rel_uprooted.is_empty()
            || !self.structure_uprooted.is_empty()
            || !self.el_uprooted.is_empty()
            || !self.el_list_uprooted.is_empty()
            || !self.el_name_uprooted.is_empty()
            || !self.morphism_uprooted.is_empty()
            || !self.symbol_kind_uprooted.is_empty()
            || !self.nat_uprooted.is_empty()
    }

    #[allow(unused_variables)]
    fn implicit_functionality_0_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RealVirtIdent(tm0, tm1) in self.real_virt_ident.iter_dirty() {
                #[allow(unused_variables)]
                for RealVirtIdent(_, tm2) in self.real_virt_ident.iter_all_0(tm0) {
                    delta.new_virt_ident_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_1_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for VirtRealIdent(tm0, tm1) in self.virt_real_ident.iter_dirty() {
                #[allow(unused_variables)]
                for VirtRealIdent(_, tm2) in self.virt_real_ident.iter_all_0(tm0) {
                    delta.new_ident_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_2_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleName(tm0, tm1) in self.rule_name.iter_dirty() {
                #[allow(unused_variables)]
                for RuleName(_, tm2) in self.rule_name.iter_all_0(tm0) {
                    delta.new_ident_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_3_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeDeclNodeLoc(tm0, tm1) in self.type_decl_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for TypeDeclNodeLoc(_, tm2) in self.type_decl_node_loc.iter_all_0(tm0) {
                    delta.new_loc_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_4_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ArgDeclNodeLoc(tm0, tm1) in self.arg_decl_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for ArgDeclNodeLoc(_, tm2) in self.arg_decl_node_loc.iter_all_0(tm0) {
                    delta.new_loc_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_5_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ArgDeclListNodeLoc(tm0, tm1) in self.arg_decl_list_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for ArgDeclListNodeLoc(_, tm2) in self.arg_decl_list_node_loc.iter_all_0(tm0) {
                    delta.new_loc_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_6_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredDeclNodeLoc(tm0, tm1) in self.pred_decl_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for PredDeclNodeLoc(_, tm2) in self.pred_decl_node_loc.iter_all_0(tm0) {
                    delta.new_loc_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_7_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncDeclNodeLoc(tm0, tm1) in self.func_decl_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for FuncDeclNodeLoc(_, tm2) in self.func_decl_node_loc.iter_all_0(tm0) {
                    delta.new_loc_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_8_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorDeclNodeLoc(tm0, tm1) in self.ctor_decl_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for CtorDeclNodeLoc(_, tm2) in self.ctor_decl_node_loc.iter_all_0(tm0) {
                    delta.new_loc_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_9_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumDeclNodeLoc(tm0, tm1) in self.enum_decl_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for EnumDeclNodeLoc(_, tm2) in self.enum_decl_node_loc.iter_all_0(tm0) {
                    delta.new_loc_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_10_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermNodeLoc(tm0, tm1) in self.term_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for TermNodeLoc(_, tm2) in self.term_node_loc.iter_all_0(tm0) {
                    delta.new_loc_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_11_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermListNodeLoc(tm0, tm1) in self.term_list_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for TermListNodeLoc(_, tm2) in self.term_list_node_loc.iter_all_0(tm0) {
                    delta.new_loc_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_12_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchCaseNodeLoc(tm0, tm1) in self.match_case_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for MatchCaseNodeLoc(_, tm2) in self.match_case_node_loc.iter_all_0(tm0) {
                    delta.new_loc_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_13_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for OptTermNodeLoc(tm0, tm1) in self.opt_term_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for OptTermNodeLoc(_, tm2) in self.opt_term_node_loc.iter_all_0(tm0) {
                    delta.new_loc_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_14_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfAtomNodeLoc(tm0, tm1) in self.if_atom_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for IfAtomNodeLoc(_, tm2) in self.if_atom_node_loc.iter_all_0(tm0) {
                    delta.new_loc_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_15_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenAtomNodeLoc(tm0, tm1) in self.then_atom_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for ThenAtomNodeLoc(_, tm2) in self.then_atom_node_loc.iter_all_0(tm0) {
                    delta.new_loc_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_16_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtNodeLoc(tm0, tm1) in self.stmt_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for StmtNodeLoc(_, tm2) in self.stmt_node_loc.iter_all_0(tm0) {
                    delta.new_loc_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_17_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtListNodeLoc(tm0, tm1) in self.stmt_list_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for StmtListNodeLoc(_, tm2) in self.stmt_list_node_loc.iter_all_0(tm0) {
                    delta.new_loc_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_18_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDeclNodeLoc(tm0, tm1) in self.rule_decl_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDeclNodeLoc(_, tm2) in self.rule_decl_node_loc.iter_all_0(tm0) {
                    delta.new_loc_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_19_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DeclNodeLoc(tm0, tm1) in self.decl_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for DeclNodeLoc(_, tm2) in self.decl_node_loc.iter_all_0(tm0) {
                    delta.new_loc_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_20_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DeclListNodeLoc(tm0, tm1) in self.decl_list_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for DeclListNodeLoc(_, tm2) in self.decl_list_node_loc.iter_all_0(tm0) {
                    delta.new_loc_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_21_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ModuleNodeLoc(tm0, tm1) in self.module_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for ModuleNodeLoc(_, tm2) in self.module_node_loc.iter_all_0(tm0) {
                    delta.new_loc_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_22_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantRule(tm0, tm1) in self.rule_descendant_rule.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantRule(_, tm2) in self.rule_descendant_rule.iter_all_0(tm0) {
                    delta.new_rule_descendant_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_23_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(tm0, tm1) in self.rule_descendant_term.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantTerm(_, tm2) in self.rule_descendant_term.iter_all_0(tm0) {
                    delta.new_rule_descendant_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_24_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTermList(tm0, tm1) in self.rule_descendant_term_list.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantTermList(_, tm2) in self.rule_descendant_term_list.iter_all_0(tm0)
                {
                    delta.new_rule_descendant_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_25_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantOptTerm(tm0, tm1) in self.rule_descendant_opt_term.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantOptTerm(_, tm2) in self.rule_descendant_opt_term.iter_all_0(tm0) {
                    delta.new_rule_descendant_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_26_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantIfAtom(tm0, tm1) in self.rule_descendant_if_atom.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantIfAtom(_, tm2) in self.rule_descendant_if_atom.iter_all_0(tm0) {
                    delta.new_rule_descendant_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_27_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantThenAtom(tm0, tm1) in self.rule_descendant_then_atom.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantThenAtom(_, tm2) in self.rule_descendant_then_atom.iter_all_0(tm0)
                {
                    delta.new_rule_descendant_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_28_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantMatchCase(tm0, tm1) in self.rule_descendant_match_case.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantMatchCase(_, tm2) in
                    self.rule_descendant_match_case.iter_all_0(tm0)
                {
                    delta.new_rule_descendant_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_29_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantMatchCaseList(tm0, tm1) in
                self.rule_descendant_match_case_list.iter_dirty()
            {
                #[allow(unused_variables)]
                for RuleDescendantMatchCaseList(_, tm2) in
                    self.rule_descendant_match_case_list.iter_all_0(tm0)
                {
                    delta.new_rule_descendant_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_30_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmt(tm0, tm1) in self.rule_descendant_stmt.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantStmt(_, tm2) in self.rule_descendant_stmt.iter_all_0(tm0) {
                    delta.new_rule_descendant_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_31_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtList(tm0, tm1) in self.rule_descendant_stmt_list.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantStmtList(_, tm2) in self.rule_descendant_stmt_list.iter_all_0(tm0)
                {
                    delta.new_rule_descendant_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_32_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtBlockList(tm0, tm1) in
                self.rule_descendant_stmt_block_list.iter_dirty()
            {
                #[allow(unused_variables)]
                for RuleDescendantStmtBlockList(_, tm2) in
                    self.rule_descendant_stmt_block_list.iter_all_0(tm0)
                {
                    delta.new_rule_descendant_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_33_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EntryScope(tm0, tm1) in self.entry_scope.iter_dirty() {
                #[allow(unused_variables)]
                for EntryScope(_, tm2) in self.entry_scope.iter_all_0(tm0) {
                    delta.new_scope_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_34_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ExitScope(tm0, tm1) in self.exit_scope.iter_dirty() {
                #[allow(unused_variables)]
                for ExitScope(_, tm2) in self.exit_scope.iter_all_0(tm0) {
                    delta.new_scope_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_35_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorEnum(tm0, tm1) in self.ctor_enum.iter_dirty() {
                #[allow(unused_variables)]
                for CtorEnum(_, tm2) in self.ctor_enum.iter_all_0(tm0) {
                    delta.new_enum_decl_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_36_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorsEnum(tm0, tm1) in self.ctors_enum.iter_dirty() {
                #[allow(unused_variables)]
                for CtorsEnum(_, tm2) in self.ctors_enum.iter_all_0(tm0) {
                    delta.new_enum_decl_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_37_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CasesDiscriminee(tm0, tm1) in self.cases_discriminee.iter_dirty() {
                #[allow(unused_variables)]
                for CasesDiscriminee(_, tm2) in self.cases_discriminee.iter_all_0(tm0) {
                    delta.new_term_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_38_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CaseDiscriminee(tm0, tm1) in self.case_discriminee.iter_dirty() {
                #[allow(unused_variables)]
                for CaseDiscriminee(_, tm2) in self.case_discriminee.iter_all_0(tm0) {
                    delta.new_term_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_39_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseEqualityAtom(tm0, tm1) in
                self.desugared_case_equality_atom.iter_dirty()
            {
                #[allow(unused_variables)]
                for DesugaredCaseEqualityAtom(_, tm2) in
                    self.desugared_case_equality_atom.iter_all_0(tm0)
                {
                    delta.new_if_atom_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_40_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseEqualityStmt(tm0, tm1) in
                self.desugared_case_equality_stmt.iter_dirty()
            {
                #[allow(unused_variables)]
                for DesugaredCaseEqualityStmt(_, tm2) in
                    self.desugared_case_equality_stmt.iter_all_0(tm0)
                {
                    delta.new_stmt_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_41_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseBlock(tm0, tm1) in self.desugared_case_block.iter_dirty() {
                #[allow(unused_variables)]
                for DesugaredCaseBlock(_, tm2) in self.desugared_case_block.iter_all_0(tm0) {
                    delta.new_stmt_list_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_42_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseBlockList(tm0, tm1) in self.desugared_case_block_list.iter_dirty() {
                #[allow(unused_variables)]
                for DesugaredCaseBlockList(_, tm2) in self.desugared_case_block_list.iter_all_0(tm0)
                {
                    delta.new_stmt_block_list_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_43_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticType(tm0, tm1) in self.semantic_type.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticType(_, tm2) in self.semantic_type.iter_all_0(tm0) {
                    delta.new_type_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_44_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticArgTypes(tm0, tm1) in self.semantic_arg_types.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticArgTypes(_, tm2) in self.semantic_arg_types.iter_all_0(tm0) {
                    delta.new_type_list_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_45_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticPred(tm0, tm1) in self.semantic_pred.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticPred(_, tm2) in self.semantic_pred.iter_all_0(tm0) {
                    delta.new_pred_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_46_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredArity(tm0, tm1) in self.pred_arity.iter_dirty() {
                #[allow(unused_variables)]
                for PredArity(_, tm2) in self.pred_arity.iter_all_0(tm0) {
                    delta.new_type_list_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_47_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticFunc(tm0, tm1) in self.semantic_func.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticFunc(_, tm2) in self.semantic_func.iter_all_0(tm0) {
                    delta.new_func_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_48_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Domain(tm0, tm1) in self.domain.iter_dirty() {
                #[allow(unused_variables)]
                for Domain(_, tm2) in self.domain.iter_all_0(tm0) {
                    delta.new_type_list_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_49_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Codomain(tm0, tm1) in self.codomain.iter_dirty() {
                #[allow(unused_variables)]
                for Codomain(_, tm2) in self.codomain.iter_all_0(tm0) {
                    delta.new_type_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_50_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Arity(tm0, tm1) in self.arity.iter_dirty() {
                #[allow(unused_variables)]
                for Arity(_, tm2) in self.arity.iter_all_0(tm0) {
                    delta.new_type_list_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_51_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Var(tm0, tm1, tm2) in self.var.iter_dirty() {
                #[allow(unused_variables)]
                for Var(_, _, tm3) in self.var.iter_all_0_1(tm0, tm1) {
                    delta.new_el_equalities.push((tm2, tm3));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_52_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElStructure(tm0, tm1) in self.el_structure.iter_dirty() {
                #[allow(unused_variables)]
                for ElStructure(_, tm2) in self.el_structure.iter_all_0(tm0) {
                    delta.new_structure_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_53_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElsStructure(tm0, tm1) in self.els_structure.iter_dirty() {
                #[allow(unused_variables)]
                for ElsStructure(_, tm2) in self.els_structure.iter_all_0(tm0) {
                    delta.new_structure_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_54_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncApp(tm0, tm1, tm2) in self.func_app.iter_dirty() {
                #[allow(unused_variables)]
                for FuncApp(_, _, tm3) in self.func_app.iter_all_0_1(tm0, tm1) {
                    delta.new_el_equalities.push((tm2, tm3));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_55_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Dom(tm0, tm1) in self.dom.iter_dirty() {
                #[allow(unused_variables)]
                for Dom(_, tm2) in self.dom.iter_all_0(tm0) {
                    delta.new_structure_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_56_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Cod(tm0, tm1) in self.cod.iter_dirty() {
                #[allow(unused_variables)]
                for Cod(_, tm2) in self.cod.iter_all_0(tm0) {
                    delta.new_structure_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_57_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEl(tm0, tm1, tm2) in self.map_el.iter_dirty() {
                #[allow(unused_variables)]
                for MapEl(_, _, tm3) in self.map_el.iter_all_0_1(tm0, tm1) {
                    delta.new_el_equalities.push((tm2, tm3));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_58_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEls(tm0, tm1, tm2) in self.map_els.iter_dirty() {
                #[allow(unused_variables)]
                for MapEls(_, _, tm3) in self.map_els.iter_all_0_1(tm0, tm1) {
                    delta.new_el_list_equalities.push((tm2, tm3));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_59_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeSymbol(tm0) in self.type_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for TypeSymbol(tm1) in self.type_symbol.iter_all() {
                    delta.new_symbol_kind_equalities.push((tm0, tm1));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_60_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredSymbol(tm0) in self.pred_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for PredSymbol(tm1) in self.pred_symbol.iter_all() {
                    delta.new_symbol_kind_equalities.push((tm0, tm1));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_61_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncSymbol(tm0) in self.func_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for FuncSymbol(tm1) in self.func_symbol.iter_all() {
                    delta.new_symbol_kind_equalities.push((tm0, tm1));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_62_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleSymbol(tm0) in self.rule_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for RuleSymbol(tm1) in self.rule_symbol.iter_all() {
                    delta.new_symbol_kind_equalities.push((tm0, tm1));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_63_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumSymbol(tm0) in self.enum_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for EnumSymbol(tm1) in self.enum_symbol.iter_all() {
                    delta.new_symbol_kind_equalities.push((tm0, tm1));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_64_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorSymbol(tm0) in self.ctor_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for CtorSymbol(tm1) in self.ctor_symbol.iter_all() {
                    delta.new_symbol_kind_equalities.push((tm0, tm1));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_65_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Zero(tm0) in self.zero.iter_dirty() {
                #[allow(unused_variables)]
                for Zero(tm1) in self.zero.iter_all() {
                    delta.new_nat_equalities.push((tm0, tm1));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_66_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Succ(tm0, tm1) in self.succ.iter_dirty() {
                #[allow(unused_variables)]
                for Succ(_, tm2) in self.succ.iter_all_0(tm0) {
                    delta.new_nat_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_67_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeListLen(tm0, tm1) in self.type_list_len.iter_dirty() {
                #[allow(unused_variables)]
                for TypeListLen(_, tm2) in self.type_list_len.iter_all_0(tm0) {
                    delta.new_nat_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_68_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermListLen(tm0, tm1) in self.term_list_len.iter_dirty() {
                #[allow(unused_variables)]
                for TermListLen(_, tm2) in self.term_list_len.iter_all_0(tm0) {
                    delta.new_nat_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_69_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BeforeRuleStructure(tm0, tm1) in self.before_rule_structure.iter_dirty() {
                #[allow(unused_variables)]
                for BeforeRuleStructure(_, tm2) in self.before_rule_structure.iter_all_0(tm0) {
                    delta.new_structure_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_70_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfAtomMorphism(tm0, tm1, tm2) in self.if_atom_morphism.iter_dirty() {
                #[allow(unused_variables)]
                for IfAtomMorphism(_, _, tm3) in self.if_atom_morphism.iter_all_0_1(tm0, tm1) {
                    delta.new_morphism_equalities.push((tm2, tm3));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_71_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenAtomMorphism(tm0, tm1, tm2) in self.then_atom_morphism.iter_dirty() {
                #[allow(unused_variables)]
                for ThenAtomMorphism(_, _, tm3) in self.then_atom_morphism.iter_all_0_1(tm0, tm1) {
                    delta.new_morphism_equalities.push((tm2, tm3));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_72_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BranchStmtMorphism(tm0, tm1, tm2) in self.branch_stmt_morphism.iter_dirty() {
                #[allow(unused_variables)]
                for BranchStmtMorphism(_, _, tm3) in
                    self.branch_stmt_morphism.iter_all_0_1(tm0, tm1)
                {
                    delta.new_morphism_equalities.push((tm2, tm3));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_73_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchStmtMorphism(tm0, tm1, tm2) in self.match_stmt_morphism.iter_dirty() {
                #[allow(unused_variables)]
                for MatchStmtMorphism(_, _, tm3) in self.match_stmt_morphism.iter_all_0_1(tm0, tm1)
                {
                    delta.new_morphism_equalities.push((tm2, tm3));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_74_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticName(tm0, tm1, tm2) in self.semantic_name.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticName(_, _, tm3) in self.semantic_name.iter_all_0_1(tm0, tm1) {
                    delta.new_el_name_equalities.push((tm2, tm3));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_75_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(tm0, tm1, tm2) in self.semantic_el.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticEl(_, _, tm3) in self.semantic_el.iter_all_0_1(tm0, tm1) {
                    delta.new_el_equalities.push((tm2, tm3));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_76_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEls(tm0, tm1, tm2) in self.semantic_els.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticEls(_, _, tm3) in self.semantic_els.iter_all_0_1(tm0, tm1) {
                    delta.new_el_list_equalities.push((tm2, tm3));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_77_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for WildcardName(tm0, tm1) in self.wildcard_name.iter_dirty() {
                #[allow(unused_variables)]
                for WildcardName(_, tm2) in self.wildcard_name.iter_all_0(tm0) {
                    delta.new_el_name_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_78_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchCasePatternCtor(tm0, tm1) in self.match_case_pattern_ctor.iter_dirty() {
                #[allow(unused_variables)]
                for MatchCasePatternCtor(_, tm2) in self.match_case_pattern_ctor.iter_all_0(tm0) {
                    delta.new_ctor_decl_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_79_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CasesDeterminedEnum(tm0, tm1) in self.cases_determined_enum.iter_dirty() {
                #[allow(unused_variables)]
                for CasesDeterminedEnum(_, tm2) in self.cases_determined_enum.iter_all_0(tm0) {
                    delta.new_enum_decl_node_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_80_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilTypeList(tm0) in self.nil_type_list.iter_dirty() {
                #[allow(unused_variables)]
                for NilTypeList(tm1) in self.nil_type_list.iter_all() {
                    delta.new_type_list_equalities.push((tm0, tm1));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_81_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsTypeList(tm0, tm1, tm2) in self.cons_type_list.iter_dirty() {
                #[allow(unused_variables)]
                for ConsTypeList(_, _, tm3) in self.cons_type_list.iter_all_0_1(tm0, tm1) {
                    delta.new_type_list_equalities.push((tm2, tm3));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_82_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SnocTypeList(tm0, tm1, tm2) in self.snoc_type_list.iter_dirty() {
                #[allow(unused_variables)]
                for SnocTypeList(_, _, tm3) in self.snoc_type_list.iter_all_0_1(tm0, tm1) {
                    delta.new_type_list_equalities.push((tm2, tm3));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_83_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredRel(tm0, tm1) in self.pred_rel.iter_dirty() {
                #[allow(unused_variables)]
                for PredRel(_, tm2) in self.pred_rel.iter_all_0(tm0) {
                    delta.new_rel_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_84_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncRel(tm0, tm1) in self.func_rel.iter_dirty() {
                #[allow(unused_variables)]
                for FuncRel(_, tm2) in self.func_rel.iter_all_0(tm0) {
                    delta.new_rel_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_85_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilElList(tm0, tm1) in self.nil_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for NilElList(_, tm2) in self.nil_el_list.iter_all_0(tm0) {
                    delta.new_el_list_equalities.push((tm1, tm2));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_86_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsElList(tm0, tm1, tm2) in self.cons_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for ConsElList(_, _, tm3) in self.cons_el_list.iter_all_0_1(tm0, tm1) {
                    delta.new_el_list_equalities.push((tm2, tm3));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn implicit_functionality_87_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SnocElList(tm0, tm1, tm2) in self.snoc_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for SnocElList(_, _, tm3) in self.snoc_el_list.iter_all_0_1(tm0, tm1) {
                    delta.new_el_list_equalities.push((tm2, tm3));
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn real_virt_ident_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.real_virt_ident_total_1(delta);
            self.real_virt_ident_total_2(delta);
            self.real_virt_ident_total_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn real_virt_ident_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn real_virt_ident_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.ident_dirty.iter().copied() {
                self.real_virt_ident_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn real_virt_ident_total_3(&self, delta: &mut ModelDelta, tm0: Ident) {
        for _ in [()] {
            self.real_virt_ident_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn real_virt_ident_total_4(&self, delta: &mut ModelDelta, tm0: Ident) {
        for _ in [()] {
            let tm1 = match self.real_virt_ident.iter_all_0(tm0).next() {
                Some(RealVirtIdent(_, res)) => res,
                None => {
                    delta.new_real_virt_ident_def.push(RealVirtIdentArgs(tm0));
                    break;
                }
            };

            self.real_virt_ident_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn real_virt_ident_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RealVirtIdent(tm0, tm1) in self.real_virt_ident.iter_dirty() {
                self.real_virt_ident_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn real_virt_ident_total_6(&self, delta: &mut ModelDelta, tm0: Ident, tm1: VirtIdent) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn virt_real_ident_retraction_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.virt_real_ident_retraction_1(delta);
            self.virt_real_ident_retraction_2(delta);
        }
    }

    #[allow(unused_variables)]
    fn virt_real_ident_retraction_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn virt_real_ident_retraction_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RealVirtIdent(tm0, tm1) in self.real_virt_ident.iter_dirty() {
                self.virt_real_ident_retraction_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn virt_real_ident_retraction_3(&self, delta: &mut ModelDelta, tm0: Ident, tm1: VirtIdent) {
        for _ in [()] {
            let exists_already = self.virt_real_ident.iter_all_0_1(tm1, tm0).next().is_some();
            if !exists_already {
                delta.new_virt_real_ident.push(VirtRealIdent(tm1, tm0));
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_rule_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.rule_descendant_rule_total_1(delta);
            self.rule_descendant_rule_total_2(delta);
            self.rule_descendant_rule_total_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_rule_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_rule_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.rule_decl_node_dirty.iter().copied() {
                self.rule_descendant_rule_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_rule_total_3(&self, delta: &mut ModelDelta, tm0: RuleDeclNode) {
        for _ in [()] {
            self.rule_descendant_rule_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_rule_total_4(&self, delta: &mut ModelDelta, tm0: RuleDeclNode) {
        for _ in [()] {
            let tm1 = match self.rule_descendant_rule.iter_all_0(tm0).next() {
                Some(RuleDescendantRule(_, res)) => res,
                None => {
                    delta
                        .new_rule_descendant_rule_def
                        .push(RuleDescendantRuleArgs(tm0));
                    break;
                }
            };

            self.rule_descendant_rule_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_rule_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantRule(tm0, tm1) in self.rule_descendant_rule.iter_dirty() {
                self.rule_descendant_rule_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_rule_total_6(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDeclNode,
        tm1: RuleDescendantNode,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_term_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.rule_descendant_term_total_1(delta);
            self.rule_descendant_term_total_2(delta);
            self.rule_descendant_term_total_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_term_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_term_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.term_node_dirty.iter().copied() {
                self.rule_descendant_term_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_term_total_3(&self, delta: &mut ModelDelta, tm0: TermNode) {
        for _ in [()] {
            self.rule_descendant_term_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_term_total_4(&self, delta: &mut ModelDelta, tm0: TermNode) {
        for _ in [()] {
            let tm1 = match self.rule_descendant_term.iter_all_0(tm0).next() {
                Some(RuleDescendantTerm(_, res)) => res,
                None => {
                    delta
                        .new_rule_descendant_term_def
                        .push(RuleDescendantTermArgs(tm0));
                    break;
                }
            };

            self.rule_descendant_term_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_term_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(tm0, tm1) in self.rule_descendant_term.iter_dirty() {
                self.rule_descendant_term_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_term_total_6(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: RuleDescendantNode,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_term_list_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.rule_descendant_term_list_total_1(delta);
            self.rule_descendant_term_list_total_2(delta);
            self.rule_descendant_term_list_total_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_term_list_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_term_list_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.term_list_node_dirty.iter().copied() {
                self.rule_descendant_term_list_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_term_list_total_3(&self, delta: &mut ModelDelta, tm0: TermListNode) {
        for _ in [()] {
            self.rule_descendant_term_list_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_term_list_total_4(&self, delta: &mut ModelDelta, tm0: TermListNode) {
        for _ in [()] {
            let tm1 = match self.rule_descendant_term_list.iter_all_0(tm0).next() {
                Some(RuleDescendantTermList(_, res)) => res,
                None => {
                    delta
                        .new_rule_descendant_term_list_def
                        .push(RuleDescendantTermListArgs(tm0));
                    break;
                }
            };

            self.rule_descendant_term_list_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_term_list_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTermList(tm0, tm1) in self.rule_descendant_term_list.iter_dirty() {
                self.rule_descendant_term_list_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_term_list_total_6(
        &self,
        delta: &mut ModelDelta,
        tm0: TermListNode,
        tm1: RuleDescendantNode,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_opt_term_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.rule_descendant_opt_term_total_1(delta);
            self.rule_descendant_opt_term_total_2(delta);
            self.rule_descendant_opt_term_total_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_opt_term_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_opt_term_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.opt_term_node_dirty.iter().copied() {
                self.rule_descendant_opt_term_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_opt_term_total_3(&self, delta: &mut ModelDelta, tm0: OptTermNode) {
        for _ in [()] {
            self.rule_descendant_opt_term_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_opt_term_total_4(&self, delta: &mut ModelDelta, tm0: OptTermNode) {
        for _ in [()] {
            let tm1 = match self.rule_descendant_opt_term.iter_all_0(tm0).next() {
                Some(RuleDescendantOptTerm(_, res)) => res,
                None => {
                    delta
                        .new_rule_descendant_opt_term_def
                        .push(RuleDescendantOptTermArgs(tm0));
                    break;
                }
            };

            self.rule_descendant_opt_term_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_opt_term_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantOptTerm(tm0, tm1) in self.rule_descendant_opt_term.iter_dirty() {
                self.rule_descendant_opt_term_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_opt_term_total_6(
        &self,
        delta: &mut ModelDelta,
        tm0: OptTermNode,
        tm1: RuleDescendantNode,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_if_atom_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.rule_descendant_if_atom_total_1(delta);
            self.rule_descendant_if_atom_total_2(delta);
            self.rule_descendant_if_atom_total_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_if_atom_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_if_atom_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.if_atom_node_dirty.iter().copied() {
                self.rule_descendant_if_atom_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_if_atom_total_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode) {
        for _ in [()] {
            self.rule_descendant_if_atom_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_if_atom_total_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode) {
        for _ in [()] {
            let tm1 = match self.rule_descendant_if_atom.iter_all_0(tm0).next() {
                Some(RuleDescendantIfAtom(_, res)) => res,
                None => {
                    delta
                        .new_rule_descendant_if_atom_def
                        .push(RuleDescendantIfAtomArgs(tm0));
                    break;
                }
            };

            self.rule_descendant_if_atom_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_if_atom_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantIfAtom(tm0, tm1) in self.rule_descendant_if_atom.iter_dirty() {
                self.rule_descendant_if_atom_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_if_atom_total_6(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: RuleDescendantNode,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_then_atom_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.rule_descendant_then_atom_total_1(delta);
            self.rule_descendant_then_atom_total_2(delta);
            self.rule_descendant_then_atom_total_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_then_atom_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_then_atom_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.then_atom_node_dirty.iter().copied() {
                self.rule_descendant_then_atom_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_then_atom_total_3(&self, delta: &mut ModelDelta, tm0: ThenAtomNode) {
        for _ in [()] {
            self.rule_descendant_then_atom_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_then_atom_total_4(&self, delta: &mut ModelDelta, tm0: ThenAtomNode) {
        for _ in [()] {
            let tm1 = match self.rule_descendant_then_atom.iter_all_0(tm0).next() {
                Some(RuleDescendantThenAtom(_, res)) => res,
                None => {
                    delta
                        .new_rule_descendant_then_atom_def
                        .push(RuleDescendantThenAtomArgs(tm0));
                    break;
                }
            };

            self.rule_descendant_then_atom_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_then_atom_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantThenAtom(tm0, tm1) in self.rule_descendant_then_atom.iter_dirty() {
                self.rule_descendant_then_atom_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_then_atom_total_6(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: RuleDescendantNode,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_match_case_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.rule_descendant_match_case_total_1(delta);
            self.rule_descendant_match_case_total_2(delta);
            self.rule_descendant_match_case_total_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_match_case_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_match_case_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.match_case_node_dirty.iter().copied() {
                self.rule_descendant_match_case_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_match_case_total_3(&self, delta: &mut ModelDelta, tm0: MatchCaseNode) {
        for _ in [()] {
            self.rule_descendant_match_case_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_match_case_total_4(&self, delta: &mut ModelDelta, tm0: MatchCaseNode) {
        for _ in [()] {
            let tm1 = match self.rule_descendant_match_case.iter_all_0(tm0).next() {
                Some(RuleDescendantMatchCase(_, res)) => res,
                None => {
                    delta
                        .new_rule_descendant_match_case_def
                        .push(RuleDescendantMatchCaseArgs(tm0));
                    break;
                }
            };

            self.rule_descendant_match_case_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_match_case_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantMatchCase(tm0, tm1) in self.rule_descendant_match_case.iter_dirty() {
                self.rule_descendant_match_case_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_match_case_total_6(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: RuleDescendantNode,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_match_case_list_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.rule_descendant_match_case_list_total_1(delta);
            self.rule_descendant_match_case_list_total_2(delta);
            self.rule_descendant_match_case_list_total_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_match_case_list_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_match_case_list_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.match_case_list_node_dirty.iter().copied() {
                self.rule_descendant_match_case_list_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_match_case_list_total_3(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
    ) {
        for _ in [()] {
            self.rule_descendant_match_case_list_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_match_case_list_total_4(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
    ) {
        for _ in [()] {
            let tm1 = match self.rule_descendant_match_case_list.iter_all_0(tm0).next() {
                Some(RuleDescendantMatchCaseList(_, res)) => res,
                None => {
                    delta
                        .new_rule_descendant_match_case_list_def
                        .push(RuleDescendantMatchCaseListArgs(tm0));
                    break;
                }
            };

            self.rule_descendant_match_case_list_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_match_case_list_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantMatchCaseList(tm0, tm1) in
                self.rule_descendant_match_case_list.iter_dirty()
            {
                self.rule_descendant_match_case_list_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_match_case_list_total_6(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: RuleDescendantNode,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.rule_descendant_stmt_total_1(delta);
            self.rule_descendant_stmt_total_2(delta);
            self.rule_descendant_stmt_total_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.stmt_node_dirty.iter().copied() {
                self.rule_descendant_stmt_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_total_3(&self, delta: &mut ModelDelta, tm0: StmtNode) {
        for _ in [()] {
            self.rule_descendant_stmt_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_total_4(&self, delta: &mut ModelDelta, tm0: StmtNode) {
        for _ in [()] {
            let tm1 = match self.rule_descendant_stmt.iter_all_0(tm0).next() {
                Some(RuleDescendantStmt(_, res)) => res,
                None => {
                    delta
                        .new_rule_descendant_stmt_def
                        .push(RuleDescendantStmtArgs(tm0));
                    break;
                }
            };

            self.rule_descendant_stmt_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmt(tm0, tm1) in self.rule_descendant_stmt.iter_dirty() {
                self.rule_descendant_stmt_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_total_6(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: RuleDescendantNode,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_list_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.rule_descendant_stmt_list_total_1(delta);
            self.rule_descendant_stmt_list_total_2(delta);
            self.rule_descendant_stmt_list_total_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_list_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_list_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.stmt_list_node_dirty.iter().copied() {
                self.rule_descendant_stmt_list_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_list_total_3(&self, delta: &mut ModelDelta, tm0: StmtListNode) {
        for _ in [()] {
            self.rule_descendant_stmt_list_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_list_total_4(&self, delta: &mut ModelDelta, tm0: StmtListNode) {
        for _ in [()] {
            let tm1 = match self.rule_descendant_stmt_list.iter_all_0(tm0).next() {
                Some(RuleDescendantStmtList(_, res)) => res,
                None => {
                    delta
                        .new_rule_descendant_stmt_list_def
                        .push(RuleDescendantStmtListArgs(tm0));
                    break;
                }
            };

            self.rule_descendant_stmt_list_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_list_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtList(tm0, tm1) in self.rule_descendant_stmt_list.iter_dirty() {
                self.rule_descendant_stmt_list_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_list_total_6(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtListNode,
        tm1: RuleDescendantNode,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_block_list_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.rule_descendant_stmt_block_list_total_1(delta);
            self.rule_descendant_stmt_block_list_total_2(delta);
            self.rule_descendant_stmt_block_list_total_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_block_list_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_block_list_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.stmt_block_list_node_dirty.iter().copied() {
                self.rule_descendant_stmt_block_list_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_block_list_total_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtBlockListNode,
    ) {
        for _ in [()] {
            self.rule_descendant_stmt_block_list_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_block_list_total_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtBlockListNode,
    ) {
        for _ in [()] {
            let tm1 = match self.rule_descendant_stmt_block_list.iter_all_0(tm0).next() {
                Some(RuleDescendantStmtBlockList(_, res)) => res,
                None => {
                    delta
                        .new_rule_descendant_stmt_block_list_def
                        .push(RuleDescendantStmtBlockListArgs(tm0));
                    break;
                }
            };

            self.rule_descendant_stmt_block_list_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_block_list_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtBlockList(tm0, tm1) in
                self.rule_descendant_stmt_block_list.iter_dirty()
            {
                self.rule_descendant_stmt_block_list_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_descendant_stmt_block_list_total_6(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtBlockListNode,
        tm1: RuleDescendantNode,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scope_extension_vars_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scope_extension_vars_1(delta);
            self.scope_extension_vars_2(delta);
            self.scope_extension_vars_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_vars_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scope_extension_vars_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for VarInScope(tm0, tm1) in self.var_in_scope.iter_dirty() {
                self.scope_extension_vars_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_vars_3(&self, delta: &mut ModelDelta, tm0: VirtIdent, tm1: Scope) {
        for _ in [()] {
            self.scope_extension_vars_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_vars_4(&self, delta: &mut ModelDelta, tm0: VirtIdent, tm1: Scope) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ScopeExtension(_, tm2) in self.scope_extension.iter_all_0(tm1) {
                self.scope_extension_vars_6(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_vars_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ScopeExtension(tm1, tm2) in self.scope_extension.iter_dirty() {
                #[allow(unused_variables)]
                for VarInScope(tm0, _) in self.var_in_scope.iter_all_1(tm1) {
                    self.scope_extension_vars_6(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_vars_6(
        &self,
        delta: &mut ModelDelta,
        tm0: VirtIdent,
        tm1: Scope,
        tm2: Scope,
    ) {
        for _ in [()] {
            let exists_already = self.var_in_scope.iter_all_0_1(tm0, tm2).next().is_some();
            if !exists_already {
                delta.new_var_in_scope.push(VarInScope(tm0, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn entry_exit_scope_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.entry_exit_scope_total_1(delta);
            self.entry_exit_scope_total_2(delta);
            self.entry_exit_scope_total_5(delta);
            self.entry_exit_scope_total_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn entry_exit_scope_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn entry_exit_scope_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.rule_descendant_node_dirty.iter().copied() {
                self.entry_exit_scope_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn entry_exit_scope_total_3(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode) {
        for _ in [()] {
            self.entry_exit_scope_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn entry_exit_scope_total_4(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode) {
        for _ in [()] {
            let tm1 = match self.entry_scope.iter_all_0(tm0).next() {
                Some(EntryScope(_, res)) => res,
                None => {
                    delta.new_entry_scope_def.push(EntryScopeArgs(tm0));
                    break;
                }
            };

            self.entry_exit_scope_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn entry_exit_scope_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EntryScope(tm0, tm1) in self.entry_scope.iter_dirty() {
                self.entry_exit_scope_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn entry_exit_scope_total_6(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDescendantNode,
        tm1: Scope,
    ) {
        for _ in [()] {
            self.entry_exit_scope_total_7(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn entry_exit_scope_total_7(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDescendantNode,
        tm1: Scope,
    ) {
        for _ in [()] {
            let tm2 = match self.exit_scope.iter_all_0(tm0).next() {
                Some(ExitScope(_, res)) => res,
                None => {
                    delta.new_exit_scope_def.push(ExitScopeArgs(tm0));
                    break;
                }
            };

            self.entry_exit_scope_total_9(delta, tm1, tm0, tm2);
        }
    }

    #[allow(unused_variables)]
    fn entry_exit_scope_total_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ExitScope(tm0, tm2) in self.exit_scope.iter_dirty() {
                #[allow(unused_variables)]
                for EntryScope(_, tm1) in self.entry_scope.iter_all_0(tm0) {
                    self.entry_exit_scope_total_9(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn entry_exit_scope_total_9(
        &self,
        delta: &mut ModelDelta,
        tm1: Scope,
        tm0: RuleDescendantNode,
        tm2: Scope,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn exit_scope_extends_entry_scope_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.exit_scope_extends_entry_scope_1(delta);
            self.exit_scope_extends_entry_scope_2(delta);
            self.exit_scope_extends_entry_scope_5(delta);
            self.exit_scope_extends_entry_scope_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn exit_scope_extends_entry_scope_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn exit_scope_extends_entry_scope_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.rule_descendant_node_dirty.iter().copied() {
                self.exit_scope_extends_entry_scope_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn exit_scope_extends_entry_scope_3(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode) {
        for _ in [()] {
            self.exit_scope_extends_entry_scope_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn exit_scope_extends_entry_scope_4(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EntryScope(_, tm1) in self.entry_scope.iter_all_0(tm0) {
                self.exit_scope_extends_entry_scope_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn exit_scope_extends_entry_scope_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EntryScope(tm0, tm1) in self.entry_scope.iter_dirty() {
                self.exit_scope_extends_entry_scope_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn exit_scope_extends_entry_scope_6(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDescendantNode,
        tm1: Scope,
    ) {
        for _ in [()] {
            self.exit_scope_extends_entry_scope_7(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn exit_scope_extends_entry_scope_7(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDescendantNode,
        tm1: Scope,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ExitScope(_, tm2) in self.exit_scope.iter_all_0(tm0) {
                self.exit_scope_extends_entry_scope_9(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn exit_scope_extends_entry_scope_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ExitScope(tm0, tm2) in self.exit_scope.iter_dirty() {
                #[allow(unused_variables)]
                for EntryScope(_, tm1) in self.entry_scope.iter_all_0(tm0) {
                    self.exit_scope_extends_entry_scope_9(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn exit_scope_extends_entry_scope_9(
        &self,
        delta: &mut ModelDelta,
        tm1: Scope,
        tm0: RuleDescendantNode,
        tm2: Scope,
    ) {
        for _ in [()] {
            let exists_already = self.scope_extension.iter_all_0_1(tm1, tm2).next().is_some();
            if !exists_already {
                delta.new_scope_extension.push(ScopeExtension(tm1, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_single_child_scopes_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scope_single_child_scopes_1(delta);
            self.scope_single_child_scopes_2(delta);
            self.scope_single_child_scopes_5(delta);
            self.scope_single_child_scopes_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn scope_single_child_scopes_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scope_single_child_scopes_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ScopeSingleChild(tm0, tm1) in self.scope_single_child.iter_dirty() {
                self.scope_single_child_scopes_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_single_child_scopes_3(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDescendantNode,
        tm1: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scope_single_child_scopes_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn scope_single_child_scopes_4(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDescendantNode,
        tm1: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EntryScope(_, tm2) in self.entry_scope.iter_all_0(tm1) {
                self.scope_single_child_scopes_6(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_single_child_scopes_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EntryScope(tm1, tm2) in self.entry_scope.iter_dirty() {
                #[allow(unused_variables)]
                for ScopeSingleChild(tm0, _) in self.scope_single_child.iter_all_1(tm1) {
                    self.scope_single_child_scopes_6(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_single_child_scopes_6(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDescendantNode,
        tm1: RuleDescendantNode,
        tm2: Scope,
    ) {
        for _ in [()] {
            self.scope_single_child_scopes_7(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scope_single_child_scopes_7(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDescendantNode,
        tm1: RuleDescendantNode,
        tm2: Scope,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ExitScope(_, tm3) in self.exit_scope.iter_all_0(tm1) {
                self.scope_single_child_scopes_9(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_single_child_scopes_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ExitScope(tm1, tm3) in self.exit_scope.iter_dirty() {
                #[allow(unused_variables)]
                for EntryScope(_, tm2) in self.entry_scope.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for ScopeSingleChild(tm0, _) in self.scope_single_child.iter_all_1(tm1) {
                        self.scope_single_child_scopes_9(delta, tm0, tm2, tm1, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_single_child_scopes_9(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDescendantNode,
        tm2: Scope,
        tm1: RuleDescendantNode,
        tm3: Scope,
    ) {
        for _ in [()] {
            let exists_already = self.entry_scope.iter_all_0_1(tm0, tm2).next().is_some();
            if !exists_already {
                delta.new_entry_scope.push(EntryScope(tm0, tm2));
            }

            let exists_already = self.exit_scope.iter_all_0_1(tm0, tm3).next().is_some();
            if !exists_already {
                delta.new_exit_scope.push(ExitScope(tm0, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_parent_first_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scope_extension_siblings_parent_first_1(delta);
            self.scope_extension_siblings_parent_first_2(delta);
            self.scope_extension_siblings_parent_first_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_parent_first_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_parent_first_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ScopeExtensionSiblings(tm0, tm1, tm2) in self.scope_extension_siblings.iter_dirty()
            {
                self.scope_extension_siblings_parent_first_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_parent_first_3(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDescendantNode,
        tm1: RuleDescendantNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scope_extension_siblings_parent_first_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_parent_first_4(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDescendantNode,
        tm1: RuleDescendantNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EntryScope(_, tm3) in self.entry_scope.iter_all_0(tm2) {
                self.scope_extension_siblings_parent_first_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_parent_first_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EntryScope(tm2, tm3) in self.entry_scope.iter_dirty() {
                #[allow(unused_variables)]
                for ScopeExtensionSiblings(tm0, tm1, _) in
                    self.scope_extension_siblings.iter_all_2(tm2)
                {
                    self.scope_extension_siblings_parent_first_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_parent_first_6(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDescendantNode,
        tm1: RuleDescendantNode,
        tm2: RuleDescendantNode,
        tm3: Scope,
    ) {
        for _ in [()] {
            let exists_already = self.entry_scope.iter_all_0_1(tm0, tm3).next().is_some();
            if !exists_already {
                delta.new_entry_scope.push(EntryScope(tm0, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_first_second_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scope_extension_siblings_first_second_1(delta);
            self.scope_extension_siblings_first_second_2(delta);
            self.scope_extension_siblings_first_second_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_first_second_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_first_second_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ScopeExtensionSiblings(tm0, tm1, tm2) in self.scope_extension_siblings.iter_dirty()
            {
                self.scope_extension_siblings_first_second_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_first_second_3(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDescendantNode,
        tm1: RuleDescendantNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scope_extension_siblings_first_second_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_first_second_4(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDescendantNode,
        tm1: RuleDescendantNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ExitScope(_, tm3) in self.exit_scope.iter_all_0(tm0) {
                self.scope_extension_siblings_first_second_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_first_second_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ExitScope(tm0, tm3) in self.exit_scope.iter_dirty() {
                #[allow(unused_variables)]
                for ScopeExtensionSiblings(_, tm1, tm2) in
                    self.scope_extension_siblings.iter_all_0(tm0)
                {
                    self.scope_extension_siblings_first_second_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_first_second_6(
        &self,
        delta: &mut ModelDelta,
        tm1: RuleDescendantNode,
        tm2: RuleDescendantNode,
        tm0: RuleDescendantNode,
        tm3: Scope,
    ) {
        for _ in [()] {
            let exists_already = self.entry_scope.iter_all_0_1(tm1, tm3).next().is_some();
            if !exists_already {
                delta.new_entry_scope.push(EntryScope(tm1, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_second_parent_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scope_extension_siblings_second_parent_1(delta);
            self.scope_extension_siblings_second_parent_2(delta);
            self.scope_extension_siblings_second_parent_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_second_parent_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_second_parent_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ScopeExtensionSiblings(tm0, tm1, tm2) in self.scope_extension_siblings.iter_dirty()
            {
                self.scope_extension_siblings_second_parent_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_second_parent_3(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDescendantNode,
        tm1: RuleDescendantNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scope_extension_siblings_second_parent_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_second_parent_4(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDescendantNode,
        tm1: RuleDescendantNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ExitScope(_, tm3) in self.exit_scope.iter_all_0(tm1) {
                self.scope_extension_siblings_second_parent_6(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_second_parent_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ExitScope(tm1, tm3) in self.exit_scope.iter_dirty() {
                #[allow(unused_variables)]
                for ScopeExtensionSiblings(tm0, _, tm2) in
                    self.scope_extension_siblings.iter_all_1(tm1)
                {
                    self.scope_extension_siblings_second_parent_6(delta, tm0, tm2, tm1, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scope_extension_siblings_second_parent_6(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDescendantNode,
        tm2: RuleDescendantNode,
        tm1: RuleDescendantNode,
        tm3: Scope,
    ) {
        for _ in [()] {
            let exists_already = self.exit_scope.iter_all_0_1(tm2, tm3).next().is_some();
            if !exists_already {
                delta.new_exit_scope.push(ExitScope(tm2, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_rule_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_rule_1(delta);
            self.scopes_rule_2(delta);
            self.scopes_rule_5(delta);
            self.scopes_rule_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_rule_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_rule_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDecl(tm0, tm1) in self.rule_decl.iter_dirty() {
                self.scopes_rule_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_rule_3(&self, delta: &mut ModelDelta, tm0: RuleDeclNode, tm1: StmtListNode) {
        for _ in [()] {
            self.scopes_rule_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn scopes_rule_4(&self, delta: &mut ModelDelta, tm0: RuleDeclNode, tm1: StmtListNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantRule(_, tm2) in self.rule_descendant_rule.iter_all_0(tm0) {
                self.scopes_rule_6(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_rule_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantRule(tm0, tm2) in self.rule_descendant_rule.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDecl(_, tm1) in self.rule_decl.iter_all_0(tm0) {
                    self.scopes_rule_6(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_rule_6(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtListNode,
        tm0: RuleDeclNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_rule_7(delta, tm1, tm0, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_rule_7(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtListNode,
        tm0: RuleDeclNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtList(_, tm3) in self.rule_descendant_stmt_list.iter_all_0(tm1) {
                self.scopes_rule_9(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_rule_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtList(tm1, tm3) in self.rule_descendant_stmt_list.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDecl(tm0, _) in self.rule_decl.iter_all_1(tm1) {
                    #[allow(unused_variables)]
                    for RuleDescendantRule(_, tm2) in self.rule_descendant_rule.iter_all_0(tm0) {
                        self.scopes_rule_9(delta, tm0, tm2, tm1, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_rule_9(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDeclNode,
        tm2: RuleDescendantNode,
        tm1: StmtListNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .scope_single_child
                .iter_all_0_1(tm3, tm2)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_scope_single_child
                    .push(ScopeSingleChild(tm3, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_list_cons_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_stmt_list_cons_1(delta);
            self.scopes_stmt_list_cons_2(delta);
            self.scopes_stmt_list_cons_5(delta);
            self.scopes_stmt_list_cons_8(delta);
            self.scopes_stmt_list_cons_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_list_cons_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_stmt_list_cons_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm0, tm1, tm2) in self.cons_stmt_list_node.iter_dirty() {
                self.scopes_stmt_list_cons_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_list_cons_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtListNode,
        tm1: StmtNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            self.scopes_stmt_list_cons_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_list_cons_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtListNode,
        tm1: StmtNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtList(_, tm3) in self.rule_descendant_stmt_list.iter_all_0(tm0) {
                self.scopes_stmt_list_cons_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_list_cons_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtList(tm0, tm3) in self.rule_descendant_stmt_list.iter_dirty() {
                #[allow(unused_variables)]
                for ConsStmtListNode(_, tm1, tm2) in self.cons_stmt_list_node.iter_all_0(tm0) {
                    self.scopes_stmt_list_cons_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_list_cons_6(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtNode,
        tm2: StmtListNode,
        tm0: StmtListNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_stmt_list_cons_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_list_cons_7(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtNode,
        tm2: StmtListNode,
        tm0: StmtListNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmt(_, tm4) in self.rule_descendant_stmt.iter_all_0(tm1) {
                self.scopes_stmt_list_cons_9(delta, tm2, tm0, tm3, tm1, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_list_cons_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmt(tm1, tm4) in self.rule_descendant_stmt.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantStmtList(tm0, tm3) in self.rule_descendant_stmt_list.iter_all() {
                    #[allow(unused_variables)]
                    for ConsStmtListNode(_, _, tm2) in
                        self.cons_stmt_list_node.iter_all_0_1(tm0, tm1)
                    {
                        self.scopes_stmt_list_cons_9(delta, tm2, tm0, tm3, tm1, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_list_cons_9(
        &self,
        delta: &mut ModelDelta,
        tm2: StmtListNode,
        tm0: StmtListNode,
        tm3: RuleDescendantNode,
        tm1: StmtNode,
        tm4: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_stmt_list_cons_10(delta, tm2, tm0, tm3, tm1, tm4);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_list_cons_10(
        &self,
        delta: &mut ModelDelta,
        tm2: StmtListNode,
        tm0: StmtListNode,
        tm3: RuleDescendantNode,
        tm1: StmtNode,
        tm4: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtList(_, tm5) in self.rule_descendant_stmt_list.iter_all_0(tm2) {
                self.scopes_stmt_list_cons_12(delta, tm0, tm3, tm1, tm4, tm2, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_list_cons_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtList(tm2, tm5) in self.rule_descendant_stmt_list.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantStmtList(tm0, tm3) in self.rule_descendant_stmt_list.iter_all() {
                    #[allow(unused_variables)]
                    for ConsStmtListNode(_, tm1, _) in
                        self.cons_stmt_list_node.iter_all_0_2(tm0, tm2)
                    {
                        #[allow(unused_variables)]
                        for RuleDescendantStmt(_, tm4) in self.rule_descendant_stmt.iter_all_0(tm1)
                        {
                            self.scopes_stmt_list_cons_12(delta, tm0, tm3, tm1, tm4, tm2, tm5);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_list_cons_12(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtListNode,
        tm3: RuleDescendantNode,
        tm1: StmtNode,
        tm4: RuleDescendantNode,
        tm2: StmtListNode,
        tm5: RuleDescendantNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .scope_extension_siblings
                .iter_all_0_1_2(tm4, tm5, tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_scope_extension_siblings
                    .push(ScopeExtensionSiblings(tm4, tm5, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_block_list_cons_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_stmt_block_list_cons_1(delta);
            self.scopes_stmt_block_list_cons_2(delta);
            self.scopes_stmt_block_list_cons_5(delta);
            self.scopes_stmt_block_list_cons_8(delta);
            self.scopes_stmt_block_list_cons_11(delta);
            self.scopes_stmt_block_list_cons_14(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_block_list_cons_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_stmt_block_list_cons_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtBlockListNode(tm0, tm1, tm2) in self.cons_stmt_block_list_node.iter_dirty()
            {
                self.scopes_stmt_block_list_cons_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_block_list_cons_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtBlockListNode,
        tm1: StmtListNode,
        tm2: StmtBlockListNode,
    ) {
        for _ in [()] {
            self.scopes_stmt_block_list_cons_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_block_list_cons_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtBlockListNode,
        tm1: StmtListNode,
        tm2: StmtBlockListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtBlockList(_, tm3) in
                self.rule_descendant_stmt_block_list.iter_all_0(tm0)
            {
                self.scopes_stmt_block_list_cons_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_block_list_cons_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtBlockList(tm0, tm3) in
                self.rule_descendant_stmt_block_list.iter_dirty()
            {
                #[allow(unused_variables)]
                for ConsStmtBlockListNode(_, tm1, tm2) in
                    self.cons_stmt_block_list_node.iter_all_0(tm0)
                {
                    self.scopes_stmt_block_list_cons_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_block_list_cons_6(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtListNode,
        tm2: StmtBlockListNode,
        tm0: StmtBlockListNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_stmt_block_list_cons_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_block_list_cons_7(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtListNode,
        tm2: StmtBlockListNode,
        tm0: StmtBlockListNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtList(_, tm4) in self.rule_descendant_stmt_list.iter_all_0(tm1) {
                self.scopes_stmt_block_list_cons_9(delta, tm2, tm0, tm3, tm1, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_block_list_cons_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtList(tm1, tm4) in self.rule_descendant_stmt_list.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantStmtBlockList(tm0, tm3) in
                    self.rule_descendant_stmt_block_list.iter_all()
                {
                    #[allow(unused_variables)]
                    for ConsStmtBlockListNode(_, _, tm2) in
                        self.cons_stmt_block_list_node.iter_all_0_1(tm0, tm1)
                    {
                        self.scopes_stmt_block_list_cons_9(delta, tm2, tm0, tm3, tm1, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_block_list_cons_9(
        &self,
        delta: &mut ModelDelta,
        tm2: StmtBlockListNode,
        tm0: StmtBlockListNode,
        tm3: RuleDescendantNode,
        tm1: StmtListNode,
        tm4: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_stmt_block_list_cons_10(delta, tm2, tm0, tm3, tm1, tm4);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_block_list_cons_10(
        &self,
        delta: &mut ModelDelta,
        tm2: StmtBlockListNode,
        tm0: StmtBlockListNode,
        tm3: RuleDescendantNode,
        tm1: StmtListNode,
        tm4: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtBlockList(_, tm5) in
                self.rule_descendant_stmt_block_list.iter_all_0(tm2)
            {
                self.scopes_stmt_block_list_cons_12(delta, tm0, tm3, tm1, tm4, tm2, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_block_list_cons_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtBlockList(tm2, tm5) in
                self.rule_descendant_stmt_block_list.iter_dirty()
            {
                #[allow(unused_variables)]
                for RuleDescendantStmtBlockList(tm0, tm3) in
                    self.rule_descendant_stmt_block_list.iter_all()
                {
                    #[allow(unused_variables)]
                    for ConsStmtBlockListNode(_, tm1, _) in
                        self.cons_stmt_block_list_node.iter_all_0_2(tm0, tm2)
                    {
                        #[allow(unused_variables)]
                        for RuleDescendantStmtList(_, tm4) in
                            self.rule_descendant_stmt_list.iter_all_0(tm1)
                        {
                            self.scopes_stmt_block_list_cons_12(
                                delta, tm0, tm3, tm1, tm4, tm2, tm5,
                            );
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_block_list_cons_12(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtBlockListNode,
        tm3: RuleDescendantNode,
        tm1: StmtListNode,
        tm4: RuleDescendantNode,
        tm2: StmtBlockListNode,
        tm5: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_stmt_block_list_cons_13(delta, tm0, tm3, tm1, tm4, tm2, tm5);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_block_list_cons_13(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtBlockListNode,
        tm3: RuleDescendantNode,
        tm1: StmtListNode,
        tm4: RuleDescendantNode,
        tm2: StmtBlockListNode,
        tm5: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EntryScope(_, tm6) in self.entry_scope.iter_all_0(tm3) {
                self.scopes_stmt_block_list_cons_15(delta, tm0, tm3, tm1, tm4, tm2, tm5, tm6);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_block_list_cons_14(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EntryScope(tm3, tm6) in self.entry_scope.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantStmtBlockList(tm0, _) in
                    self.rule_descendant_stmt_block_list.iter_all_1(tm3)
                {
                    #[allow(unused_variables)]
                    for RuleDescendantStmtBlockList(tm2, tm5) in
                        self.rule_descendant_stmt_block_list.iter_all()
                    {
                        #[allow(unused_variables)]
                        for ConsStmtBlockListNode(_, tm1, _) in
                            self.cons_stmt_block_list_node.iter_all_0_2(tm0, tm2)
                        {
                            #[allow(unused_variables)]
                            for RuleDescendantStmtList(_, tm4) in
                                self.rule_descendant_stmt_list.iter_all_0(tm1)
                            {
                                self.scopes_stmt_block_list_cons_15(
                                    delta, tm0, tm3, tm1, tm4, tm2, tm5, tm6,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_block_list_cons_15(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtBlockListNode,
        tm3: RuleDescendantNode,
        tm1: StmtListNode,
        tm4: RuleDescendantNode,
        tm2: StmtBlockListNode,
        tm5: RuleDescendantNode,
        tm6: Scope,
    ) {
        for _ in [()] {
            let exists_already = self.entry_scope.iter_all_0_1(tm4, tm6).next().is_some();
            if !exists_already {
                delta.new_entry_scope.push(EntryScope(tm4, tm6));
            }

            let exists_already = self.entry_scope.iter_all_0_1(tm5, tm6).next().is_some();
            if !exists_already {
                delta.new_entry_scope.push(EntryScope(tm5, tm6));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_if_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_stmt_if_1(delta);
            self.scopes_stmt_if_2(delta);
            self.scopes_stmt_if_5(delta);
            self.scopes_stmt_if_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_if_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_stmt_if_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfStmtNode(tm0, tm1) in self.if_stmt_node.iter_dirty() {
                self.scopes_stmt_if_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_if_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode) {
        for _ in [()] {
            self.scopes_stmt_if_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_if_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmt(_, tm2) in self.rule_descendant_stmt.iter_all_0(tm0) {
                self.scopes_stmt_if_6(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_if_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmt(tm0, tm2) in self.rule_descendant_stmt.iter_dirty() {
                #[allow(unused_variables)]
                for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                    self.scopes_stmt_if_6(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_if_6(
        &self,
        delta: &mut ModelDelta,
        tm1: IfAtomNode,
        tm0: StmtNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_stmt_if_7(delta, tm1, tm0, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_if_7(
        &self,
        delta: &mut ModelDelta,
        tm1: IfAtomNode,
        tm0: StmtNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantIfAtom(_, tm3) in self.rule_descendant_if_atom.iter_all_0(tm1) {
                self.scopes_stmt_if_9(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_if_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantIfAtom(tm1, tm3) in self.rule_descendant_if_atom.iter_dirty() {
                #[allow(unused_variables)]
                for IfStmtNode(tm0, _) in self.if_stmt_node.iter_all_1(tm1) {
                    #[allow(unused_variables)]
                    for RuleDescendantStmt(_, tm2) in self.rule_descendant_stmt.iter_all_0(tm0) {
                        self.scopes_stmt_if_9(delta, tm0, tm2, tm1, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_if_9(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm2: RuleDescendantNode,
        tm1: IfAtomNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .scope_single_child
                .iter_all_0_1(tm3, tm2)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_scope_single_child
                    .push(ScopeSingleChild(tm3, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_then_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_stmt_then_1(delta);
            self.scopes_stmt_then_2(delta);
            self.scopes_stmt_then_5(delta);
            self.scopes_stmt_then_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_then_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_stmt_then_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenStmtNode(tm0, tm1) in self.then_stmt_node.iter_dirty() {
                self.scopes_stmt_then_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_then_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode) {
        for _ in [()] {
            self.scopes_stmt_then_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_then_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmt(_, tm2) in self.rule_descendant_stmt.iter_all_0(tm0) {
                self.scopes_stmt_then_6(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_then_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmt(tm0, tm2) in self.rule_descendant_stmt.iter_dirty() {
                #[allow(unused_variables)]
                for ThenStmtNode(_, tm1) in self.then_stmt_node.iter_all_0(tm0) {
                    self.scopes_stmt_then_6(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_then_6(
        &self,
        delta: &mut ModelDelta,
        tm1: ThenAtomNode,
        tm0: StmtNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_stmt_then_7(delta, tm1, tm0, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_then_7(
        &self,
        delta: &mut ModelDelta,
        tm1: ThenAtomNode,
        tm0: StmtNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantThenAtom(_, tm3) in self.rule_descendant_then_atom.iter_all_0(tm1) {
                self.scopes_stmt_then_9(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_then_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantThenAtom(tm1, tm3) in self.rule_descendant_then_atom.iter_dirty() {
                #[allow(unused_variables)]
                for ThenStmtNode(tm0, _) in self.then_stmt_node.iter_all_1(tm1) {
                    #[allow(unused_variables)]
                    for RuleDescendantStmt(_, tm2) in self.rule_descendant_stmt.iter_all_0(tm0) {
                        self.scopes_stmt_then_9(delta, tm0, tm2, tm1, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_then_9(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm2: RuleDescendantNode,
        tm1: ThenAtomNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .scope_single_child
                .iter_all_0_1(tm3, tm2)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_scope_single_child
                    .push(ScopeSingleChild(tm3, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_branch_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_stmt_branch_1(delta);
            self.scopes_stmt_branch_2(delta);
            self.scopes_stmt_branch_5(delta);
            self.scopes_stmt_branch_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_branch_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_stmt_branch_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BranchStmtNode(tm0, tm1) in self.branch_stmt_node.iter_dirty() {
                self.scopes_stmt_branch_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_branch_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode) {
        for _ in [()] {
            self.scopes_stmt_branch_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_branch_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmt(_, tm2) in self.rule_descendant_stmt.iter_all_0(tm0) {
                self.scopes_stmt_branch_6(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_branch_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmt(tm0, tm2) in self.rule_descendant_stmt.iter_dirty() {
                #[allow(unused_variables)]
                for BranchStmtNode(_, tm1) in self.branch_stmt_node.iter_all_0(tm0) {
                    self.scopes_stmt_branch_6(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_branch_6(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtBlockListNode,
        tm0: StmtNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_stmt_branch_7(delta, tm1, tm0, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_branch_7(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtBlockListNode,
        tm0: StmtNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtBlockList(_, tm3) in
                self.rule_descendant_stmt_block_list.iter_all_0(tm1)
            {
                self.scopes_stmt_branch_9(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_branch_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtBlockList(tm1, tm3) in
                self.rule_descendant_stmt_block_list.iter_dirty()
            {
                #[allow(unused_variables)]
                for BranchStmtNode(tm0, _) in self.branch_stmt_node.iter_all_1(tm1) {
                    #[allow(unused_variables)]
                    for RuleDescendantStmt(_, tm2) in self.rule_descendant_stmt.iter_all_0(tm0) {
                        self.scopes_stmt_branch_9(delta, tm0, tm2, tm1, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_branch_9(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm2: RuleDescendantNode,
        tm1: StmtBlockListNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .scope_single_child
                .iter_all_0_1(tm3, tm2)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_scope_single_child
                    .push(ScopeSingleChild(tm3, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_match_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_stmt_match_1(delta);
            self.scopes_stmt_match_2(delta);
            self.scopes_stmt_match_5(delta);
            self.scopes_stmt_match_8(delta);
            self.scopes_stmt_match_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_match_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_stmt_match_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchStmtNode(tm0, tm1, tm2) in self.match_stmt_node.iter_dirty() {
                self.scopes_stmt_match_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_match_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            self.scopes_stmt_match_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_match_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmt(_, tm3) in self.rule_descendant_stmt.iter_all_0(tm0) {
                self.scopes_stmt_match_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_match_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmt(tm0, tm3) in self.rule_descendant_stmt.iter_dirty() {
                #[allow(unused_variables)]
                for MatchStmtNode(_, tm1, tm2) in self.match_stmt_node.iter_all_0(tm0) {
                    self.scopes_stmt_match_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_match_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm0: StmtNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_stmt_match_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_match_7(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm0: StmtNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(_, tm4) in self.rule_descendant_term.iter_all_0(tm1) {
                self.scopes_stmt_match_9(delta, tm2, tm0, tm3, tm1, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_match_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(tm1, tm4) in self.rule_descendant_term.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantStmt(tm0, tm3) in self.rule_descendant_stmt.iter_all() {
                    #[allow(unused_variables)]
                    for MatchStmtNode(_, _, tm2) in self.match_stmt_node.iter_all_0_1(tm0, tm1) {
                        self.scopes_stmt_match_9(delta, tm2, tm0, tm3, tm1, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_match_9(
        &self,
        delta: &mut ModelDelta,
        tm2: MatchCaseListNode,
        tm0: StmtNode,
        tm3: RuleDescendantNode,
        tm1: TermNode,
        tm4: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_stmt_match_10(delta, tm2, tm0, tm3, tm1, tm4);
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_match_10(
        &self,
        delta: &mut ModelDelta,
        tm2: MatchCaseListNode,
        tm0: StmtNode,
        tm3: RuleDescendantNode,
        tm1: TermNode,
        tm4: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantMatchCaseList(_, tm5) in
                self.rule_descendant_match_case_list.iter_all_0(tm2)
            {
                self.scopes_stmt_match_12(delta, tm0, tm3, tm1, tm4, tm2, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_match_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantMatchCaseList(tm2, tm5) in
                self.rule_descendant_match_case_list.iter_dirty()
            {
                #[allow(unused_variables)]
                for RuleDescendantStmt(tm0, tm3) in self.rule_descendant_stmt.iter_all() {
                    #[allow(unused_variables)]
                    for MatchStmtNode(_, tm1, _) in self.match_stmt_node.iter_all_0_2(tm0, tm2) {
                        #[allow(unused_variables)]
                        for RuleDescendantTerm(_, tm4) in self.rule_descendant_term.iter_all_0(tm1)
                        {
                            self.scopes_stmt_match_12(delta, tm0, tm3, tm1, tm4, tm2, tm5);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_stmt_match_12(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm3: RuleDescendantNode,
        tm1: TermNode,
        tm4: RuleDescendantNode,
        tm2: MatchCaseListNode,
        tm5: RuleDescendantNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .scope_extension_siblings
                .iter_all_0_1_2(tm4, tm5, tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_scope_extension_siblings
                    .push(ScopeExtensionSiblings(tm4, tm5, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_equal_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_if_atom_equal_1(delta);
            self.scopes_if_atom_equal_2(delta);
            self.scopes_if_atom_equal_5(delta);
            self.scopes_if_atom_equal_8(delta);
            self.scopes_if_atom_equal_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_equal_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_equal_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EqualIfAtomNode(tm0, tm1, tm2) in self.equal_if_atom_node.iter_dirty() {
                self.scopes_if_atom_equal_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_equal_3(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            self.scopes_if_atom_equal_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_equal_4(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantIfAtom(_, tm3) in self.rule_descendant_if_atom.iter_all_0(tm0) {
                self.scopes_if_atom_equal_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_equal_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantIfAtom(tm0, tm3) in self.rule_descendant_if_atom.iter_dirty() {
                #[allow(unused_variables)]
                for EqualIfAtomNode(_, tm1, tm2) in self.equal_if_atom_node.iter_all_0(tm0) {
                    self.scopes_if_atom_equal_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_equal_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermNode,
        tm0: IfAtomNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_if_atom_equal_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_equal_7(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermNode,
        tm0: IfAtomNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(_, tm4) in self.rule_descendant_term.iter_all_0(tm1) {
                self.scopes_if_atom_equal_9(delta, tm2, tm0, tm3, tm1, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_equal_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(tm1, tm4) in self.rule_descendant_term.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantIfAtom(tm0, tm3) in self.rule_descendant_if_atom.iter_all() {
                    #[allow(unused_variables)]
                    for EqualIfAtomNode(_, _, tm2) in self.equal_if_atom_node.iter_all_0_1(tm0, tm1)
                    {
                        self.scopes_if_atom_equal_9(delta, tm2, tm0, tm3, tm1, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_equal_9(
        &self,
        delta: &mut ModelDelta,
        tm2: TermNode,
        tm0: IfAtomNode,
        tm3: RuleDescendantNode,
        tm1: TermNode,
        tm4: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_if_atom_equal_10(delta, tm2, tm0, tm3, tm1, tm4);
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_equal_10(
        &self,
        delta: &mut ModelDelta,
        tm2: TermNode,
        tm0: IfAtomNode,
        tm3: RuleDescendantNode,
        tm1: TermNode,
        tm4: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(_, tm5) in self.rule_descendant_term.iter_all_0(tm2) {
                self.scopes_if_atom_equal_12(delta, tm0, tm3, tm1, tm4, tm2, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_equal_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(tm2, tm5) in self.rule_descendant_term.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantIfAtom(tm0, tm3) in self.rule_descendant_if_atom.iter_all() {
                    #[allow(unused_variables)]
                    for EqualIfAtomNode(_, tm1, _) in self.equal_if_atom_node.iter_all_0_2(tm0, tm2)
                    {
                        #[allow(unused_variables)]
                        for RuleDescendantTerm(_, tm4) in self.rule_descendant_term.iter_all_0(tm1)
                        {
                            self.scopes_if_atom_equal_12(delta, tm0, tm3, tm1, tm4, tm2, tm5);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_equal_12(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm3: RuleDescendantNode,
        tm1: TermNode,
        tm4: RuleDescendantNode,
        tm2: TermNode,
        tm5: RuleDescendantNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .scope_extension_siblings
                .iter_all_0_1_2(tm4, tm5, tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_scope_extension_siblings
                    .push(ScopeExtensionSiblings(tm4, tm5, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_if_atom_defined_1(delta);
            self.scopes_if_atom_defined_2(delta);
            self.scopes_if_atom_defined_5(delta);
            self.scopes_if_atom_defined_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DefinedIfAtomNode(tm0, tm1) in self.defined_if_atom_node.iter_dirty() {
                self.scopes_if_atom_defined_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_defined_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode) {
        for _ in [()] {
            self.scopes_if_atom_defined_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_defined_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantIfAtom(_, tm2) in self.rule_descendant_if_atom.iter_all_0(tm0) {
                self.scopes_if_atom_defined_6(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantIfAtom(tm0, tm2) in self.rule_descendant_if_atom.iter_dirty() {
                #[allow(unused_variables)]
                for DefinedIfAtomNode(_, tm1) in self.defined_if_atom_node.iter_all_0(tm0) {
                    self.scopes_if_atom_defined_6(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_defined_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm0: IfAtomNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_if_atom_defined_7(delta, tm1, tm0, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_defined_7(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm0: IfAtomNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(_, tm3) in self.rule_descendant_term.iter_all_0(tm1) {
                self.scopes_if_atom_defined_9(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_defined_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(tm1, tm3) in self.rule_descendant_term.iter_dirty() {
                #[allow(unused_variables)]
                for DefinedIfAtomNode(tm0, _) in self.defined_if_atom_node.iter_all_1(tm1) {
                    #[allow(unused_variables)]
                    for RuleDescendantIfAtom(_, tm2) in self.rule_descendant_if_atom.iter_all_0(tm0)
                    {
                        self.scopes_if_atom_defined_9(delta, tm0, tm2, tm1, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_defined_9(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm2: RuleDescendantNode,
        tm1: TermNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .scope_single_child
                .iter_all_0_1(tm3, tm2)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_scope_single_child
                    .push(ScopeSingleChild(tm3, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_pred_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_if_atom_pred_1(delta);
            self.scopes_if_atom_pred_2(delta);
            self.scopes_if_atom_pred_5(delta);
            self.scopes_if_atom_pred_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_pred_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_pred_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredIfAtomNode(tm0, tm1, tm2) in self.pred_if_atom_node.iter_dirty() {
                self.scopes_if_atom_pred_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_pred_3(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.scopes_if_atom_pred_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_pred_4(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantIfAtom(_, tm3) in self.rule_descendant_if_atom.iter_all_0(tm0) {
                self.scopes_if_atom_pred_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_pred_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantIfAtom(tm0, tm3) in self.rule_descendant_if_atom.iter_dirty() {
                #[allow(unused_variables)]
                for PredIfAtomNode(_, tm1, tm2) in self.pred_if_atom_node.iter_all_0(tm0) {
                    self.scopes_if_atom_pred_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_pred_6(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: TermListNode,
        tm0: IfAtomNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_if_atom_pred_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_pred_7(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: TermListNode,
        tm0: IfAtomNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTermList(_, tm4) in self.rule_descendant_term_list.iter_all_0(tm2) {
                self.scopes_if_atom_pred_9(delta, tm1, tm0, tm3, tm2, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_pred_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTermList(tm2, tm4) in self.rule_descendant_term_list.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantIfAtom(tm0, tm3) in self.rule_descendant_if_atom.iter_all() {
                    #[allow(unused_variables)]
                    for PredIfAtomNode(_, tm1, _) in self.pred_if_atom_node.iter_all_0_2(tm0, tm2) {
                        self.scopes_if_atom_pred_9(delta, tm1, tm0, tm3, tm2, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_pred_9(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm0: IfAtomNode,
        tm3: RuleDescendantNode,
        tm2: TermListNode,
        tm4: RuleDescendantNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .scope_single_child
                .iter_all_0_1(tm4, tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_scope_single_child
                    .push(ScopeSingleChild(tm4, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_var_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_if_atom_var_1(delta);
            self.scopes_if_atom_var_2(delta);
            self.scopes_if_atom_var_5(delta);
            self.scopes_if_atom_var_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_var_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_var_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for VarIfAtomNode(tm0, tm1, tm2) in self.var_if_atom_node.iter_dirty() {
                self.scopes_if_atom_var_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_var_3(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: Ident,
    ) {
        for _ in [()] {
            self.scopes_if_atom_var_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_var_4(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: Ident,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantIfAtom(_, tm3) in self.rule_descendant_if_atom.iter_all_0(tm0) {
                self.scopes_if_atom_var_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_var_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantIfAtom(tm0, tm3) in self.rule_descendant_if_atom.iter_dirty() {
                #[allow(unused_variables)]
                for VarIfAtomNode(_, tm1, tm2) in self.var_if_atom_node.iter_all_0(tm0) {
                    self.scopes_if_atom_var_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_var_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: Ident,
        tm0: IfAtomNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_if_atom_var_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_var_7(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: Ident,
        tm0: IfAtomNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(_, tm4) in self.rule_descendant_term.iter_all_0(tm1) {
                self.scopes_if_atom_var_9(delta, tm2, tm0, tm3, tm1, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_var_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(tm1, tm4) in self.rule_descendant_term.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantIfAtom(tm0, tm3) in self.rule_descendant_if_atom.iter_all() {
                    #[allow(unused_variables)]
                    for VarIfAtomNode(_, _, tm2) in self.var_if_atom_node.iter_all_0_1(tm0, tm1) {
                        self.scopes_if_atom_var_9(delta, tm2, tm0, tm3, tm1, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_if_atom_var_9(
        &self,
        delta: &mut ModelDelta,
        tm2: Ident,
        tm0: IfAtomNode,
        tm3: RuleDescendantNode,
        tm1: TermNode,
        tm4: RuleDescendantNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .scope_single_child
                .iter_all_0_1(tm4, tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_scope_single_child
                    .push(ScopeSingleChild(tm4, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_equal_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_then_atom_equal_1(delta);
            self.scopes_then_atom_equal_2(delta);
            self.scopes_then_atom_equal_5(delta);
            self.scopes_then_atom_equal_8(delta);
            self.scopes_then_atom_equal_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_equal_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_equal_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EqualThenAtomNode(tm0, tm1, tm2) in self.equal_then_atom_node.iter_dirty() {
                self.scopes_then_atom_equal_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_equal_3(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: TermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            self.scopes_then_atom_equal_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_equal_4(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: TermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantThenAtom(_, tm3) in self.rule_descendant_then_atom.iter_all_0(tm0) {
                self.scopes_then_atom_equal_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_equal_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantThenAtom(tm0, tm3) in self.rule_descendant_then_atom.iter_dirty() {
                #[allow(unused_variables)]
                for EqualThenAtomNode(_, tm1, tm2) in self.equal_then_atom_node.iter_all_0(tm0) {
                    self.scopes_then_atom_equal_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_equal_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermNode,
        tm0: ThenAtomNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_then_atom_equal_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_equal_7(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermNode,
        tm0: ThenAtomNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(_, tm4) in self.rule_descendant_term.iter_all_0(tm1) {
                self.scopes_then_atom_equal_9(delta, tm2, tm0, tm3, tm1, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_equal_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(tm1, tm4) in self.rule_descendant_term.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantThenAtom(tm0, tm3) in self.rule_descendant_then_atom.iter_all() {
                    #[allow(unused_variables)]
                    for EqualThenAtomNode(_, _, tm2) in
                        self.equal_then_atom_node.iter_all_0_1(tm0, tm1)
                    {
                        self.scopes_then_atom_equal_9(delta, tm2, tm0, tm3, tm1, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_equal_9(
        &self,
        delta: &mut ModelDelta,
        tm2: TermNode,
        tm0: ThenAtomNode,
        tm3: RuleDescendantNode,
        tm1: TermNode,
        tm4: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_then_atom_equal_10(delta, tm2, tm0, tm3, tm1, tm4);
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_equal_10(
        &self,
        delta: &mut ModelDelta,
        tm2: TermNode,
        tm0: ThenAtomNode,
        tm3: RuleDescendantNode,
        tm1: TermNode,
        tm4: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(_, tm5) in self.rule_descendant_term.iter_all_0(tm2) {
                self.scopes_then_atom_equal_12(delta, tm0, tm3, tm1, tm4, tm2, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_equal_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(tm2, tm5) in self.rule_descendant_term.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantThenAtom(tm0, tm3) in self.rule_descendant_then_atom.iter_all() {
                    #[allow(unused_variables)]
                    for EqualThenAtomNode(_, tm1, _) in
                        self.equal_then_atom_node.iter_all_0_2(tm0, tm2)
                    {
                        #[allow(unused_variables)]
                        for RuleDescendantTerm(_, tm4) in self.rule_descendant_term.iter_all_0(tm1)
                        {
                            self.scopes_then_atom_equal_12(delta, tm0, tm3, tm1, tm4, tm2, tm5);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_equal_12(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm3: RuleDescendantNode,
        tm1: TermNode,
        tm4: RuleDescendantNode,
        tm2: TermNode,
        tm5: RuleDescendantNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .scope_extension_siblings
                .iter_all_0_1_2(tm4, tm5, tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_scope_extension_siblings
                    .push(ScopeExtensionSiblings(tm4, tm5, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_then_atom_defined_1(delta);
            self.scopes_then_atom_defined_2(delta);
            self.scopes_then_atom_defined_5(delta);
            self.scopes_then_atom_defined_8(delta);
            self.scopes_then_atom_defined_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DefinedThenAtomNode(tm0, tm1, tm2) in self.defined_then_atom_node.iter_dirty() {
                self.scopes_then_atom_defined_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_defined_3(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: OptTermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            self.scopes_then_atom_defined_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_defined_4(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: OptTermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantThenAtom(_, tm3) in self.rule_descendant_then_atom.iter_all_0(tm0) {
                self.scopes_then_atom_defined_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantThenAtom(tm0, tm3) in self.rule_descendant_then_atom.iter_dirty() {
                #[allow(unused_variables)]
                for DefinedThenAtomNode(_, tm1, tm2) in self.defined_then_atom_node.iter_all_0(tm0)
                {
                    self.scopes_then_atom_defined_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_defined_6(
        &self,
        delta: &mut ModelDelta,
        tm1: OptTermNode,
        tm2: TermNode,
        tm0: ThenAtomNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_then_atom_defined_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_defined_7(
        &self,
        delta: &mut ModelDelta,
        tm1: OptTermNode,
        tm2: TermNode,
        tm0: ThenAtomNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantOptTerm(_, tm4) in self.rule_descendant_opt_term.iter_all_0(tm1) {
                self.scopes_then_atom_defined_9(delta, tm2, tm0, tm3, tm1, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_defined_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantOptTerm(tm1, tm4) in self.rule_descendant_opt_term.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantThenAtom(tm0, tm3) in self.rule_descendant_then_atom.iter_all() {
                    #[allow(unused_variables)]
                    for DefinedThenAtomNode(_, _, tm2) in
                        self.defined_then_atom_node.iter_all_0_1(tm0, tm1)
                    {
                        self.scopes_then_atom_defined_9(delta, tm2, tm0, tm3, tm1, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_defined_9(
        &self,
        delta: &mut ModelDelta,
        tm2: TermNode,
        tm0: ThenAtomNode,
        tm3: RuleDescendantNode,
        tm1: OptTermNode,
        tm4: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_then_atom_defined_10(delta, tm2, tm0, tm3, tm1, tm4);
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_defined_10(
        &self,
        delta: &mut ModelDelta,
        tm2: TermNode,
        tm0: ThenAtomNode,
        tm3: RuleDescendantNode,
        tm1: OptTermNode,
        tm4: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(_, tm5) in self.rule_descendant_term.iter_all_0(tm2) {
                self.scopes_then_atom_defined_12(delta, tm0, tm3, tm1, tm4, tm2, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_defined_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(tm2, tm5) in self.rule_descendant_term.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantThenAtom(tm0, tm3) in self.rule_descendant_then_atom.iter_all() {
                    #[allow(unused_variables)]
                    for DefinedThenAtomNode(_, tm1, _) in
                        self.defined_then_atom_node.iter_all_0_2(tm0, tm2)
                    {
                        #[allow(unused_variables)]
                        for RuleDescendantOptTerm(_, tm4) in
                            self.rule_descendant_opt_term.iter_all_0(tm1)
                        {
                            self.scopes_then_atom_defined_12(delta, tm0, tm3, tm1, tm4, tm2, tm5);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_defined_12(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm3: RuleDescendantNode,
        tm1: OptTermNode,
        tm4: RuleDescendantNode,
        tm2: TermNode,
        tm5: RuleDescendantNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .scope_extension_siblings
                .iter_all_0_1_2(tm4, tm5, tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_scope_extension_siblings
                    .push(ScopeExtensionSiblings(tm4, tm5, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_pred_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_then_atom_pred_1(delta);
            self.scopes_then_atom_pred_2(delta);
            self.scopes_then_atom_pred_5(delta);
            self.scopes_then_atom_pred_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_pred_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_pred_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredThenAtomNode(tm0, tm1, tm2) in self.pred_then_atom_node.iter_dirty() {
                self.scopes_then_atom_pred_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_pred_3(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.scopes_then_atom_pred_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_pred_4(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantThenAtom(_, tm3) in self.rule_descendant_then_atom.iter_all_0(tm0) {
                self.scopes_then_atom_pred_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_pred_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantThenAtom(tm0, tm3) in self.rule_descendant_then_atom.iter_dirty() {
                #[allow(unused_variables)]
                for PredThenAtomNode(_, tm1, tm2) in self.pred_then_atom_node.iter_all_0(tm0) {
                    self.scopes_then_atom_pred_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_pred_6(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: TermListNode,
        tm0: ThenAtomNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_then_atom_pred_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_pred_7(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: TermListNode,
        tm0: ThenAtomNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTermList(_, tm4) in self.rule_descendant_term_list.iter_all_0(tm2) {
                self.scopes_then_atom_pred_9(delta, tm1, tm0, tm3, tm2, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_pred_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTermList(tm2, tm4) in self.rule_descendant_term_list.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantThenAtom(tm0, tm3) in self.rule_descendant_then_atom.iter_all() {
                    #[allow(unused_variables)]
                    for PredThenAtomNode(_, tm1, _) in
                        self.pred_then_atom_node.iter_all_0_2(tm0, tm2)
                    {
                        self.scopes_then_atom_pred_9(delta, tm1, tm0, tm3, tm2, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_then_atom_pred_9(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm0: ThenAtomNode,
        tm3: RuleDescendantNode,
        tm2: TermListNode,
        tm4: RuleDescendantNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .scope_extension_siblings
                .iter_all_0_1_2(tm3, tm4, tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_scope_extension_siblings
                    .push(ScopeExtensionSiblings(tm3, tm4, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_list_cons_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_term_list_cons_1(delta);
            self.scopes_term_list_cons_2(delta);
            self.scopes_term_list_cons_5(delta);
            self.scopes_term_list_cons_8(delta);
            self.scopes_term_list_cons_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_list_cons_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_term_list_cons_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsTermListNode(tm0, tm1, tm2) in self.cons_term_list_node.iter_dirty() {
                self.scopes_term_list_cons_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_list_cons_3(
        &self,
        delta: &mut ModelDelta,
        tm0: TermListNode,
        tm1: TermNode,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.scopes_term_list_cons_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_list_cons_4(
        &self,
        delta: &mut ModelDelta,
        tm0: TermListNode,
        tm1: TermNode,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTermList(_, tm3) in self.rule_descendant_term_list.iter_all_0(tm0) {
                self.scopes_term_list_cons_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_list_cons_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTermList(tm0, tm3) in self.rule_descendant_term_list.iter_dirty() {
                #[allow(unused_variables)]
                for ConsTermListNode(_, tm1, tm2) in self.cons_term_list_node.iter_all_0(tm0) {
                    self.scopes_term_list_cons_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_list_cons_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermListNode,
        tm0: TermListNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_term_list_cons_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_list_cons_7(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermListNode,
        tm0: TermListNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(_, tm4) in self.rule_descendant_term.iter_all_0(tm1) {
                self.scopes_term_list_cons_9(delta, tm2, tm0, tm3, tm1, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_list_cons_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(tm1, tm4) in self.rule_descendant_term.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantTermList(tm0, tm3) in self.rule_descendant_term_list.iter_all() {
                    #[allow(unused_variables)]
                    for ConsTermListNode(_, _, tm2) in
                        self.cons_term_list_node.iter_all_0_1(tm0, tm1)
                    {
                        self.scopes_term_list_cons_9(delta, tm2, tm0, tm3, tm1, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_list_cons_9(
        &self,
        delta: &mut ModelDelta,
        tm2: TermListNode,
        tm0: TermListNode,
        tm3: RuleDescendantNode,
        tm1: TermNode,
        tm4: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_term_list_cons_10(delta, tm2, tm0, tm3, tm1, tm4);
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_list_cons_10(
        &self,
        delta: &mut ModelDelta,
        tm2: TermListNode,
        tm0: TermListNode,
        tm3: RuleDescendantNode,
        tm1: TermNode,
        tm4: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTermList(_, tm5) in self.rule_descendant_term_list.iter_all_0(tm2) {
                self.scopes_term_list_cons_12(delta, tm0, tm3, tm1, tm4, tm2, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_list_cons_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTermList(tm2, tm5) in self.rule_descendant_term_list.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantTermList(tm0, tm3) in self.rule_descendant_term_list.iter_all() {
                    #[allow(unused_variables)]
                    for ConsTermListNode(_, tm1, _) in
                        self.cons_term_list_node.iter_all_0_2(tm0, tm2)
                    {
                        #[allow(unused_variables)]
                        for RuleDescendantTerm(_, tm4) in self.rule_descendant_term.iter_all_0(tm1)
                        {
                            self.scopes_term_list_cons_12(delta, tm0, tm3, tm1, tm4, tm2, tm5);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_list_cons_12(
        &self,
        delta: &mut ModelDelta,
        tm0: TermListNode,
        tm3: RuleDescendantNode,
        tm1: TermNode,
        tm4: RuleDescendantNode,
        tm2: TermListNode,
        tm5: RuleDescendantNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .scope_extension_siblings
                .iter_all_0_1_2(tm4, tm5, tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_scope_extension_siblings
                    .push(ScopeExtensionSiblings(tm4, tm5, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_opt_term_some_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_opt_term_some_1(delta);
            self.scopes_opt_term_some_2(delta);
            self.scopes_opt_term_some_5(delta);
            self.scopes_opt_term_some_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_opt_term_some_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_opt_term_some_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SomeTermNode(tm0, tm1) in self.some_term_node.iter_dirty() {
                self.scopes_opt_term_some_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_opt_term_some_3(&self, delta: &mut ModelDelta, tm0: OptTermNode, tm1: TermNode) {
        for _ in [()] {
            self.scopes_opt_term_some_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn scopes_opt_term_some_4(&self, delta: &mut ModelDelta, tm0: OptTermNode, tm1: TermNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantOptTerm(_, tm2) in self.rule_descendant_opt_term.iter_all_0(tm0) {
                self.scopes_opt_term_some_6(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_opt_term_some_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantOptTerm(tm0, tm2) in self.rule_descendant_opt_term.iter_dirty() {
                #[allow(unused_variables)]
                for SomeTermNode(_, tm1) in self.some_term_node.iter_all_0(tm0) {
                    self.scopes_opt_term_some_6(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_opt_term_some_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm0: OptTermNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_opt_term_some_7(delta, tm1, tm0, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_opt_term_some_7(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm0: OptTermNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(_, tm3) in self.rule_descendant_term.iter_all_0(tm1) {
                self.scopes_opt_term_some_9(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_opt_term_some_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(tm1, tm3) in self.rule_descendant_term.iter_dirty() {
                #[allow(unused_variables)]
                for SomeTermNode(tm0, _) in self.some_term_node.iter_all_1(tm1) {
                    #[allow(unused_variables)]
                    for RuleDescendantOptTerm(_, tm2) in
                        self.rule_descendant_opt_term.iter_all_0(tm0)
                    {
                        self.scopes_opt_term_some_9(delta, tm0, tm2, tm1, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_opt_term_some_9(
        &self,
        delta: &mut ModelDelta,
        tm0: OptTermNode,
        tm2: RuleDescendantNode,
        tm1: TermNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .scope_single_child
                .iter_all_0_1(tm3, tm2)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_scope_single_child
                    .push(ScopeSingleChild(tm3, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_app_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_term_app_1(delta);
            self.scopes_term_app_2(delta);
            self.scopes_term_app_5(delta);
            self.scopes_term_app_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_app_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_term_app_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for AppTermNode(tm0, tm1, tm2) in self.app_term_node.iter_dirty() {
                self.scopes_term_app_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_app_3(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.scopes_term_app_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_app_4(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(_, tm3) in self.rule_descendant_term.iter_all_0(tm0) {
                self.scopes_term_app_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_app_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(tm0, tm3) in self.rule_descendant_term.iter_dirty() {
                #[allow(unused_variables)]
                for AppTermNode(_, tm1, tm2) in self.app_term_node.iter_all_0(tm0) {
                    self.scopes_term_app_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_app_6(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: TermListNode,
        tm0: TermNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_term_app_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_app_7(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: TermListNode,
        tm0: TermNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTermList(_, tm4) in self.rule_descendant_term_list.iter_all_0(tm2) {
                self.scopes_term_app_9(delta, tm1, tm0, tm3, tm2, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_app_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTermList(tm2, tm4) in self.rule_descendant_term_list.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantTerm(tm0, tm3) in self.rule_descendant_term.iter_all() {
                    #[allow(unused_variables)]
                    for AppTermNode(_, tm1, _) in self.app_term_node.iter_all_0_2(tm0, tm2) {
                        self.scopes_term_app_9(delta, tm1, tm0, tm3, tm2, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_app_9(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm0: TermNode,
        tm3: RuleDescendantNode,
        tm2: TermListNode,
        tm4: RuleDescendantNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .scope_single_child
                .iter_all_0_1(tm4, tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_scope_single_child
                    .push(ScopeSingleChild(tm4, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_var_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_term_var_1(delta);
            self.scopes_term_var_2(delta);
            self.scopes_term_var_5(delta);
            self.scopes_term_var_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_var_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_term_var_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for VarTermNode(tm0, tm1) in self.var_term_node.iter_dirty() {
                self.scopes_term_var_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_var_3(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent) {
        for _ in [()] {
            self.scopes_term_var_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_var_4(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(_, tm2) in self.rule_descendant_term.iter_all_0(tm0) {
                self.scopes_term_var_6(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_var_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(tm0, tm2) in self.rule_descendant_term.iter_dirty() {
                #[allow(unused_variables)]
                for VarTermNode(_, tm1) in self.var_term_node.iter_all_0(tm0) {
                    self.scopes_term_var_6(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_var_6(
        &self,
        delta: &mut ModelDelta,
        tm1: VirtIdent,
        tm0: TermNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_term_var_7(delta, tm1, tm0, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_var_7(
        &self,
        delta: &mut ModelDelta,
        tm1: VirtIdent,
        tm0: TermNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ExitScope(_, tm3) in self.exit_scope.iter_all_0(tm2) {
                self.scopes_term_var_9(delta, tm1, tm0, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_var_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ExitScope(tm2, tm3) in self.exit_scope.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantTerm(tm0, _) in self.rule_descendant_term.iter_all_1(tm2) {
                    #[allow(unused_variables)]
                    for VarTermNode(_, tm1) in self.var_term_node.iter_all_0(tm0) {
                        self.scopes_term_var_9(delta, tm1, tm0, tm2, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_term_var_9(
        &self,
        delta: &mut ModelDelta,
        tm1: VirtIdent,
        tm0: TermNode,
        tm2: RuleDescendantNode,
        tm3: Scope,
    ) {
        for _ in [()] {
            let exists_already = self.var_in_scope.iter_all_0_1(tm1, tm3).next().is_some();
            if !exists_already {
                delta.new_var_in_scope.push(VarInScope(tm1, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn enum_ctors_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.enum_ctors_1(delta);
            self.enum_ctors_2(delta);
        }
    }

    #[allow(unused_variables)]
    fn enum_ctors_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn enum_ctors_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumDecl(tm0, tm1, tm2) in self.enum_decl.iter_dirty() {
                self.enum_ctors_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn enum_ctors_3(
        &self,
        delta: &mut ModelDelta,
        tm0: EnumDeclNode,
        tm1: Ident,
        tm2: CtorDeclListNode,
    ) {
        for _ in [()] {
            let exists_already = self.ctors_enum.iter_all_0_1(tm2, tm0).next().is_some();
            if !exists_already {
                delta.new_ctors_enum.push(CtorsEnum(tm2, tm0));
            }
        }
    }

    #[allow(unused_variables)]
    fn enum_ctors_cons_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.enum_ctors_cons_1(delta);
            self.enum_ctors_cons_2(delta);
            self.enum_ctors_cons_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn enum_ctors_cons_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn enum_ctors_cons_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorsEnum(tm0, tm1) in self.ctors_enum.iter_dirty() {
                self.enum_ctors_cons_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn enum_ctors_cons_3(&self, delta: &mut ModelDelta, tm0: CtorDeclListNode, tm1: EnumDeclNode) {
        for _ in [()] {
            self.enum_ctors_cons_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn enum_ctors_cons_4(&self, delta: &mut ModelDelta, tm0: CtorDeclListNode, tm1: EnumDeclNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsCtorDeclListNode(_, tm2, tm3) in self.cons_ctor_decl_list_node.iter_all_0(tm0) {
                self.enum_ctors_cons_6(delta, tm1, tm0, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn enum_ctors_cons_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsCtorDeclListNode(tm0, tm2, tm3) in self.cons_ctor_decl_list_node.iter_dirty() {
                #[allow(unused_variables)]
                for CtorsEnum(_, tm1) in self.ctors_enum.iter_all_0(tm0) {
                    self.enum_ctors_cons_6(delta, tm1, tm0, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn enum_ctors_cons_6(
        &self,
        delta: &mut ModelDelta,
        tm1: EnumDeclNode,
        tm0: CtorDeclListNode,
        tm2: CtorDeclNode,
        tm3: CtorDeclListNode,
    ) {
        for _ in [()] {
            let exists_already = self.ctor_enum.iter_all_0_1(tm2, tm1).next().is_some();
            if !exists_already {
                delta.new_ctor_enum.push(CtorEnum(tm2, tm1));
            }

            let exists_already = self.ctors_enum.iter_all_0_1(tm3, tm1).next().is_some();
            if !exists_already {
                delta.new_ctors_enum.push(CtorsEnum(tm3, tm1));
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_cases_discriminee_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.match_stmt_cases_discriminee_1(delta);
            self.match_stmt_cases_discriminee_2(delta);
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_cases_discriminee_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn match_stmt_cases_discriminee_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchStmtNode(tm0, tm1, tm2) in self.match_stmt_node.iter_dirty() {
                self.match_stmt_cases_discriminee_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_cases_discriminee_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .cases_discriminee
                .iter_all_0_1(tm2, tm1)
                .next()
                .is_some();
            if !exists_already {
                delta.new_cases_discriminee.push(CasesDiscriminee(tm2, tm1));
            }
        }
    }

    #[allow(unused_variables)]
    fn cases_match_stmt_cons_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.cases_match_stmt_cons_1(delta);
            self.cases_match_stmt_cons_2(delta);
            self.cases_match_stmt_cons_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn cases_match_stmt_cons_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cases_match_stmt_cons_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CasesDiscriminee(tm0, tm1) in self.cases_discriminee.iter_dirty() {
                self.cases_match_stmt_cons_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn cases_match_stmt_cons_3(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: TermNode,
    ) {
        for _ in [()] {
            self.cases_match_stmt_cons_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn cases_match_stmt_cons_4(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: TermNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsMatchCaseListNode(_, tm2, tm3) in self.cons_match_case_list_node.iter_all_0(tm0)
            {
                self.cases_match_stmt_cons_6(delta, tm1, tm0, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn cases_match_stmt_cons_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsMatchCaseListNode(tm0, tm2, tm3) in self.cons_match_case_list_node.iter_dirty()
            {
                #[allow(unused_variables)]
                for CasesDiscriminee(_, tm1) in self.cases_discriminee.iter_all_0(tm0) {
                    self.cases_match_stmt_cons_6(delta, tm1, tm0, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cases_match_stmt_cons_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm0: MatchCaseListNode,
        tm2: MatchCaseNode,
        tm3: MatchCaseListNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .case_discriminee
                .iter_all_0_1(tm2, tm1)
                .next()
                .is_some();
            if !exists_already {
                delta.new_case_discriminee.push(CaseDiscriminee(tm2, tm1));
            }

            let exists_already = self
                .cases_discriminee
                .iter_all_0_1(tm3, tm1)
                .next()
                .is_some();
            if !exists_already {
                delta.new_cases_discriminee.push(CasesDiscriminee(tm3, tm1));
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_stmt_loc_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.desugared_case_equality_stmt_loc_1(delta);
            self.desugared_case_equality_stmt_loc_2(delta);
            self.desugared_case_equality_stmt_loc_5(delta);
            self.desugared_case_equality_stmt_loc_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_stmt_loc_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_stmt_loc_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchCase(tm0, tm1, tm2) in self.match_case.iter_dirty() {
                self.desugared_case_equality_stmt_loc_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_stmt_loc_3(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: TermNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            self.desugared_case_equality_stmt_loc_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_stmt_loc_4(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: TermNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermNodeLoc(_, tm3) in self.term_node_loc.iter_all_0(tm1) {
                self.desugared_case_equality_stmt_loc_6(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_stmt_loc_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermNodeLoc(tm1, tm3) in self.term_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for MatchCase(tm0, _, tm2) in self.match_case.iter_all_1(tm1) {
                    self.desugared_case_equality_stmt_loc_6(delta, tm0, tm2, tm1, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_stmt_loc_6(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm2: StmtListNode,
        tm1: TermNode,
        tm3: Loc,
    ) {
        for _ in [()] {
            self.desugared_case_equality_stmt_loc_7(delta, tm0, tm2, tm1, tm3);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_stmt_loc_7(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm2: StmtListNode,
        tm1: TermNode,
        tm3: Loc,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseEqualityStmt(_, tm4) in
                self.desugared_case_equality_stmt.iter_all_0(tm0)
            {
                self.desugared_case_equality_stmt_loc_9(delta, tm2, tm1, tm3, tm0, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_stmt_loc_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseEqualityStmt(tm0, tm4) in
                self.desugared_case_equality_stmt.iter_dirty()
            {
                #[allow(unused_variables)]
                for TermNodeLoc(tm1, tm3) in self.term_node_loc.iter_all() {
                    #[allow(unused_variables)]
                    for MatchCase(_, _, tm2) in self.match_case.iter_all_0_1(tm0, tm1) {
                        self.desugared_case_equality_stmt_loc_9(delta, tm2, tm1, tm3, tm0, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_stmt_loc_9(
        &self,
        delta: &mut ModelDelta,
        tm2: StmtListNode,
        tm1: TermNode,
        tm3: Loc,
        tm0: MatchCaseNode,
        tm4: StmtNode,
    ) {
        for _ in [()] {
            let exists_already = self.stmt_node_loc.iter_all_0_1(tm4, tm3).next().is_some();
            if !exists_already {
                delta.new_stmt_node_loc.push(StmtNodeLoc(tm4, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.desugared_case_defined_1(delta);
            self.desugared_case_defined_2(delta);
            self.desugared_case_defined_5(delta);
            self.desugared_case_defined_8(delta);
            self.desugared_case_defined_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn desugared_case_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchCase(tm0, tm1, tm2) in self.match_case.iter_dirty() {
                self.desugared_case_defined_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_defined_3(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: TermNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            self.desugared_case_defined_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_defined_4(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: TermNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            let tm3 = match self.desugared_case_equality_atom.iter_all_0(tm0).next() {
                Some(DesugaredCaseEqualityAtom(_, res)) => res,
                None => {
                    delta
                        .new_desugared_case_equality_atom_def
                        .push(DesugaredCaseEqualityAtomArgs(tm0));
                    break;
                }
            };

            self.desugared_case_defined_6(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseEqualityAtom(tm0, tm3) in
                self.desugared_case_equality_atom.iter_dirty()
            {
                #[allow(unused_variables)]
                for MatchCase(_, tm1, tm2) in self.match_case.iter_all_0(tm0) {
                    self.desugared_case_defined_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_defined_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: StmtListNode,
        tm0: MatchCaseNode,
        tm3: IfAtomNode,
    ) {
        for _ in [()] {
            self.desugared_case_defined_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_defined_7(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: StmtListNode,
        tm0: MatchCaseNode,
        tm3: IfAtomNode,
    ) {
        for _ in [()] {
            let tm4 = match self.desugared_case_equality_stmt.iter_all_0(tm0).next() {
                Some(DesugaredCaseEqualityStmt(_, res)) => res,
                None => {
                    delta
                        .new_desugared_case_equality_stmt_def
                        .push(DesugaredCaseEqualityStmtArgs(tm0));
                    break;
                }
            };

            self.desugared_case_defined_9(delta, tm1, tm2, tm3, tm0, tm4);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_defined_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseEqualityStmt(tm0, tm4) in
                self.desugared_case_equality_stmt.iter_dirty()
            {
                #[allow(unused_variables)]
                for DesugaredCaseEqualityAtom(_, tm3) in
                    self.desugared_case_equality_atom.iter_all_0(tm0)
                {
                    #[allow(unused_variables)]
                    for MatchCase(_, tm1, tm2) in self.match_case.iter_all_0(tm0) {
                        self.desugared_case_defined_9(delta, tm1, tm2, tm3, tm0, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_defined_9(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: StmtListNode,
        tm3: IfAtomNode,
        tm0: MatchCaseNode,
        tm4: StmtNode,
    ) {
        for _ in [()] {
            self.desugared_case_defined_10(delta, tm1, tm2, tm3, tm0, tm4);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_defined_10(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: StmtListNode,
        tm3: IfAtomNode,
        tm0: MatchCaseNode,
        tm4: StmtNode,
    ) {
        for _ in [()] {
            let tm5 = match self.desugared_case_block.iter_all_0(tm0).next() {
                Some(DesugaredCaseBlock(_, res)) => res,
                None => {
                    delta
                        .new_desugared_case_block_def
                        .push(DesugaredCaseBlockArgs(tm0));
                    break;
                }
            };

            self.desugared_case_defined_12(delta, tm1, tm2, tm3, tm4, tm0, tm5);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_defined_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseBlock(tm0, tm5) in self.desugared_case_block.iter_dirty() {
                #[allow(unused_variables)]
                for DesugaredCaseEqualityStmt(_, tm4) in
                    self.desugared_case_equality_stmt.iter_all_0(tm0)
                {
                    #[allow(unused_variables)]
                    for DesugaredCaseEqualityAtom(_, tm3) in
                        self.desugared_case_equality_atom.iter_all_0(tm0)
                    {
                        #[allow(unused_variables)]
                        for MatchCase(_, tm1, tm2) in self.match_case.iter_all_0(tm0) {
                            self.desugared_case_defined_12(delta, tm1, tm2, tm3, tm4, tm0, tm5);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_defined_12(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: StmtListNode,
        tm3: IfAtomNode,
        tm4: StmtNode,
        tm0: MatchCaseNode,
        tm5: StmtListNode,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn desugared_case_block_list_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.desugared_case_block_list_defined_1(delta);
            self.desugared_case_block_list_defined_2(delta);
            self.desugared_case_block_list_defined_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_block_list_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn desugared_case_block_list_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.match_case_list_node_dirty.iter().copied() {
                self.desugared_case_block_list_defined_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_block_list_defined_3(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode) {
        for _ in [()] {
            self.desugared_case_block_list_defined_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_block_list_defined_4(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode) {
        for _ in [()] {
            let tm1 = match self.desugared_case_block_list.iter_all_0(tm0).next() {
                Some(DesugaredCaseBlockList(_, res)) => res,
                None => {
                    delta
                        .new_desugared_case_block_list_def
                        .push(DesugaredCaseBlockListArgs(tm0));
                    break;
                }
            };

            self.desugared_case_block_list_defined_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_block_list_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseBlockList(tm0, tm1) in self.desugared_case_block_list.iter_dirty() {
                self.desugared_case_block_list_defined_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_block_list_defined_6(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: StmtBlockListNode,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_atom_stmt_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.desugared_case_equality_atom_stmt_1(delta);
            self.desugared_case_equality_atom_stmt_2(delta);
            self.desugared_case_equality_atom_stmt_5(delta);
            self.desugared_case_equality_atom_stmt_8(delta);
            self.desugared_case_equality_atom_stmt_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_atom_stmt_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_atom_stmt_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CaseDiscriminee(tm0, tm1) in self.case_discriminee.iter_dirty() {
                self.desugared_case_equality_atom_stmt_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_atom_stmt_3(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: TermNode,
    ) {
        for _ in [()] {
            self.desugared_case_equality_atom_stmt_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_atom_stmt_4(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: TermNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchCase(_, tm2, tm3) in self.match_case.iter_all_0(tm0) {
                self.desugared_case_equality_atom_stmt_6(delta, tm1, tm0, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_atom_stmt_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchCase(tm0, tm2, tm3) in self.match_case.iter_dirty() {
                #[allow(unused_variables)]
                for CaseDiscriminee(_, tm1) in self.case_discriminee.iter_all_0(tm0) {
                    self.desugared_case_equality_atom_stmt_6(delta, tm1, tm0, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_atom_stmt_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm0: MatchCaseNode,
        tm2: TermNode,
        tm3: StmtListNode,
    ) {
        for _ in [()] {
            self.desugared_case_equality_atom_stmt_7(delta, tm1, tm0, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_atom_stmt_7(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm0: MatchCaseNode,
        tm2: TermNode,
        tm3: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseEqualityAtom(_, tm4) in
                self.desugared_case_equality_atom.iter_all_0(tm0)
            {
                self.desugared_case_equality_atom_stmt_9(delta, tm1, tm2, tm3, tm0, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_atom_stmt_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseEqualityAtom(tm0, tm4) in
                self.desugared_case_equality_atom.iter_dirty()
            {
                #[allow(unused_variables)]
                for CaseDiscriminee(_, tm1) in self.case_discriminee.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for MatchCase(_, tm2, tm3) in self.match_case.iter_all_0(tm0) {
                        self.desugared_case_equality_atom_stmt_9(delta, tm1, tm2, tm3, tm0, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_atom_stmt_9(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermNode,
        tm3: StmtListNode,
        tm0: MatchCaseNode,
        tm4: IfAtomNode,
    ) {
        for _ in [()] {
            self.desugared_case_equality_atom_stmt_10(delta, tm1, tm2, tm3, tm0, tm4);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_atom_stmt_10(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermNode,
        tm3: StmtListNode,
        tm0: MatchCaseNode,
        tm4: IfAtomNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseEqualityStmt(_, tm5) in
                self.desugared_case_equality_stmt.iter_all_0(tm0)
            {
                self.desugared_case_equality_atom_stmt_12(delta, tm1, tm2, tm3, tm4, tm0, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_atom_stmt_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseEqualityStmt(tm0, tm5) in
                self.desugared_case_equality_stmt.iter_dirty()
            {
                #[allow(unused_variables)]
                for DesugaredCaseEqualityAtom(_, tm4) in
                    self.desugared_case_equality_atom.iter_all_0(tm0)
                {
                    #[allow(unused_variables)]
                    for CaseDiscriminee(_, tm1) in self.case_discriminee.iter_all_0(tm0) {
                        #[allow(unused_variables)]
                        for MatchCase(_, tm2, tm3) in self.match_case.iter_all_0(tm0) {
                            self.desugared_case_equality_atom_stmt_12(
                                delta, tm1, tm2, tm3, tm4, tm0, tm5,
                            );
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_equality_atom_stmt_12(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermNode,
        tm3: StmtListNode,
        tm4: IfAtomNode,
        tm0: MatchCaseNode,
        tm5: StmtNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .equal_if_atom_node
                .iter_all_0_1_2(tm4, tm1, tm2)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_equal_if_atom_node
                    .push(EqualIfAtomNode(tm4, tm1, tm2));
            }

            let exists_already = self.if_stmt_node.iter_all_0_1(tm5, tm4).next().is_some();
            if !exists_already {
                delta.new_if_stmt_node.push(IfStmtNode(tm5, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_block_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.desugared_case_block_structure_1(delta);
            self.desugared_case_block_structure_2(delta);
            self.desugared_case_block_structure_5(delta);
            self.desugared_case_block_structure_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_block_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn desugared_case_block_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchCase(tm0, tm1, tm2) in self.match_case.iter_dirty() {
                self.desugared_case_block_structure_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_block_structure_3(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: TermNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            self.desugared_case_block_structure_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_block_structure_4(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: TermNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseEqualityStmt(_, tm3) in
                self.desugared_case_equality_stmt.iter_all_0(tm0)
            {
                self.desugared_case_block_structure_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_block_structure_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseEqualityStmt(tm0, tm3) in
                self.desugared_case_equality_stmt.iter_dirty()
            {
                #[allow(unused_variables)]
                for MatchCase(_, tm1, tm2) in self.match_case.iter_all_0(tm0) {
                    self.desugared_case_block_structure_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_block_structure_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: StmtListNode,
        tm0: MatchCaseNode,
        tm3: StmtNode,
    ) {
        for _ in [()] {
            self.desugared_case_block_structure_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_block_structure_7(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: StmtListNode,
        tm0: MatchCaseNode,
        tm3: StmtNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseBlock(_, tm4) in self.desugared_case_block.iter_all_0(tm0) {
                self.desugared_case_block_structure_9(delta, tm1, tm2, tm3, tm0, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_block_structure_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseBlock(tm0, tm4) in self.desugared_case_block.iter_dirty() {
                #[allow(unused_variables)]
                for DesugaredCaseEqualityStmt(_, tm3) in
                    self.desugared_case_equality_stmt.iter_all_0(tm0)
                {
                    #[allow(unused_variables)]
                    for MatchCase(_, tm1, tm2) in self.match_case.iter_all_0(tm0) {
                        self.desugared_case_block_structure_9(delta, tm1, tm2, tm3, tm0, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_block_structure_9(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: StmtListNode,
        tm3: StmtNode,
        tm0: MatchCaseNode,
        tm4: StmtListNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .cons_stmt_list_node
                .iter_all_0_1_2(tm4, tm3, tm2)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_cons_stmt_list_node
                    .push(ConsStmtListNode(tm4, tm3, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_blocks_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.desugared_case_blocks_1(delta);
            self.desugared_case_blocks_2(delta);
            self.desugared_case_blocks_5(delta);
            self.desugared_case_blocks_8(delta);
            self.desugared_case_blocks_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_blocks_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn desugared_case_blocks_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsMatchCaseListNode(tm0, tm1, tm2) in self.cons_match_case_list_node.iter_dirty()
            {
                self.desugared_case_blocks_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_blocks_3(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: MatchCaseNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            self.desugared_case_blocks_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_blocks_4(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: MatchCaseNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseBlockList(_, tm3) in self.desugared_case_block_list.iter_all_0(tm0) {
                self.desugared_case_blocks_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_blocks_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseBlockList(tm0, tm3) in self.desugared_case_block_list.iter_dirty() {
                #[allow(unused_variables)]
                for ConsMatchCaseListNode(_, tm1, tm2) in
                    self.cons_match_case_list_node.iter_all_0(tm0)
                {
                    self.desugared_case_blocks_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_blocks_6(
        &self,
        delta: &mut ModelDelta,
        tm1: MatchCaseNode,
        tm2: MatchCaseListNode,
        tm0: MatchCaseListNode,
        tm3: StmtBlockListNode,
    ) {
        for _ in [()] {
            self.desugared_case_blocks_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_blocks_7(
        &self,
        delta: &mut ModelDelta,
        tm1: MatchCaseNode,
        tm2: MatchCaseListNode,
        tm0: MatchCaseListNode,
        tm3: StmtBlockListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseBlock(_, tm4) in self.desugared_case_block.iter_all_0(tm1) {
                self.desugared_case_blocks_9(delta, tm2, tm0, tm3, tm1, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_blocks_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseBlock(tm1, tm4) in self.desugared_case_block.iter_dirty() {
                #[allow(unused_variables)]
                for DesugaredCaseBlockList(tm0, tm3) in self.desugared_case_block_list.iter_all() {
                    #[allow(unused_variables)]
                    for ConsMatchCaseListNode(_, _, tm2) in
                        self.cons_match_case_list_node.iter_all_0_1(tm0, tm1)
                    {
                        self.desugared_case_blocks_9(delta, tm2, tm0, tm3, tm1, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_blocks_9(
        &self,
        delta: &mut ModelDelta,
        tm2: MatchCaseListNode,
        tm0: MatchCaseListNode,
        tm3: StmtBlockListNode,
        tm1: MatchCaseNode,
        tm4: StmtListNode,
    ) {
        for _ in [()] {
            self.desugared_case_blocks_10(delta, tm2, tm0, tm3, tm1, tm4);
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_blocks_10(
        &self,
        delta: &mut ModelDelta,
        tm2: MatchCaseListNode,
        tm0: MatchCaseListNode,
        tm3: StmtBlockListNode,
        tm1: MatchCaseNode,
        tm4: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseBlockList(_, tm5) in self.desugared_case_block_list.iter_all_0(tm2) {
                self.desugared_case_blocks_12(delta, tm0, tm3, tm1, tm4, tm2, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_blocks_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseBlockList(tm2, tm5) in self.desugared_case_block_list.iter_dirty() {
                #[allow(unused_variables)]
                for DesugaredCaseBlockList(tm0, tm3) in self.desugared_case_block_list.iter_all() {
                    #[allow(unused_variables)]
                    for ConsMatchCaseListNode(_, tm1, _) in
                        self.cons_match_case_list_node.iter_all_0_2(tm0, tm2)
                    {
                        #[allow(unused_variables)]
                        for DesugaredCaseBlock(_, tm4) in self.desugared_case_block.iter_all_0(tm1)
                        {
                            self.desugared_case_blocks_12(delta, tm0, tm3, tm1, tm4, tm2, tm5);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn desugared_case_blocks_12(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm3: StmtBlockListNode,
        tm1: MatchCaseNode,
        tm4: StmtListNode,
        tm2: MatchCaseListNode,
        tm5: StmtBlockListNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .cons_stmt_block_list_node
                .iter_all_0_1_2(tm3, tm4, tm5)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_cons_stmt_block_list_node
                    .push(ConsStmtBlockListNode(tm3, tm4, tm5));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_desugared_case_1(delta);
            self.scopes_desugared_case_2(delta);
            self.scopes_desugared_case_5(delta);
            self.scopes_desugared_case_8(delta);
            self.scopes_desugared_case_11(delta);
            self.scopes_desugared_case_14(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseBlock(tm0, tm1) in self.desugared_case_block.iter_dirty() {
                self.scopes_desugared_case_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_3(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: StmtListNode,
    ) {
        for _ in [()] {
            self.scopes_desugared_case_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_4(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtList(_, tm2) in self.rule_descendant_stmt_list.iter_all_0(tm1) {
                self.scopes_desugared_case_6(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtList(tm1, tm2) in self.rule_descendant_stmt_list.iter_dirty() {
                #[allow(unused_variables)]
                for DesugaredCaseBlock(tm0, _) in self.desugared_case_block.iter_all_1(tm1) {
                    self.scopes_desugared_case_6(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_6(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: StmtListNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_desugared_case_7(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_7(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: StmtListNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantMatchCase(_, tm3) in self.rule_descendant_match_case.iter_all_0(tm0) {
                self.scopes_desugared_case_9(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantMatchCase(tm0, tm3) in self.rule_descendant_match_case.iter_dirty() {
                #[allow(unused_variables)]
                for DesugaredCaseBlock(_, tm1) in self.desugared_case_block.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleDescendantStmtList(_, tm2) in
                        self.rule_descendant_stmt_list.iter_all_0(tm1)
                    {
                        self.scopes_desugared_case_9(delta, tm1, tm2, tm0, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_9(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtListNode,
        tm2: RuleDescendantNode,
        tm0: MatchCaseNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_desugared_case_10(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_10(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtListNode,
        tm2: RuleDescendantNode,
        tm0: MatchCaseNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EntryScope(_, tm4) in self.entry_scope.iter_all_0(tm3) {
                self.scopes_desugared_case_12(delta, tm1, tm2, tm0, tm3, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EntryScope(tm3, tm4) in self.entry_scope.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantMatchCase(tm0, _) in
                    self.rule_descendant_match_case.iter_all_1(tm3)
                {
                    #[allow(unused_variables)]
                    for DesugaredCaseBlock(_, tm1) in self.desugared_case_block.iter_all_0(tm0) {
                        #[allow(unused_variables)]
                        for RuleDescendantStmtList(_, tm2) in
                            self.rule_descendant_stmt_list.iter_all_0(tm1)
                        {
                            self.scopes_desugared_case_12(delta, tm1, tm2, tm0, tm3, tm4);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_12(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtListNode,
        tm2: RuleDescendantNode,
        tm0: MatchCaseNode,
        tm3: RuleDescendantNode,
        tm4: Scope,
    ) {
        for _ in [()] {
            self.scopes_desugared_case_13(delta, tm1, tm2, tm0, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_13(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtListNode,
        tm2: RuleDescendantNode,
        tm0: MatchCaseNode,
        tm3: RuleDescendantNode,
        tm4: Scope,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ExitScope(_, tm5) in self.exit_scope.iter_all_0(tm3) {
                self.scopes_desugared_case_15(delta, tm1, tm2, tm0, tm3, tm4, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_14(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ExitScope(tm3, tm5) in self.exit_scope.iter_dirty() {
                #[allow(unused_variables)]
                for EntryScope(_, tm4) in self.entry_scope.iter_all_0(tm3) {
                    #[allow(unused_variables)]
                    for RuleDescendantMatchCase(tm0, _) in
                        self.rule_descendant_match_case.iter_all_1(tm3)
                    {
                        #[allow(unused_variables)]
                        for DesugaredCaseBlock(_, tm1) in self.desugared_case_block.iter_all_0(tm0)
                        {
                            #[allow(unused_variables)]
                            for RuleDescendantStmtList(_, tm2) in
                                self.rule_descendant_stmt_list.iter_all_0(tm1)
                            {
                                self.scopes_desugared_case_15(delta, tm1, tm2, tm0, tm3, tm4, tm5);
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_15(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtListNode,
        tm2: RuleDescendantNode,
        tm0: MatchCaseNode,
        tm3: RuleDescendantNode,
        tm4: Scope,
        tm5: Scope,
    ) {
        for _ in [()] {
            let exists_already = self.entry_scope.iter_all_0_1(tm2, tm4).next().is_some();
            if !exists_already {
                delta.new_entry_scope.push(EntryScope(tm2, tm4));
            }

            let exists_already = self.exit_scope.iter_all_0_1(tm2, tm5).next().is_some();
            if !exists_already {
                delta.new_exit_scope.push(ExitScope(tm2, tm5));
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_list_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.scopes_desugared_case_list_1(delta);
            self.scopes_desugared_case_list_2(delta);
            self.scopes_desugared_case_list_5(delta);
            self.scopes_desugared_case_list_8(delta);
            self.scopes_desugared_case_list_11(delta);
            self.scopes_desugared_case_list_14(delta);
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_list_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_list_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseBlockList(tm0, tm1) in self.desugared_case_block_list.iter_dirty() {
                self.scopes_desugared_case_list_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_list_3(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: StmtBlockListNode,
    ) {
        for _ in [()] {
            self.scopes_desugared_case_list_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_list_4(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: StmtBlockListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtBlockList(_, tm2) in
                self.rule_descendant_stmt_block_list.iter_all_0(tm1)
            {
                self.scopes_desugared_case_list_6(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_list_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantStmtBlockList(tm1, tm2) in
                self.rule_descendant_stmt_block_list.iter_dirty()
            {
                #[allow(unused_variables)]
                for DesugaredCaseBlockList(tm0, _) in self.desugared_case_block_list.iter_all_1(tm1)
                {
                    self.scopes_desugared_case_list_6(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_list_6(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: StmtBlockListNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_desugared_case_list_7(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_list_7(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: StmtBlockListNode,
        tm2: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantMatchCaseList(_, tm3) in
                self.rule_descendant_match_case_list.iter_all_0(tm0)
            {
                self.scopes_desugared_case_list_9(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_list_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantMatchCaseList(tm0, tm3) in
                self.rule_descendant_match_case_list.iter_dirty()
            {
                #[allow(unused_variables)]
                for DesugaredCaseBlockList(_, tm1) in self.desugared_case_block_list.iter_all_0(tm0)
                {
                    #[allow(unused_variables)]
                    for RuleDescendantStmtBlockList(_, tm2) in
                        self.rule_descendant_stmt_block_list.iter_all_0(tm1)
                    {
                        self.scopes_desugared_case_list_9(delta, tm1, tm2, tm0, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_list_9(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtBlockListNode,
        tm2: RuleDescendantNode,
        tm0: MatchCaseListNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            self.scopes_desugared_case_list_10(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_list_10(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtBlockListNode,
        tm2: RuleDescendantNode,
        tm0: MatchCaseListNode,
        tm3: RuleDescendantNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EntryScope(_, tm4) in self.entry_scope.iter_all_0(tm3) {
                self.scopes_desugared_case_list_12(delta, tm1, tm2, tm0, tm3, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_list_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EntryScope(tm3, tm4) in self.entry_scope.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantMatchCaseList(tm0, _) in
                    self.rule_descendant_match_case_list.iter_all_1(tm3)
                {
                    #[allow(unused_variables)]
                    for DesugaredCaseBlockList(_, tm1) in
                        self.desugared_case_block_list.iter_all_0(tm0)
                    {
                        #[allow(unused_variables)]
                        for RuleDescendantStmtBlockList(_, tm2) in
                            self.rule_descendant_stmt_block_list.iter_all_0(tm1)
                        {
                            self.scopes_desugared_case_list_12(delta, tm1, tm2, tm0, tm3, tm4);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_list_12(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtBlockListNode,
        tm2: RuleDescendantNode,
        tm0: MatchCaseListNode,
        tm3: RuleDescendantNode,
        tm4: Scope,
    ) {
        for _ in [()] {
            self.scopes_desugared_case_list_13(delta, tm1, tm2, tm0, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_list_13(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtBlockListNode,
        tm2: RuleDescendantNode,
        tm0: MatchCaseListNode,
        tm3: RuleDescendantNode,
        tm4: Scope,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ExitScope(_, tm5) in self.exit_scope.iter_all_0(tm3) {
                self.scopes_desugared_case_list_15(delta, tm1, tm2, tm0, tm3, tm4, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_list_14(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ExitScope(tm3, tm5) in self.exit_scope.iter_dirty() {
                #[allow(unused_variables)]
                for EntryScope(_, tm4) in self.entry_scope.iter_all_0(tm3) {
                    #[allow(unused_variables)]
                    for RuleDescendantMatchCaseList(tm0, _) in
                        self.rule_descendant_match_case_list.iter_all_1(tm3)
                    {
                        #[allow(unused_variables)]
                        for DesugaredCaseBlockList(_, tm1) in
                            self.desugared_case_block_list.iter_all_0(tm0)
                        {
                            #[allow(unused_variables)]
                            for RuleDescendantStmtBlockList(_, tm2) in
                                self.rule_descendant_stmt_block_list.iter_all_0(tm1)
                            {
                                self.scopes_desugared_case_list_15(
                                    delta, tm1, tm2, tm0, tm3, tm4, tm5,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn scopes_desugared_case_list_15(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtBlockListNode,
        tm2: RuleDescendantNode,
        tm0: MatchCaseListNode,
        tm3: RuleDescendantNode,
        tm4: Scope,
        tm5: Scope,
    ) {
        for _ in [()] {
            let exists_already = self.entry_scope.iter_all_0_1(tm2, tm4).next().is_some();
            if !exists_already {
                delta.new_entry_scope.push(EntryScope(tm2, tm4));
            }

            let exists_already = self.exit_scope.iter_all_0_1(tm2, tm5).next().is_some();
            if !exists_already {
                delta.new_exit_scope.push(ExitScope(tm2, tm5));
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_nil_not_cons_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.type_list_nil_not_cons_1(delta);
            self.type_list_nil_not_cons_2(delta);
            self.type_list_nil_not_cons_3(delta);
        }
    }

    #[allow(unused_variables)]
    fn type_list_nil_not_cons_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn type_list_nil_not_cons_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilTypeList(tm2) in self.nil_type_list.iter_dirty() {
                #[allow(unused_variables)]
                for ConsTypeList(tm0, tm1, _) in self.cons_type_list.iter_all_2(tm2) {
                    self.type_list_nil_not_cons_4(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_nil_not_cons_3(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsTypeList(tm0, tm1, tm2) in self.cons_type_list.iter_dirty() {
                #[allow(unused_variables)]
                for NilTypeList(_) in self.nil_type_list.iter_all_0(tm2) {
                    self.type_list_nil_not_cons_4(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_nil_not_cons_4(
        &self,
        delta: &mut ModelDelta,
        tm0: Type,
        tm1: TypeList,
        tm2: TypeList,
    ) {
        for _ in [()] {
            let exists_already = self.absurd.iter_all().next().is_some();
            if !exists_already {
                delta.new_absurd.push(Absurd());
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_cons_injective_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.type_list_cons_injective_1(delta);
            self.type_list_cons_injective_2(delta);
            self.type_list_cons_injective_3(delta);
        }
    }

    #[allow(unused_variables)]
    fn type_list_cons_injective_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn type_list_cons_injective_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsTypeList(tm0, tm1, tm4) in self.cons_type_list.iter_dirty() {
                #[allow(unused_variables)]
                for ConsTypeList(tm2, tm3, _) in self.cons_type_list.iter_all_2(tm4) {
                    self.type_list_cons_injective_4(delta, tm0, tm1, tm2, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_cons_injective_3(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsTypeList(tm2, tm3, tm4) in self.cons_type_list.iter_dirty() {
                #[allow(unused_variables)]
                for ConsTypeList(tm0, tm1, _) in self.cons_type_list.iter_all_2(tm4) {
                    self.type_list_cons_injective_4(delta, tm0, tm1, tm2, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_cons_injective_4(
        &self,
        delta: &mut ModelDelta,
        tm0: Type,
        tm1: TypeList,
        tm2: Type,
        tm3: TypeList,
        tm4: TypeList,
    ) {
        for _ in [()] {
            delta.new_type_equalities.push((tm0, tm2));

            delta.new_type_equalities.push((tm2, tm0));

            delta.new_type_list_equalities.push((tm1, tm3));

            delta.new_type_list_equalities.push((tm3, tm1));
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_type_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.semantic_decl_type_1(delta);
            self.semantic_decl_type_2(delta);
            self.semantic_decl_type_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_type_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn semantic_decl_type_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeDecl(tm0, tm1) in self.type_decl.iter_dirty() {
                self.semantic_decl_type_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_type_3(&self, delta: &mut ModelDelta, tm0: TypeDeclNode, tm1: Ident) {
        for _ in [()] {
            self.semantic_decl_type_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_type_4(&self, delta: &mut ModelDelta, tm0: TypeDeclNode, tm1: Ident) {
        for _ in [()] {
            let tm2 = match self.semantic_type.iter_all_0(tm1).next() {
                Some(SemanticType(_, res)) => res,
                None => {
                    delta.new_semantic_type_def.push(SemanticTypeArgs(tm1));
                    break;
                }
            };

            self.semantic_decl_type_6(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_type_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticType(tm1, tm2) in self.semantic_type.iter_dirty() {
                #[allow(unused_variables)]
                for TypeDecl(tm0, _) in self.type_decl.iter_all_1(tm1) {
                    self.semantic_decl_type_6(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_type_6(
        &self,
        delta: &mut ModelDelta,
        tm0: TypeDeclNode,
        tm1: Ident,
        tm2: Type,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn semantic_decl_enum_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.semantic_decl_enum_1(delta);
            self.semantic_decl_enum_2(delta);
            self.semantic_decl_enum_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_enum_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn semantic_decl_enum_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumDecl(tm0, tm1, tm2) in self.enum_decl.iter_dirty() {
                self.semantic_decl_enum_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_enum_3(
        &self,
        delta: &mut ModelDelta,
        tm0: EnumDeclNode,
        tm1: Ident,
        tm2: CtorDeclListNode,
    ) {
        for _ in [()] {
            self.semantic_decl_enum_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_enum_4(
        &self,
        delta: &mut ModelDelta,
        tm0: EnumDeclNode,
        tm1: Ident,
        tm2: CtorDeclListNode,
    ) {
        for _ in [()] {
            let tm3 = match self.semantic_type.iter_all_0(tm1).next() {
                Some(SemanticType(_, res)) => res,
                None => {
                    delta.new_semantic_type_def.push(SemanticTypeArgs(tm1));
                    break;
                }
            };

            self.semantic_decl_enum_6(delta, tm0, tm2, tm1, tm3);
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_enum_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticType(tm1, tm3) in self.semantic_type.iter_dirty() {
                #[allow(unused_variables)]
                for EnumDecl(tm0, _, tm2) in self.enum_decl.iter_all_1(tm1) {
                    self.semantic_decl_enum_6(delta, tm0, tm2, tm1, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_enum_6(
        &self,
        delta: &mut ModelDelta,
        tm0: EnumDeclNode,
        tm2: CtorDeclListNode,
        tm1: Ident,
        tm3: Type,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_nil_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.semantic_arg_types_nil_1(delta);
            self.semantic_arg_types_nil_2(delta);
            self.semantic_arg_types_nil_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_nil_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_nil_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilArgDeclListNode(tm0) in self.nil_arg_decl_list_node.iter_dirty() {
                self.semantic_arg_types_nil_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_nil_3(&self, delta: &mut ModelDelta, tm0: ArgDeclListNode) {
        for _ in [()] {
            self.semantic_arg_types_nil_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_nil_4(&self, delta: &mut ModelDelta, tm0: ArgDeclListNode) {
        for _ in [()] {
            let tm1 = match self.nil_type_list.iter_all().next() {
                Some(NilTypeList(res)) => res,
                None => {
                    delta.new_nil_type_list_def.push(NilTypeListArgs());
                    break;
                }
            };

            self.semantic_arg_types_nil_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_nil_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilTypeList(tm1) in self.nil_type_list.iter_dirty() {
                #[allow(unused_variables)]
                for NilArgDeclListNode(tm0) in self.nil_arg_decl_list_node.iter_all() {
                    self.semantic_arg_types_nil_6(delta, tm0, tm1);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_nil_6(
        &self,
        delta: &mut ModelDelta,
        tm0: ArgDeclListNode,
        tm1: TypeList,
    ) {
        for _ in [()] {
            let exists_already = self
                .semantic_arg_types
                .iter_all_0_1(tm0, tm1)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_semantic_arg_types
                    .push(SemanticArgTypes(tm0, tm1));
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_cons_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.semantic_arg_types_cons_1(delta);
            self.semantic_arg_types_cons_2(delta);
            self.semantic_arg_types_cons_5(delta);
            self.semantic_arg_types_cons_8(delta);
            self.semantic_arg_types_cons_11(delta);
            self.semantic_arg_types_cons_14(delta);
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_cons_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_cons_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsArgDeclListNode(tm0, tm1, tm2) in self.cons_arg_decl_list_node.iter_dirty() {
                self.semantic_arg_types_cons_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_cons_3(
        &self,
        delta: &mut ModelDelta,
        tm0: ArgDeclListNode,
        tm1: ArgDeclNode,
        tm2: ArgDeclListNode,
    ) {
        for _ in [()] {
            self.semantic_arg_types_cons_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_cons_4(
        &self,
        delta: &mut ModelDelta,
        tm0: ArgDeclListNode,
        tm1: ArgDeclNode,
        tm2: ArgDeclListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ArgDeclNodeType(_, tm3) in self.arg_decl_node_type.iter_all_0(tm1) {
                self.semantic_arg_types_cons_6(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_cons_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ArgDeclNodeType(tm1, tm3) in self.arg_decl_node_type.iter_dirty() {
                #[allow(unused_variables)]
                for ConsArgDeclListNode(tm0, _, tm2) in self.cons_arg_decl_list_node.iter_all_1(tm1)
                {
                    self.semantic_arg_types_cons_6(delta, tm0, tm2, tm1, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_cons_6(
        &self,
        delta: &mut ModelDelta,
        tm0: ArgDeclListNode,
        tm2: ArgDeclListNode,
        tm1: ArgDeclNode,
        tm3: Ident,
    ) {
        for _ in [()] {
            self.semantic_arg_types_cons_7(delta, tm0, tm2, tm1, tm3);
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_cons_7(
        &self,
        delta: &mut ModelDelta,
        tm0: ArgDeclListNode,
        tm2: ArgDeclListNode,
        tm1: ArgDeclNode,
        tm3: Ident,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticType(_, tm4) in self.semantic_type.iter_all_0(tm3) {
                self.semantic_arg_types_cons_9(delta, tm0, tm2, tm1, tm3, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_cons_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticType(tm3, tm4) in self.semantic_type.iter_dirty() {
                #[allow(unused_variables)]
                for ArgDeclNodeType(tm1, _) in self.arg_decl_node_type.iter_all_1(tm3) {
                    #[allow(unused_variables)]
                    for ConsArgDeclListNode(tm0, _, tm2) in
                        self.cons_arg_decl_list_node.iter_all_1(tm1)
                    {
                        self.semantic_arg_types_cons_9(delta, tm0, tm2, tm1, tm3, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_cons_9(
        &self,
        delta: &mut ModelDelta,
        tm0: ArgDeclListNode,
        tm2: ArgDeclListNode,
        tm1: ArgDeclNode,
        tm3: Ident,
        tm4: Type,
    ) {
        for _ in [()] {
            self.semantic_arg_types_cons_10(delta, tm0, tm2, tm1, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_cons_10(
        &self,
        delta: &mut ModelDelta,
        tm0: ArgDeclListNode,
        tm2: ArgDeclListNode,
        tm1: ArgDeclNode,
        tm3: Ident,
        tm4: Type,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticArgTypes(_, tm5) in self.semantic_arg_types.iter_all_0(tm2) {
                self.semantic_arg_types_cons_12(delta, tm0, tm1, tm3, tm4, tm2, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_cons_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticArgTypes(tm2, tm5) in self.semantic_arg_types.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticType(tm3, tm4) in self.semantic_type.iter_all() {
                    #[allow(unused_variables)]
                    for ArgDeclNodeType(tm1, _) in self.arg_decl_node_type.iter_all_1(tm3) {
                        #[allow(unused_variables)]
                        for ConsArgDeclListNode(tm0, _, _) in
                            self.cons_arg_decl_list_node.iter_all_1_2(tm1, tm2)
                        {
                            self.semantic_arg_types_cons_12(delta, tm0, tm1, tm3, tm4, tm2, tm5);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_cons_12(
        &self,
        delta: &mut ModelDelta,
        tm0: ArgDeclListNode,
        tm1: ArgDeclNode,
        tm3: Ident,
        tm4: Type,
        tm2: ArgDeclListNode,
        tm5: TypeList,
    ) {
        for _ in [()] {
            self.semantic_arg_types_cons_13(delta, tm0, tm1, tm3, tm4, tm2, tm5);
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_cons_13(
        &self,
        delta: &mut ModelDelta,
        tm0: ArgDeclListNode,
        tm1: ArgDeclNode,
        tm3: Ident,
        tm4: Type,
        tm2: ArgDeclListNode,
        tm5: TypeList,
    ) {
        for _ in [()] {
            let tm6 = match self.cons_type_list.iter_all_0_1(tm4, tm5).next() {
                Some(ConsTypeList(_, _, res)) => res,
                None => {
                    delta
                        .new_cons_type_list_def
                        .push(ConsTypeListArgs(tm4, tm5));
                    break;
                }
            };

            self.semantic_arg_types_cons_15(delta, tm0, tm1, tm3, tm4, tm2, tm5, tm6);
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_cons_14(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsTypeList(tm4, tm5, tm6) in self.cons_type_list.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticArgTypes(tm2, _) in self.semantic_arg_types.iter_all_1(tm5) {
                    #[allow(unused_variables)]
                    for SemanticType(tm3, _) in self.semantic_type.iter_all_1(tm4) {
                        #[allow(unused_variables)]
                        for ArgDeclNodeType(tm1, _) in self.arg_decl_node_type.iter_all_1(tm3) {
                            #[allow(unused_variables)]
                            for ConsArgDeclListNode(tm0, _, _) in
                                self.cons_arg_decl_list_node.iter_all_1_2(tm1, tm2)
                            {
                                self.semantic_arg_types_cons_15(
                                    delta, tm0, tm1, tm3, tm4, tm2, tm5, tm6,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_arg_types_cons_15(
        &self,
        delta: &mut ModelDelta,
        tm0: ArgDeclListNode,
        tm1: ArgDeclNode,
        tm3: Ident,
        tm4: Type,
        tm2: ArgDeclListNode,
        tm5: TypeList,
        tm6: TypeList,
    ) {
        for _ in [()] {
            let exists_already = self
                .semantic_arg_types
                .iter_all_0_1(tm0, tm6)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_semantic_arg_types
                    .push(SemanticArgTypes(tm0, tm6));
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_pred_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.semantic_decl_pred_1(delta);
            self.semantic_decl_pred_2(delta);
            self.semantic_decl_pred_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_pred_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn semantic_decl_pred_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredDecl(tm0, tm1, tm2) in self.pred_decl.iter_dirty() {
                self.semantic_decl_pred_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_pred_3(
        &self,
        delta: &mut ModelDelta,
        tm0: PredDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
    ) {
        for _ in [()] {
            self.semantic_decl_pred_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_pred_4(
        &self,
        delta: &mut ModelDelta,
        tm0: PredDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
    ) {
        for _ in [()] {
            let tm3 = match self.semantic_pred.iter_all_0(tm1).next() {
                Some(SemanticPred(_, res)) => res,
                None => {
                    delta.new_semantic_pred_def.push(SemanticPredArgs(tm1));
                    break;
                }
            };

            self.semantic_decl_pred_6(delta, tm0, tm2, tm1, tm3);
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_pred_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticPred(tm1, tm3) in self.semantic_pred.iter_dirty() {
                #[allow(unused_variables)]
                for PredDecl(tm0, _, tm2) in self.pred_decl.iter_all_1(tm1) {
                    self.semantic_decl_pred_6(delta, tm0, tm2, tm1, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_pred_6(
        &self,
        delta: &mut ModelDelta,
        tm0: PredDeclNode,
        tm2: ArgDeclListNode,
        tm1: Ident,
        tm3: Pred,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn pred_arity_decl_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.pred_arity_decl_1(delta);
            self.pred_arity_decl_2(delta);
            self.pred_arity_decl_5(delta);
            self.pred_arity_decl_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn pred_arity_decl_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn pred_arity_decl_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredDecl(tm0, tm1, tm2) in self.pred_decl.iter_dirty() {
                self.pred_arity_decl_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_arity_decl_3(
        &self,
        delta: &mut ModelDelta,
        tm0: PredDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
    ) {
        for _ in [()] {
            self.pred_arity_decl_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn pred_arity_decl_4(
        &self,
        delta: &mut ModelDelta,
        tm0: PredDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticPred(_, tm3) in self.semantic_pred.iter_all_0(tm1) {
                self.pred_arity_decl_6(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_arity_decl_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticPred(tm1, tm3) in self.semantic_pred.iter_dirty() {
                #[allow(unused_variables)]
                for PredDecl(tm0, _, tm2) in self.pred_decl.iter_all_1(tm1) {
                    self.pred_arity_decl_6(delta, tm0, tm2, tm1, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_arity_decl_6(
        &self,
        delta: &mut ModelDelta,
        tm0: PredDeclNode,
        tm2: ArgDeclListNode,
        tm1: Ident,
        tm3: Pred,
    ) {
        for _ in [()] {
            self.pred_arity_decl_7(delta, tm0, tm2, tm1, tm3);
        }
    }

    #[allow(unused_variables)]
    fn pred_arity_decl_7(
        &self,
        delta: &mut ModelDelta,
        tm0: PredDeclNode,
        tm2: ArgDeclListNode,
        tm1: Ident,
        tm3: Pred,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticArgTypes(_, tm4) in self.semantic_arg_types.iter_all_0(tm2) {
                self.pred_arity_decl_9(delta, tm0, tm1, tm3, tm2, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_arity_decl_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticArgTypes(tm2, tm4) in self.semantic_arg_types.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticPred(tm1, tm3) in self.semantic_pred.iter_all() {
                    #[allow(unused_variables)]
                    for PredDecl(tm0, _, _) in self.pred_decl.iter_all_1_2(tm1, tm2) {
                        self.pred_arity_decl_9(delta, tm0, tm1, tm3, tm2, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_arity_decl_9(
        &self,
        delta: &mut ModelDelta,
        tm0: PredDeclNode,
        tm1: Ident,
        tm3: Pred,
        tm2: ArgDeclListNode,
        tm4: TypeList,
    ) {
        for _ in [()] {
            let exists_already = self.pred_arity.iter_all_0_1(tm3, tm4).next().is_some();
            if !exists_already {
                delta.new_pred_arity.push(PredArity(tm3, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_func_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.semantic_decl_func_1(delta);
            self.semantic_decl_func_2(delta);
            self.semantic_decl_func_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_func_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn semantic_decl_func_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncDecl(tm0, tm1, tm2, tm3) in self.func_decl.iter_dirty() {
                self.semantic_decl_func_3(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_func_3(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: Ident,
    ) {
        for _ in [()] {
            self.semantic_decl_func_4(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_func_4(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: Ident,
    ) {
        for _ in [()] {
            let tm4 = match self.semantic_func.iter_all_0(tm1).next() {
                Some(SemanticFunc(_, res)) => res,
                None => {
                    delta.new_semantic_func_def.push(SemanticFuncArgs(tm1));
                    break;
                }
            };

            self.semantic_decl_func_6(delta, tm0, tm2, tm3, tm1, tm4);
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_func_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticFunc(tm1, tm4) in self.semantic_func.iter_dirty() {
                #[allow(unused_variables)]
                for FuncDecl(tm0, _, tm2, tm3) in self.func_decl.iter_all_1(tm1) {
                    self.semantic_decl_func_6(delta, tm0, tm2, tm3, tm1, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_func_6(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm2: ArgDeclListNode,
        tm3: Ident,
        tm1: Ident,
        tm4: Func,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn semantic_decl_func_ctor_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.semantic_decl_func_ctor_1(delta);
            self.semantic_decl_func_ctor_2(delta);
            self.semantic_decl_func_ctor_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_func_ctor_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn semantic_decl_func_ctor_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorDecl(tm0, tm1, tm2) in self.ctor_decl.iter_dirty() {
                self.semantic_decl_func_ctor_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_func_ctor_3(
        &self,
        delta: &mut ModelDelta,
        tm0: CtorDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
    ) {
        for _ in [()] {
            self.semantic_decl_func_ctor_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_func_ctor_4(
        &self,
        delta: &mut ModelDelta,
        tm0: CtorDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
    ) {
        for _ in [()] {
            let tm3 = match self.semantic_func.iter_all_0(tm1).next() {
                Some(SemanticFunc(_, res)) => res,
                None => {
                    delta.new_semantic_func_def.push(SemanticFuncArgs(tm1));
                    break;
                }
            };

            self.semantic_decl_func_ctor_6(delta, tm0, tm2, tm1, tm3);
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_func_ctor_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticFunc(tm1, tm3) in self.semantic_func.iter_dirty() {
                #[allow(unused_variables)]
                for CtorDecl(tm0, _, tm2) in self.ctor_decl.iter_all_1(tm1) {
                    self.semantic_decl_func_ctor_6(delta, tm0, tm2, tm1, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_decl_func_ctor_6(
        &self,
        delta: &mut ModelDelta,
        tm0: CtorDeclNode,
        tm2: ArgDeclListNode,
        tm1: Ident,
        tm3: Func,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn func_decl_domain_codomain_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.func_decl_domain_codomain_1(delta);
            self.func_decl_domain_codomain_2(delta);
            self.func_decl_domain_codomain_5(delta);
            self.func_decl_domain_codomain_8(delta);
            self.func_decl_domain_codomain_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn func_decl_domain_codomain_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn func_decl_domain_codomain_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncDecl(tm0, tm1, tm2, tm3) in self.func_decl.iter_dirty() {
                self.func_decl_domain_codomain_3(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn func_decl_domain_codomain_3(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: Ident,
    ) {
        for _ in [()] {
            self.func_decl_domain_codomain_4(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn func_decl_domain_codomain_4(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: Ident,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticFunc(_, tm4) in self.semantic_func.iter_all_0(tm1) {
                self.func_decl_domain_codomain_6(delta, tm0, tm2, tm3, tm1, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn func_decl_domain_codomain_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticFunc(tm1, tm4) in self.semantic_func.iter_dirty() {
                #[allow(unused_variables)]
                for FuncDecl(tm0, _, tm2, tm3) in self.func_decl.iter_all_1(tm1) {
                    self.func_decl_domain_codomain_6(delta, tm0, tm2, tm3, tm1, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn func_decl_domain_codomain_6(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm2: ArgDeclListNode,
        tm3: Ident,
        tm1: Ident,
        tm4: Func,
    ) {
        for _ in [()] {
            self.func_decl_domain_codomain_7(delta, tm0, tm2, tm3, tm1, tm4);
        }
    }

    #[allow(unused_variables)]
    fn func_decl_domain_codomain_7(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm2: ArgDeclListNode,
        tm3: Ident,
        tm1: Ident,
        tm4: Func,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticArgTypes(_, tm5) in self.semantic_arg_types.iter_all_0(tm2) {
                self.func_decl_domain_codomain_9(delta, tm0, tm3, tm1, tm4, tm2, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn func_decl_domain_codomain_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticArgTypes(tm2, tm5) in self.semantic_arg_types.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticFunc(tm1, tm4) in self.semantic_func.iter_all() {
                    #[allow(unused_variables)]
                    for FuncDecl(tm0, _, _, tm3) in self.func_decl.iter_all_1_2(tm1, tm2) {
                        self.func_decl_domain_codomain_9(delta, tm0, tm3, tm1, tm4, tm2, tm5);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn func_decl_domain_codomain_9(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm3: Ident,
        tm1: Ident,
        tm4: Func,
        tm2: ArgDeclListNode,
        tm5: TypeList,
    ) {
        for _ in [()] {
            self.func_decl_domain_codomain_10(delta, tm0, tm3, tm1, tm4, tm2, tm5);
        }
    }

    #[allow(unused_variables)]
    fn func_decl_domain_codomain_10(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm3: Ident,
        tm1: Ident,
        tm4: Func,
        tm2: ArgDeclListNode,
        tm5: TypeList,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticType(_, tm6) in self.semantic_type.iter_all_0(tm3) {
                self.func_decl_domain_codomain_12(delta, tm0, tm1, tm4, tm2, tm5, tm3, tm6);
            }
        }
    }

    #[allow(unused_variables)]
    fn func_decl_domain_codomain_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticType(tm3, tm6) in self.semantic_type.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticFunc(tm1, tm4) in self.semantic_func.iter_all() {
                    #[allow(unused_variables)]
                    for FuncDecl(tm0, _, tm2, _) in self.func_decl.iter_all_1_3(tm1, tm3) {
                        #[allow(unused_variables)]
                        for SemanticArgTypes(_, tm5) in self.semantic_arg_types.iter_all_0(tm2) {
                            self.func_decl_domain_codomain_12(
                                delta, tm0, tm1, tm4, tm2, tm5, tm3, tm6,
                            );
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn func_decl_domain_codomain_12(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm1: Ident,
        tm4: Func,
        tm2: ArgDeclListNode,
        tm5: TypeList,
        tm3: Ident,
        tm6: Type,
    ) {
        for _ in [()] {
            let exists_already = self.domain.iter_all_0_1(tm4, tm5).next().is_some();
            if !exists_already {
                delta.new_domain.push(Domain(tm4, tm5));
            }

            let exists_already = self.codomain.iter_all_0_1(tm4, tm6).next().is_some();
            if !exists_already {
                delta.new_codomain.push(Codomain(tm4, tm6));
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_domain_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.ctor_decl_domain_1(delta);
            self.ctor_decl_domain_2(delta);
            self.ctor_decl_domain_5(delta);
            self.ctor_decl_domain_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_domain_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn ctor_decl_domain_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorDecl(tm0, tm1, tm2) in self.ctor_decl.iter_dirty() {
                self.ctor_decl_domain_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_domain_3(
        &self,
        delta: &mut ModelDelta,
        tm0: CtorDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
    ) {
        for _ in [()] {
            self.ctor_decl_domain_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_domain_4(
        &self,
        delta: &mut ModelDelta,
        tm0: CtorDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticFunc(_, tm3) in self.semantic_func.iter_all_0(tm1) {
                self.ctor_decl_domain_6(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_domain_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticFunc(tm1, tm3) in self.semantic_func.iter_dirty() {
                #[allow(unused_variables)]
                for CtorDecl(tm0, _, tm2) in self.ctor_decl.iter_all_1(tm1) {
                    self.ctor_decl_domain_6(delta, tm0, tm2, tm1, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_domain_6(
        &self,
        delta: &mut ModelDelta,
        tm0: CtorDeclNode,
        tm2: ArgDeclListNode,
        tm1: Ident,
        tm3: Func,
    ) {
        for _ in [()] {
            self.ctor_decl_domain_7(delta, tm0, tm2, tm1, tm3);
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_domain_7(
        &self,
        delta: &mut ModelDelta,
        tm0: CtorDeclNode,
        tm2: ArgDeclListNode,
        tm1: Ident,
        tm3: Func,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticArgTypes(_, tm4) in self.semantic_arg_types.iter_all_0(tm2) {
                self.ctor_decl_domain_9(delta, tm0, tm1, tm3, tm2, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_domain_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticArgTypes(tm2, tm4) in self.semantic_arg_types.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticFunc(tm1, tm3) in self.semantic_func.iter_all() {
                    #[allow(unused_variables)]
                    for CtorDecl(tm0, _, _) in self.ctor_decl.iter_all_1_2(tm1, tm2) {
                        self.ctor_decl_domain_9(delta, tm0, tm1, tm3, tm2, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_domain_9(
        &self,
        delta: &mut ModelDelta,
        tm0: CtorDeclNode,
        tm1: Ident,
        tm3: Func,
        tm2: ArgDeclListNode,
        tm4: TypeList,
    ) {
        for _ in [()] {
            let exists_already = self.domain.iter_all_0_1(tm3, tm4).next().is_some();
            if !exists_already {
                delta.new_domain.push(Domain(tm3, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_codomain_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.ctor_decl_codomain_1(delta);
            self.ctor_decl_codomain_2(delta);
            self.ctor_decl_codomain_5(delta);
            self.ctor_decl_codomain_8(delta);
            self.ctor_decl_codomain_9(delta);
            self.ctor_decl_codomain_12(delta);
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_codomain_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn ctor_decl_codomain_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorDecl(tm0, tm1, tm2) in self.ctor_decl.iter_dirty() {
                self.ctor_decl_codomain_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_codomain_3(
        &self,
        delta: &mut ModelDelta,
        tm0: CtorDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
    ) {
        for _ in [()] {
            self.ctor_decl_codomain_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_codomain_4(
        &self,
        delta: &mut ModelDelta,
        tm0: CtorDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticFunc(_, tm3) in self.semantic_func.iter_all_0(tm1) {
                self.ctor_decl_codomain_6(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_codomain_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticFunc(tm1, tm3) in self.semantic_func.iter_dirty() {
                #[allow(unused_variables)]
                for CtorDecl(tm0, _, tm2) in self.ctor_decl.iter_all_1(tm1) {
                    self.ctor_decl_codomain_6(delta, tm0, tm2, tm1, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_codomain_6(
        &self,
        delta: &mut ModelDelta,
        tm0: CtorDeclNode,
        tm2: ArgDeclListNode,
        tm1: Ident,
        tm3: Func,
    ) {
        for _ in [()] {
            self.ctor_decl_codomain_7(delta, tm0, tm2, tm1, tm3);
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_codomain_7(
        &self,
        delta: &mut ModelDelta,
        tm0: CtorDeclNode,
        tm2: ArgDeclListNode,
        tm1: Ident,
        tm3: Func,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorEnum(_, tm4) in self.ctor_enum.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for EnumDecl(_, tm5, tm6) in self.enum_decl.iter_all_0(tm4) {
                    self.ctor_decl_codomain_10(delta, tm2, tm1, tm3, tm0, tm4, tm5, tm6);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_codomain_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumDecl(tm4, tm5, tm6) in self.enum_decl.iter_dirty() {
                #[allow(unused_variables)]
                for CtorEnum(tm0, _) in self.ctor_enum.iter_all_1(tm4) {
                    #[allow(unused_variables)]
                    for SemanticFunc(tm1, tm3) in self.semantic_func.iter_all() {
                        #[allow(unused_variables)]
                        for CtorDecl(_, _, tm2) in self.ctor_decl.iter_all_0_1(tm0, tm1) {
                            self.ctor_decl_codomain_10(delta, tm2, tm1, tm3, tm0, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_codomain_9(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorEnum(tm0, tm4) in self.ctor_enum.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticFunc(tm1, tm3) in self.semantic_func.iter_all() {
                    #[allow(unused_variables)]
                    for CtorDecl(_, _, tm2) in self.ctor_decl.iter_all_0_1(tm0, tm1) {
                        #[allow(unused_variables)]
                        for EnumDecl(_, tm5, tm6) in self.enum_decl.iter_all_0(tm4) {
                            self.ctor_decl_codomain_10(delta, tm2, tm1, tm3, tm0, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_codomain_10(
        &self,
        delta: &mut ModelDelta,
        tm2: ArgDeclListNode,
        tm1: Ident,
        tm3: Func,
        tm0: CtorDeclNode,
        tm4: EnumDeclNode,
        tm5: Ident,
        tm6: CtorDeclListNode,
    ) {
        for _ in [()] {
            self.ctor_decl_codomain_11(delta, tm2, tm1, tm3, tm0, tm4, tm5, tm6);
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_codomain_11(
        &self,
        delta: &mut ModelDelta,
        tm2: ArgDeclListNode,
        tm1: Ident,
        tm3: Func,
        tm0: CtorDeclNode,
        tm4: EnumDeclNode,
        tm5: Ident,
        tm6: CtorDeclListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticType(_, tm7) in self.semantic_type.iter_all_0(tm5) {
                self.ctor_decl_codomain_13(delta, tm2, tm1, tm3, tm0, tm4, tm6, tm5, tm7);
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_codomain_12(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticType(tm5, tm7) in self.semantic_type.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticFunc(tm1, tm3) in self.semantic_func.iter_all() {
                    #[allow(unused_variables)]
                    for CtorDecl(tm0, _, tm2) in self.ctor_decl.iter_all_1(tm1) {
                        #[allow(unused_variables)]
                        for CtorEnum(_, tm4) in self.ctor_enum.iter_all_0(tm0) {
                            #[allow(unused_variables)]
                            for EnumDecl(_, _, tm6) in self.enum_decl.iter_all_0_1(tm4, tm5) {
                                self.ctor_decl_codomain_13(
                                    delta, tm2, tm1, tm3, tm0, tm4, tm6, tm5, tm7,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_codomain_13(
        &self,
        delta: &mut ModelDelta,
        tm2: ArgDeclListNode,
        tm1: Ident,
        tm3: Func,
        tm0: CtorDeclNode,
        tm4: EnumDeclNode,
        tm6: CtorDeclListNode,
        tm5: Ident,
        tm7: Type,
    ) {
        for _ in [()] {
            let exists_already = self.codomain.iter_all_0_1(tm3, tm7).next().is_some();
            if !exists_already {
                delta.new_codomain.push(Codomain(tm3, tm7));
            }
        }
    }

    #[allow(unused_variables)]
    fn rel_constructors_pred_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.rel_constructors_pred_total_1(delta);
            self.rel_constructors_pred_total_2(delta);
            self.rel_constructors_pred_total_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn rel_constructors_pred_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rel_constructors_pred_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.pred_dirty.iter().copied() {
                self.rel_constructors_pred_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn rel_constructors_pred_total_3(&self, delta: &mut ModelDelta, tm0: Pred) {
        for _ in [()] {
            self.rel_constructors_pred_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn rel_constructors_pred_total_4(&self, delta: &mut ModelDelta, tm0: Pred) {
        for _ in [()] {
            let tm1 = match self.pred_rel.iter_all_0(tm0).next() {
                Some(PredRel(_, res)) => res,
                None => {
                    delta.new_pred_rel_def.push(PredRelArgs(tm0));
                    break;
                }
            };

            self.rel_constructors_pred_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn rel_constructors_pred_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredRel(tm0, tm1) in self.pred_rel.iter_dirty() {
                self.rel_constructors_pred_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn rel_constructors_pred_total_6(&self, delta: &mut ModelDelta, tm0: Pred, tm1: Rel) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rel_constructors_func_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.rel_constructors_func_total_1(delta);
            self.rel_constructors_func_total_2(delta);
            self.rel_constructors_func_total_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn rel_constructors_func_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rel_constructors_func_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.func_dirty.iter().copied() {
                self.rel_constructors_func_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn rel_constructors_func_total_3(&self, delta: &mut ModelDelta, tm0: Func) {
        for _ in [()] {
            self.rel_constructors_func_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn rel_constructors_func_total_4(&self, delta: &mut ModelDelta, tm0: Func) {
        for _ in [()] {
            let tm1 = match self.func_rel.iter_all_0(tm0).next() {
                Some(FuncRel(_, res)) => res,
                None => {
                    delta.new_func_rel_def.push(FuncRelArgs(tm0));
                    break;
                }
            };

            self.rel_constructors_func_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn rel_constructors_func_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncRel(tm0, tm1) in self.func_rel.iter_dirty() {
                self.rel_constructors_func_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn rel_constructors_func_total_6(&self, delta: &mut ModelDelta, tm0: Func, tm1: Rel) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn arity_laws_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.arity_laws_1(delta);
            self.arity_laws_2(delta);
            self.arity_laws_7(delta);
            self.arity_laws_10(delta);
            self.arity_laws_13(delta);
            self.arity_laws_16(delta);
            self.arity_laws_19(delta);
            self.arity_laws_22(delta);
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn arity_laws_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.rel_dirty.iter().copied() {
                self.arity_laws_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_3(&self, delta: &mut ModelDelta, tm0: Rel) {
        for _ in [()] {
            self.arity_laws_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_4(&self, delta: &mut ModelDelta, tm0: Rel) {
        for _ in [()] {
            self.arity_laws_5(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_5(&self, delta: &mut ModelDelta, tm0: Rel) {
        for _ in [()] {
            self.arity_laws_6(delta, tm0);
            self.arity_laws_9(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_6(&self, delta: &mut ModelDelta, tm0: Rel) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredRel(tm1, _) in self.pred_rel.iter_all_1(tm0) {
                self.arity_laws_8(delta, tm1, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_7(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredRel(tm1, tm0) in self.pred_rel.iter_dirty() {
                self.arity_laws_8(delta, tm1, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_8(&self, delta: &mut ModelDelta, tm1: Pred, tm0: Rel) {
        for _ in [()] {
            self.arity_laws_12(delta, tm1, tm0);
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_9(&self, delta: &mut ModelDelta, tm0: Rel) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncRel(tm2, _) in self.func_rel.iter_all_1(tm0) {
                self.arity_laws_11(delta, tm2, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_10(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncRel(tm2, tm0) in self.func_rel.iter_dirty() {
                self.arity_laws_11(delta, tm2, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_11(&self, delta: &mut ModelDelta, tm2: Func, tm0: Rel) {
        for _ in [()] {
            self.arity_laws_15(delta, tm2, tm0);
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_12(&self, delta: &mut ModelDelta, tm1: Pred, tm0: Rel) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredArity(_, tm3) in self.pred_arity.iter_all_0(tm1) {
                self.arity_laws_14(delta, tm0, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_13(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredArity(tm1, tm3) in self.pred_arity.iter_dirty() {
                #[allow(unused_variables)]
                for PredRel(_, tm0) in self.pred_rel.iter_all_0(tm1) {
                    self.arity_laws_14(delta, tm0, tm1, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_14(&self, delta: &mut ModelDelta, tm0: Rel, tm1: Pred, tm3: TypeList) {
        for _ in [()] {
            let exists_already = self.arity.iter_all_0_1(tm0, tm3).next().is_some();
            if !exists_already {
                delta.new_arity.push(Arity(tm0, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_15(&self, delta: &mut ModelDelta, tm2: Func, tm0: Rel) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Domain(_, tm4) in self.domain.iter_all_0(tm2) {
                self.arity_laws_17(delta, tm0, tm2, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_16(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Domain(tm2, tm4) in self.domain.iter_dirty() {
                #[allow(unused_variables)]
                for FuncRel(_, tm0) in self.func_rel.iter_all_0(tm2) {
                    self.arity_laws_17(delta, tm0, tm2, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_17(&self, delta: &mut ModelDelta, tm0: Rel, tm2: Func, tm4: TypeList) {
        for _ in [()] {
            self.arity_laws_18(delta, tm0, tm2, tm4);
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_18(&self, delta: &mut ModelDelta, tm0: Rel, tm2: Func, tm4: TypeList) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Codomain(_, tm5) in self.codomain.iter_all_0(tm2) {
                self.arity_laws_20(delta, tm0, tm4, tm2, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_19(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Codomain(tm2, tm5) in self.codomain.iter_dirty() {
                #[allow(unused_variables)]
                for FuncRel(_, tm0) in self.func_rel.iter_all_0(tm2) {
                    #[allow(unused_variables)]
                    for Domain(_, tm4) in self.domain.iter_all_0(tm2) {
                        self.arity_laws_20(delta, tm0, tm4, tm2, tm5);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_20(&self, delta: &mut ModelDelta, tm0: Rel, tm4: TypeList, tm2: Func, tm5: Type) {
        for _ in [()] {
            self.arity_laws_21(delta, tm0, tm4, tm2, tm5);
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_21(&self, delta: &mut ModelDelta, tm0: Rel, tm4: TypeList, tm2: Func, tm5: Type) {
        for _ in [()] {
            let tm6 = match self.snoc_type_list.iter_all_0_1(tm4, tm5).next() {
                Some(SnocTypeList(_, _, res)) => res,
                None => {
                    delta
                        .new_snoc_type_list_def
                        .push(SnocTypeListArgs(tm4, tm5));
                    break;
                }
            };

            self.arity_laws_23(delta, tm0, tm4, tm2, tm5, tm6);
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_22(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SnocTypeList(tm4, tm5, tm6) in self.snoc_type_list.iter_dirty() {
                #[allow(unused_variables)]
                for Codomain(tm2, _) in self.codomain.iter_all_1(tm5) {
                    #[allow(unused_variables)]
                    for Domain(_, _) in self.domain.iter_all_0_1(tm2, tm4) {
                        #[allow(unused_variables)]
                        for FuncRel(_, tm0) in self.func_rel.iter_all_0(tm2) {
                            self.arity_laws_23(delta, tm0, tm4, tm2, tm5, tm6);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn arity_laws_23(
        &self,
        delta: &mut ModelDelta,
        tm0: Rel,
        tm4: TypeList,
        tm2: Func,
        tm5: Type,
        tm6: TypeList,
    ) {
        for _ in [()] {
            let exists_already = self.arity.iter_all_0_1(tm0, tm6).next().is_some();
            if !exists_already {
                delta.new_arity.push(Arity(tm0, tm6));
            }
        }
    }

    #[allow(unused_variables)]
    fn el_list_cons_injective_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.el_list_cons_injective_1(delta);
            self.el_list_cons_injective_2(delta);
            self.el_list_cons_injective_3(delta);
        }
    }

    #[allow(unused_variables)]
    fn el_list_cons_injective_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn el_list_cons_injective_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsElList(tm0, tm1, tm4) in self.cons_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for ConsElList(tm2, tm3, _) in self.cons_el_list.iter_all_2(tm4) {
                    self.el_list_cons_injective_4(delta, tm0, tm1, tm2, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn el_list_cons_injective_3(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsElList(tm2, tm3, tm4) in self.cons_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for ConsElList(tm0, tm1, _) in self.cons_el_list.iter_all_2(tm4) {
                    self.el_list_cons_injective_4(delta, tm0, tm1, tm2, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn el_list_cons_injective_4(
        &self,
        delta: &mut ModelDelta,
        tm0: El,
        tm1: ElList,
        tm2: El,
        tm3: ElList,
        tm4: ElList,
    ) {
        for _ in [()] {
            delta.new_el_equalities.push((tm0, tm2));

            delta.new_el_equalities.push((tm2, tm0));

            delta.new_el_list_equalities.push((tm1, tm3));

            delta.new_el_list_equalities.push((tm3, tm1));
        }
    }

    #[allow(unused_variables)]
    fn el_list_snoc_injective_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.el_list_snoc_injective_1(delta);
            self.el_list_snoc_injective_2(delta);
            self.el_list_snoc_injective_3(delta);
        }
    }

    #[allow(unused_variables)]
    fn el_list_snoc_injective_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn el_list_snoc_injective_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SnocElList(tm0, tm1, tm4) in self.snoc_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for SnocElList(tm2, tm3, _) in self.snoc_el_list.iter_all_2(tm4) {
                    self.el_list_snoc_injective_4(delta, tm0, tm1, tm2, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn el_list_snoc_injective_3(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SnocElList(tm2, tm3, tm4) in self.snoc_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for SnocElList(tm0, tm1, _) in self.snoc_el_list.iter_all_2(tm4) {
                    self.el_list_snoc_injective_4(delta, tm0, tm1, tm2, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn el_list_snoc_injective_4(
        &self,
        delta: &mut ModelDelta,
        tm0: ElList,
        tm1: El,
        tm2: ElList,
        tm3: El,
        tm4: ElList,
    ) {
        for _ in [()] {
            delta.new_el_list_equalities.push((tm0, tm2));

            delta.new_el_list_equalities.push((tm2, tm0));

            delta.new_el_equalities.push((tm1, tm3));

            delta.new_el_equalities.push((tm3, tm1));
        }
    }

    #[allow(unused_variables)]
    fn el_list_cons_nil_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.el_list_cons_nil_1(delta);
            self.el_list_cons_nil_2(delta);
            self.el_list_cons_nil_3(delta);
        }
    }

    #[allow(unused_variables)]
    fn el_list_cons_nil_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn el_list_cons_nil_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilElList(tm2, tm3) in self.nil_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for ConsElList(tm0, tm1, _) in self.cons_el_list.iter_all_2(tm3) {
                    self.el_list_cons_nil_4(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn el_list_cons_nil_3(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsElList(tm0, tm1, tm3) in self.cons_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for NilElList(tm2, _) in self.nil_el_list.iter_all_1(tm3) {
                    self.el_list_cons_nil_4(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn el_list_cons_nil_4(
        &self,
        delta: &mut ModelDelta,
        tm0: El,
        tm1: ElList,
        tm2: Structure,
        tm3: ElList,
    ) {
        for _ in [()] {
            let exists_already = self.absurd.iter_all().next().is_some();
            if !exists_already {
                delta.new_absurd.push(Absurd());
            }
        }
    }

    #[allow(unused_variables)]
    fn el_list_snoc_nil_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.el_list_snoc_nil_1(delta);
            self.el_list_snoc_nil_2(delta);
            self.el_list_snoc_nil_3(delta);
        }
    }

    #[allow(unused_variables)]
    fn el_list_snoc_nil_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn el_list_snoc_nil_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilElList(tm2, tm3) in self.nil_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for SnocElList(tm0, tm1, _) in self.snoc_el_list.iter_all_2(tm3) {
                    self.el_list_snoc_nil_4(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn el_list_snoc_nil_3(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SnocElList(tm0, tm1, tm3) in self.snoc_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for NilElList(tm2, _) in self.nil_el_list.iter_all_1(tm3) {
                    self.el_list_snoc_nil_4(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn el_list_snoc_nil_4(
        &self,
        delta: &mut ModelDelta,
        tm0: ElList,
        tm1: El,
        tm2: Structure,
        tm3: ElList,
    ) {
        for _ in [()] {
            let exists_already = self.absurd.iter_all().next().is_some();
            if !exists_already {
                delta.new_absurd.push(Absurd());
            }
        }
    }

    #[allow(unused_variables)]
    fn nil_els_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.nil_els_structure_1(delta);
            self.nil_els_structure_2(delta);
        }
    }

    #[allow(unused_variables)]
    fn nil_els_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn nil_els_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilElList(tm0, tm1) in self.nil_el_list.iter_dirty() {
                self.nil_els_structure_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn nil_els_structure_3(&self, delta: &mut ModelDelta, tm0: Structure, tm1: ElList) {
        for _ in [()] {
            let exists_already = self.els_structure.iter_all_0_1(tm1, tm0).next().is_some();
            if !exists_already {
                delta.new_els_structure.push(ElsStructure(tm1, tm0));
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_els_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.cons_els_structure_1(delta);
            self.cons_els_structure_2(delta);
            self.cons_els_structure_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn cons_els_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cons_els_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsElList(tm0, tm1, tm2) in self.cons_el_list.iter_dirty() {
                self.cons_els_structure_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_els_structure_3(&self, delta: &mut ModelDelta, tm0: El, tm1: ElList, tm2: ElList) {
        for _ in [()] {
            self.cons_els_structure_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn cons_els_structure_4(&self, delta: &mut ModelDelta, tm0: El, tm1: ElList, tm2: ElList) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElStructure(_, tm3) in self.el_structure.iter_all_0(tm0) {
                self.cons_els_structure_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_els_structure_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElStructure(tm0, tm3) in self.el_structure.iter_dirty() {
                #[allow(unused_variables)]
                for ConsElList(_, tm1, tm2) in self.cons_el_list.iter_all_0(tm0) {
                    self.cons_els_structure_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_els_structure_6(
        &self,
        delta: &mut ModelDelta,
        tm1: ElList,
        tm2: ElList,
        tm0: El,
        tm3: Structure,
    ) {
        for _ in [()] {
            let exists_already = self.els_structure.iter_all_0_1(tm2, tm3).next().is_some();
            if !exists_already {
                delta.new_els_structure.push(ElsStructure(tm2, tm3));
            }

            let exists_already = self.els_structure.iter_all_0_1(tm1, tm3).next().is_some();
            if !exists_already {
                delta.new_els_structure.push(ElsStructure(tm1, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn snoc_els_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.snoc_els_structure_1(delta);
            self.snoc_els_structure_2(delta);
            self.snoc_els_structure_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn snoc_els_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn snoc_els_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SnocElList(tm0, tm1, tm2) in self.snoc_el_list.iter_dirty() {
                self.snoc_els_structure_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn snoc_els_structure_3(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList) {
        for _ in [()] {
            self.snoc_els_structure_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn snoc_els_structure_4(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElStructure(_, tm3) in self.el_structure.iter_all_0(tm1) {
                self.snoc_els_structure_6(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn snoc_els_structure_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElStructure(tm1, tm3) in self.el_structure.iter_dirty() {
                #[allow(unused_variables)]
                for SnocElList(tm0, _, tm2) in self.snoc_el_list.iter_all_1(tm1) {
                    self.snoc_els_structure_6(delta, tm0, tm2, tm1, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn snoc_els_structure_6(
        &self,
        delta: &mut ModelDelta,
        tm0: ElList,
        tm2: ElList,
        tm1: El,
        tm3: Structure,
    ) {
        for _ in [()] {
            let exists_already = self.els_structure.iter_all_0_1(tm2, tm3).next().is_some();
            if !exists_already {
                delta.new_els_structure.push(ElsStructure(tm2, tm3));
            }

            let exists_already = self.els_structure.iter_all_0_1(tm0, tm3).next().is_some();
            if !exists_already {
                delta.new_els_structure.push(ElsStructure(tm0, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn var_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.var_structure_1(delta);
            self.var_structure_2(delta);
        }
    }

    #[allow(unused_variables)]
    fn var_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn var_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Var(tm0, tm1, tm2) in self.var.iter_dirty() {
                self.var_structure_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn var_structure_3(&self, delta: &mut ModelDelta, tm0: Structure, tm1: ElName, tm2: El) {
        for _ in [()] {
            let exists_already = self.el_structure.iter_all_0_1(tm2, tm0).next().is_some();
            if !exists_already {
                delta.new_el_structure.push(ElStructure(tm2, tm0));
            }
        }
    }

    #[allow(unused_variables)]
    fn nil_el_types_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.nil_el_types_1(delta);
            self.nil_el_types_2(delta);
            self.nil_el_types_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn nil_el_types_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn nil_el_types_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilElList(tm0, tm1) in self.nil_el_list.iter_dirty() {
                self.nil_el_types_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn nil_el_types_3(&self, delta: &mut ModelDelta, tm0: Structure, tm1: ElList) {
        for _ in [()] {
            self.nil_el_types_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn nil_el_types_4(&self, delta: &mut ModelDelta, tm0: Structure, tm1: ElList) {
        for _ in [()] {
            let tm2 = match self.nil_type_list.iter_all().next() {
                Some(NilTypeList(res)) => res,
                None => {
                    delta.new_nil_type_list_def.push(NilTypeListArgs());
                    break;
                }
            };

            self.nil_el_types_6(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn nil_el_types_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilTypeList(tm2) in self.nil_type_list.iter_dirty() {
                #[allow(unused_variables)]
                for NilElList(tm0, tm1) in self.nil_el_list.iter_all() {
                    self.nil_el_types_6(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn nil_el_types_6(&self, delta: &mut ModelDelta, tm0: Structure, tm1: ElList, tm2: TypeList) {
        for _ in [()] {
            let exists_already = self.el_types.iter_all_0_1(tm1, tm2).next().is_some();
            if !exists_already {
                delta.new_el_types.push(ElTypes(tm1, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_el_types_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.cons_el_types_1(delta);
            self.cons_el_types_2(delta);
            self.cons_el_types_5(delta);
            self.cons_el_types_8(delta);
            self.cons_el_types_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn cons_el_types_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cons_el_types_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsElList(tm0, tm1, tm2) in self.cons_el_list.iter_dirty() {
                self.cons_el_types_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_el_types_3(&self, delta: &mut ModelDelta, tm0: El, tm1: ElList, tm2: ElList) {
        for _ in [()] {
            self.cons_el_types_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn cons_el_types_4(&self, delta: &mut ModelDelta, tm0: El, tm1: ElList, tm2: ElList) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElType(_, tm3) in self.el_type.iter_all_0(tm0) {
                self.cons_el_types_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_el_types_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElType(tm0, tm3) in self.el_type.iter_dirty() {
                #[allow(unused_variables)]
                for ConsElList(_, tm1, tm2) in self.cons_el_list.iter_all_0(tm0) {
                    self.cons_el_types_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_el_types_6(
        &self,
        delta: &mut ModelDelta,
        tm1: ElList,
        tm2: ElList,
        tm0: El,
        tm3: Type,
    ) {
        for _ in [()] {
            self.cons_el_types_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn cons_el_types_7(
        &self,
        delta: &mut ModelDelta,
        tm1: ElList,
        tm2: ElList,
        tm0: El,
        tm3: Type,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElTypes(_, tm4) in self.el_types.iter_all_0(tm1) {
                self.cons_el_types_9(delta, tm2, tm0, tm3, tm1, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_el_types_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElTypes(tm1, tm4) in self.el_types.iter_dirty() {
                #[allow(unused_variables)]
                for ConsElList(tm0, _, tm2) in self.cons_el_list.iter_all_1(tm1) {
                    #[allow(unused_variables)]
                    for ElType(_, tm3) in self.el_type.iter_all_0(tm0) {
                        self.cons_el_types_9(delta, tm2, tm0, tm3, tm1, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_el_types_9(
        &self,
        delta: &mut ModelDelta,
        tm2: ElList,
        tm0: El,
        tm3: Type,
        tm1: ElList,
        tm4: TypeList,
    ) {
        for _ in [()] {
            self.cons_el_types_10(delta, tm2, tm0, tm3, tm1, tm4);
        }
    }

    #[allow(unused_variables)]
    fn cons_el_types_10(
        &self,
        delta: &mut ModelDelta,
        tm2: ElList,
        tm0: El,
        tm3: Type,
        tm1: ElList,
        tm4: TypeList,
    ) {
        for _ in [()] {
            let tm5 = match self.cons_type_list.iter_all_0_1(tm3, tm4).next() {
                Some(ConsTypeList(_, _, res)) => res,
                None => {
                    delta
                        .new_cons_type_list_def
                        .push(ConsTypeListArgs(tm3, tm4));
                    break;
                }
            };

            self.cons_el_types_12(delta, tm2, tm0, tm1, tm3, tm4, tm5);
        }
    }

    #[allow(unused_variables)]
    fn cons_el_types_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsTypeList(tm3, tm4, tm5) in self.cons_type_list.iter_dirty() {
                #[allow(unused_variables)]
                for ElTypes(tm1, _) in self.el_types.iter_all_1(tm4) {
                    #[allow(unused_variables)]
                    for ElType(tm0, _) in self.el_type.iter_all_1(tm3) {
                        #[allow(unused_variables)]
                        for ConsElList(_, _, tm2) in self.cons_el_list.iter_all_0_1(tm0, tm1) {
                            self.cons_el_types_12(delta, tm2, tm0, tm1, tm3, tm4, tm5);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_el_types_12(
        &self,
        delta: &mut ModelDelta,
        tm2: ElList,
        tm0: El,
        tm1: ElList,
        tm3: Type,
        tm4: TypeList,
        tm5: TypeList,
    ) {
        for _ in [()] {
            let exists_already = self.el_types.iter_all_0_1(tm2, tm5).next().is_some();
            if !exists_already {
                delta.new_el_types.push(ElTypes(tm2, tm5));
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_el_types_reverse_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.cons_el_types_reverse_1(delta);
            self.cons_el_types_reverse_2(delta);
            self.cons_el_types_reverse_5(delta);
            self.cons_el_types_reverse_6(delta);
        }
    }

    #[allow(unused_variables)]
    fn cons_el_types_reverse_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cons_el_types_reverse_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsElList(tm0, tm1, tm2) in self.cons_el_list.iter_dirty() {
                self.cons_el_types_reverse_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_el_types_reverse_3(&self, delta: &mut ModelDelta, tm0: El, tm1: ElList, tm2: ElList) {
        for _ in [()] {
            self.cons_el_types_reverse_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn cons_el_types_reverse_4(&self, delta: &mut ModelDelta, tm0: El, tm1: ElList, tm2: ElList) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElTypes(_, tm5) in self.el_types.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for ConsTypeList(tm3, tm4, _) in self.cons_type_list.iter_all_2(tm5) {
                    self.cons_el_types_reverse_7(delta, tm0, tm1, tm2, tm3, tm4, tm5);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_el_types_reverse_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElTypes(tm2, tm5) in self.el_types.iter_dirty() {
                #[allow(unused_variables)]
                for ConsElList(tm0, tm1, _) in self.cons_el_list.iter_all_2(tm2) {
                    #[allow(unused_variables)]
                    for ConsTypeList(tm3, tm4, _) in self.cons_type_list.iter_all_2(tm5) {
                        self.cons_el_types_reverse_7(delta, tm0, tm1, tm2, tm3, tm4, tm5);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_el_types_reverse_6(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsTypeList(tm3, tm4, tm5) in self.cons_type_list.iter_dirty() {
                #[allow(unused_variables)]
                for ElTypes(tm2, _) in self.el_types.iter_all_1(tm5) {
                    #[allow(unused_variables)]
                    for ConsElList(tm0, tm1, _) in self.cons_el_list.iter_all_2(tm2) {
                        self.cons_el_types_reverse_7(delta, tm0, tm1, tm2, tm3, tm4, tm5);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_el_types_reverse_7(
        &self,
        delta: &mut ModelDelta,
        tm0: El,
        tm1: ElList,
        tm2: ElList,
        tm3: Type,
        tm4: TypeList,
        tm5: TypeList,
    ) {
        for _ in [()] {
            let exists_already = self.el_type.iter_all_0_1(tm0, tm3).next().is_some();
            if !exists_already {
                delta.new_el_type.push(ElType(tm0, tm3));
            }

            let exists_already = self.el_types.iter_all_0_1(tm1, tm4).next().is_some();
            if !exists_already {
                delta.new_el_types.push(ElTypes(tm1, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn snoc_el_types_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.snoc_el_types_1(delta);
            self.snoc_el_types_2(delta);
            self.snoc_el_types_5(delta);
            self.snoc_el_types_8(delta);
            self.snoc_el_types_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn snoc_el_types_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn snoc_el_types_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SnocElList(tm0, tm1, tm2) in self.snoc_el_list.iter_dirty() {
                self.snoc_el_types_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn snoc_el_types_3(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList) {
        for _ in [()] {
            self.snoc_el_types_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn snoc_el_types_4(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElTypes(_, tm3) in self.el_types.iter_all_0(tm0) {
                self.snoc_el_types_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn snoc_el_types_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElTypes(tm0, tm3) in self.el_types.iter_dirty() {
                #[allow(unused_variables)]
                for SnocElList(_, tm1, tm2) in self.snoc_el_list.iter_all_0(tm0) {
                    self.snoc_el_types_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn snoc_el_types_6(
        &self,
        delta: &mut ModelDelta,
        tm1: El,
        tm2: ElList,
        tm0: ElList,
        tm3: TypeList,
    ) {
        for _ in [()] {
            self.snoc_el_types_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn snoc_el_types_7(
        &self,
        delta: &mut ModelDelta,
        tm1: El,
        tm2: ElList,
        tm0: ElList,
        tm3: TypeList,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElType(_, tm4) in self.el_type.iter_all_0(tm1) {
                self.snoc_el_types_9(delta, tm2, tm0, tm3, tm1, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn snoc_el_types_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElType(tm1, tm4) in self.el_type.iter_dirty() {
                #[allow(unused_variables)]
                for SnocElList(tm0, _, tm2) in self.snoc_el_list.iter_all_1(tm1) {
                    #[allow(unused_variables)]
                    for ElTypes(_, tm3) in self.el_types.iter_all_0(tm0) {
                        self.snoc_el_types_9(delta, tm2, tm0, tm3, tm1, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn snoc_el_types_9(
        &self,
        delta: &mut ModelDelta,
        tm2: ElList,
        tm0: ElList,
        tm3: TypeList,
        tm1: El,
        tm4: Type,
    ) {
        for _ in [()] {
            self.snoc_el_types_10(delta, tm2, tm0, tm3, tm1, tm4);
        }
    }

    #[allow(unused_variables)]
    fn snoc_el_types_10(
        &self,
        delta: &mut ModelDelta,
        tm2: ElList,
        tm0: ElList,
        tm3: TypeList,
        tm1: El,
        tm4: Type,
    ) {
        for _ in [()] {
            let tm5 = match self.snoc_type_list.iter_all_0_1(tm3, tm4).next() {
                Some(SnocTypeList(_, _, res)) => res,
                None => {
                    delta
                        .new_snoc_type_list_def
                        .push(SnocTypeListArgs(tm3, tm4));
                    break;
                }
            };

            self.snoc_el_types_12(delta, tm2, tm0, tm1, tm3, tm4, tm5);
        }
    }

    #[allow(unused_variables)]
    fn snoc_el_types_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SnocTypeList(tm3, tm4, tm5) in self.snoc_type_list.iter_dirty() {
                #[allow(unused_variables)]
                for ElTypes(tm0, _) in self.el_types.iter_all_1(tm3) {
                    #[allow(unused_variables)]
                    for ElType(tm1, _) in self.el_type.iter_all_1(tm4) {
                        #[allow(unused_variables)]
                        for SnocElList(_, _, tm2) in self.snoc_el_list.iter_all_0_1(tm0, tm1) {
                            self.snoc_el_types_12(delta, tm2, tm0, tm1, tm3, tm4, tm5);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn snoc_el_types_12(
        &self,
        delta: &mut ModelDelta,
        tm2: ElList,
        tm0: ElList,
        tm1: El,
        tm3: TypeList,
        tm4: Type,
        tm5: TypeList,
    ) {
        for _ in [()] {
            let exists_already = self.el_types.iter_all_0_1(tm2, tm5).next().is_some();
            if !exists_already {
                delta.new_el_types.push(ElTypes(tm2, tm5));
            }
        }
    }

    #[allow(unused_variables)]
    fn snoc_el_types_reverse_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.snoc_el_types_reverse_1(delta);
            self.snoc_el_types_reverse_2(delta);
            self.snoc_el_types_reverse_5(delta);
            self.snoc_el_types_reverse_6(delta);
        }
    }

    #[allow(unused_variables)]
    fn snoc_el_types_reverse_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn snoc_el_types_reverse_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SnocElList(tm0, tm1, tm2) in self.snoc_el_list.iter_dirty() {
                self.snoc_el_types_reverse_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn snoc_el_types_reverse_3(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList) {
        for _ in [()] {
            self.snoc_el_types_reverse_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn snoc_el_types_reverse_4(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElTypes(_, tm5) in self.el_types.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for SnocTypeList(tm3, tm4, _) in self.snoc_type_list.iter_all_2(tm5) {
                    self.snoc_el_types_reverse_7(delta, tm0, tm1, tm2, tm3, tm4, tm5);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn snoc_el_types_reverse_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElTypes(tm2, tm5) in self.el_types.iter_dirty() {
                #[allow(unused_variables)]
                for SnocElList(tm0, tm1, _) in self.snoc_el_list.iter_all_2(tm2) {
                    #[allow(unused_variables)]
                    for SnocTypeList(tm3, tm4, _) in self.snoc_type_list.iter_all_2(tm5) {
                        self.snoc_el_types_reverse_7(delta, tm0, tm1, tm2, tm3, tm4, tm5);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn snoc_el_types_reverse_6(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SnocTypeList(tm3, tm4, tm5) in self.snoc_type_list.iter_dirty() {
                #[allow(unused_variables)]
                for ElTypes(tm2, _) in self.el_types.iter_all_1(tm5) {
                    #[allow(unused_variables)]
                    for SnocElList(tm0, tm1, _) in self.snoc_el_list.iter_all_2(tm2) {
                        self.snoc_el_types_reverse_7(delta, tm0, tm1, tm2, tm3, tm4, tm5);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn snoc_el_types_reverse_7(
        &self,
        delta: &mut ModelDelta,
        tm0: ElList,
        tm1: El,
        tm2: ElList,
        tm3: TypeList,
        tm4: Type,
        tm5: TypeList,
    ) {
        for _ in [()] {
            let exists_already = self.el_types.iter_all_0_1(tm0, tm3).next().is_some();
            if !exists_already {
                delta.new_el_types.push(ElTypes(tm0, tm3));
            }

            let exists_already = self.el_type.iter_all_0_1(tm1, tm4).next().is_some();
            if !exists_already {
                delta.new_el_type.push(ElType(tm1, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn rel_app_types_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.rel_app_types_1(delta);
            self.rel_app_types_2(delta);
            self.rel_app_types_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn rel_app_types_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rel_app_types_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RelApp(tm0, tm1) in self.rel_app.iter_dirty() {
                self.rel_app_types_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn rel_app_types_3(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList) {
        for _ in [()] {
            self.rel_app_types_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn rel_app_types_4(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Arity(_, tm2) in self.arity.iter_all_0(tm0) {
                self.rel_app_types_6(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn rel_app_types_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Arity(tm0, tm2) in self.arity.iter_dirty() {
                #[allow(unused_variables)]
                for RelApp(_, tm1) in self.rel_app.iter_all_0(tm0) {
                    self.rel_app_types_6(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn rel_app_types_6(&self, delta: &mut ModelDelta, tm1: ElList, tm0: Rel, tm2: TypeList) {
        for _ in [()] {
            let exists_already = self.el_types.iter_all_0_1(tm1, tm2).next().is_some();
            if !exists_already {
                delta.new_el_types.push(ElTypes(tm1, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn rel_app_func_app_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.rel_app_func_app_1(delta);
            self.rel_app_func_app_2(delta);
            self.rel_app_func_app_3(delta);
            self.rel_app_func_app_4(delta);
        }
    }

    #[allow(unused_variables)]
    fn rel_app_func_app_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rel_app_func_app_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RelApp(tm1, tm4) in self.rel_app.iter_dirty() {
                #[allow(unused_variables)]
                for FuncRel(tm0, _) in self.func_rel.iter_all_1(tm1) {
                    #[allow(unused_variables)]
                    for SnocElList(tm2, tm3, _) in self.snoc_el_list.iter_all_2(tm4) {
                        self.rel_app_func_app_5(delta, tm0, tm1, tm2, tm3, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn rel_app_func_app_3(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncRel(tm0, tm1) in self.func_rel.iter_dirty() {
                #[allow(unused_variables)]
                for RelApp(_, tm4) in self.rel_app.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for SnocElList(tm2, tm3, _) in self.snoc_el_list.iter_all_2(tm4) {
                        self.rel_app_func_app_5(delta, tm0, tm1, tm2, tm3, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn rel_app_func_app_4(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SnocElList(tm2, tm3, tm4) in self.snoc_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for RelApp(tm1, _) in self.rel_app.iter_all_1(tm4) {
                    #[allow(unused_variables)]
                    for FuncRel(tm0, _) in self.func_rel.iter_all_1(tm1) {
                        self.rel_app_func_app_5(delta, tm0, tm1, tm2, tm3, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn rel_app_func_app_5(
        &self,
        delta: &mut ModelDelta,
        tm0: Func,
        tm1: Rel,
        tm2: ElList,
        tm3: El,
        tm4: ElList,
    ) {
        for _ in [()] {
            let exists_already = self.func_app.iter_all_0_1_2(tm0, tm2, tm3).next().is_some();
            if !exists_already {
                delta.new_func_app.push(FuncApp(tm0, tm2, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn rel_app_constrained_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.rel_app_constrained_1(delta);
            self.rel_app_constrained_2(delta);
        }
    }

    #[allow(unused_variables)]
    fn rel_app_constrained_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rel_app_constrained_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RelApp(tm0, tm1) in self.rel_app.iter_dirty() {
                self.rel_app_constrained_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn rel_app_constrained_3(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList) {
        for _ in [()] {
            let exists_already = self.constrained_els.iter_all_0(tm1).next().is_some();
            if !exists_already {
                delta.new_constrained_els.push(ConstrainedEls(tm1));
            }
        }
    }

    #[allow(unused_variables)]
    fn constrained_head_tail_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.constrained_head_tail_1(delta);
            self.constrained_head_tail_2(delta);
            self.constrained_head_tail_3(delta);
        }
    }

    #[allow(unused_variables)]
    fn constrained_head_tail_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn constrained_head_tail_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConstrainedEls(tm2) in self.constrained_els.iter_dirty() {
                #[allow(unused_variables)]
                for ConsElList(tm0, tm1, _) in self.cons_el_list.iter_all_2(tm2) {
                    self.constrained_head_tail_4(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn constrained_head_tail_3(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsElList(tm0, tm1, tm2) in self.cons_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for ConstrainedEls(_) in self.constrained_els.iter_all_0(tm2) {
                    self.constrained_head_tail_4(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn constrained_head_tail_4(&self, delta: &mut ModelDelta, tm0: El, tm1: ElList, tm2: ElList) {
        for _ in [()] {
            let exists_already = self.constrained_el.iter_all_0(tm0).next().is_some();
            if !exists_already {
                delta.new_constrained_el.push(ConstrainedEl(tm0));
            }

            let exists_already = self.constrained_els.iter_all_0(tm1).next().is_some();
            if !exists_already {
                delta.new_constrained_els.push(ConstrainedEls(tm1));
            }
        }
    }

    #[allow(unused_variables)]
    fn constrained_init_snoc_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.constrained_init_snoc_1(delta);
            self.constrained_init_snoc_2(delta);
            self.constrained_init_snoc_3(delta);
        }
    }

    #[allow(unused_variables)]
    fn constrained_init_snoc_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn constrained_init_snoc_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConstrainedEls(tm2) in self.constrained_els.iter_dirty() {
                #[allow(unused_variables)]
                for SnocElList(tm0, tm1, _) in self.snoc_el_list.iter_all_2(tm2) {
                    self.constrained_init_snoc_4(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn constrained_init_snoc_3(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SnocElList(tm0, tm1, tm2) in self.snoc_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for ConstrainedEls(_) in self.constrained_els.iter_all_0(tm2) {
                    self.constrained_init_snoc_4(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn constrained_init_snoc_4(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList) {
        for _ in [()] {
            let exists_already = self.constrained_els.iter_all_0(tm0).next().is_some();
            if !exists_already {
                delta.new_constrained_els.push(ConstrainedEls(tm0));
            }

            let exists_already = self.constrained_el.iter_all_0(tm1).next().is_some();
            if !exists_already {
                delta.new_constrained_el.push(ConstrainedEl(tm1));
            }
        }
    }

    #[allow(unused_variables)]
    fn dom_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.dom_total_1(delta);
            self.dom_total_2(delta);
            self.dom_total_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn dom_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn dom_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.morphism_dirty.iter().copied() {
                self.dom_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn dom_total_3(&self, delta: &mut ModelDelta, tm0: Morphism) {
        for _ in [()] {
            self.dom_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn dom_total_4(&self, delta: &mut ModelDelta, tm0: Morphism) {
        for _ in [()] {
            let tm1 = match self.dom.iter_all_0(tm0).next() {
                Some(Dom(_, res)) => res,
                None => {
                    delta.new_dom_def.push(DomArgs(tm0));
                    break;
                }
            };

            self.dom_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn dom_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Dom(tm0, tm1) in self.dom.iter_dirty() {
                self.dom_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn dom_total_6(&self, delta: &mut ModelDelta, tm0: Morphism, tm1: Structure) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cod_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.cod_total_1(delta);
            self.cod_total_2(delta);
            self.cod_total_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn cod_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cod_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.morphism_dirty.iter().copied() {
                self.cod_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn cod_total_3(&self, delta: &mut ModelDelta, tm0: Morphism) {
        for _ in [()] {
            self.cod_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn cod_total_4(&self, delta: &mut ModelDelta, tm0: Morphism) {
        for _ in [()] {
            let tm1 = match self.cod.iter_all_0(tm0).next() {
                Some(Cod(_, res)) => res,
                None => {
                    delta.new_cod_def.push(CodArgs(tm0));
                    break;
                }
            };

            self.cod_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn cod_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Cod(tm0, tm1) in self.cod.iter_dirty() {
                self.cod_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn cod_total_6(&self, delta: &mut ModelDelta, tm0: Morphism, tm1: Structure) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn map_el_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.map_el_structure_1(delta);
            self.map_el_structure_2(delta);
            self.map_el_structure_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn map_el_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn map_el_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEl(tm0, tm1, tm2) in self.map_el.iter_dirty() {
                self.map_el_structure_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn map_el_structure_3(&self, delta: &mut ModelDelta, tm0: Morphism, tm1: El, tm2: El) {
        for _ in [()] {
            self.map_el_structure_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn map_el_structure_4(&self, delta: &mut ModelDelta, tm0: Morphism, tm1: El, tm2: El) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Cod(_, tm3) in self.cod.iter_all_0(tm0) {
                self.map_el_structure_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn map_el_structure_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Cod(tm0, tm3) in self.cod.iter_dirty() {
                #[allow(unused_variables)]
                for MapEl(_, tm1, tm2) in self.map_el.iter_all_0(tm0) {
                    self.map_el_structure_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_el_structure_6(
        &self,
        delta: &mut ModelDelta,
        tm1: El,
        tm2: El,
        tm0: Morphism,
        tm3: Structure,
    ) {
        for _ in [()] {
            let exists_already = self.el_structure.iter_all_0_1(tm2, tm3).next().is_some();
            if !exists_already {
                delta.new_el_structure.push(ElStructure(tm2, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn map_el_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.map_el_defined_1(delta);
            self.map_el_defined_2(delta);
            self.map_el_defined_5(delta);
            self.map_el_defined_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn map_el_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn map_el_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Dom(tm0, tm1) in self.dom.iter_dirty() {
                self.map_el_defined_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn map_el_defined_3(&self, delta: &mut ModelDelta, tm0: Morphism, tm1: Structure) {
        for _ in [()] {
            self.map_el_defined_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn map_el_defined_4(&self, delta: &mut ModelDelta, tm0: Morphism, tm1: Structure) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElStructure(tm2, _) in self.el_structure.iter_all_1(tm1) {
                self.map_el_defined_6(delta, tm0, tm2, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn map_el_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElStructure(tm2, tm1) in self.el_structure.iter_dirty() {
                #[allow(unused_variables)]
                for Dom(tm0, _) in self.dom.iter_all_1(tm1) {
                    self.map_el_defined_6(delta, tm0, tm2, tm1);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_el_defined_6(&self, delta: &mut ModelDelta, tm0: Morphism, tm2: El, tm1: Structure) {
        for _ in [()] {
            self.map_el_defined_7(delta, tm0, tm2, tm1);
        }
    }

    #[allow(unused_variables)]
    fn map_el_defined_7(&self, delta: &mut ModelDelta, tm0: Morphism, tm2: El, tm1: Structure) {
        for _ in [()] {
            let tm3 = match self.map_el.iter_all_0_1(tm0, tm2).next() {
                Some(MapEl(_, _, res)) => res,
                None => {
                    delta.new_map_el_def.push(MapElArgs(tm0, tm2));
                    break;
                }
            };

            self.map_el_defined_9(delta, tm1, tm0, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn map_el_defined_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEl(tm0, tm2, tm3) in self.map_el.iter_dirty() {
                #[allow(unused_variables)]
                for Dom(_, tm1) in self.dom.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for ElStructure(_, _) in self.el_structure.iter_all_0_1(tm2, tm1) {
                        self.map_el_defined_9(delta, tm1, tm0, tm2, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_el_defined_9(
        &self,
        delta: &mut ModelDelta,
        tm1: Structure,
        tm0: Morphism,
        tm2: El,
        tm3: El,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn map_els_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.map_els_defined_1(delta);
            self.map_els_defined_2(delta);
            self.map_els_defined_3(delta);
            self.map_els_defined_8(delta);
            self.map_els_defined_11(delta);
            self.map_els_defined_14(delta);
            self.map_els_defined_17(delta);
            self.map_els_defined_20(delta);
            self.map_els_defined_23(delta);
            self.map_els_defined_26(delta);
            self.map_els_defined_29(delta);
            self.map_els_defined_32(delta);
            self.map_els_defined_35(delta);
            self.map_els_defined_38(delta);
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn map_els_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElsStructure(tm0, tm2) in self.els_structure.iter_dirty() {
                #[allow(unused_variables)]
                for Dom(tm1, _) in self.dom.iter_all_1(tm2) {
                    self.map_els_defined_4(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_3(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Dom(tm1, tm2) in self.dom.iter_dirty() {
                #[allow(unused_variables)]
                for ElsStructure(tm0, _) in self.els_structure.iter_all_1(tm2) {
                    self.map_els_defined_4(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_4(
        &self,
        delta: &mut ModelDelta,
        tm0: ElList,
        tm1: Morphism,
        tm2: Structure,
    ) {
        for _ in [()] {
            self.map_els_defined_5(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_5(
        &self,
        delta: &mut ModelDelta,
        tm0: ElList,
        tm1: Morphism,
        tm2: Structure,
    ) {
        for _ in [()] {
            self.map_els_defined_6(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_6(
        &self,
        delta: &mut ModelDelta,
        tm0: ElList,
        tm1: Morphism,
        tm2: Structure,
    ) {
        for _ in [()] {
            self.map_els_defined_7(delta, tm0, tm1, tm2);
            self.map_els_defined_10(delta, tm0, tm1, tm2);
            self.map_els_defined_13(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_7(
        &self,
        delta: &mut ModelDelta,
        tm0: ElList,
        tm1: Morphism,
        tm2: Structure,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilElList(tm3, _) in self.nil_el_list.iter_all_1(tm0) {
                self.map_els_defined_9(delta, tm1, tm2, tm3, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilElList(tm3, tm0) in self.nil_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for ElsStructure(_, tm2) in self.els_structure.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for Dom(tm1, _) in self.dom.iter_all_1(tm2) {
                        self.map_els_defined_9(delta, tm1, tm2, tm3, tm0);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_9(
        &self,
        delta: &mut ModelDelta,
        tm1: Morphism,
        tm2: Structure,
        tm3: Structure,
        tm0: ElList,
    ) {
        for _ in [()] {
            self.map_els_defined_16(delta, tm1, tm2, tm3, tm0);
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_10(
        &self,
        delta: &mut ModelDelta,
        tm0: ElList,
        tm1: Morphism,
        tm2: Structure,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsElList(tm4, tm5, _) in self.cons_el_list.iter_all_2(tm0) {
                self.map_els_defined_12(delta, tm1, tm2, tm4, tm5, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsElList(tm4, tm5, tm0) in self.cons_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for ElsStructure(_, tm2) in self.els_structure.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for Dom(tm1, _) in self.dom.iter_all_1(tm2) {
                        self.map_els_defined_12(delta, tm1, tm2, tm4, tm5, tm0);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_12(
        &self,
        delta: &mut ModelDelta,
        tm1: Morphism,
        tm2: Structure,
        tm4: El,
        tm5: ElList,
        tm0: ElList,
    ) {
        for _ in [()] {
            self.map_els_defined_19(delta, tm1, tm2, tm4, tm5, tm0);
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_13(
        &self,
        delta: &mut ModelDelta,
        tm0: ElList,
        tm1: Morphism,
        tm2: Structure,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SnocElList(tm6, tm7, _) in self.snoc_el_list.iter_all_2(tm0) {
                self.map_els_defined_15(delta, tm1, tm2, tm6, tm7, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_14(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SnocElList(tm6, tm7, tm0) in self.snoc_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for ElsStructure(_, tm2) in self.els_structure.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for Dom(tm1, _) in self.dom.iter_all_1(tm2) {
                        self.map_els_defined_15(delta, tm1, tm2, tm6, tm7, tm0);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_15(
        &self,
        delta: &mut ModelDelta,
        tm1: Morphism,
        tm2: Structure,
        tm6: ElList,
        tm7: El,
        tm0: ElList,
    ) {
        for _ in [()] {
            self.map_els_defined_22(delta, tm1, tm2, tm6, tm7, tm0);
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_16(
        &self,
        delta: &mut ModelDelta,
        tm1: Morphism,
        tm2: Structure,
        tm3: Structure,
        tm0: ElList,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Cod(_, tm8) in self.cod.iter_all_0(tm1) {
                self.map_els_defined_18(delta, tm2, tm3, tm0, tm1, tm8);
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_17(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Cod(tm1, tm8) in self.cod.iter_dirty() {
                #[allow(unused_variables)]
                for Dom(_, tm2) in self.dom.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for ElsStructure(tm0, _) in self.els_structure.iter_all_1(tm2) {
                        #[allow(unused_variables)]
                        for NilElList(tm3, _) in self.nil_el_list.iter_all_1(tm0) {
                            self.map_els_defined_18(delta, tm2, tm3, tm0, tm1, tm8);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_18(
        &self,
        delta: &mut ModelDelta,
        tm2: Structure,
        tm3: Structure,
        tm0: ElList,
        tm1: Morphism,
        tm8: Structure,
    ) {
        for _ in [()] {
            self.map_els_defined_31(delta, tm2, tm3, tm0, tm1, tm8);
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_19(
        &self,
        delta: &mut ModelDelta,
        tm1: Morphism,
        tm2: Structure,
        tm4: El,
        tm5: ElList,
        tm0: ElList,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEl(_, _, tm9) in self.map_el.iter_all_0_1(tm1, tm4) {
                self.map_els_defined_21(delta, tm2, tm5, tm0, tm1, tm4, tm9);
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_20(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEl(tm1, tm4, tm9) in self.map_el.iter_dirty() {
                #[allow(unused_variables)]
                for Dom(_, tm2) in self.dom.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for ElsStructure(tm0, _) in self.els_structure.iter_all_1(tm2) {
                        #[allow(unused_variables)]
                        for ConsElList(_, tm5, _) in self.cons_el_list.iter_all_0_2(tm4, tm0) {
                            self.map_els_defined_21(delta, tm2, tm5, tm0, tm1, tm4, tm9);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_21(
        &self,
        delta: &mut ModelDelta,
        tm2: Structure,
        tm5: ElList,
        tm0: ElList,
        tm1: Morphism,
        tm4: El,
        tm9: El,
    ) {
        for _ in [()] {
            self.map_els_defined_25(delta, tm2, tm5, tm0, tm1, tm4, tm9);
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_22(
        &self,
        delta: &mut ModelDelta,
        tm1: Morphism,
        tm2: Structure,
        tm6: ElList,
        tm7: El,
        tm0: ElList,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEls(_, _, tm10) in self.map_els.iter_all_0_1(tm1, tm6) {
                self.map_els_defined_24(delta, tm2, tm7, tm0, tm1, tm6, tm10);
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_23(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEls(tm1, tm6, tm10) in self.map_els.iter_dirty() {
                #[allow(unused_variables)]
                for Dom(_, tm2) in self.dom.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for ElsStructure(tm0, _) in self.els_structure.iter_all_1(tm2) {
                        #[allow(unused_variables)]
                        for SnocElList(_, tm7, _) in self.snoc_el_list.iter_all_0_2(tm6, tm0) {
                            self.map_els_defined_24(delta, tm2, tm7, tm0, tm1, tm6, tm10);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_24(
        &self,
        delta: &mut ModelDelta,
        tm2: Structure,
        tm7: El,
        tm0: ElList,
        tm1: Morphism,
        tm6: ElList,
        tm10: ElList,
    ) {
        for _ in [()] {
            self.map_els_defined_28(delta, tm2, tm7, tm0, tm1, tm6, tm10);
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_25(
        &self,
        delta: &mut ModelDelta,
        tm2: Structure,
        tm5: ElList,
        tm0: ElList,
        tm1: Morphism,
        tm4: El,
        tm9: El,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEls(_, _, tm11) in self.map_els.iter_all_0_1(tm1, tm5) {
                self.map_els_defined_27(delta, tm2, tm0, tm4, tm9, tm1, tm5, tm11);
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_26(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEls(tm1, tm5, tm11) in self.map_els.iter_dirty() {
                #[allow(unused_variables)]
                for Dom(_, tm2) in self.dom.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for ElsStructure(tm0, _) in self.els_structure.iter_all_1(tm2) {
                        #[allow(unused_variables)]
                        for ConsElList(tm4, _, _) in self.cons_el_list.iter_all_1_2(tm5, tm0) {
                            #[allow(unused_variables)]
                            for MapEl(_, _, tm9) in self.map_el.iter_all_0_1(tm1, tm4) {
                                self.map_els_defined_27(delta, tm2, tm0, tm4, tm9, tm1, tm5, tm11);
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_27(
        &self,
        delta: &mut ModelDelta,
        tm2: Structure,
        tm0: ElList,
        tm4: El,
        tm9: El,
        tm1: Morphism,
        tm5: ElList,
        tm11: ElList,
    ) {
        for _ in [()] {
            self.map_els_defined_34(delta, tm2, tm0, tm4, tm9, tm1, tm5, tm11);
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_28(
        &self,
        delta: &mut ModelDelta,
        tm2: Structure,
        tm7: El,
        tm0: ElList,
        tm1: Morphism,
        tm6: ElList,
        tm10: ElList,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEl(_, _, tm12) in self.map_el.iter_all_0_1(tm1, tm7) {
                self.map_els_defined_30(delta, tm2, tm0, tm6, tm10, tm1, tm7, tm12);
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_29(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEl(tm1, tm7, tm12) in self.map_el.iter_dirty() {
                #[allow(unused_variables)]
                for Dom(_, tm2) in self.dom.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for ElsStructure(tm0, _) in self.els_structure.iter_all_1(tm2) {
                        #[allow(unused_variables)]
                        for SnocElList(tm6, _, _) in self.snoc_el_list.iter_all_1_2(tm7, tm0) {
                            #[allow(unused_variables)]
                            for MapEls(_, _, tm10) in self.map_els.iter_all_0_1(tm1, tm6) {
                                self.map_els_defined_30(delta, tm2, tm0, tm6, tm10, tm1, tm7, tm12);
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_30(
        &self,
        delta: &mut ModelDelta,
        tm2: Structure,
        tm0: ElList,
        tm6: ElList,
        tm10: ElList,
        tm1: Morphism,
        tm7: El,
        tm12: El,
    ) {
        for _ in [()] {
            self.map_els_defined_37(delta, tm2, tm0, tm6, tm10, tm1, tm7, tm12);
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_31(
        &self,
        delta: &mut ModelDelta,
        tm2: Structure,
        tm3: Structure,
        tm0: ElList,
        tm1: Morphism,
        tm8: Structure,
    ) {
        for _ in [()] {
            let tm13 = match self.nil_el_list.iter_all_0(tm8).next() {
                Some(NilElList(_, res)) => res,
                None => {
                    delta.new_nil_el_list_def.push(NilElListArgs(tm8));
                    break;
                }
            };

            self.map_els_defined_33(delta, tm2, tm3, tm0, tm1, tm8, tm13);
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_32(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilElList(tm8, tm13) in self.nil_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for Cod(tm1, _) in self.cod.iter_all_1(tm8) {
                    #[allow(unused_variables)]
                    for Dom(_, tm2) in self.dom.iter_all_0(tm1) {
                        #[allow(unused_variables)]
                        for ElsStructure(tm0, _) in self.els_structure.iter_all_1(tm2) {
                            #[allow(unused_variables)]
                            for NilElList(tm3, _) in self.nil_el_list.iter_all_1(tm0) {
                                self.map_els_defined_33(delta, tm2, tm3, tm0, tm1, tm8, tm13);
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_33(
        &self,
        delta: &mut ModelDelta,
        tm2: Structure,
        tm3: Structure,
        tm0: ElList,
        tm1: Morphism,
        tm8: Structure,
        tm13: ElList,
    ) {
        for _ in [()] {
            let exists_already = self.map_els.iter_all_0_1_2(tm1, tm0, tm13).next().is_some();
            if !exists_already {
                delta.new_map_els.push(MapEls(tm1, tm0, tm13));
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_34(
        &self,
        delta: &mut ModelDelta,
        tm2: Structure,
        tm0: ElList,
        tm4: El,
        tm9: El,
        tm1: Morphism,
        tm5: ElList,
        tm11: ElList,
    ) {
        for _ in [()] {
            let tm14 = match self.cons_el_list.iter_all_0_1(tm9, tm11).next() {
                Some(ConsElList(_, _, res)) => res,
                None => {
                    delta.new_cons_el_list_def.push(ConsElListArgs(tm9, tm11));
                    break;
                }
            };

            self.map_els_defined_36(delta, tm2, tm0, tm4, tm9, tm1, tm5, tm11, tm14);
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_35(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsElList(tm9, tm11, tm14) in self.cons_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for MapEls(tm1, tm5, _) in self.map_els.iter_all_2(tm11) {
                    #[allow(unused_variables)]
                    for MapEl(_, tm4, _) in self.map_el.iter_all_0_2(tm1, tm9) {
                        #[allow(unused_variables)]
                        for ConsElList(_, _, tm0) in self.cons_el_list.iter_all_0_1(tm4, tm5) {
                            #[allow(unused_variables)]
                            for Dom(_, tm2) in self.dom.iter_all_0(tm1) {
                                #[allow(unused_variables)]
                                for ElsStructure(_, _) in self.els_structure.iter_all_0_1(tm0, tm2)
                                {
                                    self.map_els_defined_36(
                                        delta, tm2, tm0, tm4, tm9, tm1, tm5, tm11, tm14,
                                    );
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_36(
        &self,
        delta: &mut ModelDelta,
        tm2: Structure,
        tm0: ElList,
        tm4: El,
        tm9: El,
        tm1: Morphism,
        tm5: ElList,
        tm11: ElList,
        tm14: ElList,
    ) {
        for _ in [()] {
            let exists_already = self.map_els.iter_all_0_1_2(tm1, tm0, tm14).next().is_some();
            if !exists_already {
                delta.new_map_els.push(MapEls(tm1, tm0, tm14));
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_37(
        &self,
        delta: &mut ModelDelta,
        tm2: Structure,
        tm0: ElList,
        tm6: ElList,
        tm10: ElList,
        tm1: Morphism,
        tm7: El,
        tm12: El,
    ) {
        for _ in [()] {
            let tm15 = match self.snoc_el_list.iter_all_0_1(tm10, tm12).next() {
                Some(SnocElList(_, _, res)) => res,
                None => {
                    delta.new_snoc_el_list_def.push(SnocElListArgs(tm10, tm12));
                    break;
                }
            };

            self.map_els_defined_39(delta, tm2, tm0, tm6, tm10, tm1, tm7, tm12, tm15);
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_38(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SnocElList(tm10, tm12, tm15) in self.snoc_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for MapEls(tm1, tm6, _) in self.map_els.iter_all_2(tm10) {
                    #[allow(unused_variables)]
                    for MapEl(_, tm7, _) in self.map_el.iter_all_0_2(tm1, tm12) {
                        #[allow(unused_variables)]
                        for SnocElList(_, _, tm0) in self.snoc_el_list.iter_all_0_1(tm6, tm7) {
                            #[allow(unused_variables)]
                            for Dom(_, tm2) in self.dom.iter_all_0(tm1) {
                                #[allow(unused_variables)]
                                for ElsStructure(_, _) in self.els_structure.iter_all_0_1(tm0, tm2)
                                {
                                    self.map_els_defined_39(
                                        delta, tm2, tm0, tm6, tm10, tm1, tm7, tm12, tm15,
                                    );
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_els_defined_39(
        &self,
        delta: &mut ModelDelta,
        tm2: Structure,
        tm0: ElList,
        tm6: ElList,
        tm10: ElList,
        tm1: Morphism,
        tm7: El,
        tm12: El,
        tm15: ElList,
    ) {
        for _ in [()] {
            let exists_already = self.map_els.iter_all_0_1_2(tm1, tm0, tm15).next().is_some();
            if !exists_already {
                delta.new_map_els.push(MapEls(tm1, tm0, tm15));
            }
        }
    }

    #[allow(unused_variables)]
    fn map_var_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.map_var_1(delta);
            self.map_var_2(delta);
            self.map_var_5(delta);
            self.map_var_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn map_var_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn map_var_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Var(tm0, tm1, tm2) in self.var.iter_dirty() {
                self.map_var_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn map_var_3(&self, delta: &mut ModelDelta, tm0: Structure, tm1: ElName, tm2: El) {
        for _ in [()] {
            self.map_var_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn map_var_4(&self, delta: &mut ModelDelta, tm0: Structure, tm1: ElName, tm2: El) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEl(tm3, _, tm4) in self.map_el.iter_all_1(tm2) {
                self.map_var_6(delta, tm0, tm1, tm2, tm3, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn map_var_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEl(tm3, tm2, tm4) in self.map_el.iter_dirty() {
                #[allow(unused_variables)]
                for Var(tm0, tm1, _) in self.var.iter_all_2(tm2) {
                    self.map_var_6(delta, tm0, tm1, tm2, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_var_6(
        &self,
        delta: &mut ModelDelta,
        tm0: Structure,
        tm1: ElName,
        tm2: El,
        tm3: Morphism,
        tm4: El,
    ) {
        for _ in [()] {
            self.map_var_7(delta, tm0, tm1, tm2, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn map_var_7(
        &self,
        delta: &mut ModelDelta,
        tm0: Structure,
        tm1: ElName,
        tm2: El,
        tm3: Morphism,
        tm4: El,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Cod(_, tm5) in self.cod.iter_all_0(tm3) {
                self.map_var_9(delta, tm0, tm1, tm2, tm4, tm3, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn map_var_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Cod(tm3, tm5) in self.cod.iter_dirty() {
                #[allow(unused_variables)]
                for MapEl(_, tm2, tm4) in self.map_el.iter_all_0(tm3) {
                    #[allow(unused_variables)]
                    for Var(tm0, tm1, _) in self.var.iter_all_2(tm2) {
                        self.map_var_9(delta, tm0, tm1, tm2, tm4, tm3, tm5);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_var_9(
        &self,
        delta: &mut ModelDelta,
        tm0: Structure,
        tm1: ElName,
        tm2: El,
        tm4: El,
        tm3: Morphism,
        tm5: Structure,
    ) {
        for _ in [()] {
            let exists_already = self.var.iter_all_0_1_2(tm5, tm1, tm4).next().is_some();
            if !exists_already {
                delta.new_var.push(Var(tm5, tm1, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn map_rel_app_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.map_rel_app_1(delta);
            self.map_rel_app_2(delta);
            self.map_rel_app_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn map_rel_app_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn map_rel_app_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RelApp(tm0, tm1) in self.rel_app.iter_dirty() {
                self.map_rel_app_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn map_rel_app_3(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList) {
        for _ in [()] {
            self.map_rel_app_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn map_rel_app_4(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEls(tm2, _, tm3) in self.map_els.iter_all_1(tm1) {
                self.map_rel_app_6(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn map_rel_app_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEls(tm2, tm1, tm3) in self.map_els.iter_dirty() {
                #[allow(unused_variables)]
                for RelApp(tm0, _) in self.rel_app.iter_all_1(tm1) {
                    self.map_rel_app_6(delta, tm0, tm2, tm1, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_rel_app_6(
        &self,
        delta: &mut ModelDelta,
        tm0: Rel,
        tm2: Morphism,
        tm1: ElList,
        tm3: ElList,
    ) {
        for _ in [()] {
            let exists_already = self.rel_app.iter_all_0_1(tm0, tm3).next().is_some();
            if !exists_already {
                delta.new_rel_app.push(RelApp(tm0, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn map_preserves_el_type_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.map_preserves_el_type_1(delta);
            self.map_preserves_el_type_2(delta);
            self.map_preserves_el_type_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn map_preserves_el_type_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn map_preserves_el_type_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElType(tm0, tm1) in self.el_type.iter_dirty() {
                self.map_preserves_el_type_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn map_preserves_el_type_3(&self, delta: &mut ModelDelta, tm0: El, tm1: Type) {
        for _ in [()] {
            self.map_preserves_el_type_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn map_preserves_el_type_4(&self, delta: &mut ModelDelta, tm0: El, tm1: Type) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEl(tm2, _, tm3) in self.map_el.iter_all_1(tm0) {
                self.map_preserves_el_type_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn map_preserves_el_type_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEl(tm2, tm0, tm3) in self.map_el.iter_dirty() {
                #[allow(unused_variables)]
                for ElType(_, tm1) in self.el_type.iter_all_0(tm0) {
                    self.map_preserves_el_type_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_preserves_el_type_6(
        &self,
        delta: &mut ModelDelta,
        tm1: Type,
        tm2: Morphism,
        tm0: El,
        tm3: El,
    ) {
        for _ in [()] {
            let exists_already = self.el_type.iter_all_0_1(tm3, tm1).next().is_some();
            if !exists_already {
                delta.new_el_type.push(ElType(tm3, tm1));
            }
        }
    }

    #[allow(unused_variables)]
    fn map_reflects_el_type_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.map_reflects_el_type_1(delta);
            self.map_reflects_el_type_2(delta);
            self.map_reflects_el_type_3(delta);
        }
    }

    #[allow(unused_variables)]
    fn map_reflects_el_type_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn map_reflects_el_type_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElType(tm2, tm3) in self.el_type.iter_dirty() {
                #[allow(unused_variables)]
                for MapEl(tm0, tm1, _) in self.map_el.iter_all_2(tm2) {
                    self.map_reflects_el_type_4(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_reflects_el_type_3(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEl(tm0, tm1, tm2) in self.map_el.iter_dirty() {
                #[allow(unused_variables)]
                for ElType(_, tm3) in self.el_type.iter_all_0(tm2) {
                    self.map_reflects_el_type_4(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn map_reflects_el_type_4(
        &self,
        delta: &mut ModelDelta,
        tm0: Morphism,
        tm1: El,
        tm2: El,
        tm3: Type,
    ) {
        for _ in [()] {
            let exists_already = self.el_type.iter_all_0_1(tm1, tm3).next().is_some();
            if !exists_already {
                delta.new_el_type.push(ElType(tm1, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn in_ker_rule_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.in_ker_rule_1(delta);
            self.in_ker_rule_2(delta);
            self.in_ker_rule_3(delta);
        }
    }

    #[allow(unused_variables)]
    fn in_ker_rule_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn in_ker_rule_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEl(tm0, tm1, tm3) in self.map_el.iter_dirty() {
                #[allow(unused_variables)]
                for MapEl(_, tm2, _) in self.map_el.iter_all_0_2(tm0, tm3) {
                    self.in_ker_rule_4(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn in_ker_rule_3(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEl(tm0, tm2, tm3) in self.map_el.iter_dirty() {
                #[allow(unused_variables)]
                for MapEl(_, tm1, _) in self.map_el.iter_all_0_2(tm0, tm3) {
                    self.in_ker_rule_4(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn in_ker_rule_4(&self, delta: &mut ModelDelta, tm0: Morphism, tm1: El, tm2: El, tm3: El) {
        for _ in [()] {
            let exists_already = self.in_ker.iter_all_0_1_2(tm0, tm1, tm2).next().is_some();
            if !exists_already {
                delta.new_in_ker.push(InKer(tm0, tm1, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn el_in_img_rule_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.el_in_img_rule_1(delta);
            self.el_in_img_rule_2(delta);
        }
    }

    #[allow(unused_variables)]
    fn el_in_img_rule_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn el_in_img_rule_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEl(tm0, tm1, tm2) in self.map_el.iter_dirty() {
                self.el_in_img_rule_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn el_in_img_rule_3(&self, delta: &mut ModelDelta, tm0: Morphism, tm1: El, tm2: El) {
        for _ in [()] {
            let exists_already = self.el_in_img.iter_all_0_1(tm0, tm2).next().is_some();
            if !exists_already {
                delta.new_el_in_img.push(ElInImg(tm0, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn rel_tuple_in_img_law_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.rel_tuple_in_img_law_1(delta);
            self.rel_tuple_in_img_law_2(delta);
            self.rel_tuple_in_img_law_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn rel_tuple_in_img_law_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rel_tuple_in_img_law_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RelApp(tm0, tm1) in self.rel_app.iter_dirty() {
                self.rel_tuple_in_img_law_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn rel_tuple_in_img_law_3(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList) {
        for _ in [()] {
            self.rel_tuple_in_img_law_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn rel_tuple_in_img_law_4(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEls(tm2, _, tm3) in self.map_els.iter_all_1(tm1) {
                self.rel_tuple_in_img_law_6(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn rel_tuple_in_img_law_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MapEls(tm2, tm1, tm3) in self.map_els.iter_dirty() {
                #[allow(unused_variables)]
                for RelApp(tm0, _) in self.rel_app.iter_all_1(tm1) {
                    self.rel_tuple_in_img_law_6(delta, tm0, tm2, tm1, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn rel_tuple_in_img_law_6(
        &self,
        delta: &mut ModelDelta,
        tm0: Rel,
        tm2: Morphism,
        tm1: ElList,
        tm3: ElList,
    ) {
        for _ in [()] {
            let exists_already = self
                .rel_tuple_in_img
                .iter_all_0_1_2(tm2, tm0, tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_rel_tuple_in_img
                    .push(RelTupleInImg(tm2, tm0, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.anonymous_rule_96_1(delta);
            self.anonymous_rule_96_3(delta);
            self.anonymous_rule_96_6(delta);
            self.anonymous_rule_96_9(delta);
            self.anonymous_rule_96_12(delta);
            self.anonymous_rule_96_15(delta);
            self.anonymous_rule_96_18(delta);
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.anonymous_rule_96_2(delta);
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            let tm0 = match self.type_symbol.iter_all().next() {
                Some(TypeSymbol(res)) => res,
                None => {
                    delta.new_type_symbol_def.push(TypeSymbolArgs());
                    break;
                }
            };

            self.anonymous_rule_96_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_3(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeSymbol(tm0) in self.type_symbol.iter_dirty() {
                self.anonymous_rule_96_4(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_4(&self, delta: &mut ModelDelta, tm0: SymbolKind) {
        for _ in [()] {
            self.anonymous_rule_96_5(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_5(&self, delta: &mut ModelDelta, tm0: SymbolKind) {
        for _ in [()] {
            let tm1 = match self.pred_symbol.iter_all().next() {
                Some(PredSymbol(res)) => res,
                None => {
                    delta.new_pred_symbol_def.push(PredSymbolArgs());
                    break;
                }
            };

            self.anonymous_rule_96_7(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_6(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredSymbol(tm1) in self.pred_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for TypeSymbol(tm0) in self.type_symbol.iter_all() {
                    self.anonymous_rule_96_7(delta, tm0, tm1);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_7(&self, delta: &mut ModelDelta, tm0: SymbolKind, tm1: SymbolKind) {
        for _ in [()] {
            self.anonymous_rule_96_8(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_8(&self, delta: &mut ModelDelta, tm0: SymbolKind, tm1: SymbolKind) {
        for _ in [()] {
            let tm2 = match self.func_symbol.iter_all().next() {
                Some(FuncSymbol(res)) => res,
                None => {
                    delta.new_func_symbol_def.push(FuncSymbolArgs());
                    break;
                }
            };

            self.anonymous_rule_96_10(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_9(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncSymbol(tm2) in self.func_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for PredSymbol(tm1) in self.pred_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for TypeSymbol(tm0) in self.type_symbol.iter_all() {
                        self.anonymous_rule_96_10(delta, tm0, tm1, tm2);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_10(
        &self,
        delta: &mut ModelDelta,
        tm0: SymbolKind,
        tm1: SymbolKind,
        tm2: SymbolKind,
    ) {
        for _ in [()] {
            self.anonymous_rule_96_11(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_11(
        &self,
        delta: &mut ModelDelta,
        tm0: SymbolKind,
        tm1: SymbolKind,
        tm2: SymbolKind,
    ) {
        for _ in [()] {
            let tm3 = match self.rule_symbol.iter_all().next() {
                Some(RuleSymbol(res)) => res,
                None => {
                    delta.new_rule_symbol_def.push(RuleSymbolArgs());
                    break;
                }
            };

            self.anonymous_rule_96_13(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_12(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleSymbol(tm3) in self.rule_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for FuncSymbol(tm2) in self.func_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for TypeSymbol(tm0) in self.type_symbol.iter_all() {
                        #[allow(unused_variables)]
                        for PredSymbol(tm1) in self.pred_symbol.iter_all() {
                            self.anonymous_rule_96_13(delta, tm0, tm1, tm2, tm3);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_13(
        &self,
        delta: &mut ModelDelta,
        tm0: SymbolKind,
        tm1: SymbolKind,
        tm2: SymbolKind,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            self.anonymous_rule_96_14(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_14(
        &self,
        delta: &mut ModelDelta,
        tm0: SymbolKind,
        tm1: SymbolKind,
        tm2: SymbolKind,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            let tm4 = match self.enum_symbol.iter_all().next() {
                Some(EnumSymbol(res)) => res,
                None => {
                    delta.new_enum_symbol_def.push(EnumSymbolArgs());
                    break;
                }
            };

            self.anonymous_rule_96_16(delta, tm0, tm1, tm2, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_15(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumSymbol(tm4) in self.enum_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for RuleSymbol(tm3) in self.rule_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for TypeSymbol(tm0) in self.type_symbol.iter_all() {
                        #[allow(unused_variables)]
                        for PredSymbol(tm1) in self.pred_symbol.iter_all() {
                            #[allow(unused_variables)]
                            for FuncSymbol(tm2) in self.func_symbol.iter_all() {
                                self.anonymous_rule_96_16(delta, tm0, tm1, tm2, tm3, tm4);
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_16(
        &self,
        delta: &mut ModelDelta,
        tm0: SymbolKind,
        tm1: SymbolKind,
        tm2: SymbolKind,
        tm3: SymbolKind,
        tm4: SymbolKind,
    ) {
        for _ in [()] {
            self.anonymous_rule_96_17(delta, tm0, tm1, tm2, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_17(
        &self,
        delta: &mut ModelDelta,
        tm0: SymbolKind,
        tm1: SymbolKind,
        tm2: SymbolKind,
        tm3: SymbolKind,
        tm4: SymbolKind,
    ) {
        for _ in [()] {
            let tm5 = match self.ctor_symbol.iter_all().next() {
                Some(CtorSymbol(res)) => res,
                None => {
                    delta.new_ctor_symbol_def.push(CtorSymbolArgs());
                    break;
                }
            };

            self.anonymous_rule_96_19(delta, tm0, tm1, tm2, tm3, tm4, tm5);
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_18(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorSymbol(tm5) in self.ctor_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for EnumSymbol(tm4) in self.enum_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for TypeSymbol(tm0) in self.type_symbol.iter_all() {
                        #[allow(unused_variables)]
                        for PredSymbol(tm1) in self.pred_symbol.iter_all() {
                            #[allow(unused_variables)]
                            for FuncSymbol(tm2) in self.func_symbol.iter_all() {
                                #[allow(unused_variables)]
                                for RuleSymbol(tm3) in self.rule_symbol.iter_all() {
                                    self.anonymous_rule_96_19(delta, tm0, tm1, tm2, tm3, tm4, tm5);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn anonymous_rule_96_19(
        &self,
        delta: &mut ModelDelta,
        tm0: SymbolKind,
        tm1: SymbolKind,
        tm2: SymbolKind,
        tm3: SymbolKind,
        tm4: SymbolKind,
        tm5: SymbolKind,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn type_decl_defines_symbol_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.type_decl_defines_symbol_1(delta);
            self.type_decl_defines_symbol_2(delta);
            self.type_decl_defines_symbol_5(delta);
            self.type_decl_defines_symbol_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn type_decl_defines_symbol_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn type_decl_defines_symbol_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeDecl(tm0, tm1) in self.type_decl.iter_dirty() {
                self.type_decl_defines_symbol_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn type_decl_defines_symbol_3(&self, delta: &mut ModelDelta, tm0: TypeDeclNode, tm1: Ident) {
        for _ in [()] {
            self.type_decl_defines_symbol_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn type_decl_defines_symbol_4(&self, delta: &mut ModelDelta, tm0: TypeDeclNode, tm1: Ident) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeSymbol(tm2) in self.type_symbol.iter_all() {
                self.type_decl_defines_symbol_6(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn type_decl_defines_symbol_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeSymbol(tm2) in self.type_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for TypeDecl(tm0, tm1) in self.type_decl.iter_all() {
                    self.type_decl_defines_symbol_6(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn type_decl_defines_symbol_6(
        &self,
        delta: &mut ModelDelta,
        tm0: TypeDeclNode,
        tm1: Ident,
        tm2: SymbolKind,
    ) {
        for _ in [()] {
            self.type_decl_defines_symbol_7(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn type_decl_defines_symbol_7(
        &self,
        delta: &mut ModelDelta,
        tm0: TypeDeclNode,
        tm1: Ident,
        tm2: SymbolKind,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeDeclNodeLoc(_, tm3) in self.type_decl_node_loc.iter_all_0(tm0) {
                self.type_decl_defines_symbol_9(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn type_decl_defines_symbol_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeDeclNodeLoc(tm0, tm3) in self.type_decl_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for TypeSymbol(tm2) in self.type_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for TypeDecl(_, tm1) in self.type_decl.iter_all_0(tm0) {
                        self.type_decl_defines_symbol_9(delta, tm1, tm2, tm0, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn type_decl_defines_symbol_9(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: SymbolKind,
        tm0: TypeDeclNode,
        tm3: Loc,
    ) {
        for _ in [()] {
            let exists_already = self
                .defined_symbol
                .iter_all_0_1_2(tm1, tm2, tm3)
                .next()
                .is_some();
            if !exists_already {
                delta.new_defined_symbol.push(DefinedSymbol(tm1, tm2, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn enum_decl_defines_symbol_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.enum_decl_defines_symbol_1(delta);
            self.enum_decl_defines_symbol_2(delta);
            self.enum_decl_defines_symbol_5(delta);
            self.enum_decl_defines_symbol_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn enum_decl_defines_symbol_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn enum_decl_defines_symbol_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumDecl(tm0, tm1, tm2) in self.enum_decl.iter_dirty() {
                self.enum_decl_defines_symbol_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn enum_decl_defines_symbol_3(
        &self,
        delta: &mut ModelDelta,
        tm0: EnumDeclNode,
        tm1: Ident,
        tm2: CtorDeclListNode,
    ) {
        for _ in [()] {
            self.enum_decl_defines_symbol_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn enum_decl_defines_symbol_4(
        &self,
        delta: &mut ModelDelta,
        tm0: EnumDeclNode,
        tm1: Ident,
        tm2: CtorDeclListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumSymbol(tm3) in self.enum_symbol.iter_all() {
                self.enum_decl_defines_symbol_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn enum_decl_defines_symbol_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumSymbol(tm3) in self.enum_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for EnumDecl(tm0, tm1, tm2) in self.enum_decl.iter_all() {
                    self.enum_decl_defines_symbol_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn enum_decl_defines_symbol_6(
        &self,
        delta: &mut ModelDelta,
        tm0: EnumDeclNode,
        tm1: Ident,
        tm2: CtorDeclListNode,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            self.enum_decl_defines_symbol_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn enum_decl_defines_symbol_7(
        &self,
        delta: &mut ModelDelta,
        tm0: EnumDeclNode,
        tm1: Ident,
        tm2: CtorDeclListNode,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumDeclNodeLoc(_, tm4) in self.enum_decl_node_loc.iter_all_0(tm0) {
                self.enum_decl_defines_symbol_9(delta, tm1, tm2, tm3, tm0, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn enum_decl_defines_symbol_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumDeclNodeLoc(tm0, tm4) in self.enum_decl_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for EnumSymbol(tm3) in self.enum_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for EnumDecl(_, tm1, tm2) in self.enum_decl.iter_all_0(tm0) {
                        self.enum_decl_defines_symbol_9(delta, tm1, tm2, tm3, tm0, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn enum_decl_defines_symbol_9(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: CtorDeclListNode,
        tm3: SymbolKind,
        tm0: EnumDeclNode,
        tm4: Loc,
    ) {
        for _ in [()] {
            let exists_already = self
                .defined_symbol
                .iter_all_0_1_2(tm1, tm3, tm4)
                .next()
                .is_some();
            if !exists_already {
                delta.new_defined_symbol.push(DefinedSymbol(tm1, tm3, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_decl_defines_symbol_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.pred_decl_defines_symbol_1(delta);
            self.pred_decl_defines_symbol_2(delta);
            self.pred_decl_defines_symbol_5(delta);
            self.pred_decl_defines_symbol_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn pred_decl_defines_symbol_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn pred_decl_defines_symbol_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredDecl(tm0, tm1, tm2) in self.pred_decl.iter_dirty() {
                self.pred_decl_defines_symbol_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_decl_defines_symbol_3(
        &self,
        delta: &mut ModelDelta,
        tm0: PredDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
    ) {
        for _ in [()] {
            self.pred_decl_defines_symbol_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn pred_decl_defines_symbol_4(
        &self,
        delta: &mut ModelDelta,
        tm0: PredDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredSymbol(tm3) in self.pred_symbol.iter_all() {
                self.pred_decl_defines_symbol_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_decl_defines_symbol_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredSymbol(tm3) in self.pred_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for PredDecl(tm0, tm1, tm2) in self.pred_decl.iter_all() {
                    self.pred_decl_defines_symbol_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_decl_defines_symbol_6(
        &self,
        delta: &mut ModelDelta,
        tm0: PredDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            self.pred_decl_defines_symbol_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn pred_decl_defines_symbol_7(
        &self,
        delta: &mut ModelDelta,
        tm0: PredDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredDeclNodeLoc(_, tm4) in self.pred_decl_node_loc.iter_all_0(tm0) {
                self.pred_decl_defines_symbol_9(delta, tm1, tm2, tm3, tm0, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_decl_defines_symbol_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredDeclNodeLoc(tm0, tm4) in self.pred_decl_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for PredSymbol(tm3) in self.pred_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for PredDecl(_, tm1, tm2) in self.pred_decl.iter_all_0(tm0) {
                        self.pred_decl_defines_symbol_9(delta, tm1, tm2, tm3, tm0, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_decl_defines_symbol_9(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: SymbolKind,
        tm0: PredDeclNode,
        tm4: Loc,
    ) {
        for _ in [()] {
            let exists_already = self
                .defined_symbol
                .iter_all_0_1_2(tm1, tm3, tm4)
                .next()
                .is_some();
            if !exists_already {
                delta.new_defined_symbol.push(DefinedSymbol(tm1, tm3, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn func_decl_defines_symbol_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.func_decl_defines_symbol_1(delta);
            self.func_decl_defines_symbol_2(delta);
            self.func_decl_defines_symbol_5(delta);
            self.func_decl_defines_symbol_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn func_decl_defines_symbol_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn func_decl_defines_symbol_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncDecl(tm0, tm1, tm2, tm3) in self.func_decl.iter_dirty() {
                self.func_decl_defines_symbol_3(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn func_decl_defines_symbol_3(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: Ident,
    ) {
        for _ in [()] {
            self.func_decl_defines_symbol_4(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn func_decl_defines_symbol_4(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: Ident,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncSymbol(tm4) in self.func_symbol.iter_all() {
                self.func_decl_defines_symbol_6(delta, tm0, tm1, tm2, tm3, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn func_decl_defines_symbol_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncSymbol(tm4) in self.func_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for FuncDecl(tm0, tm1, tm2, tm3) in self.func_decl.iter_all() {
                    self.func_decl_defines_symbol_6(delta, tm0, tm1, tm2, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn func_decl_defines_symbol_6(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: Ident,
        tm4: SymbolKind,
    ) {
        for _ in [()] {
            self.func_decl_defines_symbol_7(delta, tm0, tm1, tm2, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn func_decl_defines_symbol_7(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: Ident,
        tm4: SymbolKind,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncDeclNodeLoc(_, tm5) in self.func_decl_node_loc.iter_all_0(tm0) {
                self.func_decl_defines_symbol_9(delta, tm1, tm2, tm3, tm4, tm0, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn func_decl_defines_symbol_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncDeclNodeLoc(tm0, tm5) in self.func_decl_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for FuncSymbol(tm4) in self.func_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for FuncDecl(_, tm1, tm2, tm3) in self.func_decl.iter_all_0(tm0) {
                        self.func_decl_defines_symbol_9(delta, tm1, tm2, tm3, tm4, tm0, tm5);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn func_decl_defines_symbol_9(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: Ident,
        tm4: SymbolKind,
        tm0: FuncDeclNode,
        tm5: Loc,
    ) {
        for _ in [()] {
            let exists_already = self
                .defined_symbol
                .iter_all_0_1_2(tm1, tm4, tm5)
                .next()
                .is_some();
            if !exists_already {
                delta.new_defined_symbol.push(DefinedSymbol(tm1, tm4, tm5));
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_defines_symbol_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.ctor_decl_defines_symbol_1(delta);
            self.ctor_decl_defines_symbol_2(delta);
            self.ctor_decl_defines_symbol_5(delta);
            self.ctor_decl_defines_symbol_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_defines_symbol_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn ctor_decl_defines_symbol_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorDecl(tm0, tm1, tm2) in self.ctor_decl.iter_dirty() {
                self.ctor_decl_defines_symbol_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_defines_symbol_3(
        &self,
        delta: &mut ModelDelta,
        tm0: CtorDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
    ) {
        for _ in [()] {
            self.ctor_decl_defines_symbol_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_defines_symbol_4(
        &self,
        delta: &mut ModelDelta,
        tm0: CtorDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorSymbol(tm3) in self.ctor_symbol.iter_all() {
                self.ctor_decl_defines_symbol_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_defines_symbol_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorSymbol(tm3) in self.ctor_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for CtorDecl(tm0, tm1, tm2) in self.ctor_decl.iter_all() {
                    self.ctor_decl_defines_symbol_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_defines_symbol_6(
        &self,
        delta: &mut ModelDelta,
        tm0: CtorDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            self.ctor_decl_defines_symbol_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_defines_symbol_7(
        &self,
        delta: &mut ModelDelta,
        tm0: CtorDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorDeclNodeLoc(_, tm4) in self.ctor_decl_node_loc.iter_all_0(tm0) {
                self.ctor_decl_defines_symbol_9(delta, tm1, tm2, tm3, tm0, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_defines_symbol_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorDeclNodeLoc(tm0, tm4) in self.ctor_decl_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for CtorSymbol(tm3) in self.ctor_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for CtorDecl(_, tm1, tm2) in self.ctor_decl.iter_all_0(tm0) {
                        self.ctor_decl_defines_symbol_9(delta, tm1, tm2, tm3, tm0, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_decl_defines_symbol_9(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: SymbolKind,
        tm0: CtorDeclNode,
        tm4: Loc,
    ) {
        for _ in [()] {
            let exists_already = self
                .defined_symbol
                .iter_all_0_1_2(tm1, tm3, tm4)
                .next()
                .is_some();
            if !exists_already {
                delta.new_defined_symbol.push(DefinedSymbol(tm1, tm3, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_decl_defines_symbol_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.rule_decl_defines_symbol_1(delta);
            self.rule_decl_defines_symbol_2(delta);
            self.rule_decl_defines_symbol_5(delta);
            self.rule_decl_defines_symbol_8(delta);
            self.rule_decl_defines_symbol_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn rule_decl_defines_symbol_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn rule_decl_defines_symbol_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDecl(tm0, tm1) in self.rule_decl.iter_dirty() {
                self.rule_decl_defines_symbol_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_decl_defines_symbol_3(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDeclNode,
        tm1: StmtListNode,
    ) {
        for _ in [()] {
            self.rule_decl_defines_symbol_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn rule_decl_defines_symbol_4(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDeclNode,
        tm1: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleName(_, tm2) in self.rule_name.iter_all_0(tm0) {
                self.rule_decl_defines_symbol_6(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_decl_defines_symbol_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleName(tm0, tm2) in self.rule_name.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDecl(_, tm1) in self.rule_decl.iter_all_0(tm0) {
                    self.rule_decl_defines_symbol_6(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_decl_defines_symbol_6(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtListNode,
        tm0: RuleDeclNode,
        tm2: Ident,
    ) {
        for _ in [()] {
            self.rule_decl_defines_symbol_7(delta, tm1, tm0, tm2);
        }
    }

    #[allow(unused_variables)]
    fn rule_decl_defines_symbol_7(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtListNode,
        tm0: RuleDeclNode,
        tm2: Ident,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleSymbol(tm3) in self.rule_symbol.iter_all() {
                self.rule_decl_defines_symbol_9(delta, tm1, tm0, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_decl_defines_symbol_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleSymbol(tm3) in self.rule_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for RuleName(tm0, tm2) in self.rule_name.iter_all() {
                    #[allow(unused_variables)]
                    for RuleDecl(_, tm1) in self.rule_decl.iter_all_0(tm0) {
                        self.rule_decl_defines_symbol_9(delta, tm1, tm0, tm2, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_decl_defines_symbol_9(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtListNode,
        tm0: RuleDeclNode,
        tm2: Ident,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            self.rule_decl_defines_symbol_10(delta, tm1, tm0, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn rule_decl_defines_symbol_10(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtListNode,
        tm0: RuleDeclNode,
        tm2: Ident,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDeclNodeLoc(_, tm4) in self.rule_decl_node_loc.iter_all_0(tm0) {
                self.rule_decl_defines_symbol_12(delta, tm1, tm2, tm3, tm0, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_decl_defines_symbol_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDeclNodeLoc(tm0, tm4) in self.rule_decl_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for RuleSymbol(tm3) in self.rule_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for RuleDecl(_, tm1) in self.rule_decl.iter_all_0(tm0) {
                        #[allow(unused_variables)]
                        for RuleName(_, tm2) in self.rule_name.iter_all_0(tm0) {
                            self.rule_decl_defines_symbol_12(delta, tm1, tm2, tm3, tm0, tm4);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn rule_decl_defines_symbol_12(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtListNode,
        tm2: Ident,
        tm3: SymbolKind,
        tm0: RuleDeclNode,
        tm4: Loc,
    ) {
        for _ in [()] {
            let exists_already = self
                .defined_symbol
                .iter_all_0_1_2(tm2, tm3, tm4)
                .next()
                .is_some();
            if !exists_already {
                delta.new_defined_symbol.push(DefinedSymbol(tm2, tm3, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn arg_decl_should_be_type_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.arg_decl_should_be_type_1(delta);
            self.arg_decl_should_be_type_2(delta);
            self.arg_decl_should_be_type_5(delta);
            self.arg_decl_should_be_type_8(delta);
            self.arg_decl_should_be_type_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn arg_decl_should_be_type_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn arg_decl_should_be_type_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ArgDeclNodeType(tm0, tm1) in self.arg_decl_node_type.iter_dirty() {
                self.arg_decl_should_be_type_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn arg_decl_should_be_type_3(&self, delta: &mut ModelDelta, tm0: ArgDeclNode, tm1: Ident) {
        for _ in [()] {
            self.arg_decl_should_be_type_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn arg_decl_should_be_type_4(&self, delta: &mut ModelDelta, tm0: ArgDeclNode, tm1: Ident) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeSymbol(tm2) in self.type_symbol.iter_all() {
                self.arg_decl_should_be_type_6(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn arg_decl_should_be_type_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeSymbol(tm2) in self.type_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for ArgDeclNodeType(tm0, tm1) in self.arg_decl_node_type.iter_all() {
                    self.arg_decl_should_be_type_6(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn arg_decl_should_be_type_6(
        &self,
        delta: &mut ModelDelta,
        tm0: ArgDeclNode,
        tm1: Ident,
        tm2: SymbolKind,
    ) {
        for _ in [()] {
            self.arg_decl_should_be_type_7(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn arg_decl_should_be_type_7(
        &self,
        delta: &mut ModelDelta,
        tm0: ArgDeclNode,
        tm1: Ident,
        tm2: SymbolKind,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumSymbol(tm3) in self.enum_symbol.iter_all() {
                self.arg_decl_should_be_type_9(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn arg_decl_should_be_type_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumSymbol(tm3) in self.enum_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for TypeSymbol(tm2) in self.type_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for ArgDeclNodeType(tm0, tm1) in self.arg_decl_node_type.iter_all() {
                        self.arg_decl_should_be_type_9(delta, tm0, tm1, tm2, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn arg_decl_should_be_type_9(
        &self,
        delta: &mut ModelDelta,
        tm0: ArgDeclNode,
        tm1: Ident,
        tm2: SymbolKind,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            self.arg_decl_should_be_type_10(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn arg_decl_should_be_type_10(
        &self,
        delta: &mut ModelDelta,
        tm0: ArgDeclNode,
        tm1: Ident,
        tm2: SymbolKind,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ArgDeclNodeLoc(_, tm4) in self.arg_decl_node_loc.iter_all_0(tm0) {
                self.arg_decl_should_be_type_12(delta, tm1, tm2, tm3, tm0, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn arg_decl_should_be_type_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ArgDeclNodeLoc(tm0, tm4) in self.arg_decl_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for EnumSymbol(tm3) in self.enum_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for ArgDeclNodeType(_, tm1) in self.arg_decl_node_type.iter_all_0(tm0) {
                        #[allow(unused_variables)]
                        for TypeSymbol(tm2) in self.type_symbol.iter_all() {
                            self.arg_decl_should_be_type_12(delta, tm1, tm2, tm3, tm0, tm4);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn arg_decl_should_be_type_12(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: SymbolKind,
        tm3: SymbolKind,
        tm0: ArgDeclNode,
        tm4: Loc,
    ) {
        for _ in [()] {
            let exists_already = self
                .should_be_symbol_2
                .iter_all_0_1_2_3(tm1, tm2, tm3, tm4)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_should_be_symbol_2
                    .push(ShouldBeSymbol2(tm1, tm2, tm3, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn result_should_be_type_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.result_should_be_type_1(delta);
            self.result_should_be_type_2(delta);
            self.result_should_be_type_5(delta);
            self.result_should_be_type_8(delta);
            self.result_should_be_type_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn result_should_be_type_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn result_should_be_type_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncDecl(tm0, tm1, tm2, tm3) in self.func_decl.iter_dirty() {
                self.result_should_be_type_3(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn result_should_be_type_3(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: Ident,
    ) {
        for _ in [()] {
            self.result_should_be_type_4(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn result_should_be_type_4(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: Ident,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeSymbol(tm4) in self.type_symbol.iter_all() {
                self.result_should_be_type_6(delta, tm0, tm1, tm2, tm3, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn result_should_be_type_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeSymbol(tm4) in self.type_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for FuncDecl(tm0, tm1, tm2, tm3) in self.func_decl.iter_all() {
                    self.result_should_be_type_6(delta, tm0, tm1, tm2, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn result_should_be_type_6(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: Ident,
        tm4: SymbolKind,
    ) {
        for _ in [()] {
            self.result_should_be_type_7(delta, tm0, tm1, tm2, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn result_should_be_type_7(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: Ident,
        tm4: SymbolKind,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumSymbol(tm5) in self.enum_symbol.iter_all() {
                self.result_should_be_type_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn result_should_be_type_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumSymbol(tm5) in self.enum_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for TypeSymbol(tm4) in self.type_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for FuncDecl(tm0, tm1, tm2, tm3) in self.func_decl.iter_all() {
                        self.result_should_be_type_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn result_should_be_type_9(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: Ident,
        tm4: SymbolKind,
        tm5: SymbolKind,
    ) {
        for _ in [()] {
            self.result_should_be_type_10(delta, tm0, tm1, tm2, tm3, tm4, tm5);
        }
    }

    #[allow(unused_variables)]
    fn result_should_be_type_10(
        &self,
        delta: &mut ModelDelta,
        tm0: FuncDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: Ident,
        tm4: SymbolKind,
        tm5: SymbolKind,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncDeclNodeLoc(_, tm6) in self.func_decl_node_loc.iter_all_0(tm0) {
                self.result_should_be_type_12(delta, tm1, tm2, tm3, tm4, tm5, tm0, tm6);
            }
        }
    }

    #[allow(unused_variables)]
    fn result_should_be_type_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncDeclNodeLoc(tm0, tm6) in self.func_decl_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for EnumSymbol(tm5) in self.enum_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for TypeSymbol(tm4) in self.type_symbol.iter_all() {
                        #[allow(unused_variables)]
                        for FuncDecl(_, tm1, tm2, tm3) in self.func_decl.iter_all_0(tm0) {
                            self.result_should_be_type_12(delta, tm1, tm2, tm3, tm4, tm5, tm0, tm6);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn result_should_be_type_12(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: ArgDeclListNode,
        tm3: Ident,
        tm4: SymbolKind,
        tm5: SymbolKind,
        tm0: FuncDeclNode,
        tm6: Loc,
    ) {
        for _ in [()] {
            let exists_already = self
                .should_be_symbol_2
                .iter_all_0_1_2_3(tm3, tm4, tm5, tm6)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_should_be_symbol_2
                    .push(ShouldBeSymbol2(tm3, tm4, tm5, tm6));
            }
        }
    }

    #[allow(unused_variables)]
    fn var_atom_should_be_type_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.var_atom_should_be_type_1(delta);
            self.var_atom_should_be_type_2(delta);
            self.var_atom_should_be_type_5(delta);
            self.var_atom_should_be_type_8(delta);
            self.var_atom_should_be_type_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn var_atom_should_be_type_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn var_atom_should_be_type_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for VarIfAtomNode(tm0, tm1, tm2) in self.var_if_atom_node.iter_dirty() {
                self.var_atom_should_be_type_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn var_atom_should_be_type_3(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: Ident,
    ) {
        for _ in [()] {
            self.var_atom_should_be_type_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn var_atom_should_be_type_4(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: Ident,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeSymbol(tm3) in self.type_symbol.iter_all() {
                self.var_atom_should_be_type_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn var_atom_should_be_type_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeSymbol(tm3) in self.type_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for VarIfAtomNode(tm0, tm1, tm2) in self.var_if_atom_node.iter_all() {
                    self.var_atom_should_be_type_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn var_atom_should_be_type_6(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: Ident,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            self.var_atom_should_be_type_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn var_atom_should_be_type_7(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: Ident,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumSymbol(tm4) in self.enum_symbol.iter_all() {
                self.var_atom_should_be_type_9(delta, tm0, tm1, tm2, tm3, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn var_atom_should_be_type_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumSymbol(tm4) in self.enum_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for TypeSymbol(tm3) in self.type_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for VarIfAtomNode(tm0, tm1, tm2) in self.var_if_atom_node.iter_all() {
                        self.var_atom_should_be_type_9(delta, tm0, tm1, tm2, tm3, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn var_atom_should_be_type_9(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: Ident,
        tm3: SymbolKind,
        tm4: SymbolKind,
    ) {
        for _ in [()] {
            self.var_atom_should_be_type_10(delta, tm0, tm1, tm2, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn var_atom_should_be_type_10(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: Ident,
        tm3: SymbolKind,
        tm4: SymbolKind,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfAtomNodeLoc(_, tm5) in self.if_atom_node_loc.iter_all_0(tm0) {
                self.var_atom_should_be_type_12(delta, tm1, tm2, tm3, tm4, tm0, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn var_atom_should_be_type_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfAtomNodeLoc(tm0, tm5) in self.if_atom_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for EnumSymbol(tm4) in self.enum_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for TypeSymbol(tm3) in self.type_symbol.iter_all() {
                        #[allow(unused_variables)]
                        for VarIfAtomNode(_, tm1, tm2) in self.var_if_atom_node.iter_all_0(tm0) {
                            self.var_atom_should_be_type_12(delta, tm1, tm2, tm3, tm4, tm0, tm5);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn var_atom_should_be_type_12(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: Ident,
        tm3: SymbolKind,
        tm4: SymbolKind,
        tm0: IfAtomNode,
        tm5: Loc,
    ) {
        for _ in [()] {
            let exists_already = self
                .should_be_symbol_2
                .iter_all_0_1_2_3(tm2, tm3, tm4, tm5)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_should_be_symbol_2
                    .push(ShouldBeSymbol2(tm2, tm3, tm4, tm5));
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_should_be_pred_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.pred_if_atom_should_be_pred_1(delta);
            self.pred_if_atom_should_be_pred_2(delta);
            self.pred_if_atom_should_be_pred_5(delta);
            self.pred_if_atom_should_be_pred_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_should_be_pred_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn pred_if_atom_should_be_pred_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredIfAtomNode(tm0, tm1, tm2) in self.pred_if_atom_node.iter_dirty() {
                self.pred_if_atom_should_be_pred_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_should_be_pred_3(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.pred_if_atom_should_be_pred_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_should_be_pred_4(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredSymbol(tm3) in self.pred_symbol.iter_all() {
                self.pred_if_atom_should_be_pred_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_should_be_pred_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredSymbol(tm3) in self.pred_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for PredIfAtomNode(tm0, tm1, tm2) in self.pred_if_atom_node.iter_all() {
                    self.pred_if_atom_should_be_pred_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_should_be_pred_6(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: Ident,
        tm2: TermListNode,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            self.pred_if_atom_should_be_pred_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_should_be_pred_7(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: Ident,
        tm2: TermListNode,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfAtomNodeLoc(_, tm4) in self.if_atom_node_loc.iter_all_0(tm0) {
                self.pred_if_atom_should_be_pred_9(delta, tm1, tm2, tm3, tm0, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_should_be_pred_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfAtomNodeLoc(tm0, tm4) in self.if_atom_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for PredSymbol(tm3) in self.pred_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for PredIfAtomNode(_, tm1, tm2) in self.pred_if_atom_node.iter_all_0(tm0) {
                        self.pred_if_atom_should_be_pred_9(delta, tm1, tm2, tm3, tm0, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_should_be_pred_9(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: TermListNode,
        tm3: SymbolKind,
        tm0: IfAtomNode,
        tm4: Loc,
    ) {
        for _ in [()] {
            let exists_already = self
                .should_be_symbol
                .iter_all_0_1_2(tm1, tm3, tm4)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_should_be_symbol
                    .push(ShouldBeSymbol(tm1, tm3, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_should_be_pred_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.pred_then_atom_should_be_pred_1(delta);
            self.pred_then_atom_should_be_pred_2(delta);
            self.pred_then_atom_should_be_pred_5(delta);
            self.pred_then_atom_should_be_pred_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_should_be_pred_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn pred_then_atom_should_be_pred_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredThenAtomNode(tm0, tm1, tm2) in self.pred_then_atom_node.iter_dirty() {
                self.pred_then_atom_should_be_pred_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_should_be_pred_3(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.pred_then_atom_should_be_pred_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_should_be_pred_4(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredSymbol(tm3) in self.pred_symbol.iter_all() {
                self.pred_then_atom_should_be_pred_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_should_be_pred_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredSymbol(tm3) in self.pred_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for PredThenAtomNode(tm0, tm1, tm2) in self.pred_then_atom_node.iter_all() {
                    self.pred_then_atom_should_be_pred_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_should_be_pred_6(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: Ident,
        tm2: TermListNode,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            self.pred_then_atom_should_be_pred_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_should_be_pred_7(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: Ident,
        tm2: TermListNode,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenAtomNodeLoc(_, tm4) in self.then_atom_node_loc.iter_all_0(tm0) {
                self.pred_then_atom_should_be_pred_9(delta, tm1, tm2, tm3, tm0, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_should_be_pred_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenAtomNodeLoc(tm0, tm4) in self.then_atom_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for PredSymbol(tm3) in self.pred_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for PredThenAtomNode(_, tm1, tm2) in self.pred_then_atom_node.iter_all_0(tm0) {
                        self.pred_then_atom_should_be_pred_9(delta, tm1, tm2, tm3, tm0, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_should_be_pred_9(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: TermListNode,
        tm3: SymbolKind,
        tm0: ThenAtomNode,
        tm4: Loc,
    ) {
        for _ in [()] {
            let exists_already = self
                .should_be_symbol
                .iter_all_0_1_2(tm1, tm3, tm4)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_should_be_symbol
                    .push(ShouldBeSymbol(tm1, tm3, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn app_atom_should_be_func_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.app_atom_should_be_func_1(delta);
            self.app_atom_should_be_func_2(delta);
            self.app_atom_should_be_func_5(delta);
            self.app_atom_should_be_func_8(delta);
            self.app_atom_should_be_func_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn app_atom_should_be_func_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn app_atom_should_be_func_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for AppTermNode(tm0, tm1, tm2) in self.app_term_node.iter_dirty() {
                self.app_atom_should_be_func_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn app_atom_should_be_func_3(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.app_atom_should_be_func_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn app_atom_should_be_func_4(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncSymbol(tm3) in self.func_symbol.iter_all() {
                self.app_atom_should_be_func_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn app_atom_should_be_func_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncSymbol(tm3) in self.func_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for AppTermNode(tm0, tm1, tm2) in self.app_term_node.iter_all() {
                    self.app_atom_should_be_func_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn app_atom_should_be_func_6(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            self.app_atom_should_be_func_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn app_atom_should_be_func_7(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
        tm3: SymbolKind,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorSymbol(tm4) in self.ctor_symbol.iter_all() {
                self.app_atom_should_be_func_9(delta, tm0, tm1, tm2, tm3, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn app_atom_should_be_func_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorSymbol(tm4) in self.ctor_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for FuncSymbol(tm3) in self.func_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for AppTermNode(tm0, tm1, tm2) in self.app_term_node.iter_all() {
                        self.app_atom_should_be_func_9(delta, tm0, tm1, tm2, tm3, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn app_atom_should_be_func_9(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
        tm3: SymbolKind,
        tm4: SymbolKind,
    ) {
        for _ in [()] {
            self.app_atom_should_be_func_10(delta, tm0, tm1, tm2, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn app_atom_should_be_func_10(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
        tm3: SymbolKind,
        tm4: SymbolKind,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermNodeLoc(_, tm5) in self.term_node_loc.iter_all_0(tm0) {
                self.app_atom_should_be_func_12(delta, tm1, tm2, tm3, tm4, tm0, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn app_atom_should_be_func_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermNodeLoc(tm0, tm5) in self.term_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for CtorSymbol(tm4) in self.ctor_symbol.iter_all() {
                    #[allow(unused_variables)]
                    for FuncSymbol(tm3) in self.func_symbol.iter_all() {
                        #[allow(unused_variables)]
                        for AppTermNode(_, tm1, tm2) in self.app_term_node.iter_all_0(tm0) {
                            self.app_atom_should_be_func_12(delta, tm1, tm2, tm3, tm4, tm0, tm5);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn app_atom_should_be_func_12(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: TermListNode,
        tm3: SymbolKind,
        tm4: SymbolKind,
        tm0: TermNode,
        tm5: Loc,
    ) {
        for _ in [()] {
            let exists_already = self
                .should_be_symbol_2
                .iter_all_0_1_2_3(tm1, tm3, tm4, tm5)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_should_be_symbol_2
                    .push(ShouldBeSymbol2(tm1, tm3, tm4, tm5));
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.type_list_len_total_1(delta);
            self.type_list_len_total_2(delta);
            self.type_list_len_total_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn type_list_len_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.type_list_dirty.iter().copied() {
                self.type_list_len_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_total_3(&self, delta: &mut ModelDelta, tm0: TypeList) {
        for _ in [()] {
            self.type_list_len_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_total_4(&self, delta: &mut ModelDelta, tm0: TypeList) {
        for _ in [()] {
            let tm1 = match self.type_list_len.iter_all_0(tm0).next() {
                Some(TypeListLen(_, res)) => res,
                None => {
                    delta.new_type_list_len_def.push(TypeListLenArgs(tm0));
                    break;
                }
            };

            self.type_list_len_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeListLen(tm0, tm1) in self.type_list_len.iter_dirty() {
                self.type_list_len_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_total_6(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: Nat) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn type_list_len_nil_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.type_list_len_nil_1(delta);
            self.type_list_len_nil_2(delta);
            self.type_list_len_nil_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_nil_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn type_list_len_nil_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilTypeList(tm0) in self.nil_type_list.iter_dirty() {
                self.type_list_len_nil_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_nil_3(&self, delta: &mut ModelDelta, tm0: TypeList) {
        for _ in [()] {
            self.type_list_len_nil_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_nil_4(&self, delta: &mut ModelDelta, tm0: TypeList) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeListLen(_, tm1) in self.type_list_len.iter_all_0(tm0) {
                self.type_list_len_nil_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_nil_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeListLen(tm0, tm1) in self.type_list_len.iter_dirty() {
                #[allow(unused_variables)]
                for NilTypeList(_) in self.nil_type_list.iter_all_0(tm0) {
                    self.type_list_len_nil_6(delta, tm0, tm1);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_nil_6(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: Nat) {
        for _ in [()] {
            let exists_already = self.zero.iter_all_0(tm1).next().is_some();
            if !exists_already {
                delta.new_zero.push(Zero(tm1));
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_cons_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.type_list_len_cons_1(delta);
            self.type_list_len_cons_2(delta);
            self.type_list_len_cons_5(delta);
            self.type_list_len_cons_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_cons_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn type_list_len_cons_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsTypeList(tm0, tm1, tm2) in self.cons_type_list.iter_dirty() {
                self.type_list_len_cons_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_cons_3(
        &self,
        delta: &mut ModelDelta,
        tm0: Type,
        tm1: TypeList,
        tm2: TypeList,
    ) {
        for _ in [()] {
            self.type_list_len_cons_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_cons_4(
        &self,
        delta: &mut ModelDelta,
        tm0: Type,
        tm1: TypeList,
        tm2: TypeList,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeListLen(_, tm3) in self.type_list_len.iter_all_0(tm2) {
                self.type_list_len_cons_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_cons_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeListLen(tm2, tm3) in self.type_list_len.iter_dirty() {
                #[allow(unused_variables)]
                for ConsTypeList(tm0, tm1, _) in self.cons_type_list.iter_all_2(tm2) {
                    self.type_list_len_cons_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_cons_6(
        &self,
        delta: &mut ModelDelta,
        tm0: Type,
        tm1: TypeList,
        tm2: TypeList,
        tm3: Nat,
    ) {
        for _ in [()] {
            self.type_list_len_cons_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_cons_7(
        &self,
        delta: &mut ModelDelta,
        tm0: Type,
        tm1: TypeList,
        tm2: TypeList,
        tm3: Nat,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeListLen(_, tm4) in self.type_list_len.iter_all_0(tm1) {
                self.type_list_len_cons_9(delta, tm0, tm2, tm3, tm1, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_cons_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeListLen(tm1, tm4) in self.type_list_len.iter_dirty() {
                #[allow(unused_variables)]
                for ConsTypeList(tm0, _, tm2) in self.cons_type_list.iter_all_1(tm1) {
                    #[allow(unused_variables)]
                    for TypeListLen(_, tm3) in self.type_list_len.iter_all_0(tm2) {
                        self.type_list_len_cons_9(delta, tm0, tm2, tm3, tm1, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_cons_9(
        &self,
        delta: &mut ModelDelta,
        tm0: Type,
        tm2: TypeList,
        tm3: Nat,
        tm1: TypeList,
        tm4: Nat,
    ) {
        for _ in [()] {
            let exists_already = self.succ.iter_all_0_1(tm4, tm3).next().is_some();
            if !exists_already {
                delta.new_succ.push(Succ(tm4, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_snoc_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.type_list_len_snoc_1(delta);
            self.type_list_len_snoc_2(delta);
            self.type_list_len_snoc_5(delta);
            self.type_list_len_snoc_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_snoc_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn type_list_len_snoc_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SnocTypeList(tm0, tm1, tm2) in self.snoc_type_list.iter_dirty() {
                self.type_list_len_snoc_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_snoc_3(
        &self,
        delta: &mut ModelDelta,
        tm0: TypeList,
        tm1: Type,
        tm2: TypeList,
    ) {
        for _ in [()] {
            self.type_list_len_snoc_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_snoc_4(
        &self,
        delta: &mut ModelDelta,
        tm0: TypeList,
        tm1: Type,
        tm2: TypeList,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeListLen(_, tm3) in self.type_list_len.iter_all_0(tm2) {
                self.type_list_len_snoc_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_snoc_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeListLen(tm2, tm3) in self.type_list_len.iter_dirty() {
                #[allow(unused_variables)]
                for SnocTypeList(tm0, tm1, _) in self.snoc_type_list.iter_all_2(tm2) {
                    self.type_list_len_snoc_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_snoc_6(
        &self,
        delta: &mut ModelDelta,
        tm0: TypeList,
        tm1: Type,
        tm2: TypeList,
        tm3: Nat,
    ) {
        for _ in [()] {
            self.type_list_len_snoc_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_snoc_7(
        &self,
        delta: &mut ModelDelta,
        tm0: TypeList,
        tm1: Type,
        tm2: TypeList,
        tm3: Nat,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeListLen(_, tm4) in self.type_list_len.iter_all_0(tm0) {
                self.type_list_len_snoc_9(delta, tm1, tm2, tm3, tm0, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_snoc_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeListLen(tm0, tm4) in self.type_list_len.iter_dirty() {
                #[allow(unused_variables)]
                for SnocTypeList(_, tm1, tm2) in self.snoc_type_list.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for TypeListLen(_, tm3) in self.type_list_len.iter_all_0(tm2) {
                        self.type_list_len_snoc_9(delta, tm1, tm2, tm3, tm0, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn type_list_len_snoc_9(
        &self,
        delta: &mut ModelDelta,
        tm1: Type,
        tm2: TypeList,
        tm3: Nat,
        tm0: TypeList,
        tm4: Nat,
    ) {
        for _ in [()] {
            let exists_already = self.succ.iter_all_0_1(tm4, tm3).next().is_some();
            if !exists_already {
                delta.new_succ.push(Succ(tm4, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.term_list_len_total_1(delta);
            self.term_list_len_total_2(delta);
            self.term_list_len_total_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn term_list_len_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.term_list_node_dirty.iter().copied() {
                self.term_list_len_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_total_3(&self, delta: &mut ModelDelta, tm0: TermListNode) {
        for _ in [()] {
            self.term_list_len_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_total_4(&self, delta: &mut ModelDelta, tm0: TermListNode) {
        for _ in [()] {
            let tm1 = match self.term_list_len.iter_all_0(tm0).next() {
                Some(TermListLen(_, res)) => res,
                None => {
                    delta.new_term_list_len_def.push(TermListLenArgs(tm0));
                    break;
                }
            };

            self.term_list_len_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermListLen(tm0, tm1) in self.term_list_len.iter_dirty() {
                self.term_list_len_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_total_6(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: Nat) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn term_list_len_nil_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.term_list_len_nil_1(delta);
            self.term_list_len_nil_2(delta);
            self.term_list_len_nil_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_nil_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn term_list_len_nil_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilTermListNode(tm0) in self.nil_term_list_node.iter_dirty() {
                self.term_list_len_nil_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_nil_3(&self, delta: &mut ModelDelta, tm0: TermListNode) {
        for _ in [()] {
            self.term_list_len_nil_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_nil_4(&self, delta: &mut ModelDelta, tm0: TermListNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermListLen(_, tm1) in self.term_list_len.iter_all_0(tm0) {
                self.term_list_len_nil_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_nil_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermListLen(tm0, tm1) in self.term_list_len.iter_dirty() {
                #[allow(unused_variables)]
                for NilTermListNode(_) in self.nil_term_list_node.iter_all_0(tm0) {
                    self.term_list_len_nil_6(delta, tm0, tm1);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_nil_6(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: Nat) {
        for _ in [()] {
            let exists_already = self.zero.iter_all_0(tm1).next().is_some();
            if !exists_already {
                delta.new_zero.push(Zero(tm1));
            }
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_cons_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.term_list_len_cons_1(delta);
            self.term_list_len_cons_2(delta);
            self.term_list_len_cons_5(delta);
            self.term_list_len_cons_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_cons_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn term_list_len_cons_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsTermListNode(tm0, tm1, tm2) in self.cons_term_list_node.iter_dirty() {
                self.term_list_len_cons_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_cons_3(
        &self,
        delta: &mut ModelDelta,
        tm0: TermListNode,
        tm1: TermNode,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.term_list_len_cons_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_cons_4(
        &self,
        delta: &mut ModelDelta,
        tm0: TermListNode,
        tm1: TermNode,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermListLen(_, tm3) in self.term_list_len.iter_all_0(tm0) {
                self.term_list_len_cons_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_cons_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermListLen(tm0, tm3) in self.term_list_len.iter_dirty() {
                #[allow(unused_variables)]
                for ConsTermListNode(_, tm1, tm2) in self.cons_term_list_node.iter_all_0(tm0) {
                    self.term_list_len_cons_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_cons_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermListNode,
        tm0: TermListNode,
        tm3: Nat,
    ) {
        for _ in [()] {
            self.term_list_len_cons_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_cons_7(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermListNode,
        tm0: TermListNode,
        tm3: Nat,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermListLen(_, tm4) in self.term_list_len.iter_all_0(tm2) {
                self.term_list_len_cons_9(delta, tm1, tm0, tm3, tm2, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_cons_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermListLen(tm2, tm4) in self.term_list_len.iter_dirty() {
                #[allow(unused_variables)]
                for TermListLen(tm0, tm3) in self.term_list_len.iter_all() {
                    #[allow(unused_variables)]
                    for ConsTermListNode(_, tm1, _) in
                        self.cons_term_list_node.iter_all_0_2(tm0, tm2)
                    {
                        self.term_list_len_cons_9(delta, tm1, tm0, tm3, tm2, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn term_list_len_cons_9(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm0: TermListNode,
        tm3: Nat,
        tm2: TermListNode,
        tm4: Nat,
    ) {
        for _ in [()] {
            let exists_already = self.succ.iter_all_0_1(tm4, tm3).next().is_some();
            if !exists_already {
                delta.new_succ.push(Succ(tm4, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_arg_num_should_match_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.pred_if_atom_arg_num_should_match_1(delta);
            self.pred_if_atom_arg_num_should_match_2(delta);
            self.pred_if_atom_arg_num_should_match_5(delta);
            self.pred_if_atom_arg_num_should_match_8(delta);
            self.pred_if_atom_arg_num_should_match_9(delta);
            self.pred_if_atom_arg_num_should_match_10(delta);
            self.pred_if_atom_arg_num_should_match_13(delta);
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_arg_num_should_match_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn pred_if_atom_arg_num_should_match_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredIfAtomNode(tm0, tm1, tm2) in self.pred_if_atom_node.iter_dirty() {
                self.pred_if_atom_arg_num_should_match_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_arg_num_should_match_3(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.pred_if_atom_arg_num_should_match_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_arg_num_should_match_4(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermListLen(_, tm3) in self.term_list_len.iter_all_0(tm2) {
                self.pred_if_atom_arg_num_should_match_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_arg_num_should_match_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermListLen(tm2, tm3) in self.term_list_len.iter_dirty() {
                #[allow(unused_variables)]
                for PredIfAtomNode(tm0, tm1, _) in self.pred_if_atom_node.iter_all_2(tm2) {
                    self.pred_if_atom_arg_num_should_match_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_arg_num_should_match_6(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: Ident,
        tm2: TermListNode,
        tm3: Nat,
    ) {
        for _ in [()] {
            self.pred_if_atom_arg_num_should_match_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_arg_num_should_match_7(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: Ident,
        tm2: TermListNode,
        tm3: Nat,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticPred(_, tm4) in self.semantic_pred.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for PredArity(_, tm5) in self.pred_arity.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                        self.pred_if_atom_arg_num_should_match_11(
                            delta, tm0, tm2, tm3, tm1, tm4, tm5, tm6,
                        );
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_arg_num_should_match_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticPred(tm1, tm4) in self.semantic_pred.iter_dirty() {
                #[allow(unused_variables)]
                for PredArity(_, tm5) in self.pred_arity.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                        #[allow(unused_variables)]
                        for TermListLen(tm2, tm3) in self.term_list_len.iter_all() {
                            #[allow(unused_variables)]
                            for PredIfAtomNode(tm0, _, _) in
                                self.pred_if_atom_node.iter_all_1_2(tm1, tm2)
                            {
                                self.pred_if_atom_arg_num_should_match_11(
                                    delta, tm0, tm2, tm3, tm1, tm4, tm5, tm6,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_arg_num_should_match_9(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredArity(tm4, tm5) in self.pred_arity.iter_dirty() {
                #[allow(unused_variables)]
                for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                    #[allow(unused_variables)]
                    for SemanticPred(tm1, _) in self.semantic_pred.iter_all_1(tm4) {
                        #[allow(unused_variables)]
                        for TermListLen(tm2, tm3) in self.term_list_len.iter_all() {
                            #[allow(unused_variables)]
                            for PredIfAtomNode(tm0, _, _) in
                                self.pred_if_atom_node.iter_all_1_2(tm1, tm2)
                            {
                                self.pred_if_atom_arg_num_should_match_11(
                                    delta, tm0, tm2, tm3, tm1, tm4, tm5, tm6,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_arg_num_should_match_10(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeListLen(tm5, tm6) in self.type_list_len.iter_dirty() {
                #[allow(unused_variables)]
                for PredArity(tm4, _) in self.pred_arity.iter_all_1(tm5) {
                    #[allow(unused_variables)]
                    for SemanticPred(tm1, _) in self.semantic_pred.iter_all_1(tm4) {
                        #[allow(unused_variables)]
                        for TermListLen(tm2, tm3) in self.term_list_len.iter_all() {
                            #[allow(unused_variables)]
                            for PredIfAtomNode(tm0, _, _) in
                                self.pred_if_atom_node.iter_all_1_2(tm1, tm2)
                            {
                                self.pred_if_atom_arg_num_should_match_11(
                                    delta, tm0, tm2, tm3, tm1, tm4, tm5, tm6,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_arg_num_should_match_11(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm2: TermListNode,
        tm3: Nat,
        tm1: Ident,
        tm4: Pred,
        tm5: TypeList,
        tm6: Nat,
    ) {
        for _ in [()] {
            self.pred_if_atom_arg_num_should_match_12(delta, tm0, tm2, tm3, tm1, tm4, tm5, tm6);
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_arg_num_should_match_12(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm2: TermListNode,
        tm3: Nat,
        tm1: Ident,
        tm4: Pred,
        tm5: TypeList,
        tm6: Nat,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfAtomNodeLoc(_, tm7) in self.if_atom_node_loc.iter_all_0(tm0) {
                self.pred_if_atom_arg_num_should_match_14(
                    delta, tm2, tm3, tm1, tm4, tm5, tm6, tm0, tm7,
                );
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_arg_num_should_match_13(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfAtomNodeLoc(tm0, tm7) in self.if_atom_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for TermListLen(tm2, tm3) in self.term_list_len.iter_all() {
                    #[allow(unused_variables)]
                    for PredIfAtomNode(_, tm1, _) in self.pred_if_atom_node.iter_all_0_2(tm0, tm2) {
                        #[allow(unused_variables)]
                        for SemanticPred(_, tm4) in self.semantic_pred.iter_all_0(tm1) {
                            #[allow(unused_variables)]
                            for PredArity(_, tm5) in self.pred_arity.iter_all_0(tm4) {
                                #[allow(unused_variables)]
                                for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                                    self.pred_if_atom_arg_num_should_match_14(
                                        delta, tm2, tm3, tm1, tm4, tm5, tm6, tm0, tm7,
                                    );
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_arg_num_should_match_14(
        &self,
        delta: &mut ModelDelta,
        tm2: TermListNode,
        tm3: Nat,
        tm1: Ident,
        tm4: Pred,
        tm5: TypeList,
        tm6: Nat,
        tm0: IfAtomNode,
        tm7: Loc,
    ) {
        for _ in [()] {
            let exists_already = self
                .pred_arg_num_should_match
                .iter_all_0_1_2(tm3, tm6, tm7)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_pred_arg_num_should_match
                    .push(PredArgNumShouldMatch(tm3, tm6, tm7));
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_arg_num_should_match_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.pred_then_atom_arg_num_should_match_1(delta);
            self.pred_then_atom_arg_num_should_match_2(delta);
            self.pred_then_atom_arg_num_should_match_5(delta);
            self.pred_then_atom_arg_num_should_match_8(delta);
            self.pred_then_atom_arg_num_should_match_9(delta);
            self.pred_then_atom_arg_num_should_match_10(delta);
            self.pred_then_atom_arg_num_should_match_13(delta);
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_arg_num_should_match_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn pred_then_atom_arg_num_should_match_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredThenAtomNode(tm0, tm1, tm2) in self.pred_then_atom_node.iter_dirty() {
                self.pred_then_atom_arg_num_should_match_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_arg_num_should_match_3(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.pred_then_atom_arg_num_should_match_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_arg_num_should_match_4(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermListLen(_, tm3) in self.term_list_len.iter_all_0(tm2) {
                self.pred_then_atom_arg_num_should_match_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_arg_num_should_match_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermListLen(tm2, tm3) in self.term_list_len.iter_dirty() {
                #[allow(unused_variables)]
                for PredThenAtomNode(tm0, tm1, _) in self.pred_then_atom_node.iter_all_2(tm2) {
                    self.pred_then_atom_arg_num_should_match_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_arg_num_should_match_6(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: Ident,
        tm2: TermListNode,
        tm3: Nat,
    ) {
        for _ in [()] {
            self.pred_then_atom_arg_num_should_match_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_arg_num_should_match_7(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: Ident,
        tm2: TermListNode,
        tm3: Nat,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticPred(_, tm4) in self.semantic_pred.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for PredArity(_, tm5) in self.pred_arity.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                        self.pred_then_atom_arg_num_should_match_11(
                            delta, tm0, tm2, tm3, tm1, tm4, tm5, tm6,
                        );
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_arg_num_should_match_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticPred(tm1, tm4) in self.semantic_pred.iter_dirty() {
                #[allow(unused_variables)]
                for PredArity(_, tm5) in self.pred_arity.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                        #[allow(unused_variables)]
                        for TermListLen(tm2, tm3) in self.term_list_len.iter_all() {
                            #[allow(unused_variables)]
                            for PredThenAtomNode(tm0, _, _) in
                                self.pred_then_atom_node.iter_all_1_2(tm1, tm2)
                            {
                                self.pred_then_atom_arg_num_should_match_11(
                                    delta, tm0, tm2, tm3, tm1, tm4, tm5, tm6,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_arg_num_should_match_9(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredArity(tm4, tm5) in self.pred_arity.iter_dirty() {
                #[allow(unused_variables)]
                for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                    #[allow(unused_variables)]
                    for SemanticPred(tm1, _) in self.semantic_pred.iter_all_1(tm4) {
                        #[allow(unused_variables)]
                        for TermListLen(tm2, tm3) in self.term_list_len.iter_all() {
                            #[allow(unused_variables)]
                            for PredThenAtomNode(tm0, _, _) in
                                self.pred_then_atom_node.iter_all_1_2(tm1, tm2)
                            {
                                self.pred_then_atom_arg_num_should_match_11(
                                    delta, tm0, tm2, tm3, tm1, tm4, tm5, tm6,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_arg_num_should_match_10(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeListLen(tm5, tm6) in self.type_list_len.iter_dirty() {
                #[allow(unused_variables)]
                for PredArity(tm4, _) in self.pred_arity.iter_all_1(tm5) {
                    #[allow(unused_variables)]
                    for SemanticPred(tm1, _) in self.semantic_pred.iter_all_1(tm4) {
                        #[allow(unused_variables)]
                        for TermListLen(tm2, tm3) in self.term_list_len.iter_all() {
                            #[allow(unused_variables)]
                            for PredThenAtomNode(tm0, _, _) in
                                self.pred_then_atom_node.iter_all_1_2(tm1, tm2)
                            {
                                self.pred_then_atom_arg_num_should_match_11(
                                    delta, tm0, tm2, tm3, tm1, tm4, tm5, tm6,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_arg_num_should_match_11(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm2: TermListNode,
        tm3: Nat,
        tm1: Ident,
        tm4: Pred,
        tm5: TypeList,
        tm6: Nat,
    ) {
        for _ in [()] {
            self.pred_then_atom_arg_num_should_match_12(delta, tm0, tm2, tm3, tm1, tm4, tm5, tm6);
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_arg_num_should_match_12(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm2: TermListNode,
        tm3: Nat,
        tm1: Ident,
        tm4: Pred,
        tm5: TypeList,
        tm6: Nat,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenAtomNodeLoc(_, tm7) in self.then_atom_node_loc.iter_all_0(tm0) {
                self.pred_then_atom_arg_num_should_match_14(
                    delta, tm2, tm3, tm1, tm4, tm5, tm6, tm0, tm7,
                );
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_arg_num_should_match_13(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenAtomNodeLoc(tm0, tm7) in self.then_atom_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for TermListLen(tm2, tm3) in self.term_list_len.iter_all() {
                    #[allow(unused_variables)]
                    for PredThenAtomNode(_, tm1, _) in
                        self.pred_then_atom_node.iter_all_0_2(tm0, tm2)
                    {
                        #[allow(unused_variables)]
                        for SemanticPred(_, tm4) in self.semantic_pred.iter_all_0(tm1) {
                            #[allow(unused_variables)]
                            for PredArity(_, tm5) in self.pred_arity.iter_all_0(tm4) {
                                #[allow(unused_variables)]
                                for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                                    self.pred_then_atom_arg_num_should_match_14(
                                        delta, tm2, tm3, tm1, tm4, tm5, tm6, tm0, tm7,
                                    );
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_arg_num_should_match_14(
        &self,
        delta: &mut ModelDelta,
        tm2: TermListNode,
        tm3: Nat,
        tm1: Ident,
        tm4: Pred,
        tm5: TypeList,
        tm6: Nat,
        tm0: ThenAtomNode,
        tm7: Loc,
    ) {
        for _ in [()] {
            let exists_already = self
                .pred_arg_num_should_match
                .iter_all_0_1_2(tm3, tm6, tm7)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_pred_arg_num_should_match
                    .push(PredArgNumShouldMatch(tm3, tm6, tm7));
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_arg_num_should_match_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.app_term_arg_num_should_match_1(delta);
            self.app_term_arg_num_should_match_2(delta);
            self.app_term_arg_num_should_match_5(delta);
            self.app_term_arg_num_should_match_8(delta);
            self.app_term_arg_num_should_match_9(delta);
            self.app_term_arg_num_should_match_10(delta);
            self.app_term_arg_num_should_match_13(delta);
        }
    }

    #[allow(unused_variables)]
    fn app_term_arg_num_should_match_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn app_term_arg_num_should_match_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for AppTermNode(tm0, tm1, tm2) in self.app_term_node.iter_dirty() {
                self.app_term_arg_num_should_match_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_arg_num_should_match_3(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.app_term_arg_num_should_match_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn app_term_arg_num_should_match_4(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermListLen(_, tm3) in self.term_list_len.iter_all_0(tm2) {
                self.app_term_arg_num_should_match_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_arg_num_should_match_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermListLen(tm2, tm3) in self.term_list_len.iter_dirty() {
                #[allow(unused_variables)]
                for AppTermNode(tm0, tm1, _) in self.app_term_node.iter_all_2(tm2) {
                    self.app_term_arg_num_should_match_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_arg_num_should_match_6(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
        tm3: Nat,
    ) {
        for _ in [()] {
            self.app_term_arg_num_should_match_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn app_term_arg_num_should_match_7(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
        tm3: Nat,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticFunc(_, tm4) in self.semantic_func.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for Domain(_, tm5) in self.domain.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                        self.app_term_arg_num_should_match_11(
                            delta, tm0, tm2, tm3, tm1, tm4, tm5, tm6,
                        );
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_arg_num_should_match_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticFunc(tm1, tm4) in self.semantic_func.iter_dirty() {
                #[allow(unused_variables)]
                for Domain(_, tm5) in self.domain.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                        #[allow(unused_variables)]
                        for TermListLen(tm2, tm3) in self.term_list_len.iter_all() {
                            #[allow(unused_variables)]
                            for AppTermNode(tm0, _, _) in self.app_term_node.iter_all_1_2(tm1, tm2)
                            {
                                self.app_term_arg_num_should_match_11(
                                    delta, tm0, tm2, tm3, tm1, tm4, tm5, tm6,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_arg_num_should_match_9(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Domain(tm4, tm5) in self.domain.iter_dirty() {
                #[allow(unused_variables)]
                for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                    #[allow(unused_variables)]
                    for SemanticFunc(tm1, _) in self.semantic_func.iter_all_1(tm4) {
                        #[allow(unused_variables)]
                        for TermListLen(tm2, tm3) in self.term_list_len.iter_all() {
                            #[allow(unused_variables)]
                            for AppTermNode(tm0, _, _) in self.app_term_node.iter_all_1_2(tm1, tm2)
                            {
                                self.app_term_arg_num_should_match_11(
                                    delta, tm0, tm2, tm3, tm1, tm4, tm5, tm6,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_arg_num_should_match_10(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeListLen(tm5, tm6) in self.type_list_len.iter_dirty() {
                #[allow(unused_variables)]
                for Domain(tm4, _) in self.domain.iter_all_1(tm5) {
                    #[allow(unused_variables)]
                    for SemanticFunc(tm1, _) in self.semantic_func.iter_all_1(tm4) {
                        #[allow(unused_variables)]
                        for TermListLen(tm2, tm3) in self.term_list_len.iter_all() {
                            #[allow(unused_variables)]
                            for AppTermNode(tm0, _, _) in self.app_term_node.iter_all_1_2(tm1, tm2)
                            {
                                self.app_term_arg_num_should_match_11(
                                    delta, tm0, tm2, tm3, tm1, tm4, tm5, tm6,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_arg_num_should_match_11(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm2: TermListNode,
        tm3: Nat,
        tm1: Ident,
        tm4: Func,
        tm5: TypeList,
        tm6: Nat,
    ) {
        for _ in [()] {
            self.app_term_arg_num_should_match_12(delta, tm0, tm2, tm3, tm1, tm4, tm5, tm6);
        }
    }

    #[allow(unused_variables)]
    fn app_term_arg_num_should_match_12(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm2: TermListNode,
        tm3: Nat,
        tm1: Ident,
        tm4: Func,
        tm5: TypeList,
        tm6: Nat,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermNodeLoc(_, tm7) in self.term_node_loc.iter_all_0(tm0) {
                self.app_term_arg_num_should_match_14(
                    delta, tm2, tm3, tm1, tm4, tm5, tm6, tm0, tm7,
                );
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_arg_num_should_match_13(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermNodeLoc(tm0, tm7) in self.term_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for TermListLen(tm2, tm3) in self.term_list_len.iter_all() {
                    #[allow(unused_variables)]
                    for AppTermNode(_, tm1, _) in self.app_term_node.iter_all_0_2(tm0, tm2) {
                        #[allow(unused_variables)]
                        for SemanticFunc(_, tm4) in self.semantic_func.iter_all_0(tm1) {
                            #[allow(unused_variables)]
                            for Domain(_, tm5) in self.domain.iter_all_0(tm4) {
                                #[allow(unused_variables)]
                                for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                                    self.app_term_arg_num_should_match_14(
                                        delta, tm2, tm3, tm1, tm4, tm5, tm6, tm0, tm7,
                                    );
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_arg_num_should_match_14(
        &self,
        delta: &mut ModelDelta,
        tm2: TermListNode,
        tm3: Nat,
        tm1: Ident,
        tm4: Func,
        tm5: TypeList,
        tm6: Nat,
        tm0: TermNode,
        tm7: Loc,
    ) {
        for _ in [()] {
            let exists_already = self
                .func_arg_num_should_match
                .iter_all_0_1_2(tm3, tm6, tm7)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_func_arg_num_should_match
                    .push(FuncArgNumShouldMatch(tm3, tm6, tm7));
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmts_stmt_cons_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.cfg_edge_stmts_stmt_cons_1(delta);
            self.cfg_edge_stmts_stmt_cons_2(delta);
            self.cfg_edge_stmts_stmt_cons_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmts_stmt_cons_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmts_stmt_cons_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CfgEdgeStmtsStmt(tm0, tm1) in self.cfg_edge_stmts_stmt.iter_dirty() {
                self.cfg_edge_stmts_stmt_cons_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmts_stmt_cons_3(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode) {
        for _ in [()] {
            self.cfg_edge_stmts_stmt_cons_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmts_stmt_cons_4(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(_, tm2, tm3) in self.cons_stmt_list_node.iter_all_0(tm0) {
                self.cfg_edge_stmts_stmt_cons_6(delta, tm1, tm0, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmts_stmt_cons_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm0, tm2, tm3) in self.cons_stmt_list_node.iter_dirty() {
                #[allow(unused_variables)]
                for CfgEdgeStmtsStmt(_, tm1) in self.cfg_edge_stmts_stmt.iter_all_0(tm0) {
                    self.cfg_edge_stmts_stmt_cons_6(delta, tm1, tm0, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmts_stmt_cons_6(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtNode,
        tm0: StmtListNode,
        tm2: StmtNode,
        tm3: StmtListNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .cfg_edge_stmts_stmt
                .iter_all_0_1(tm3, tm1)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_cfg_edge_stmts_stmt
                    .push(CfgEdgeStmtsStmt(tm3, tm1));
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmts_stmt_singleton_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.cfg_edge_stmts_stmt_singleton_1(delta);
            self.cfg_edge_stmts_stmt_singleton_2(delta);
            self.cfg_edge_stmts_stmt_singleton_5(delta);
            self.cfg_edge_stmts_stmt_singleton_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmts_stmt_singleton_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmts_stmt_singleton_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CfgEdgeStmtsStmt(tm0, tm1) in self.cfg_edge_stmts_stmt.iter_dirty() {
                self.cfg_edge_stmts_stmt_singleton_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmts_stmt_singleton_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtListNode,
        tm1: StmtNode,
    ) {
        for _ in [()] {
            self.cfg_edge_stmts_stmt_singleton_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmts_stmt_singleton_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtListNode,
        tm1: StmtNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(_, tm2, tm3) in self.cons_stmt_list_node.iter_all_0(tm0) {
                self.cfg_edge_stmts_stmt_singleton_6(delta, tm1, tm0, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmts_stmt_singleton_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm0, tm2, tm3) in self.cons_stmt_list_node.iter_dirty() {
                #[allow(unused_variables)]
                for CfgEdgeStmtsStmt(_, tm1) in self.cfg_edge_stmts_stmt.iter_all_0(tm0) {
                    self.cfg_edge_stmts_stmt_singleton_6(delta, tm1, tm0, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmts_stmt_singleton_6(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtNode,
        tm0: StmtListNode,
        tm2: StmtNode,
        tm3: StmtListNode,
    ) {
        for _ in [()] {
            self.cfg_edge_stmts_stmt_singleton_7(delta, tm1, tm0, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmts_stmt_singleton_7(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtNode,
        tm0: StmtListNode,
        tm2: StmtNode,
        tm3: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilStmtListNode(_) in self.nil_stmt_list_node.iter_all_0(tm3) {
                self.cfg_edge_stmts_stmt_singleton_9(delta, tm1, tm0, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmts_stmt_singleton_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilStmtListNode(tm3) in self.nil_stmt_list_node.iter_dirty() {
                #[allow(unused_variables)]
                for CfgEdgeStmtsStmt(tm0, tm1) in self.cfg_edge_stmts_stmt.iter_all() {
                    #[allow(unused_variables)]
                    for ConsStmtListNode(_, tm2, _) in
                        self.cons_stmt_list_node.iter_all_0_2(tm0, tm3)
                    {
                        self.cfg_edge_stmts_stmt_singleton_9(delta, tm1, tm0, tm2, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmts_stmt_singleton_9(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtNode,
        tm0: StmtListNode,
        tm2: StmtNode,
        tm3: StmtListNode,
    ) {
        for _ in [()] {
            let exists_already = self.cfg_edge.iter_all_0_1(tm2, tm1).next().is_some();
            if !exists_already {
                delta.new_cfg_edge.push(CfgEdge(tm2, tm1));
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_stmts_cons_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.cfg_edge_stmt_stmts_cons_1(delta);
            self.cfg_edge_stmt_stmts_cons_2(delta);
            self.cfg_edge_stmt_stmts_cons_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_stmts_cons_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_stmts_cons_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CfgEdgeStmtStmts(tm0, tm1) in self.cfg_edge_stmt_stmts.iter_dirty() {
                self.cfg_edge_stmt_stmts_cons_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_stmts_cons_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtListNode) {
        for _ in [()] {
            self.cfg_edge_stmt_stmts_cons_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_stmts_cons_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtListNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(_, tm2, tm3) in self.cons_stmt_list_node.iter_all_0(tm1) {
                self.cfg_edge_stmt_stmts_cons_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_stmts_cons_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm1, tm2, tm3) in self.cons_stmt_list_node.iter_dirty() {
                #[allow(unused_variables)]
                for CfgEdgeStmtStmts(tm0, _) in self.cfg_edge_stmt_stmts.iter_all_1(tm1) {
                    self.cfg_edge_stmt_stmts_cons_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_stmts_cons_6(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: StmtListNode,
        tm2: StmtNode,
        tm3: StmtListNode,
    ) {
        for _ in [()] {
            let exists_already = self.cfg_edge.iter_all_0_1(tm0, tm2).next().is_some();
            if !exists_already {
                delta.new_cfg_edge.push(CfgEdge(tm0, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_stmts_nil_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.cfg_edge_stmt_stmts_nil_1(delta);
            self.cfg_edge_stmt_stmts_nil_2(delta);
            self.cfg_edge_stmt_stmts_nil_5(delta);
            self.cfg_edge_stmt_stmts_nil_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_stmts_nil_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_stmts_nil_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CfgEdgeStmtStmts(tm0, tm1) in self.cfg_edge_stmt_stmts.iter_dirty() {
                self.cfg_edge_stmt_stmts_nil_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_stmts_nil_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtListNode) {
        for _ in [()] {
            self.cfg_edge_stmt_stmts_nil_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_stmts_nil_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtListNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilStmtListNode(_) in self.nil_stmt_list_node.iter_all_0(tm1) {
                self.cfg_edge_stmt_stmts_nil_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_stmts_nil_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilStmtListNode(tm1) in self.nil_stmt_list_node.iter_dirty() {
                #[allow(unused_variables)]
                for CfgEdgeStmtStmts(tm0, _) in self.cfg_edge_stmt_stmts.iter_all_1(tm1) {
                    self.cfg_edge_stmt_stmts_nil_6(delta, tm0, tm1);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_stmts_nil_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtListNode) {
        for _ in [()] {
            self.cfg_edge_stmt_stmts_nil_7(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_stmts_nil_7(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtListNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CfgEdgeStmtsStmt(_, tm2) in self.cfg_edge_stmts_stmt.iter_all_0(tm1) {
                self.cfg_edge_stmt_stmts_nil_9(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_stmts_nil_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CfgEdgeStmtsStmt(tm1, tm2) in self.cfg_edge_stmts_stmt.iter_dirty() {
                #[allow(unused_variables)]
                for NilStmtListNode(_) in self.nil_stmt_list_node.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for CfgEdgeStmtStmts(tm0, _) in self.cfg_edge_stmt_stmts.iter_all_1(tm1) {
                        self.cfg_edge_stmt_stmts_nil_9(delta, tm0, tm1, tm2);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_stmts_nil_9(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: StmtListNode,
        tm2: StmtNode,
    ) {
        for _ in [()] {
            let exists_already = self.cfg_edge.iter_all_0_1(tm0, tm2).next().is_some();
            if !exists_already {
                delta.new_cfg_edge.push(CfgEdge(tm0, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_fork_cons_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.cfg_edge_fork_cons_1(delta);
            self.cfg_edge_fork_cons_2(delta);
            self.cfg_edge_fork_cons_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_fork_cons_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cfg_edge_fork_cons_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CfgEdgeFork(tm0, tm1) in self.cfg_edge_fork.iter_dirty() {
                self.cfg_edge_fork_cons_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_fork_cons_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode) {
        for _ in [()] {
            self.cfg_edge_fork_cons_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_fork_cons_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtBlockListNode(_, tm2, tm3) in self.cons_stmt_block_list_node.iter_all_0(tm1)
            {
                self.cfg_edge_fork_cons_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_fork_cons_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtBlockListNode(tm1, tm2, tm3) in self.cons_stmt_block_list_node.iter_dirty()
            {
                #[allow(unused_variables)]
                for CfgEdgeFork(tm0, _) in self.cfg_edge_fork.iter_all_1(tm1) {
                    self.cfg_edge_fork_cons_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_fork_cons_6(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: StmtBlockListNode,
        tm2: StmtListNode,
        tm3: StmtBlockListNode,
    ) {
        for _ in [()] {
            let exists_already = self.cfg_edge_fork.iter_all_0_1(tm0, tm3).next().is_some();
            if !exists_already {
                delta.new_cfg_edge_fork.push(CfgEdgeFork(tm0, tm3));
            }

            let exists_already = self
                .cfg_edge_stmt_stmts
                .iter_all_0_1(tm0, tm2)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_cfg_edge_stmt_stmts
                    .push(CfgEdgeStmtStmts(tm0, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_join_cons_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.cfg_edge_join_cons_1(delta);
            self.cfg_edge_join_cons_2(delta);
            self.cfg_edge_join_cons_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_join_cons_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cfg_edge_join_cons_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CfgEdgeJoin(tm0, tm1) in self.cfg_edge_join.iter_dirty() {
                self.cfg_edge_join_cons_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_join_cons_3(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: StmtNode) {
        for _ in [()] {
            self.cfg_edge_join_cons_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_join_cons_4(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: StmtNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtBlockListNode(_, tm2, tm3) in self.cons_stmt_block_list_node.iter_all_0(tm0)
            {
                self.cfg_edge_join_cons_6(delta, tm1, tm0, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_join_cons_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtBlockListNode(tm0, tm2, tm3) in self.cons_stmt_block_list_node.iter_dirty()
            {
                #[allow(unused_variables)]
                for CfgEdgeJoin(_, tm1) in self.cfg_edge_join.iter_all_0(tm0) {
                    self.cfg_edge_join_cons_6(delta, tm1, tm0, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_join_cons_6(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtNode,
        tm0: StmtBlockListNode,
        tm2: StmtListNode,
        tm3: StmtBlockListNode,
    ) {
        for _ in [()] {
            let exists_already = self.cfg_edge_join.iter_all_0_1(tm3, tm1).next().is_some();
            if !exists_already {
                delta.new_cfg_edge_join.push(CfgEdgeJoin(tm3, tm1));
            }

            let exists_already = self
                .cfg_edge_stmts_stmt
                .iter_all_0_1(tm2, tm1)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_cfg_edge_stmts_stmt
                    .push(CfgEdgeStmtsStmt(tm2, tm1));
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_if_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.cfg_edge_if_1(delta);
            self.cfg_edge_if_2(delta);
            self.cfg_edge_if_5(delta);
            self.cfg_edge_if_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_if_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cfg_edge_if_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm0, tm1, tm2) in self.cons_stmt_list_node.iter_dirty() {
                self.cfg_edge_if_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_if_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtListNode,
        tm1: StmtNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            self.cfg_edge_if_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_if_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtListNode,
        tm1: StmtNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfStmtNode(_, tm3) in self.if_stmt_node.iter_all_0(tm1) {
                self.cfg_edge_if_6(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_if_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfStmtNode(tm1, tm3) in self.if_stmt_node.iter_dirty() {
                #[allow(unused_variables)]
                for ConsStmtListNode(tm0, _, tm2) in self.cons_stmt_list_node.iter_all_1(tm1) {
                    self.cfg_edge_if_6(delta, tm0, tm2, tm1, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_if_6(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtListNode,
        tm2: StmtListNode,
        tm1: StmtNode,
        tm3: IfAtomNode,
    ) {
        for _ in [()] {
            self.cfg_edge_if_7(delta, tm0, tm2, tm1, tm3);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_if_7(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtListNode,
        tm2: StmtListNode,
        tm1: StmtNode,
        tm3: IfAtomNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(_, tm4, tm5) in self.cons_stmt_list_node.iter_all_0(tm2) {
                self.cfg_edge_if_9(delta, tm0, tm1, tm3, tm2, tm4, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_if_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm2, tm4, tm5) in self.cons_stmt_list_node.iter_dirty() {
                #[allow(unused_variables)]
                for ConsStmtListNode(tm0, tm1, _) in self.cons_stmt_list_node.iter_all_2(tm2) {
                    #[allow(unused_variables)]
                    for IfStmtNode(_, tm3) in self.if_stmt_node.iter_all_0(tm1) {
                        self.cfg_edge_if_9(delta, tm0, tm1, tm3, tm2, tm4, tm5);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_if_9(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtListNode,
        tm1: StmtNode,
        tm3: IfAtomNode,
        tm2: StmtListNode,
        tm4: StmtNode,
        tm5: StmtListNode,
    ) {
        for _ in [()] {
            let exists_already = self.cfg_edge.iter_all_0_1(tm1, tm4).next().is_some();
            if !exists_already {
                delta.new_cfg_edge.push(CfgEdge(tm1, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_then_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.cfg_edge_then_1(delta);
            self.cfg_edge_then_2(delta);
            self.cfg_edge_then_5(delta);
            self.cfg_edge_then_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_then_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cfg_edge_then_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm0, tm1, tm2) in self.cons_stmt_list_node.iter_dirty() {
                self.cfg_edge_then_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_then_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtListNode,
        tm1: StmtNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            self.cfg_edge_then_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_then_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtListNode,
        tm1: StmtNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm1) {
                self.cfg_edge_then_6(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_then_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenStmtNode(tm1, tm3) in self.then_stmt_node.iter_dirty() {
                #[allow(unused_variables)]
                for ConsStmtListNode(tm0, _, tm2) in self.cons_stmt_list_node.iter_all_1(tm1) {
                    self.cfg_edge_then_6(delta, tm0, tm2, tm1, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_then_6(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtListNode,
        tm2: StmtListNode,
        tm1: StmtNode,
        tm3: ThenAtomNode,
    ) {
        for _ in [()] {
            self.cfg_edge_then_7(delta, tm0, tm2, tm1, tm3);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_then_7(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtListNode,
        tm2: StmtListNode,
        tm1: StmtNode,
        tm3: ThenAtomNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(_, tm4, tm5) in self.cons_stmt_list_node.iter_all_0(tm2) {
                self.cfg_edge_then_9(delta, tm0, tm1, tm3, tm2, tm4, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_then_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm2, tm4, tm5) in self.cons_stmt_list_node.iter_dirty() {
                #[allow(unused_variables)]
                for ConsStmtListNode(tm0, tm1, _) in self.cons_stmt_list_node.iter_all_2(tm2) {
                    #[allow(unused_variables)]
                    for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm1) {
                        self.cfg_edge_then_9(delta, tm0, tm1, tm3, tm2, tm4, tm5);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_then_9(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtListNode,
        tm1: StmtNode,
        tm3: ThenAtomNode,
        tm2: StmtListNode,
        tm4: StmtNode,
        tm5: StmtListNode,
    ) {
        for _ in [()] {
            let exists_already = self.cfg_edge.iter_all_0_1(tm1, tm4).next().is_some();
            if !exists_already {
                delta.new_cfg_edge.push(CfgEdge(tm1, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_branch_fork_blocks_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.cfg_edge_branch_fork_blocks_1(delta);
            self.cfg_edge_branch_fork_blocks_2(delta);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_branch_fork_blocks_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cfg_edge_branch_fork_blocks_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BranchStmtNode(tm0, tm1) in self.branch_stmt_node.iter_dirty() {
                self.cfg_edge_branch_fork_blocks_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_branch_fork_blocks_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: StmtBlockListNode,
    ) {
        for _ in [()] {
            let exists_already = self.cfg_edge_fork.iter_all_0_1(tm0, tm1).next().is_some();
            if !exists_already {
                delta.new_cfg_edge_fork.push(CfgEdgeFork(tm0, tm1));
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_fork_blocks_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.cfg_edge_match_fork_blocks_1(delta);
            self.cfg_edge_match_fork_blocks_2(delta);
            self.cfg_edge_match_fork_blocks_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_fork_blocks_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_fork_blocks_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchStmtNode(tm0, tm1, tm2) in self.match_stmt_node.iter_dirty() {
                self.cfg_edge_match_fork_blocks_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_fork_blocks_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            self.cfg_edge_match_fork_blocks_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_fork_blocks_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseBlockList(_, tm3) in self.desugared_case_block_list.iter_all_0(tm2) {
                self.cfg_edge_match_fork_blocks_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_fork_blocks_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseBlockList(tm2, tm3) in self.desugared_case_block_list.iter_dirty() {
                #[allow(unused_variables)]
                for MatchStmtNode(tm0, tm1, _) in self.match_stmt_node.iter_all_2(tm2) {
                    self.cfg_edge_match_fork_blocks_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_fork_blocks_6(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm3: StmtBlockListNode,
    ) {
        for _ in [()] {
            let exists_already = self.cfg_edge_fork.iter_all_0_1(tm0, tm3).next().is_some();
            if !exists_already {
                delta.new_cfg_edge_fork.push(CfgEdgeFork(tm0, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_branch_join_blocks_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.cfg_edge_branch_join_blocks_1(delta);
            self.cfg_edge_branch_join_blocks_2(delta);
            self.cfg_edge_branch_join_blocks_5(delta);
            self.cfg_edge_branch_join_blocks_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_branch_join_blocks_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cfg_edge_branch_join_blocks_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BranchStmtNode(tm0, tm1) in self.branch_stmt_node.iter_dirty() {
                self.cfg_edge_branch_join_blocks_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_branch_join_blocks_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: StmtBlockListNode,
    ) {
        for _ in [()] {
            self.cfg_edge_branch_join_blocks_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_branch_join_blocks_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: StmtBlockListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm2, _, tm3) in self.cons_stmt_list_node.iter_all_1(tm0) {
                self.cfg_edge_branch_join_blocks_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_branch_join_blocks_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm2, tm0, tm3) in self.cons_stmt_list_node.iter_dirty() {
                #[allow(unused_variables)]
                for BranchStmtNode(_, tm1) in self.branch_stmt_node.iter_all_0(tm0) {
                    self.cfg_edge_branch_join_blocks_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_branch_join_blocks_6(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtBlockListNode,
        tm2: StmtListNode,
        tm0: StmtNode,
        tm3: StmtListNode,
    ) {
        for _ in [()] {
            self.cfg_edge_branch_join_blocks_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_branch_join_blocks_7(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtBlockListNode,
        tm2: StmtListNode,
        tm0: StmtNode,
        tm3: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(_, tm4, tm5) in self.cons_stmt_list_node.iter_all_0(tm3) {
                self.cfg_edge_branch_join_blocks_9(delta, tm1, tm2, tm0, tm3, tm4, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_branch_join_blocks_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm3, tm4, tm5) in self.cons_stmt_list_node.iter_dirty() {
                #[allow(unused_variables)]
                for ConsStmtListNode(tm2, tm0, _) in self.cons_stmt_list_node.iter_all_2(tm3) {
                    #[allow(unused_variables)]
                    for BranchStmtNode(_, tm1) in self.branch_stmt_node.iter_all_0(tm0) {
                        self.cfg_edge_branch_join_blocks_9(delta, tm1, tm2, tm0, tm3, tm4, tm5);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_branch_join_blocks_9(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtBlockListNode,
        tm2: StmtListNode,
        tm0: StmtNode,
        tm3: StmtListNode,
        tm4: StmtNode,
        tm5: StmtListNode,
    ) {
        for _ in [()] {
            let exists_already = self.cfg_edge_join.iter_all_0_1(tm1, tm4).next().is_some();
            if !exists_already {
                delta.new_cfg_edge_join.push(CfgEdgeJoin(tm1, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_join_blocks_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.cfg_edge_match_join_blocks_1(delta);
            self.cfg_edge_match_join_blocks_2(delta);
            self.cfg_edge_match_join_blocks_5(delta);
            self.cfg_edge_match_join_blocks_8(delta);
            self.cfg_edge_match_join_blocks_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_join_blocks_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_join_blocks_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchStmtNode(tm0, tm1, tm2) in self.match_stmt_node.iter_dirty() {
                self.cfg_edge_match_join_blocks_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_join_blocks_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            self.cfg_edge_match_join_blocks_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_join_blocks_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm3, _, tm4) in self.cons_stmt_list_node.iter_all_1(tm0) {
                self.cfg_edge_match_join_blocks_6(delta, tm1, tm2, tm3, tm0, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_join_blocks_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm3, tm0, tm4) in self.cons_stmt_list_node.iter_dirty() {
                #[allow(unused_variables)]
                for MatchStmtNode(_, tm1, tm2) in self.match_stmt_node.iter_all_0(tm0) {
                    self.cfg_edge_match_join_blocks_6(delta, tm1, tm2, tm3, tm0, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_join_blocks_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm3: StmtListNode,
        tm0: StmtNode,
        tm4: StmtListNode,
    ) {
        for _ in [()] {
            self.cfg_edge_match_join_blocks_7(delta, tm1, tm2, tm3, tm0, tm4);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_join_blocks_7(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm3: StmtListNode,
        tm0: StmtNode,
        tm4: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(_, tm5, tm6) in self.cons_stmt_list_node.iter_all_0(tm4) {
                self.cfg_edge_match_join_blocks_9(delta, tm1, tm2, tm3, tm0, tm4, tm5, tm6);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_join_blocks_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm4, tm5, tm6) in self.cons_stmt_list_node.iter_dirty() {
                #[allow(unused_variables)]
                for ConsStmtListNode(tm3, tm0, _) in self.cons_stmt_list_node.iter_all_2(tm4) {
                    #[allow(unused_variables)]
                    for MatchStmtNode(_, tm1, tm2) in self.match_stmt_node.iter_all_0(tm0) {
                        self.cfg_edge_match_join_blocks_9(delta, tm1, tm2, tm3, tm0, tm4, tm5, tm6);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_join_blocks_9(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm3: StmtListNode,
        tm0: StmtNode,
        tm4: StmtListNode,
        tm5: StmtNode,
        tm6: StmtListNode,
    ) {
        for _ in [()] {
            self.cfg_edge_match_join_blocks_10(delta, tm1, tm2, tm3, tm0, tm4, tm5, tm6);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_join_blocks_10(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm3: StmtListNode,
        tm0: StmtNode,
        tm4: StmtListNode,
        tm5: StmtNode,
        tm6: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseBlockList(_, tm7) in self.desugared_case_block_list.iter_all_0(tm2) {
                self.cfg_edge_match_join_blocks_12(delta, tm1, tm3, tm0, tm4, tm5, tm6, tm2, tm7);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_join_blocks_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DesugaredCaseBlockList(tm2, tm7) in self.desugared_case_block_list.iter_dirty() {
                #[allow(unused_variables)]
                for MatchStmtNode(tm0, tm1, _) in self.match_stmt_node.iter_all_2(tm2) {
                    #[allow(unused_variables)]
                    for ConsStmtListNode(tm3, _, tm4) in self.cons_stmt_list_node.iter_all_1(tm0) {
                        #[allow(unused_variables)]
                        for ConsStmtListNode(_, tm5, tm6) in
                            self.cons_stmt_list_node.iter_all_0(tm4)
                        {
                            self.cfg_edge_match_join_blocks_12(
                                delta, tm1, tm3, tm0, tm4, tm5, tm6, tm2, tm7,
                            );
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_match_join_blocks_12(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm3: StmtListNode,
        tm0: StmtNode,
        tm4: StmtListNode,
        tm5: StmtNode,
        tm6: StmtListNode,
        tm2: MatchCaseListNode,
        tm7: StmtBlockListNode,
    ) {
        for _ in [()] {
            let exists_already = self.cfg_edge_join.iter_all_0_1(tm7, tm5).next().is_some();
            if !exists_already {
                delta.new_cfg_edge_join.push(CfgEdgeJoin(tm7, tm5));
            }
        }
    }

    #[allow(unused_variables)]
    fn before_rule_structure_total_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.before_rule_structure_total_1(delta);
            self.before_rule_structure_total_2(delta);
            self.before_rule_structure_total_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn before_rule_structure_total_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn before_rule_structure_total_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.rule_decl_node_dirty.iter().copied() {
                self.before_rule_structure_total_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn before_rule_structure_total_3(&self, delta: &mut ModelDelta, tm0: RuleDeclNode) {
        for _ in [()] {
            self.before_rule_structure_total_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn before_rule_structure_total_4(&self, delta: &mut ModelDelta, tm0: RuleDeclNode) {
        for _ in [()] {
            let tm1 = match self.before_rule_structure.iter_all_0(tm0).next() {
                Some(BeforeRuleStructure(_, res)) => res,
                None => {
                    delta
                        .new_before_rule_structure_def
                        .push(BeforeRuleStructureArgs(tm0));
                    break;
                }
            };

            self.before_rule_structure_total_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn before_rule_structure_total_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BeforeRuleStructure(tm0, tm1) in self.before_rule_structure.iter_dirty() {
                self.before_rule_structure_total_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn before_rule_structure_total_6(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDeclNode,
        tm1: Structure,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn before_first_rule_stmt_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.before_first_rule_stmt_1(delta);
            self.before_first_rule_stmt_2(delta);
            self.before_first_rule_stmt_5(delta);
            self.before_first_rule_stmt_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn before_first_rule_stmt_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn before_first_rule_stmt_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDecl(tm0, tm1) in self.rule_decl.iter_dirty() {
                self.before_first_rule_stmt_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn before_first_rule_stmt_3(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDeclNode,
        tm1: StmtListNode,
    ) {
        for _ in [()] {
            self.before_first_rule_stmt_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn before_first_rule_stmt_4(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDeclNode,
        tm1: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(_, tm2, tm3) in self.cons_stmt_list_node.iter_all_0(tm1) {
                self.before_first_rule_stmt_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn before_first_rule_stmt_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm1, tm2, tm3) in self.cons_stmt_list_node.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDecl(tm0, _) in self.rule_decl.iter_all_1(tm1) {
                    self.before_first_rule_stmt_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn before_first_rule_stmt_6(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDeclNode,
        tm1: StmtListNode,
        tm2: StmtNode,
        tm3: StmtListNode,
    ) {
        for _ in [()] {
            self.before_first_rule_stmt_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn before_first_rule_stmt_7(
        &self,
        delta: &mut ModelDelta,
        tm0: RuleDeclNode,
        tm1: StmtListNode,
        tm2: StmtNode,
        tm3: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BeforeRuleStructure(_, tm4) in self.before_rule_structure.iter_all_0(tm0) {
                self.before_first_rule_stmt_9(delta, tm1, tm2, tm3, tm0, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn before_first_rule_stmt_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BeforeRuleStructure(tm0, tm4) in self.before_rule_structure.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDecl(_, tm1) in self.rule_decl.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for ConsStmtListNode(_, tm2, tm3) in self.cons_stmt_list_node.iter_all_0(tm1) {
                        self.before_first_rule_stmt_9(delta, tm1, tm2, tm3, tm0, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn before_first_rule_stmt_9(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtListNode,
        tm2: StmtNode,
        tm3: StmtListNode,
        tm0: RuleDeclNode,
        tm4: Structure,
    ) {
        for _ in [()] {
            let exists_already = self
                .before_stmt_structure
                .iter_all_0_1(tm2, tm4)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_before_stmt_structure
                    .push(BeforeStmtStructure(tm2, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.cfg_edge_stmt_structure_1(delta);
            self.cfg_edge_stmt_structure_2(delta);
            self.cfg_edge_stmt_structure_5(delta);
            self.cfg_edge_stmt_structure_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CfgEdge(tm0, tm1) in self.cfg_edge.iter_dirty() {
                self.cfg_edge_stmt_structure_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_structure_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtNode) {
        for _ in [()] {
            self.cfg_edge_stmt_structure_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_structure_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtMorphism(_, tm2) in self.stmt_morphism.iter_all_0(tm0) {
                self.cfg_edge_stmt_structure_6(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_structure_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtMorphism(tm0, tm2) in self.stmt_morphism.iter_dirty() {
                #[allow(unused_variables)]
                for CfgEdge(_, tm1) in self.cfg_edge.iter_all_0(tm0) {
                    self.cfg_edge_stmt_structure_6(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_structure_6(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtNode,
        tm0: StmtNode,
        tm2: Morphism,
    ) {
        for _ in [()] {
            self.cfg_edge_stmt_structure_7(delta, tm1, tm0, tm2);
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_structure_7(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtNode,
        tm0: StmtNode,
        tm2: Morphism,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Cod(_, tm3) in self.cod.iter_all_0(tm2) {
                self.cfg_edge_stmt_structure_9(delta, tm1, tm0, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_structure_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Cod(tm2, tm3) in self.cod.iter_dirty() {
                #[allow(unused_variables)]
                for StmtMorphism(tm0, _) in self.stmt_morphism.iter_all_1(tm2) {
                    #[allow(unused_variables)]
                    for CfgEdge(_, tm1) in self.cfg_edge.iter_all_0(tm0) {
                        self.cfg_edge_stmt_structure_9(delta, tm1, tm0, tm2, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cfg_edge_stmt_structure_9(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtNode,
        tm0: StmtNode,
        tm2: Morphism,
        tm3: Structure,
    ) {
        for _ in [()] {
            let exists_already = self
                .before_stmt_structure
                .iter_all_0_1(tm1, tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_before_stmt_structure
                    .push(BeforeStmtStructure(tm1, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn if_atom_morphism_dom_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.if_atom_morphism_dom_1(delta);
            self.if_atom_morphism_dom_2(delta);
            self.if_atom_morphism_dom_3(delta);
        }
    }

    #[allow(unused_variables)]
    fn if_atom_morphism_dom_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn if_atom_morphism_dom_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Dom(tm2, tm3) in self.dom.iter_dirty() {
                #[allow(unused_variables)]
                for IfAtomMorphism(tm0, tm1, _) in self.if_atom_morphism.iter_all_2(tm2) {
                    self.if_atom_morphism_dom_4(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn if_atom_morphism_dom_3(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfAtomMorphism(tm0, tm1, tm2) in self.if_atom_morphism.iter_dirty() {
                #[allow(unused_variables)]
                for Dom(_, tm3) in self.dom.iter_all_0(tm2) {
                    self.if_atom_morphism_dom_4(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn if_atom_morphism_dom_4(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: Structure,
        tm2: Morphism,
        tm3: Structure,
    ) {
        for _ in [()] {
            delta.new_structure_equalities.push((tm1, tm3));

            delta.new_structure_equalities.push((tm3, tm1));
        }
    }

    #[allow(unused_variables)]
    fn then_atom_morphism_dom_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.then_atom_morphism_dom_1(delta);
            self.then_atom_morphism_dom_2(delta);
            self.then_atom_morphism_dom_3(delta);
        }
    }

    #[allow(unused_variables)]
    fn then_atom_morphism_dom_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn then_atom_morphism_dom_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Dom(tm2, tm3) in self.dom.iter_dirty() {
                #[allow(unused_variables)]
                for ThenAtomMorphism(tm0, tm1, _) in self.then_atom_morphism.iter_all_2(tm2) {
                    self.then_atom_morphism_dom_4(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn then_atom_morphism_dom_3(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenAtomMorphism(tm0, tm1, tm2) in self.then_atom_morphism.iter_dirty() {
                #[allow(unused_variables)]
                for Dom(_, tm3) in self.dom.iter_all_0(tm2) {
                    self.then_atom_morphism_dom_4(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn then_atom_morphism_dom_4(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: Structure,
        tm2: Morphism,
        tm3: Structure,
    ) {
        for _ in [()] {
            delta.new_structure_equalities.push((tm1, tm3));

            delta.new_structure_equalities.push((tm3, tm1));
        }
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_dom_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.branch_stmt_morphism_dom_1(delta);
            self.branch_stmt_morphism_dom_2(delta);
            self.branch_stmt_morphism_dom_3(delta);
        }
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_dom_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_dom_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Dom(tm2, tm3) in self.dom.iter_dirty() {
                #[allow(unused_variables)]
                for BranchStmtMorphism(tm0, tm1, _) in self.branch_stmt_morphism.iter_all_2(tm2) {
                    self.branch_stmt_morphism_dom_4(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_dom_3(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BranchStmtMorphism(tm0, tm1, tm2) in self.branch_stmt_morphism.iter_dirty() {
                #[allow(unused_variables)]
                for Dom(_, tm3) in self.dom.iter_all_0(tm2) {
                    self.branch_stmt_morphism_dom_4(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_dom_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: Structure,
        tm2: Morphism,
        tm3: Structure,
    ) {
        for _ in [()] {
            delta.new_structure_equalities.push((tm1, tm3));

            delta.new_structure_equalities.push((tm3, tm1));
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_dom_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.match_stmt_morphism_dom_1(delta);
            self.match_stmt_morphism_dom_2(delta);
            self.match_stmt_morphism_dom_3(delta);
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_dom_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_dom_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Dom(tm2, tm3) in self.dom.iter_dirty() {
                #[allow(unused_variables)]
                for MatchStmtMorphism(tm0, tm1, _) in self.match_stmt_morphism.iter_all_2(tm2) {
                    self.match_stmt_morphism_dom_4(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_dom_3(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchStmtMorphism(tm0, tm1, tm2) in self.match_stmt_morphism.iter_dirty() {
                #[allow(unused_variables)]
                for Dom(_, tm3) in self.dom.iter_all_0(tm2) {
                    self.match_stmt_morphism_dom_4(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_dom_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: Structure,
        tm2: Morphism,
        tm3: Structure,
    ) {
        for _ in [()] {
            delta.new_structure_equalities.push((tm1, tm3));

            delta.new_structure_equalities.push((tm3, tm1));
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_morphism_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.if_stmt_morphism_defined_1(delta);
            self.if_stmt_morphism_defined_2(delta);
            self.if_stmt_morphism_defined_5(delta);
            self.if_stmt_morphism_defined_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_morphism_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn if_stmt_morphism_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfStmtNode(tm0, tm1) in self.if_stmt_node.iter_dirty() {
                self.if_stmt_morphism_defined_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_morphism_defined_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode) {
        for _ in [()] {
            self.if_stmt_morphism_defined_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_morphism_defined_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BeforeStmtStructure(_, tm2) in self.before_stmt_structure.iter_all_0(tm0) {
                self.if_stmt_morphism_defined_6(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_morphism_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BeforeStmtStructure(tm0, tm2) in self.before_stmt_structure.iter_dirty() {
                #[allow(unused_variables)]
                for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                    self.if_stmt_morphism_defined_6(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_morphism_defined_6(
        &self,
        delta: &mut ModelDelta,
        tm1: IfAtomNode,
        tm0: StmtNode,
        tm2: Structure,
    ) {
        for _ in [()] {
            self.if_stmt_morphism_defined_7(delta, tm1, tm0, tm2);
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_morphism_defined_7(
        &self,
        delta: &mut ModelDelta,
        tm1: IfAtomNode,
        tm0: StmtNode,
        tm2: Structure,
    ) {
        for _ in [()] {
            let tm3 = match self.if_atom_morphism.iter_all_0_1(tm1, tm2).next() {
                Some(IfAtomMorphism(_, _, res)) => res,
                None => {
                    delta
                        .new_if_atom_morphism_def
                        .push(IfAtomMorphismArgs(tm1, tm2));
                    break;
                }
            };

            self.if_stmt_morphism_defined_9(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_morphism_defined_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfAtomMorphism(tm1, tm2, tm3) in self.if_atom_morphism.iter_dirty() {
                #[allow(unused_variables)]
                for BeforeStmtStructure(tm0, _) in self.before_stmt_structure.iter_all_1(tm2) {
                    #[allow(unused_variables)]
                    for IfStmtNode(_, _) in self.if_stmt_node.iter_all_0_1(tm0, tm1) {
                        self.if_stmt_morphism_defined_9(delta, tm0, tm1, tm2, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_morphism_defined_9(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: IfAtomNode,
        tm2: Structure,
        tm3: Morphism,
    ) {
        for _ in [()] {
            let exists_already = self.stmt_morphism.iter_all_0_1(tm0, tm3).next().is_some();
            if !exists_already {
                delta.new_stmt_morphism.push(StmtMorphism(tm0, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn then_stmt_morphism_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.then_stmt_morphism_defined_1(delta);
            self.then_stmt_morphism_defined_2(delta);
            self.then_stmt_morphism_defined_5(delta);
            self.then_stmt_morphism_defined_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn then_stmt_morphism_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn then_stmt_morphism_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenStmtNode(tm0, tm1) in self.then_stmt_node.iter_dirty() {
                self.then_stmt_morphism_defined_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn then_stmt_morphism_defined_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: ThenAtomNode,
    ) {
        for _ in [()] {
            self.then_stmt_morphism_defined_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn then_stmt_morphism_defined_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: ThenAtomNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BeforeStmtStructure(_, tm2) in self.before_stmt_structure.iter_all_0(tm0) {
                self.then_stmt_morphism_defined_6(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn then_stmt_morphism_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BeforeStmtStructure(tm0, tm2) in self.before_stmt_structure.iter_dirty() {
                #[allow(unused_variables)]
                for ThenStmtNode(_, tm1) in self.then_stmt_node.iter_all_0(tm0) {
                    self.then_stmt_morphism_defined_6(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn then_stmt_morphism_defined_6(
        &self,
        delta: &mut ModelDelta,
        tm1: ThenAtomNode,
        tm0: StmtNode,
        tm2: Structure,
    ) {
        for _ in [()] {
            self.then_stmt_morphism_defined_7(delta, tm1, tm0, tm2);
        }
    }

    #[allow(unused_variables)]
    fn then_stmt_morphism_defined_7(
        &self,
        delta: &mut ModelDelta,
        tm1: ThenAtomNode,
        tm0: StmtNode,
        tm2: Structure,
    ) {
        for _ in [()] {
            let tm3 = match self.then_atom_morphism.iter_all_0_1(tm1, tm2).next() {
                Some(ThenAtomMorphism(_, _, res)) => res,
                None => {
                    delta
                        .new_then_atom_morphism_def
                        .push(ThenAtomMorphismArgs(tm1, tm2));
                    break;
                }
            };

            self.then_stmt_morphism_defined_9(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn then_stmt_morphism_defined_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenAtomMorphism(tm1, tm2, tm3) in self.then_atom_morphism.iter_dirty() {
                #[allow(unused_variables)]
                for BeforeStmtStructure(tm0, _) in self.before_stmt_structure.iter_all_1(tm2) {
                    #[allow(unused_variables)]
                    for ThenStmtNode(_, _) in self.then_stmt_node.iter_all_0_1(tm0, tm1) {
                        self.then_stmt_morphism_defined_9(delta, tm0, tm1, tm2, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn then_stmt_morphism_defined_9(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: ThenAtomNode,
        tm2: Structure,
        tm3: Morphism,
    ) {
        for _ in [()] {
            let exists_already = self.stmt_morphism.iter_all_0_1(tm0, tm3).next().is_some();
            if !exists_already {
                delta.new_stmt_morphism.push(StmtMorphism(tm0, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.branch_stmt_morphism_defined_1(delta);
            self.branch_stmt_morphism_defined_2(delta);
            self.branch_stmt_morphism_defined_5(delta);
            self.branch_stmt_morphism_defined_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BranchStmtNode(tm0, tm1) in self.branch_stmt_node.iter_dirty() {
                self.branch_stmt_morphism_defined_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_defined_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: StmtBlockListNode,
    ) {
        for _ in [()] {
            self.branch_stmt_morphism_defined_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_defined_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: StmtBlockListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BeforeStmtStructure(_, tm2) in self.before_stmt_structure.iter_all_0(tm0) {
                self.branch_stmt_morphism_defined_6(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BeforeStmtStructure(tm0, tm2) in self.before_stmt_structure.iter_dirty() {
                #[allow(unused_variables)]
                for BranchStmtNode(_, tm1) in self.branch_stmt_node.iter_all_0(tm0) {
                    self.branch_stmt_morphism_defined_6(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_defined_6(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtBlockListNode,
        tm0: StmtNode,
        tm2: Structure,
    ) {
        for _ in [()] {
            self.branch_stmt_morphism_defined_7(delta, tm1, tm0, tm2);
        }
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_defined_7(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtBlockListNode,
        tm0: StmtNode,
        tm2: Structure,
    ) {
        for _ in [()] {
            let tm3 = match self.branch_stmt_morphism.iter_all_0_1(tm0, tm2).next() {
                Some(BranchStmtMorphism(_, _, res)) => res,
                None => {
                    delta
                        .new_branch_stmt_morphism_def
                        .push(BranchStmtMorphismArgs(tm0, tm2));
                    break;
                }
            };

            self.branch_stmt_morphism_defined_9(delta, tm1, tm0, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_defined_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BranchStmtMorphism(tm0, tm2, tm3) in self.branch_stmt_morphism.iter_dirty() {
                #[allow(unused_variables)]
                for BeforeStmtStructure(_, _) in self.before_stmt_structure.iter_all_0_1(tm0, tm2) {
                    #[allow(unused_variables)]
                    for BranchStmtNode(_, tm1) in self.branch_stmt_node.iter_all_0(tm0) {
                        self.branch_stmt_morphism_defined_9(delta, tm1, tm0, tm2, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_defined_9(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtBlockListNode,
        tm0: StmtNode,
        tm2: Structure,
        tm3: Morphism,
    ) {
        for _ in [()] {
            let exists_already = self.stmt_morphism.iter_all_0_1(tm0, tm3).next().is_some();
            if !exists_already {
                delta.new_stmt_morphism.push(StmtMorphism(tm0, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.match_stmt_morphism_defined_1(delta);
            self.match_stmt_morphism_defined_2(delta);
            self.match_stmt_morphism_defined_5(delta);
            self.match_stmt_morphism_defined_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchStmtNode(tm0, tm1, tm2) in self.match_stmt_node.iter_dirty() {
                self.match_stmt_morphism_defined_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_defined_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            self.match_stmt_morphism_defined_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_defined_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BeforeStmtStructure(_, tm3) in self.before_stmt_structure.iter_all_0(tm0) {
                self.match_stmt_morphism_defined_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BeforeStmtStructure(tm0, tm3) in self.before_stmt_structure.iter_dirty() {
                #[allow(unused_variables)]
                for MatchStmtNode(_, tm1, tm2) in self.match_stmt_node.iter_all_0(tm0) {
                    self.match_stmt_morphism_defined_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_defined_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm0: StmtNode,
        tm3: Structure,
    ) {
        for _ in [()] {
            self.match_stmt_morphism_defined_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_defined_7(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm0: StmtNode,
        tm3: Structure,
    ) {
        for _ in [()] {
            let tm4 = match self.match_stmt_morphism.iter_all_0_1(tm0, tm3).next() {
                Some(MatchStmtMorphism(_, _, res)) => res,
                None => {
                    delta
                        .new_match_stmt_morphism_def
                        .push(MatchStmtMorphismArgs(tm0, tm3));
                    break;
                }
            };

            self.match_stmt_morphism_defined_9(delta, tm1, tm2, tm0, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_defined_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchStmtMorphism(tm0, tm3, tm4) in self.match_stmt_morphism.iter_dirty() {
                #[allow(unused_variables)]
                for BeforeStmtStructure(_, _) in self.before_stmt_structure.iter_all_0_1(tm0, tm3) {
                    #[allow(unused_variables)]
                    for MatchStmtNode(_, tm1, tm2) in self.match_stmt_node.iter_all_0(tm0) {
                        self.match_stmt_morphism_defined_9(delta, tm1, tm2, tm0, tm3, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_defined_9(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm0: StmtNode,
        tm3: Structure,
        tm4: Morphism,
    ) {
        for _ in [()] {
            let exists_already = self.stmt_morphism.iter_all_0_1(tm0, tm4).next().is_some();
            if !exists_already {
                delta.new_stmt_morphism.push(StmtMorphism(tm0, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_morphism_is_if_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.if_stmt_morphism_is_if_1(delta);
            self.if_stmt_morphism_is_if_2(delta);
            self.if_stmt_morphism_is_if_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_morphism_is_if_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn if_stmt_morphism_is_if_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfStmtNode(tm0, tm1) in self.if_stmt_node.iter_dirty() {
                self.if_stmt_morphism_is_if_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_morphism_is_if_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode) {
        for _ in [()] {
            self.if_stmt_morphism_is_if_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_morphism_is_if_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtMorphism(_, tm2) in self.stmt_morphism.iter_all_0(tm0) {
                self.if_stmt_morphism_is_if_6(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_morphism_is_if_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtMorphism(tm0, tm2) in self.stmt_morphism.iter_dirty() {
                #[allow(unused_variables)]
                for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                    self.if_stmt_morphism_is_if_6(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_morphism_is_if_6(
        &self,
        delta: &mut ModelDelta,
        tm1: IfAtomNode,
        tm0: StmtNode,
        tm2: Morphism,
    ) {
        for _ in [()] {
            let exists_already = self.if_morphism.iter_all_0(tm2).next().is_some();
            if !exists_already {
                delta.new_if_morphism.push(IfMorphism(tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn then_equal_stmt_morphism_is_surj_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.then_equal_stmt_morphism_is_surj_1(delta);
            self.then_equal_stmt_morphism_is_surj_2(delta);
            self.then_equal_stmt_morphism_is_surj_5(delta);
            self.then_equal_stmt_morphism_is_surj_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn then_equal_stmt_morphism_is_surj_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn then_equal_stmt_morphism_is_surj_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenStmtNode(tm0, tm1) in self.then_stmt_node.iter_dirty() {
                self.then_equal_stmt_morphism_is_surj_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn then_equal_stmt_morphism_is_surj_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: ThenAtomNode,
    ) {
        for _ in [()] {
            self.then_equal_stmt_morphism_is_surj_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn then_equal_stmt_morphism_is_surj_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: ThenAtomNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EqualThenAtomNode(_, tm2, tm3) in self.equal_then_atom_node.iter_all_0(tm1) {
                self.then_equal_stmt_morphism_is_surj_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn then_equal_stmt_morphism_is_surj_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EqualThenAtomNode(tm1, tm2, tm3) in self.equal_then_atom_node.iter_dirty() {
                #[allow(unused_variables)]
                for ThenStmtNode(tm0, _) in self.then_stmt_node.iter_all_1(tm1) {
                    self.then_equal_stmt_morphism_is_surj_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn then_equal_stmt_morphism_is_surj_6(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: ThenAtomNode,
        tm2: TermNode,
        tm3: TermNode,
    ) {
        for _ in [()] {
            self.then_equal_stmt_morphism_is_surj_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn then_equal_stmt_morphism_is_surj_7(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: ThenAtomNode,
        tm2: TermNode,
        tm3: TermNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtMorphism(_, tm4) in self.stmt_morphism.iter_all_0(tm0) {
                self.then_equal_stmt_morphism_is_surj_9(delta, tm1, tm2, tm3, tm0, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn then_equal_stmt_morphism_is_surj_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtMorphism(tm0, tm4) in self.stmt_morphism.iter_dirty() {
                #[allow(unused_variables)]
                for ThenStmtNode(_, tm1) in self.then_stmt_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for EqualThenAtomNode(_, tm2, tm3) in self.equal_then_atom_node.iter_all_0(tm1)
                    {
                        self.then_equal_stmt_morphism_is_surj_9(delta, tm1, tm2, tm3, tm0, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn then_equal_stmt_morphism_is_surj_9(
        &self,
        delta: &mut ModelDelta,
        tm1: ThenAtomNode,
        tm2: TermNode,
        tm3: TermNode,
        tm0: StmtNode,
        tm4: Morphism,
    ) {
        for _ in [()] {
            let exists_already = self.surj_then_morphism.iter_all_0(tm4).next().is_some();
            if !exists_already {
                delta.new_surj_then_morphism.push(SurjThenMorphism(tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn then_pred_stmt_morphism_is_surj_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.then_pred_stmt_morphism_is_surj_1(delta);
            self.then_pred_stmt_morphism_is_surj_2(delta);
            self.then_pred_stmt_morphism_is_surj_5(delta);
            self.then_pred_stmt_morphism_is_surj_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn then_pred_stmt_morphism_is_surj_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn then_pred_stmt_morphism_is_surj_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenStmtNode(tm0, tm1) in self.then_stmt_node.iter_dirty() {
                self.then_pred_stmt_morphism_is_surj_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn then_pred_stmt_morphism_is_surj_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: ThenAtomNode,
    ) {
        for _ in [()] {
            self.then_pred_stmt_morphism_is_surj_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn then_pred_stmt_morphism_is_surj_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: ThenAtomNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredThenAtomNode(_, tm2, tm3) in self.pred_then_atom_node.iter_all_0(tm1) {
                self.then_pred_stmt_morphism_is_surj_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn then_pred_stmt_morphism_is_surj_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredThenAtomNode(tm1, tm2, tm3) in self.pred_then_atom_node.iter_dirty() {
                #[allow(unused_variables)]
                for ThenStmtNode(tm0, _) in self.then_stmt_node.iter_all_1(tm1) {
                    self.then_pred_stmt_morphism_is_surj_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn then_pred_stmt_morphism_is_surj_6(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: ThenAtomNode,
        tm2: Ident,
        tm3: TermListNode,
    ) {
        for _ in [()] {
            self.then_pred_stmt_morphism_is_surj_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn then_pred_stmt_morphism_is_surj_7(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: ThenAtomNode,
        tm2: Ident,
        tm3: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtMorphism(_, tm4) in self.stmt_morphism.iter_all_0(tm0) {
                self.then_pred_stmt_morphism_is_surj_9(delta, tm1, tm2, tm3, tm0, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn then_pred_stmt_morphism_is_surj_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtMorphism(tm0, tm4) in self.stmt_morphism.iter_dirty() {
                #[allow(unused_variables)]
                for ThenStmtNode(_, tm1) in self.then_stmt_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for PredThenAtomNode(_, tm2, tm3) in self.pred_then_atom_node.iter_all_0(tm1) {
                        self.then_pred_stmt_morphism_is_surj_9(delta, tm1, tm2, tm3, tm0, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn then_pred_stmt_morphism_is_surj_9(
        &self,
        delta: &mut ModelDelta,
        tm1: ThenAtomNode,
        tm2: Ident,
        tm3: TermListNode,
        tm0: StmtNode,
        tm4: Morphism,
    ) {
        for _ in [()] {
            let exists_already = self.surj_then_morphism.iter_all_0(tm4).next().is_some();
            if !exists_already {
                delta.new_surj_then_morphism.push(SurjThenMorphism(tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn then_defined_stmt_morphism_is_non_surj_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.then_defined_stmt_morphism_is_non_surj_1(delta);
            self.then_defined_stmt_morphism_is_non_surj_2(delta);
            self.then_defined_stmt_morphism_is_non_surj_5(delta);
            self.then_defined_stmt_morphism_is_non_surj_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn then_defined_stmt_morphism_is_non_surj_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn then_defined_stmt_morphism_is_non_surj_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenStmtNode(tm0, tm1) in self.then_stmt_node.iter_dirty() {
                self.then_defined_stmt_morphism_is_non_surj_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn then_defined_stmt_morphism_is_non_surj_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: ThenAtomNode,
    ) {
        for _ in [()] {
            self.then_defined_stmt_morphism_is_non_surj_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn then_defined_stmt_morphism_is_non_surj_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: ThenAtomNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DefinedThenAtomNode(_, tm2, tm3) in self.defined_then_atom_node.iter_all_0(tm1) {
                self.then_defined_stmt_morphism_is_non_surj_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn then_defined_stmt_morphism_is_non_surj_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DefinedThenAtomNode(tm1, tm2, tm3) in self.defined_then_atom_node.iter_dirty() {
                #[allow(unused_variables)]
                for ThenStmtNode(tm0, _) in self.then_stmt_node.iter_all_1(tm1) {
                    self.then_defined_stmt_morphism_is_non_surj_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn then_defined_stmt_morphism_is_non_surj_6(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: ThenAtomNode,
        tm2: OptTermNode,
        tm3: TermNode,
    ) {
        for _ in [()] {
            self.then_defined_stmt_morphism_is_non_surj_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn then_defined_stmt_morphism_is_non_surj_7(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: ThenAtomNode,
        tm2: OptTermNode,
        tm3: TermNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtMorphism(_, tm4) in self.stmt_morphism.iter_all_0(tm0) {
                self.then_defined_stmt_morphism_is_non_surj_9(delta, tm1, tm2, tm3, tm0, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn then_defined_stmt_morphism_is_non_surj_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtMorphism(tm0, tm4) in self.stmt_morphism.iter_dirty() {
                #[allow(unused_variables)]
                for ThenStmtNode(_, tm1) in self.then_stmt_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for DefinedThenAtomNode(_, tm2, tm3) in
                        self.defined_then_atom_node.iter_all_0(tm1)
                    {
                        self.then_defined_stmt_morphism_is_non_surj_9(
                            delta, tm1, tm2, tm3, tm0, tm4,
                        );
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn then_defined_stmt_morphism_is_non_surj_9(
        &self,
        delta: &mut ModelDelta,
        tm1: ThenAtomNode,
        tm2: OptTermNode,
        tm3: TermNode,
        tm0: StmtNode,
        tm4: Morphism,
    ) {
        for _ in [()] {
            let exists_already = self.non_surj_then_morphism.iter_all_0(tm4).next().is_some();
            if !exists_already {
                delta
                    .new_non_surj_then_morphism
                    .push(NonSurjThenMorphism(tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_is_noop_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.branch_stmt_morphism_is_noop_1(delta);
            self.branch_stmt_morphism_is_noop_2(delta);
            self.branch_stmt_morphism_is_noop_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_is_noop_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_is_noop_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for BranchStmtNode(tm0, tm1) in self.branch_stmt_node.iter_dirty() {
                self.branch_stmt_morphism_is_noop_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_is_noop_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: StmtBlockListNode,
    ) {
        for _ in [()] {
            self.branch_stmt_morphism_is_noop_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_is_noop_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: StmtBlockListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtMorphism(_, tm2) in self.stmt_morphism.iter_all_0(tm0) {
                self.branch_stmt_morphism_is_noop_6(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_is_noop_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtMorphism(tm0, tm2) in self.stmt_morphism.iter_dirty() {
                #[allow(unused_variables)]
                for BranchStmtNode(_, tm1) in self.branch_stmt_node.iter_all_0(tm0) {
                    self.branch_stmt_morphism_is_noop_6(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn branch_stmt_morphism_is_noop_6(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtBlockListNode,
        tm0: StmtNode,
        tm2: Morphism,
    ) {
        for _ in [()] {
            let exists_already = self.noop_morphism.iter_all_0(tm2).next().is_some();
            if !exists_already {
                delta.new_noop_morphism.push(NoopMorphism(tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_is_if_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.match_stmt_morphism_is_if_1(delta);
            self.match_stmt_morphism_is_if_2(delta);
            self.match_stmt_morphism_is_if_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_is_if_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_is_if_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchStmtNode(tm0, tm1, tm2) in self.match_stmt_node.iter_dirty() {
                self.match_stmt_morphism_is_if_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_is_if_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            self.match_stmt_morphism_is_if_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_is_if_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtMorphism(_, tm3) in self.stmt_morphism.iter_all_0(tm0) {
                self.match_stmt_morphism_is_if_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_is_if_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtMorphism(tm0, tm3) in self.stmt_morphism.iter_dirty() {
                #[allow(unused_variables)]
                for MatchStmtNode(_, tm1, tm2) in self.match_stmt_node.iter_all_0(tm0) {
                    self.match_stmt_morphism_is_if_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_morphism_is_if_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm0: StmtNode,
        tm3: Morphism,
    ) {
        for _ in [()] {
            let exists_already = self.if_morphism.iter_all_0(tm3).next().is_some();
            if !exists_already {
                delta.new_if_morphism.push(IfMorphism(tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn stmt_structure_morphism_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.stmt_structure_morphism_1(delta);
            self.stmt_structure_morphism_2(delta);
            self.stmt_structure_morphism_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn stmt_structure_morphism_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn stmt_structure_morphism_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtMorphism(tm0, tm1) in self.stmt_morphism.iter_dirty() {
                self.stmt_structure_morphism_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn stmt_structure_morphism_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: Morphism) {
        for _ in [()] {
            self.stmt_structure_morphism_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn stmt_structure_morphism_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: Morphism) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Cod(_, tm2) in self.cod.iter_all_0(tm1) {
                self.stmt_structure_morphism_6(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn stmt_structure_morphism_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Cod(tm1, tm2) in self.cod.iter_dirty() {
                #[allow(unused_variables)]
                for StmtMorphism(tm0, _) in self.stmt_morphism.iter_all_1(tm1) {
                    self.stmt_structure_morphism_6(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn stmt_structure_morphism_6(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: Morphism,
        tm2: Structure,
    ) {
        for _ in [()] {
            let exists_already = self.stmt_structure.iter_all_0_1(tm0, tm2).next().is_some();
            if !exists_already {
                delta.new_stmt_structure.push(StmtStructure(tm0, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.if_stmt_structure_1(delta);
            self.if_stmt_structure_2(delta);
            self.if_stmt_structure_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn if_stmt_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfStmtNode(tm0, tm1) in self.if_stmt_node.iter_dirty() {
                self.if_stmt_structure_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_structure_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode) {
        for _ in [()] {
            self.if_stmt_structure_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_structure_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtStructure(_, tm2) in self.stmt_structure.iter_all_0(tm0) {
                self.if_stmt_structure_6(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_structure_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtStructure(tm0, tm2) in self.stmt_structure.iter_dirty() {
                #[allow(unused_variables)]
                for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                    self.if_stmt_structure_6(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn if_stmt_structure_6(
        &self,
        delta: &mut ModelDelta,
        tm1: IfAtomNode,
        tm0: StmtNode,
        tm2: Structure,
    ) {
        for _ in [()] {
            let exists_already = self
                .if_atom_structure
                .iter_all_0_1(tm1, tm2)
                .next()
                .is_some();
            if !exists_already {
                delta.new_if_atom_structure.push(IfAtomStructure(tm1, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn then_stmt_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.then_stmt_structure_1(delta);
            self.then_stmt_structure_2(delta);
            self.then_stmt_structure_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn then_stmt_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn then_stmt_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenStmtNode(tm0, tm1) in self.then_stmt_node.iter_dirty() {
                self.then_stmt_structure_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn then_stmt_structure_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode) {
        for _ in [()] {
            self.then_stmt_structure_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn then_stmt_structure_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtStructure(_, tm2) in self.stmt_structure.iter_all_0(tm0) {
                self.then_stmt_structure_6(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn then_stmt_structure_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtStructure(tm0, tm2) in self.stmt_structure.iter_dirty() {
                #[allow(unused_variables)]
                for ThenStmtNode(_, tm1) in self.then_stmt_node.iter_all_0(tm0) {
                    self.then_stmt_structure_6(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn then_stmt_structure_6(
        &self,
        delta: &mut ModelDelta,
        tm1: ThenAtomNode,
        tm0: StmtNode,
        tm2: Structure,
    ) {
        for _ in [()] {
            let exists_already = self
                .then_atom_structure
                .iter_all_0_1(tm1, tm2)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_then_atom_structure
                    .push(ThenAtomStructure(tm1, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.match_stmt_structure_1(delta);
            self.match_stmt_structure_2(delta);
            self.match_stmt_structure_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn match_stmt_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchStmtNode(tm0, tm1, tm2) in self.match_stmt_node.iter_dirty() {
                self.match_stmt_structure_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_structure_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            self.match_stmt_structure_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_structure_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtStructure(_, tm3) in self.stmt_structure.iter_all_0(tm0) {
                self.match_stmt_structure_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_structure_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for StmtStructure(tm0, tm3) in self.stmt_structure.iter_dirty() {
                #[allow(unused_variables)]
                for MatchStmtNode(_, tm1, tm2) in self.match_stmt_node.iter_all_0(tm0) {
                    self.match_stmt_structure_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_structure_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm0: StmtNode,
        tm3: Structure,
    ) {
        for _ in [()] {
            let exists_already = self.term_structure.iter_all_0_1(tm1, tm3).next().is_some();
            if !exists_already {
                delta.new_term_structure.push(TermStructure(tm1, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_if_atom_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.equal_if_atom_structure_1(delta);
            self.equal_if_atom_structure_2(delta);
            self.equal_if_atom_structure_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn equal_if_atom_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn equal_if_atom_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EqualIfAtomNode(tm0, tm1, tm2) in self.equal_if_atom_node.iter_dirty() {
                self.equal_if_atom_structure_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_if_atom_structure_3(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            self.equal_if_atom_structure_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn equal_if_atom_structure_4(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfAtomStructure(_, tm3) in self.if_atom_structure.iter_all_0(tm0) {
                self.equal_if_atom_structure_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_if_atom_structure_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfAtomStructure(tm0, tm3) in self.if_atom_structure.iter_dirty() {
                #[allow(unused_variables)]
                for EqualIfAtomNode(_, tm1, tm2) in self.equal_if_atom_node.iter_all_0(tm0) {
                    self.equal_if_atom_structure_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_if_atom_structure_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermNode,
        tm0: IfAtomNode,
        tm3: Structure,
    ) {
        for _ in [()] {
            let exists_already = self.term_structure.iter_all_0_1(tm1, tm3).next().is_some();
            if !exists_already {
                delta.new_term_structure.push(TermStructure(tm1, tm3));
            }

            let exists_already = self.term_structure.iter_all_0_1(tm2, tm3).next().is_some();
            if !exists_already {
                delta.new_term_structure.push(TermStructure(tm2, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_if_atom_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.defined_if_atom_structure_1(delta);
            self.defined_if_atom_structure_2(delta);
            self.defined_if_atom_structure_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn defined_if_atom_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn defined_if_atom_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DefinedIfAtomNode(tm0, tm1) in self.defined_if_atom_node.iter_dirty() {
                self.defined_if_atom_structure_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_if_atom_structure_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode) {
        for _ in [()] {
            self.defined_if_atom_structure_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn defined_if_atom_structure_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfAtomStructure(_, tm2) in self.if_atom_structure.iter_all_0(tm0) {
                self.defined_if_atom_structure_6(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_if_atom_structure_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfAtomStructure(tm0, tm2) in self.if_atom_structure.iter_dirty() {
                #[allow(unused_variables)]
                for DefinedIfAtomNode(_, tm1) in self.defined_if_atom_node.iter_all_0(tm0) {
                    self.defined_if_atom_structure_6(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_if_atom_structure_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm0: IfAtomNode,
        tm2: Structure,
    ) {
        for _ in [()] {
            let exists_already = self.term_structure.iter_all_0_1(tm1, tm2).next().is_some();
            if !exists_already {
                delta.new_term_structure.push(TermStructure(tm1, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.pred_if_atom_structure_1(delta);
            self.pred_if_atom_structure_2(delta);
            self.pred_if_atom_structure_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn pred_if_atom_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredIfAtomNode(tm0, tm1, tm2) in self.pred_if_atom_node.iter_dirty() {
                self.pred_if_atom_structure_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_structure_3(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.pred_if_atom_structure_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_structure_4(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfAtomStructure(_, tm3) in self.if_atom_structure.iter_all_0(tm0) {
                self.pred_if_atom_structure_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_structure_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfAtomStructure(tm0, tm3) in self.if_atom_structure.iter_dirty() {
                #[allow(unused_variables)]
                for PredIfAtomNode(_, tm1, tm2) in self.pred_if_atom_node.iter_all_0(tm0) {
                    self.pred_if_atom_structure_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_structure_6(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: TermListNode,
        tm0: IfAtomNode,
        tm3: Structure,
    ) {
        for _ in [()] {
            let exists_already = self.terms_structure.iter_all_0_1(tm2, tm3).next().is_some();
            if !exists_already {
                delta.new_terms_structure.push(TermsStructure(tm2, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn var_if_atom_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.var_if_atom_structure_1(delta);
            self.var_if_atom_structure_2(delta);
            self.var_if_atom_structure_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn var_if_atom_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn var_if_atom_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for VarIfAtomNode(tm0, tm1, tm2) in self.var_if_atom_node.iter_dirty() {
                self.var_if_atom_structure_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn var_if_atom_structure_3(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: Ident,
    ) {
        for _ in [()] {
            self.var_if_atom_structure_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn var_if_atom_structure_4(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: Ident,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfAtomStructure(_, tm3) in self.if_atom_structure.iter_all_0(tm0) {
                self.var_if_atom_structure_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn var_if_atom_structure_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IfAtomStructure(tm0, tm3) in self.if_atom_structure.iter_dirty() {
                #[allow(unused_variables)]
                for VarIfAtomNode(_, tm1, tm2) in self.var_if_atom_node.iter_all_0(tm0) {
                    self.var_if_atom_structure_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn var_if_atom_structure_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: Ident,
        tm0: IfAtomNode,
        tm3: Structure,
    ) {
        for _ in [()] {
            let exists_already = self.term_structure.iter_all_0_1(tm1, tm3).next().is_some();
            if !exists_already {
                delta.new_term_structure.push(TermStructure(tm1, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_then_atom_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.equal_then_atom_structure_1(delta);
            self.equal_then_atom_structure_2(delta);
            self.equal_then_atom_structure_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn equal_then_atom_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn equal_then_atom_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EqualThenAtomNode(tm0, tm1, tm2) in self.equal_then_atom_node.iter_dirty() {
                self.equal_then_atom_structure_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_then_atom_structure_3(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: TermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            self.equal_then_atom_structure_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn equal_then_atom_structure_4(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: TermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenAtomStructure(_, tm3) in self.then_atom_structure.iter_all_0(tm0) {
                self.equal_then_atom_structure_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_then_atom_structure_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenAtomStructure(tm0, tm3) in self.then_atom_structure.iter_dirty() {
                #[allow(unused_variables)]
                for EqualThenAtomNode(_, tm1, tm2) in self.equal_then_atom_node.iter_all_0(tm0) {
                    self.equal_then_atom_structure_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_then_atom_structure_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermNode,
        tm0: ThenAtomNode,
        tm3: Structure,
    ) {
        for _ in [()] {
            let exists_already = self.term_structure.iter_all_0_1(tm1, tm3).next().is_some();
            if !exists_already {
                delta.new_term_structure.push(TermStructure(tm1, tm3));
            }

            let exists_already = self.term_structure.iter_all_0_1(tm2, tm3).next().is_some();
            if !exists_already {
                delta.new_term_structure.push(TermStructure(tm2, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_atom_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.defined_then_atom_structure_1(delta);
            self.defined_then_atom_structure_2(delta);
            self.defined_then_atom_structure_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn defined_then_atom_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn defined_then_atom_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DefinedThenAtomNode(tm0, tm1, tm2) in self.defined_then_atom_node.iter_dirty() {
                self.defined_then_atom_structure_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_atom_structure_3(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: OptTermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            self.defined_then_atom_structure_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn defined_then_atom_structure_4(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: OptTermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenAtomStructure(_, tm3) in self.then_atom_structure.iter_all_0(tm0) {
                self.defined_then_atom_structure_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_atom_structure_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenAtomStructure(tm0, tm3) in self.then_atom_structure.iter_dirty() {
                #[allow(unused_variables)]
                for DefinedThenAtomNode(_, tm1, tm2) in self.defined_then_atom_node.iter_all_0(tm0)
                {
                    self.defined_then_atom_structure_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_atom_structure_6(
        &self,
        delta: &mut ModelDelta,
        tm1: OptTermNode,
        tm2: TermNode,
        tm0: ThenAtomNode,
        tm3: Structure,
    ) {
        for _ in [()] {
            let exists_already = self
                .opt_term_structure
                .iter_all_0_1(tm1, tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_opt_term_structure
                    .push(OptTermStructure(tm1, tm3));
            }

            let exists_already = self.term_structure.iter_all_0_1(tm2, tm3).next().is_some();
            if !exists_already {
                delta.new_term_structure.push(TermStructure(tm2, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.pred_then_atom_structure_1(delta);
            self.pred_then_atom_structure_2(delta);
            self.pred_then_atom_structure_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn pred_then_atom_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredThenAtomNode(tm0, tm1, tm2) in self.pred_then_atom_node.iter_dirty() {
                self.pred_then_atom_structure_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_structure_3(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.pred_then_atom_structure_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_structure_4(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenAtomStructure(_, tm3) in self.then_atom_structure.iter_all_0(tm0) {
                self.pred_then_atom_structure_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_structure_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ThenAtomStructure(tm0, tm3) in self.then_atom_structure.iter_dirty() {
                #[allow(unused_variables)]
                for PredThenAtomNode(_, tm1, tm2) in self.pred_then_atom_node.iter_all_0(tm0) {
                    self.pred_then_atom_structure_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_structure_6(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: TermListNode,
        tm0: ThenAtomNode,
        tm3: Structure,
    ) {
        for _ in [()] {
            let exists_already = self.terms_structure.iter_all_0_1(tm2, tm3).next().is_some();
            if !exists_already {
                delta.new_terms_structure.push(TermsStructure(tm2, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_term_list_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.cons_term_list_structure_1(delta);
            self.cons_term_list_structure_2(delta);
            self.cons_term_list_structure_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn cons_term_list_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn cons_term_list_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsTermListNode(tm0, tm1, tm2) in self.cons_term_list_node.iter_dirty() {
                self.cons_term_list_structure_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_term_list_structure_3(
        &self,
        delta: &mut ModelDelta,
        tm0: TermListNode,
        tm1: TermNode,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.cons_term_list_structure_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn cons_term_list_structure_4(
        &self,
        delta: &mut ModelDelta,
        tm0: TermListNode,
        tm1: TermNode,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermsStructure(_, tm3) in self.terms_structure.iter_all_0(tm0) {
                self.cons_term_list_structure_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_term_list_structure_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermsStructure(tm0, tm3) in self.terms_structure.iter_dirty() {
                #[allow(unused_variables)]
                for ConsTermListNode(_, tm1, tm2) in self.cons_term_list_node.iter_all_0(tm0) {
                    self.cons_term_list_structure_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn cons_term_list_structure_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermListNode,
        tm0: TermListNode,
        tm3: Structure,
    ) {
        for _ in [()] {
            let exists_already = self.term_structure.iter_all_0_1(tm1, tm3).next().is_some();
            if !exists_already {
                delta.new_term_structure.push(TermStructure(tm1, tm3));
            }

            let exists_already = self.terms_structure.iter_all_0_1(tm2, tm3).next().is_some();
            if !exists_already {
                delta.new_terms_structure.push(TermsStructure(tm2, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn some_opt_term_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.some_opt_term_structure_1(delta);
            self.some_opt_term_structure_2(delta);
            self.some_opt_term_structure_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn some_opt_term_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn some_opt_term_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SomeTermNode(tm0, tm1) in self.some_term_node.iter_dirty() {
                self.some_opt_term_structure_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn some_opt_term_structure_3(&self, delta: &mut ModelDelta, tm0: OptTermNode, tm1: TermNode) {
        for _ in [()] {
            self.some_opt_term_structure_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn some_opt_term_structure_4(&self, delta: &mut ModelDelta, tm0: OptTermNode, tm1: TermNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for OptTermStructure(_, tm2) in self.opt_term_structure.iter_all_0(tm0) {
                self.some_opt_term_structure_6(delta, tm1, tm0, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn some_opt_term_structure_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for OptTermStructure(tm0, tm2) in self.opt_term_structure.iter_dirty() {
                #[allow(unused_variables)]
                for SomeTermNode(_, tm1) in self.some_term_node.iter_all_0(tm0) {
                    self.some_opt_term_structure_6(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn some_opt_term_structure_6(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm0: OptTermNode,
        tm2: Structure,
    ) {
        for _ in [()] {
            let exists_already = self.term_structure.iter_all_0_1(tm1, tm2).next().is_some();
            if !exists_already {
                delta.new_term_structure.push(TermStructure(tm1, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_structure_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.app_term_structure_1(delta);
            self.app_term_structure_2(delta);
            self.app_term_structure_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn app_term_structure_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn app_term_structure_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for AppTermNode(tm0, tm1, tm2) in self.app_term_node.iter_dirty() {
                self.app_term_structure_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_structure_3(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.app_term_structure_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn app_term_structure_4(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermStructure(_, tm3) in self.term_structure.iter_all_0(tm0) {
                self.app_term_structure_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_structure_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermStructure(tm0, tm3) in self.term_structure.iter_dirty() {
                #[allow(unused_variables)]
                for AppTermNode(_, tm1, tm2) in self.app_term_node.iter_all_0(tm0) {
                    self.app_term_structure_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_structure_6(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: TermListNode,
        tm0: TermNode,
        tm3: Structure,
    ) {
        for _ in [()] {
            let exists_already = self.terms_structure.iter_all_0_1(tm2, tm3).next().is_some();
            if !exists_already {
                delta.new_terms_structure.push(TermsStructure(tm2, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_name_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.semantic_name_defined_1(delta);
            self.semantic_name_defined_2(delta);
            self.semantic_name_defined_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn semantic_name_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn semantic_name_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for VarInScope(tm0, tm1) in self.var_in_scope.iter_dirty() {
                self.semantic_name_defined_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_name_defined_3(&self, delta: &mut ModelDelta, tm0: VirtIdent, tm1: Scope) {
        for _ in [()] {
            self.semantic_name_defined_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn semantic_name_defined_4(&self, delta: &mut ModelDelta, tm0: VirtIdent, tm1: Scope) {
        for _ in [()] {
            let tm2 = match self.semantic_name.iter_all_0_1(tm0, tm1).next() {
                Some(SemanticName(_, _, res)) => res,
                None => {
                    delta.new_semantic_name_def.push(SemanticNameArgs(tm0, tm1));
                    break;
                }
            };

            self.semantic_name_defined_6(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn semantic_name_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticName(tm0, tm1, tm2) in self.semantic_name.iter_dirty() {
                #[allow(unused_variables)]
                for VarInScope(_, _) in self.var_in_scope.iter_all_0_1(tm0, tm1) {
                    self.semantic_name_defined_6(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_name_defined_6(
        &self,
        delta: &mut ModelDelta,
        tm0: VirtIdent,
        tm1: Scope,
        tm2: ElName,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn semantic_name_extension_scope_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.semantic_name_extension_scope_1(delta);
            self.semantic_name_extension_scope_2(delta);
            self.semantic_name_extension_scope_5(delta);
            self.semantic_name_extension_scope_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn semantic_name_extension_scope_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn semantic_name_extension_scope_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ScopeExtension(tm0, tm1) in self.scope_extension.iter_dirty() {
                self.semantic_name_extension_scope_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_name_extension_scope_3(&self, delta: &mut ModelDelta, tm0: Scope, tm1: Scope) {
        for _ in [()] {
            self.semantic_name_extension_scope_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn semantic_name_extension_scope_4(&self, delta: &mut ModelDelta, tm0: Scope, tm1: Scope) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticName(tm2, _, tm3) in self.semantic_name.iter_all_1(tm0) {
                self.semantic_name_extension_scope_6(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_name_extension_scope_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticName(tm2, tm0, tm3) in self.semantic_name.iter_dirty() {
                #[allow(unused_variables)]
                for ScopeExtension(_, tm1) in self.scope_extension.iter_all_0(tm0) {
                    self.semantic_name_extension_scope_6(delta, tm1, tm2, tm0, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_name_extension_scope_6(
        &self,
        delta: &mut ModelDelta,
        tm1: Scope,
        tm2: VirtIdent,
        tm0: Scope,
        tm3: ElName,
    ) {
        for _ in [()] {
            self.semantic_name_extension_scope_7(delta, tm1, tm2, tm0, tm3);
        }
    }

    #[allow(unused_variables)]
    fn semantic_name_extension_scope_7(
        &self,
        delta: &mut ModelDelta,
        tm1: Scope,
        tm2: VirtIdent,
        tm0: Scope,
        tm3: ElName,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticName(_, _, tm4) in self.semantic_name.iter_all_0_1(tm2, tm1) {
                self.semantic_name_extension_scope_9(delta, tm0, tm3, tm2, tm1, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_name_extension_scope_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticName(tm2, tm1, tm4) in self.semantic_name.iter_dirty() {
                #[allow(unused_variables)]
                for ScopeExtension(tm0, _) in self.scope_extension.iter_all_1(tm1) {
                    #[allow(unused_variables)]
                    for SemanticName(_, _, tm3) in self.semantic_name.iter_all_0_1(tm2, tm0) {
                        self.semantic_name_extension_scope_9(delta, tm0, tm3, tm2, tm1, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_name_extension_scope_9(
        &self,
        delta: &mut ModelDelta,
        tm0: Scope,
        tm3: ElName,
        tm2: VirtIdent,
        tm1: Scope,
        tm4: ElName,
    ) {
        for _ in [()] {
            delta.new_el_name_equalities.push((tm3, tm4));

            delta.new_el_name_equalities.push((tm4, tm3));
        }
    }

    #[allow(unused_variables)]
    fn semantic_el_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.semantic_el_defined_1(delta);
            self.semantic_el_defined_2(delta);
            self.semantic_el_defined_5(delta);
            self.semantic_el_defined_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn semantic_el_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn semantic_el_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for tm0 in self.term_node_dirty.iter().copied() {
                self.semantic_el_defined_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_el_defined_3(&self, delta: &mut ModelDelta, tm0: TermNode) {
        for _ in [()] {
            self.semantic_el_defined_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn semantic_el_defined_4(&self, delta: &mut ModelDelta, tm0: TermNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermStructure(_, tm1) in self.term_structure.iter_all_0(tm0) {
                self.semantic_el_defined_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_el_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermStructure(tm0, tm1) in self.term_structure.iter_dirty() {
                self.semantic_el_defined_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_el_defined_6(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Structure) {
        for _ in [()] {
            self.semantic_el_defined_7(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn semantic_el_defined_7(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Structure) {
        for _ in [()] {
            let tm2 = match self.semantic_el.iter_all_0_1(tm0, tm1).next() {
                Some(SemanticEl(_, _, res)) => res,
                None => {
                    delta.new_semantic_el_def.push(SemanticElArgs(tm0, tm1));
                    break;
                }
            };

            self.semantic_el_defined_9(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn semantic_el_defined_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(tm0, tm1, tm2) in self.semantic_el.iter_dirty() {
                #[allow(unused_variables)]
                for TermStructure(_, _) in self.term_structure.iter_all_0_1(tm0, tm1) {
                    self.semantic_el_defined_9(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_el_defined_9(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Structure,
        tm2: El,
    ) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn semantic_els_nil_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.semantic_els_nil_1(delta);
            self.semantic_els_nil_2(delta);
            self.semantic_els_nil_5(delta);
            self.semantic_els_nil_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_nil_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn semantic_els_nil_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilTermListNode(tm0) in self.nil_term_list_node.iter_dirty() {
                self.semantic_els_nil_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_nil_3(&self, delta: &mut ModelDelta, tm0: TermListNode) {
        for _ in [()] {
            self.semantic_els_nil_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_nil_4(&self, delta: &mut ModelDelta, tm0: TermListNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermsStructure(_, tm1) in self.terms_structure.iter_all_0(tm0) {
                self.semantic_els_nil_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_nil_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermsStructure(tm0, tm1) in self.terms_structure.iter_dirty() {
                #[allow(unused_variables)]
                for NilTermListNode(_) in self.nil_term_list_node.iter_all_0(tm0) {
                    self.semantic_els_nil_6(delta, tm0, tm1);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_nil_6(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: Structure) {
        for _ in [()] {
            self.semantic_els_nil_7(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_nil_7(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: Structure) {
        for _ in [()] {
            let tm2 = match self.nil_el_list.iter_all_0(tm1).next() {
                Some(NilElList(_, res)) => res,
                None => {
                    delta.new_nil_el_list_def.push(NilElListArgs(tm1));
                    break;
                }
            };

            self.semantic_els_nil_9(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_nil_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilElList(tm1, tm2) in self.nil_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for TermsStructure(tm0, _) in self.terms_structure.iter_all_1(tm1) {
                    #[allow(unused_variables)]
                    for NilTermListNode(_) in self.nil_term_list_node.iter_all_0(tm0) {
                        self.semantic_els_nil_9(delta, tm0, tm1, tm2);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_nil_9(
        &self,
        delta: &mut ModelDelta,
        tm0: TermListNode,
        tm1: Structure,
        tm2: ElList,
    ) {
        for _ in [()] {
            let exists_already = self
                .semantic_els
                .iter_all_0_1_2(tm0, tm1, tm2)
                .next()
                .is_some();
            if !exists_already {
                delta.new_semantic_els.push(SemanticEls(tm0, tm1, tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_cons_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.semantic_els_cons_1(delta);
            self.semantic_els_cons_2(delta);
            self.semantic_els_cons_5(delta);
            self.semantic_els_cons_8(delta);
            self.semantic_els_cons_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_cons_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn semantic_els_cons_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsTermListNode(tm0, tm1, tm2) in self.cons_term_list_node.iter_dirty() {
                self.semantic_els_cons_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_cons_3(
        &self,
        delta: &mut ModelDelta,
        tm0: TermListNode,
        tm1: TermNode,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.semantic_els_cons_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_cons_4(
        &self,
        delta: &mut ModelDelta,
        tm0: TermListNode,
        tm1: TermNode,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(_, tm3, tm4) in self.semantic_el.iter_all_0(tm1) {
                self.semantic_els_cons_6(delta, tm0, tm2, tm1, tm3, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_cons_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(tm1, tm3, tm4) in self.semantic_el.iter_dirty() {
                #[allow(unused_variables)]
                for ConsTermListNode(tm0, _, tm2) in self.cons_term_list_node.iter_all_1(tm1) {
                    self.semantic_els_cons_6(delta, tm0, tm2, tm1, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_cons_6(
        &self,
        delta: &mut ModelDelta,
        tm0: TermListNode,
        tm2: TermListNode,
        tm1: TermNode,
        tm3: Structure,
        tm4: El,
    ) {
        for _ in [()] {
            self.semantic_els_cons_7(delta, tm0, tm2, tm1, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_cons_7(
        &self,
        delta: &mut ModelDelta,
        tm0: TermListNode,
        tm2: TermListNode,
        tm1: TermNode,
        tm3: Structure,
        tm4: El,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEls(_, _, tm5) in self.semantic_els.iter_all_0_1(tm2, tm3) {
                self.semantic_els_cons_9(delta, tm0, tm1, tm4, tm2, tm3, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_cons_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEls(tm2, tm3, tm5) in self.semantic_els.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticEl(tm1, _, tm4) in self.semantic_el.iter_all_1(tm3) {
                    #[allow(unused_variables)]
                    for ConsTermListNode(tm0, _, _) in
                        self.cons_term_list_node.iter_all_1_2(tm1, tm2)
                    {
                        self.semantic_els_cons_9(delta, tm0, tm1, tm4, tm2, tm3, tm5);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_cons_9(
        &self,
        delta: &mut ModelDelta,
        tm0: TermListNode,
        tm1: TermNode,
        tm4: El,
        tm2: TermListNode,
        tm3: Structure,
        tm5: ElList,
    ) {
        for _ in [()] {
            self.semantic_els_cons_10(delta, tm0, tm1, tm4, tm2, tm3, tm5);
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_cons_10(
        &self,
        delta: &mut ModelDelta,
        tm0: TermListNode,
        tm1: TermNode,
        tm4: El,
        tm2: TermListNode,
        tm3: Structure,
        tm5: ElList,
    ) {
        for _ in [()] {
            let tm6 = match self.cons_el_list.iter_all_0_1(tm4, tm5).next() {
                Some(ConsElList(_, _, res)) => res,
                None => {
                    delta.new_cons_el_list_def.push(ConsElListArgs(tm4, tm5));
                    break;
                }
            };

            self.semantic_els_cons_12(delta, tm0, tm1, tm4, tm2, tm3, tm5, tm6);
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_cons_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsElList(tm4, tm5, tm6) in self.cons_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticEls(tm2, tm3, _) in self.semantic_els.iter_all_2(tm5) {
                    #[allow(unused_variables)]
                    for SemanticEl(tm1, _, _) in self.semantic_el.iter_all_1_2(tm3, tm4) {
                        #[allow(unused_variables)]
                        for ConsTermListNode(tm0, _, _) in
                            self.cons_term_list_node.iter_all_1_2(tm1, tm2)
                        {
                            self.semantic_els_cons_12(delta, tm0, tm1, tm4, tm2, tm3, tm5, tm6);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_cons_12(
        &self,
        delta: &mut ModelDelta,
        tm0: TermListNode,
        tm1: TermNode,
        tm4: El,
        tm2: TermListNode,
        tm3: Structure,
        tm5: ElList,
        tm6: ElList,
    ) {
        for _ in [()] {
            let exists_already = self
                .semantic_els
                .iter_all_0_1_2(tm0, tm3, tm6)
                .next()
                .is_some();
            if !exists_already {
                delta.new_semantic_els.push(SemanticEls(tm0, tm3, tm6));
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_el_struct_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.semantic_el_struct_1(delta);
            self.semantic_el_struct_2(delta);
        }
    }

    #[allow(unused_variables)]
    fn semantic_el_struct_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn semantic_el_struct_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(tm0, tm1, tm2) in self.semantic_el.iter_dirty() {
                self.semantic_el_struct_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_el_struct_3(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Structure, tm2: El) {
        for _ in [()] {
            let exists_already = self.el_structure.iter_all_0_1(tm2, tm1).next().is_some();
            if !exists_already {
                delta.new_el_structure.push(ElStructure(tm2, tm1));
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_struct_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.semantic_els_struct_1(delta);
            self.semantic_els_struct_2(delta);
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_struct_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn semantic_els_struct_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEls(tm0, tm1, tm2) in self.semantic_els.iter_dirty() {
                self.semantic_els_struct_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn semantic_els_struct_3(
        &self,
        delta: &mut ModelDelta,
        tm0: TermListNode,
        tm1: Structure,
        tm2: ElList,
    ) {
        for _ in [()] {
            let exists_already = self.els_structure.iter_all_0_1(tm2, tm1).next().is_some();
            if !exists_already {
                delta.new_els_structure.push(ElsStructure(tm2, tm1));
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_semantics_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.app_term_semantics_1(delta);
            self.app_term_semantics_2(delta);
            self.app_term_semantics_5(delta);
            self.app_term_semantics_8(delta);
            self.app_term_semantics_11(delta);
            self.app_term_semantics_12(delta);
            self.app_term_semantics_15(delta);
        }
    }

    #[allow(unused_variables)]
    fn app_term_semantics_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn app_term_semantics_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for AppTermNode(tm0, tm1, tm2) in self.app_term_node.iter_dirty() {
                self.app_term_semantics_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_semantics_3(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.app_term_semantics_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn app_term_semantics_4(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(_, tm3, tm4) in self.semantic_el.iter_all_0(tm0) {
                self.app_term_semantics_6(delta, tm1, tm2, tm0, tm3, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_semantics_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(tm0, tm3, tm4) in self.semantic_el.iter_dirty() {
                #[allow(unused_variables)]
                for AppTermNode(_, tm1, tm2) in self.app_term_node.iter_all_0(tm0) {
                    self.app_term_semantics_6(delta, tm1, tm2, tm0, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_semantics_6(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: TermListNode,
        tm0: TermNode,
        tm3: Structure,
        tm4: El,
    ) {
        for _ in [()] {
            self.app_term_semantics_7(delta, tm1, tm2, tm0, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn app_term_semantics_7(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: TermListNode,
        tm0: TermNode,
        tm3: Structure,
        tm4: El,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEls(_, _, tm5) in self.semantic_els.iter_all_0_1(tm2, tm3) {
                self.app_term_semantics_9(delta, tm1, tm0, tm4, tm2, tm3, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_semantics_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEls(tm2, tm3, tm5) in self.semantic_els.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticEl(tm0, _, tm4) in self.semantic_el.iter_all_1(tm3) {
                    #[allow(unused_variables)]
                    for AppTermNode(_, tm1, _) in self.app_term_node.iter_all_0_2(tm0, tm2) {
                        self.app_term_semantics_9(delta, tm1, tm0, tm4, tm2, tm3, tm5);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_semantics_9(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm0: TermNode,
        tm4: El,
        tm2: TermListNode,
        tm3: Structure,
        tm5: ElList,
    ) {
        for _ in [()] {
            self.app_term_semantics_10(delta, tm1, tm0, tm4, tm2, tm3, tm5);
        }
    }

    #[allow(unused_variables)]
    fn app_term_semantics_10(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm0: TermNode,
        tm4: El,
        tm2: TermListNode,
        tm3: Structure,
        tm5: ElList,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticFunc(_, tm6) in self.semantic_func.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for FuncRel(_, tm7) in self.func_rel.iter_all_0(tm6) {
                    self.app_term_semantics_13(delta, tm0, tm4, tm2, tm3, tm5, tm1, tm6, tm7);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_semantics_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticFunc(tm1, tm6) in self.semantic_func.iter_dirty() {
                #[allow(unused_variables)]
                for FuncRel(_, tm7) in self.func_rel.iter_all_0(tm6) {
                    #[allow(unused_variables)]
                    for AppTermNode(tm0, _, tm2) in self.app_term_node.iter_all_1(tm1) {
                        #[allow(unused_variables)]
                        for SemanticEls(_, tm3, tm5) in self.semantic_els.iter_all_0(tm2) {
                            #[allow(unused_variables)]
                            for SemanticEl(_, _, tm4) in self.semantic_el.iter_all_0_1(tm0, tm3) {
                                self.app_term_semantics_13(
                                    delta, tm0, tm4, tm2, tm3, tm5, tm1, tm6, tm7,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_semantics_12(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for FuncRel(tm6, tm7) in self.func_rel.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticFunc(tm1, _) in self.semantic_func.iter_all_1(tm6) {
                    #[allow(unused_variables)]
                    for AppTermNode(tm0, _, tm2) in self.app_term_node.iter_all_1(tm1) {
                        #[allow(unused_variables)]
                        for SemanticEls(_, tm3, tm5) in self.semantic_els.iter_all_0(tm2) {
                            #[allow(unused_variables)]
                            for SemanticEl(_, _, tm4) in self.semantic_el.iter_all_0_1(tm0, tm3) {
                                self.app_term_semantics_13(
                                    delta, tm0, tm4, tm2, tm3, tm5, tm1, tm6, tm7,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_semantics_13(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm4: El,
        tm2: TermListNode,
        tm3: Structure,
        tm5: ElList,
        tm1: Ident,
        tm6: Func,
        tm7: Rel,
    ) {
        for _ in [()] {
            self.app_term_semantics_14(delta, tm0, tm4, tm2, tm3, tm5, tm1, tm6, tm7);
        }
    }

    #[allow(unused_variables)]
    fn app_term_semantics_14(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm4: El,
        tm2: TermListNode,
        tm3: Structure,
        tm5: ElList,
        tm1: Ident,
        tm6: Func,
        tm7: Rel,
    ) {
        for _ in [()] {
            let tm8 = match self.snoc_el_list.iter_all_0_1(tm5, tm4).next() {
                Some(SnocElList(_, _, res)) => res,
                None => {
                    delta.new_snoc_el_list_def.push(SnocElListArgs(tm5, tm4));
                    break;
                }
            };

            self.app_term_semantics_16(delta, tm0, tm4, tm2, tm3, tm5, tm1, tm6, tm7, tm8);
        }
    }

    #[allow(unused_variables)]
    fn app_term_semantics_15(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SnocElList(tm5, tm4, tm8) in self.snoc_el_list.iter_dirty() {
                #[allow(unused_variables)]
                for FuncRel(tm6, tm7) in self.func_rel.iter_all() {
                    #[allow(unused_variables)]
                    for SemanticFunc(tm1, _) in self.semantic_func.iter_all_1(tm6) {
                        #[allow(unused_variables)]
                        for AppTermNode(tm0, _, tm2) in self.app_term_node.iter_all_1(tm1) {
                            #[allow(unused_variables)]
                            for SemanticEl(_, tm3, _) in self.semantic_el.iter_all_0_2(tm0, tm4) {
                                #[allow(unused_variables)]
                                for SemanticEls(_, _, _) in
                                    self.semantic_els.iter_all_0_1_2(tm2, tm3, tm5)
                                {
                                    self.app_term_semantics_16(
                                        delta, tm0, tm4, tm2, tm3, tm5, tm1, tm6, tm7, tm8,
                                    );
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn app_term_semantics_16(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm4: El,
        tm2: TermListNode,
        tm3: Structure,
        tm5: ElList,
        tm1: Ident,
        tm6: Func,
        tm7: Rel,
        tm8: ElList,
    ) {
        for _ in [()] {
            let exists_already = self.rel_app.iter_all_0_1(tm7, tm8).next().is_some();
            if !exists_already {
                delta.new_rel_app.push(RelApp(tm7, tm8));
            }
        }
    }

    #[allow(unused_variables)]
    fn var_term_semantics_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.var_term_semantics_1(delta);
            self.var_term_semantics_2(delta);
            self.var_term_semantics_5(delta);
            self.var_term_semantics_6(delta);
            self.var_term_semantics_9(delta);
            self.var_term_semantics_12(delta);
        }
    }

    #[allow(unused_variables)]
    fn var_term_semantics_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn var_term_semantics_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for VarTermNode(tm0, tm1) in self.var_term_node.iter_dirty() {
                self.var_term_semantics_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn var_term_semantics_3(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent) {
        for _ in [()] {
            self.var_term_semantics_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn var_term_semantics_4(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(_, tm2) in self.rule_descendant_term.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for ExitScope(_, tm3) in self.exit_scope.iter_all_0(tm2) {
                    self.var_term_semantics_7(delta, tm1, tm0, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn var_term_semantics_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(tm0, tm2) in self.rule_descendant_term.iter_dirty() {
                #[allow(unused_variables)]
                for VarTermNode(_, tm1) in self.var_term_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for ExitScope(_, tm3) in self.exit_scope.iter_all_0(tm2) {
                        self.var_term_semantics_7(delta, tm1, tm0, tm2, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn var_term_semantics_6(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ExitScope(tm2, tm3) in self.exit_scope.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantTerm(tm0, _) in self.rule_descendant_term.iter_all_1(tm2) {
                    #[allow(unused_variables)]
                    for VarTermNode(_, tm1) in self.var_term_node.iter_all_0(tm0) {
                        self.var_term_semantics_7(delta, tm1, tm0, tm2, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn var_term_semantics_7(
        &self,
        delta: &mut ModelDelta,
        tm1: VirtIdent,
        tm0: TermNode,
        tm2: RuleDescendantNode,
        tm3: Scope,
    ) {
        for _ in [()] {
            self.var_term_semantics_8(delta, tm1, tm0, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn var_term_semantics_8(
        &self,
        delta: &mut ModelDelta,
        tm1: VirtIdent,
        tm0: TermNode,
        tm2: RuleDescendantNode,
        tm3: Scope,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticName(_, _, tm4) in self.semantic_name.iter_all_0_1(tm1, tm3) {
                self.var_term_semantics_10(delta, tm0, tm2, tm3, tm1, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn var_term_semantics_9(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticName(tm1, tm3, tm4) in self.semantic_name.iter_dirty() {
                #[allow(unused_variables)]
                for ExitScope(tm2, _) in self.exit_scope.iter_all_1(tm3) {
                    #[allow(unused_variables)]
                    for VarTermNode(tm0, _) in self.var_term_node.iter_all_1(tm1) {
                        #[allow(unused_variables)]
                        for RuleDescendantTerm(_, _) in
                            self.rule_descendant_term.iter_all_0_1(tm0, tm2)
                        {
                            self.var_term_semantics_10(delta, tm0, tm2, tm3, tm1, tm4);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn var_term_semantics_10(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm2: RuleDescendantNode,
        tm3: Scope,
        tm1: VirtIdent,
        tm4: ElName,
    ) {
        for _ in [()] {
            self.var_term_semantics_11(delta, tm0, tm2, tm3, tm1, tm4);
        }
    }

    #[allow(unused_variables)]
    fn var_term_semantics_11(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm2: RuleDescendantNode,
        tm3: Scope,
        tm1: VirtIdent,
        tm4: ElName,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(_, tm5, tm6) in self.semantic_el.iter_all_0(tm0) {
                self.var_term_semantics_13(delta, tm2, tm3, tm1, tm4, tm0, tm5, tm6);
            }
        }
    }

    #[allow(unused_variables)]
    fn var_term_semantics_12(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(tm0, tm5, tm6) in self.semantic_el.iter_dirty() {
                #[allow(unused_variables)]
                for RuleDescendantTerm(_, tm2) in self.rule_descendant_term.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for ExitScope(_, tm3) in self.exit_scope.iter_all_0(tm2) {
                        #[allow(unused_variables)]
                        for VarTermNode(_, tm1) in self.var_term_node.iter_all_0(tm0) {
                            #[allow(unused_variables)]
                            for SemanticName(_, _, tm4) in self.semantic_name.iter_all_0_1(tm1, tm3)
                            {
                                self.var_term_semantics_13(
                                    delta, tm2, tm3, tm1, tm4, tm0, tm5, tm6,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn var_term_semantics_13(
        &self,
        delta: &mut ModelDelta,
        tm2: RuleDescendantNode,
        tm3: Scope,
        tm1: VirtIdent,
        tm4: ElName,
        tm0: TermNode,
        tm5: Structure,
        tm6: El,
    ) {
        for _ in [()] {
            let exists_already = self.var.iter_all_0_1_2(tm5, tm4, tm6).next().is_some();
            if !exists_already {
                delta.new_var.push(Var(tm5, tm4, tm6));
            }
        }
    }

    #[allow(unused_variables)]
    fn wildcard_name_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.wildcard_name_defined_1(delta);
            self.wildcard_name_defined_2(delta);
            self.wildcard_name_defined_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn wildcard_name_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn wildcard_name_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for WildcardTermNode(tm0) in self.wildcard_term_node.iter_dirty() {
                self.wildcard_name_defined_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn wildcard_name_defined_3(&self, delta: &mut ModelDelta, tm0: TermNode) {
        for _ in [()] {
            self.wildcard_name_defined_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn wildcard_name_defined_4(&self, delta: &mut ModelDelta, tm0: TermNode) {
        for _ in [()] {
            let tm1 = match self.wildcard_name.iter_all_0(tm0).next() {
                Some(WildcardName(_, res)) => res,
                None => {
                    delta.new_wildcard_name_def.push(WildcardNameArgs(tm0));
                    break;
                }
            };

            self.wildcard_name_defined_6(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn wildcard_name_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for WildcardName(tm0, tm1) in self.wildcard_name.iter_dirty() {
                #[allow(unused_variables)]
                for WildcardTermNode(_) in self.wildcard_term_node.iter_all_0(tm0) {
                    self.wildcard_name_defined_6(delta, tm0, tm1);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn wildcard_name_defined_6(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: ElName) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn wildcard_term_semantics_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.wildcard_term_semantics_1(delta);
            self.wildcard_term_semantics_2(delta);
            self.wildcard_term_semantics_5(delta);
            self.wildcard_term_semantics_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn wildcard_term_semantics_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn wildcard_term_semantics_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for WildcardTermNode(tm0) in self.wildcard_term_node.iter_dirty() {
                self.wildcard_term_semantics_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn wildcard_term_semantics_3(&self, delta: &mut ModelDelta, tm0: TermNode) {
        for _ in [()] {
            self.wildcard_term_semantics_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn wildcard_term_semantics_4(&self, delta: &mut ModelDelta, tm0: TermNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for WildcardName(_, tm1) in self.wildcard_name.iter_all_0(tm0) {
                self.wildcard_term_semantics_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn wildcard_term_semantics_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for WildcardName(tm0, tm1) in self.wildcard_name.iter_dirty() {
                #[allow(unused_variables)]
                for WildcardTermNode(_) in self.wildcard_term_node.iter_all_0(tm0) {
                    self.wildcard_term_semantics_6(delta, tm0, tm1);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn wildcard_term_semantics_6(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: ElName) {
        for _ in [()] {
            self.wildcard_term_semantics_7(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn wildcard_term_semantics_7(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: ElName) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(_, tm2, tm3) in self.semantic_el.iter_all_0(tm0) {
                self.wildcard_term_semantics_9(delta, tm1, tm0, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn wildcard_term_semantics_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(tm0, tm2, tm3) in self.semantic_el.iter_dirty() {
                #[allow(unused_variables)]
                for WildcardTermNode(_) in self.wildcard_term_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for WildcardName(_, tm1) in self.wildcard_name.iter_all_0(tm0) {
                        self.wildcard_term_semantics_9(delta, tm1, tm0, tm2, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn wildcard_term_semantics_9(
        &self,
        delta: &mut ModelDelta,
        tm1: ElName,
        tm0: TermNode,
        tm2: Structure,
        tm3: El,
    ) {
        for _ in [()] {
            let exists_already = self.var.iter_all_0_1_2(tm2, tm1, tm3).next().is_some();
            if !exists_already {
                delta.new_var.push(Var(tm2, tm1, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_if_atom_semantics_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.equal_if_atom_semantics_1(delta);
            self.equal_if_atom_semantics_2(delta);
            self.equal_if_atom_semantics_5(delta);
            self.equal_if_atom_semantics_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn equal_if_atom_semantics_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn equal_if_atom_semantics_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EqualIfAtomNode(tm0, tm1, tm2) in self.equal_if_atom_node.iter_dirty() {
                self.equal_if_atom_semantics_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_if_atom_semantics_3(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            self.equal_if_atom_semantics_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn equal_if_atom_semantics_4(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(_, tm3, tm4) in self.semantic_el.iter_all_0(tm1) {
                self.equal_if_atom_semantics_6(delta, tm0, tm2, tm1, tm3, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_if_atom_semantics_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(tm1, tm3, tm4) in self.semantic_el.iter_dirty() {
                #[allow(unused_variables)]
                for EqualIfAtomNode(tm0, _, tm2) in self.equal_if_atom_node.iter_all_1(tm1) {
                    self.equal_if_atom_semantics_6(delta, tm0, tm2, tm1, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_if_atom_semantics_6(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm2: TermNode,
        tm1: TermNode,
        tm3: Structure,
        tm4: El,
    ) {
        for _ in [()] {
            self.equal_if_atom_semantics_7(delta, tm0, tm2, tm1, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn equal_if_atom_semantics_7(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm2: TermNode,
        tm1: TermNode,
        tm3: Structure,
        tm4: El,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(_, _, tm5) in self.semantic_el.iter_all_0_1(tm2, tm3) {
                self.equal_if_atom_semantics_9(delta, tm0, tm1, tm4, tm2, tm3, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_if_atom_semantics_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(tm2, tm3, tm5) in self.semantic_el.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticEl(tm1, _, tm4) in self.semantic_el.iter_all_1(tm3) {
                    #[allow(unused_variables)]
                    for EqualIfAtomNode(tm0, _, _) in self.equal_if_atom_node.iter_all_1_2(tm1, tm2)
                    {
                        self.equal_if_atom_semantics_9(delta, tm0, tm1, tm4, tm2, tm3, tm5);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_if_atom_semantics_9(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm4: El,
        tm2: TermNode,
        tm3: Structure,
        tm5: El,
    ) {
        for _ in [()] {
            delta.new_el_equalities.push((tm4, tm5));

            delta.new_el_equalities.push((tm5, tm4));
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_semantics_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.pred_if_atom_semantics_1(delta);
            self.pred_if_atom_semantics_2(delta);
            self.pred_if_atom_semantics_5(delta);
            self.pred_if_atom_semantics_6(delta);
            self.pred_if_atom_semantics_9(delta);
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_semantics_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn pred_if_atom_semantics_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredIfAtomNode(tm0, tm1, tm2) in self.pred_if_atom_node.iter_dirty() {
                self.pred_if_atom_semantics_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_semantics_3(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.pred_if_atom_semantics_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_semantics_4(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticPred(_, tm3) in self.semantic_pred.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for PredRel(_, tm4) in self.pred_rel.iter_all_0(tm3) {
                    self.pred_if_atom_semantics_7(delta, tm0, tm2, tm1, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_semantics_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticPred(tm1, tm3) in self.semantic_pred.iter_dirty() {
                #[allow(unused_variables)]
                for PredRel(_, tm4) in self.pred_rel.iter_all_0(tm3) {
                    #[allow(unused_variables)]
                    for PredIfAtomNode(tm0, _, tm2) in self.pred_if_atom_node.iter_all_1(tm1) {
                        self.pred_if_atom_semantics_7(delta, tm0, tm2, tm1, tm3, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_semantics_6(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredRel(tm3, tm4) in self.pred_rel.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticPred(tm1, _) in self.semantic_pred.iter_all_1(tm3) {
                    #[allow(unused_variables)]
                    for PredIfAtomNode(tm0, _, tm2) in self.pred_if_atom_node.iter_all_1(tm1) {
                        self.pred_if_atom_semantics_7(delta, tm0, tm2, tm1, tm3, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_semantics_7(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm2: TermListNode,
        tm1: Ident,
        tm3: Pred,
        tm4: Rel,
    ) {
        for _ in [()] {
            self.pred_if_atom_semantics_8(delta, tm0, tm2, tm1, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_semantics_8(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm2: TermListNode,
        tm1: Ident,
        tm3: Pred,
        tm4: Rel,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEls(_, tm5, tm6) in self.semantic_els.iter_all_0(tm2) {
                self.pred_if_atom_semantics_10(delta, tm0, tm1, tm3, tm4, tm2, tm5, tm6);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_semantics_9(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEls(tm2, tm5, tm6) in self.semantic_els.iter_dirty() {
                #[allow(unused_variables)]
                for PredRel(tm3, tm4) in self.pred_rel.iter_all() {
                    #[allow(unused_variables)]
                    for SemanticPred(tm1, _) in self.semantic_pred.iter_all_1(tm3) {
                        #[allow(unused_variables)]
                        for PredIfAtomNode(tm0, _, _) in
                            self.pred_if_atom_node.iter_all_1_2(tm1, tm2)
                        {
                            self.pred_if_atom_semantics_10(
                                delta, tm0, tm1, tm3, tm4, tm2, tm5, tm6,
                            );
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_if_atom_semantics_10(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: Ident,
        tm3: Pred,
        tm4: Rel,
        tm2: TermListNode,
        tm5: Structure,
        tm6: ElList,
    ) {
        for _ in [()] {
            let exists_already = self.rel_app.iter_all_0_1(tm4, tm6).next().is_some();
            if !exists_already {
                delta.new_rel_app.push(RelApp(tm4, tm6));
            }
        }
    }

    #[allow(unused_variables)]
    fn var_if_atom_semantics_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.var_if_atom_semantics_1(delta);
            self.var_if_atom_semantics_2(delta);
            self.var_if_atom_semantics_5(delta);
            self.var_if_atom_semantics_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn var_if_atom_semantics_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn var_if_atom_semantics_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for VarIfAtomNode(tm0, tm1, tm2) in self.var_if_atom_node.iter_dirty() {
                self.var_if_atom_semantics_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn var_if_atom_semantics_3(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: Ident,
    ) {
        for _ in [()] {
            self.var_if_atom_semantics_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn var_if_atom_semantics_4(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: Ident,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticType(_, tm3) in self.semantic_type.iter_all_0(tm2) {
                self.var_if_atom_semantics_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn var_if_atom_semantics_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticType(tm2, tm3) in self.semantic_type.iter_dirty() {
                #[allow(unused_variables)]
                for VarIfAtomNode(tm0, tm1, _) in self.var_if_atom_node.iter_all_2(tm2) {
                    self.var_if_atom_semantics_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn var_if_atom_semantics_6(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: Ident,
        tm3: Type,
    ) {
        for _ in [()] {
            self.var_if_atom_semantics_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn var_if_atom_semantics_7(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm1: TermNode,
        tm2: Ident,
        tm3: Type,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(_, tm4, tm5) in self.semantic_el.iter_all_0(tm1) {
                self.var_if_atom_semantics_9(delta, tm0, tm2, tm3, tm1, tm4, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn var_if_atom_semantics_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(tm1, tm4, tm5) in self.semantic_el.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticType(tm2, tm3) in self.semantic_type.iter_all() {
                    #[allow(unused_variables)]
                    for VarIfAtomNode(tm0, _, _) in self.var_if_atom_node.iter_all_1_2(tm1, tm2) {
                        self.var_if_atom_semantics_9(delta, tm0, tm2, tm3, tm1, tm4, tm5);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn var_if_atom_semantics_9(
        &self,
        delta: &mut ModelDelta,
        tm0: IfAtomNode,
        tm2: Ident,
        tm3: Type,
        tm1: TermNode,
        tm4: Structure,
        tm5: El,
    ) {
        for _ in [()] {
            let exists_already = self.el_type.iter_all_0_1(tm5, tm3).next().is_some();
            if !exists_already {
                delta.new_el_type.push(ElType(tm5, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_then_atom_semantics_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.equal_then_atom_semantics_1(delta);
            self.equal_then_atom_semantics_2(delta);
            self.equal_then_atom_semantics_5(delta);
            self.equal_then_atom_semantics_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn equal_then_atom_semantics_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn equal_then_atom_semantics_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EqualThenAtomNode(tm0, tm1, tm2) in self.equal_then_atom_node.iter_dirty() {
                self.equal_then_atom_semantics_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_then_atom_semantics_3(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: TermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            self.equal_then_atom_semantics_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn equal_then_atom_semantics_4(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: TermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(_, tm3, tm4) in self.semantic_el.iter_all_0(tm1) {
                self.equal_then_atom_semantics_6(delta, tm0, tm2, tm1, tm3, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_then_atom_semantics_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(tm1, tm3, tm4) in self.semantic_el.iter_dirty() {
                #[allow(unused_variables)]
                for EqualThenAtomNode(tm0, _, tm2) in self.equal_then_atom_node.iter_all_1(tm1) {
                    self.equal_then_atom_semantics_6(delta, tm0, tm2, tm1, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_then_atom_semantics_6(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm2: TermNode,
        tm1: TermNode,
        tm3: Structure,
        tm4: El,
    ) {
        for _ in [()] {
            self.equal_then_atom_semantics_7(delta, tm0, tm2, tm1, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn equal_then_atom_semantics_7(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm2: TermNode,
        tm1: TermNode,
        tm3: Structure,
        tm4: El,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(_, _, tm5) in self.semantic_el.iter_all_0_1(tm2, tm3) {
                self.equal_then_atom_semantics_9(delta, tm0, tm1, tm4, tm2, tm3, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_then_atom_semantics_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(tm2, tm3, tm5) in self.semantic_el.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticEl(tm1, _, tm4) in self.semantic_el.iter_all_1(tm3) {
                    #[allow(unused_variables)]
                    for EqualThenAtomNode(tm0, _, _) in
                        self.equal_then_atom_node.iter_all_1_2(tm1, tm2)
                    {
                        self.equal_then_atom_semantics_9(delta, tm0, tm1, tm4, tm2, tm3, tm5);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn equal_then_atom_semantics_9(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: TermNode,
        tm4: El,
        tm2: TermNode,
        tm3: Structure,
        tm5: El,
    ) {
        for _ in [()] {
            delta.new_el_equalities.push((tm4, tm5));

            delta.new_el_equalities.push((tm5, tm4));
        }
    }

    #[allow(unused_variables)]
    fn defined_then_atom_semantics_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.defined_then_atom_semantics_1(delta);
            self.defined_then_atom_semantics_2(delta);
            self.defined_then_atom_semantics_5(delta);
            self.defined_then_atom_semantics_8(delta);
            self.defined_then_atom_semantics_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn defined_then_atom_semantics_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn defined_then_atom_semantics_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DefinedThenAtomNode(tm0, tm1, tm2) in self.defined_then_atom_node.iter_dirty() {
                self.defined_then_atom_semantics_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_atom_semantics_3(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: OptTermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            self.defined_then_atom_semantics_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn defined_then_atom_semantics_4(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: OptTermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SomeTermNode(_, tm3) in self.some_term_node.iter_all_0(tm1) {
                self.defined_then_atom_semantics_6(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_atom_semantics_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SomeTermNode(tm1, tm3) in self.some_term_node.iter_dirty() {
                #[allow(unused_variables)]
                for DefinedThenAtomNode(tm0, _, tm2) in self.defined_then_atom_node.iter_all_1(tm1)
                {
                    self.defined_then_atom_semantics_6(delta, tm0, tm2, tm1, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_atom_semantics_6(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm2: TermNode,
        tm1: OptTermNode,
        tm3: TermNode,
    ) {
        for _ in [()] {
            self.defined_then_atom_semantics_7(delta, tm0, tm2, tm1, tm3);
        }
    }

    #[allow(unused_variables)]
    fn defined_then_atom_semantics_7(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm2: TermNode,
        tm1: OptTermNode,
        tm3: TermNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(_, tm4, tm5) in self.semantic_el.iter_all_0(tm3) {
                self.defined_then_atom_semantics_9(delta, tm0, tm2, tm1, tm3, tm4, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_atom_semantics_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(tm3, tm4, tm5) in self.semantic_el.iter_dirty() {
                #[allow(unused_variables)]
                for SomeTermNode(tm1, _) in self.some_term_node.iter_all_1(tm3) {
                    #[allow(unused_variables)]
                    for DefinedThenAtomNode(tm0, _, tm2) in
                        self.defined_then_atom_node.iter_all_1(tm1)
                    {
                        self.defined_then_atom_semantics_9(delta, tm0, tm2, tm1, tm3, tm4, tm5);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_atom_semantics_9(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm2: TermNode,
        tm1: OptTermNode,
        tm3: TermNode,
        tm4: Structure,
        tm5: El,
    ) {
        for _ in [()] {
            self.defined_then_atom_semantics_10(delta, tm0, tm2, tm1, tm3, tm4, tm5);
        }
    }

    #[allow(unused_variables)]
    fn defined_then_atom_semantics_10(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm2: TermNode,
        tm1: OptTermNode,
        tm3: TermNode,
        tm4: Structure,
        tm5: El,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(_, _, tm6) in self.semantic_el.iter_all_0_1(tm2, tm4) {
                self.defined_then_atom_semantics_12(delta, tm0, tm1, tm3, tm5, tm2, tm4, tm6);
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_atom_semantics_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(tm2, tm4, tm6) in self.semantic_el.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticEl(tm3, _, tm5) in self.semantic_el.iter_all_1(tm4) {
                    #[allow(unused_variables)]
                    for SomeTermNode(tm1, _) in self.some_term_node.iter_all_1(tm3) {
                        #[allow(unused_variables)]
                        for DefinedThenAtomNode(tm0, _, _) in
                            self.defined_then_atom_node.iter_all_1_2(tm1, tm2)
                        {
                            self.defined_then_atom_semantics_12(
                                delta, tm0, tm1, tm3, tm5, tm2, tm4, tm6,
                            );
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_atom_semantics_12(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: OptTermNode,
        tm3: TermNode,
        tm5: El,
        tm2: TermNode,
        tm4: Structure,
        tm6: El,
    ) {
        for _ in [()] {
            delta.new_el_equalities.push((tm5, tm6));

            delta.new_el_equalities.push((tm6, tm5));
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_semantics_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.pred_then_atom_semantics_1(delta);
            self.pred_then_atom_semantics_2(delta);
            self.pred_then_atom_semantics_5(delta);
            self.pred_then_atom_semantics_6(delta);
            self.pred_then_atom_semantics_9(delta);
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_semantics_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn pred_then_atom_semantics_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredThenAtomNode(tm0, tm1, tm2) in self.pred_then_atom_node.iter_dirty() {
                self.pred_then_atom_semantics_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_semantics_3(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.pred_then_atom_semantics_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_semantics_4(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticPred(_, tm3) in self.semantic_pred.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for PredRel(_, tm4) in self.pred_rel.iter_all_0(tm3) {
                    self.pred_then_atom_semantics_7(delta, tm0, tm2, tm1, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_semantics_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticPred(tm1, tm3) in self.semantic_pred.iter_dirty() {
                #[allow(unused_variables)]
                for PredRel(_, tm4) in self.pred_rel.iter_all_0(tm3) {
                    #[allow(unused_variables)]
                    for PredThenAtomNode(tm0, _, tm2) in self.pred_then_atom_node.iter_all_1(tm1) {
                        self.pred_then_atom_semantics_7(delta, tm0, tm2, tm1, tm3, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_semantics_6(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredRel(tm3, tm4) in self.pred_rel.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticPred(tm1, _) in self.semantic_pred.iter_all_1(tm3) {
                    #[allow(unused_variables)]
                    for PredThenAtomNode(tm0, _, tm2) in self.pred_then_atom_node.iter_all_1(tm1) {
                        self.pred_then_atom_semantics_7(delta, tm0, tm2, tm1, tm3, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_semantics_7(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm2: TermListNode,
        tm1: Ident,
        tm3: Pred,
        tm4: Rel,
    ) {
        for _ in [()] {
            self.pred_then_atom_semantics_8(delta, tm0, tm2, tm1, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_semantics_8(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm2: TermListNode,
        tm1: Ident,
        tm3: Pred,
        tm4: Rel,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEls(_, tm5, tm6) in self.semantic_els.iter_all_0(tm2) {
                self.pred_then_atom_semantics_10(delta, tm0, tm1, tm3, tm4, tm2, tm5, tm6);
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_semantics_9(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEls(tm2, tm5, tm6) in self.semantic_els.iter_dirty() {
                #[allow(unused_variables)]
                for PredRel(tm3, tm4) in self.pred_rel.iter_all() {
                    #[allow(unused_variables)]
                    for SemanticPred(tm1, _) in self.semantic_pred.iter_all_1(tm3) {
                        #[allow(unused_variables)]
                        for PredThenAtomNode(tm0, _, _) in
                            self.pred_then_atom_node.iter_all_1_2(tm1, tm2)
                        {
                            self.pred_then_atom_semantics_10(
                                delta, tm0, tm1, tm3, tm4, tm2, tm5, tm6,
                            );
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pred_then_atom_semantics_10(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: Ident,
        tm3: Pred,
        tm4: Rel,
        tm2: TermListNode,
        tm5: Structure,
        tm6: ElList,
    ) {
        for _ in [()] {
            let exists_already = self.rel_app.iter_all_0_1(tm4, tm6).next().is_some();
            if !exists_already {
                delta.new_rel_app.push(RelApp(tm4, tm6));
            }
        }
    }

    #[allow(unused_variables)]
    fn terms_should_be_epic_ok_cons_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.terms_should_be_epic_ok_cons_1(delta);
            self.terms_should_be_epic_ok_cons_2(delta);
            self.terms_should_be_epic_ok_cons_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn terms_should_be_epic_ok_cons_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn terms_should_be_epic_ok_cons_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermsShouldBeEpicOk(tm0) in self.terms_should_be_epic_ok.iter_dirty() {
                self.terms_should_be_epic_ok_cons_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn terms_should_be_epic_ok_cons_3(&self, delta: &mut ModelDelta, tm0: TermListNode) {
        for _ in [()] {
            self.terms_should_be_epic_ok_cons_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn terms_should_be_epic_ok_cons_4(&self, delta: &mut ModelDelta, tm0: TermListNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsTermListNode(_, tm1, tm2) in self.cons_term_list_node.iter_all_0(tm0) {
                self.terms_should_be_epic_ok_cons_6(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn terms_should_be_epic_ok_cons_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsTermListNode(tm0, tm1, tm2) in self.cons_term_list_node.iter_dirty() {
                #[allow(unused_variables)]
                for TermsShouldBeEpicOk(_) in self.terms_should_be_epic_ok.iter_all_0(tm0) {
                    self.terms_should_be_epic_ok_cons_6(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn terms_should_be_epic_ok_cons_6(
        &self,
        delta: &mut ModelDelta,
        tm0: TermListNode,
        tm1: TermNode,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            let exists_already = self.term_should_be_epic_ok.iter_all_0(tm1).next().is_some();
            if !exists_already {
                delta
                    .new_term_should_be_epic_ok
                    .push(TermShouldBeEpicOk(tm1));
            }

            let exists_already = self
                .terms_should_be_epic_ok
                .iter_all_0(tm2)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_terms_should_be_epic_ok
                    .push(TermsShouldBeEpicOk(tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn terms_should_be_epic_ok_app_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.terms_should_be_epic_ok_app_1(delta);
            self.terms_should_be_epic_ok_app_2(delta);
            self.terms_should_be_epic_ok_app_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn terms_should_be_epic_ok_app_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn terms_should_be_epic_ok_app_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermShouldBeEpicOk(tm0) in self.term_should_be_epic_ok.iter_dirty() {
                self.terms_should_be_epic_ok_app_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn terms_should_be_epic_ok_app_3(&self, delta: &mut ModelDelta, tm0: TermNode) {
        for _ in [()] {
            self.terms_should_be_epic_ok_app_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn terms_should_be_epic_ok_app_4(&self, delta: &mut ModelDelta, tm0: TermNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for AppTermNode(_, tm1, tm2) in self.app_term_node.iter_all_0(tm0) {
                self.terms_should_be_epic_ok_app_6(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn terms_should_be_epic_ok_app_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for AppTermNode(tm0, tm1, tm2) in self.app_term_node.iter_dirty() {
                #[allow(unused_variables)]
                for TermShouldBeEpicOk(_) in self.term_should_be_epic_ok.iter_all_0(tm0) {
                    self.terms_should_be_epic_ok_app_6(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn terms_should_be_epic_ok_app_6(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .terms_should_be_epic_ok
                .iter_all_0(tm2)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_terms_should_be_epic_ok
                    .push(TermsShouldBeEpicOk(tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn then_atom_epic_ok_equal_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.then_atom_epic_ok_equal_1(delta);
            self.then_atom_epic_ok_equal_2(delta);
        }
    }

    #[allow(unused_variables)]
    fn then_atom_epic_ok_equal_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn then_atom_epic_ok_equal_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EqualThenAtomNode(tm0, tm1, tm2) in self.equal_then_atom_node.iter_dirty() {
                self.then_atom_epic_ok_equal_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn then_atom_epic_ok_equal_3(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: TermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            let exists_already = self.term_should_be_epic_ok.iter_all_0(tm1).next().is_some();
            if !exists_already {
                delta
                    .new_term_should_be_epic_ok
                    .push(TermShouldBeEpicOk(tm1));
            }

            let exists_already = self.term_should_be_epic_ok.iter_all_0(tm2).next().is_some();
            if !exists_already {
                delta
                    .new_term_should_be_epic_ok
                    .push(TermShouldBeEpicOk(tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn then_atom_epic_ok_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.then_atom_epic_ok_defined_1(delta);
            self.then_atom_epic_ok_defined_2(delta);
        }
    }

    #[allow(unused_variables)]
    fn then_atom_epic_ok_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn then_atom_epic_ok_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DefinedThenAtomNode(tm0, tm1, tm2) in self.defined_then_atom_node.iter_dirty() {
                self.then_atom_epic_ok_defined_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn then_atom_epic_ok_defined_3(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: OptTermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            let exists_already = self.term_should_be_epic_ok.iter_all_0(tm2).next().is_some();
            if !exists_already {
                delta
                    .new_term_should_be_epic_ok
                    .push(TermShouldBeEpicOk(tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn then_atom_epic_ok_pred_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.then_atom_epic_ok_pred_1(delta);
            self.then_atom_epic_ok_pred_2(delta);
        }
    }

    #[allow(unused_variables)]
    fn then_atom_epic_ok_pred_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn then_atom_epic_ok_pred_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for PredThenAtomNode(tm0, tm1, tm2) in self.pred_then_atom_node.iter_dirty() {
                self.then_atom_epic_ok_pred_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn then_atom_epic_ok_pred_3(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .terms_should_be_epic_ok
                .iter_all_0(tm2)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_terms_should_be_epic_ok
                    .push(TermsShouldBeEpicOk(tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn surjective_codomain_should_be_ok_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.surjective_codomain_should_be_ok_1(delta);
            self.surjective_codomain_should_be_ok_2(delta);
            self.surjective_codomain_should_be_ok_5(delta);
            self.surjective_codomain_should_be_ok_6(delta);
        }
    }

    #[allow(unused_variables)]
    fn surjective_codomain_should_be_ok_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn surjective_codomain_should_be_ok_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SurjThenMorphism(tm0) in self.surj_then_morphism.iter_dirty() {
                self.surjective_codomain_should_be_ok_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn surjective_codomain_should_be_ok_3(&self, delta: &mut ModelDelta, tm0: Morphism) {
        for _ in [()] {
            self.surjective_codomain_should_be_ok_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn surjective_codomain_should_be_ok_4(&self, delta: &mut ModelDelta, tm0: Morphism) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Cod(_, tm2) in self.cod.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for ElStructure(tm1, _) in self.el_structure.iter_all_1(tm2) {
                    self.surjective_codomain_should_be_ok_7(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn surjective_codomain_should_be_ok_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElStructure(tm1, tm2) in self.el_structure.iter_dirty() {
                #[allow(unused_variables)]
                for SurjThenMorphism(tm0) in self.surj_then_morphism.iter_all() {
                    #[allow(unused_variables)]
                    for Cod(_, _) in self.cod.iter_all_0_1(tm0, tm2) {
                        self.surjective_codomain_should_be_ok_7(delta, tm1, tm0, tm2);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn surjective_codomain_should_be_ok_6(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Cod(tm0, tm2) in self.cod.iter_dirty() {
                #[allow(unused_variables)]
                for SurjThenMorphism(_) in self.surj_then_morphism.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for ElStructure(tm1, _) in self.el_structure.iter_all_1(tm2) {
                        self.surjective_codomain_should_be_ok_7(delta, tm1, tm0, tm2);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn surjective_codomain_should_be_ok_7(
        &self,
        delta: &mut ModelDelta,
        tm1: El,
        tm0: Morphism,
        tm2: Structure,
    ) {
        for _ in [()] {
            let exists_already = self
                .el_should_be_surjective_ok
                .iter_all_0(tm1)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_el_should_be_surjective_ok
                    .push(ElShouldBeSurjectiveOk(tm1));
            }
        }
    }

    #[allow(unused_variables)]
    fn non_surjective_codomain_should_be_ok_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.non_surjective_codomain_should_be_ok_1(delta);
            self.non_surjective_codomain_should_be_ok_2(delta);
            self.non_surjective_codomain_should_be_ok_5(delta);
            self.non_surjective_codomain_should_be_ok_6(delta);
        }
    }

    #[allow(unused_variables)]
    fn non_surjective_codomain_should_be_ok_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn non_surjective_codomain_should_be_ok_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NonSurjThenMorphism(tm0) in self.non_surj_then_morphism.iter_dirty() {
                self.non_surjective_codomain_should_be_ok_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn non_surjective_codomain_should_be_ok_3(&self, delta: &mut ModelDelta, tm0: Morphism) {
        for _ in [()] {
            self.non_surjective_codomain_should_be_ok_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn non_surjective_codomain_should_be_ok_4(&self, delta: &mut ModelDelta, tm0: Morphism) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Cod(_, tm2) in self.cod.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for ElStructure(tm1, _) in self.el_structure.iter_all_1(tm2) {
                    self.non_surjective_codomain_should_be_ok_7(delta, tm1, tm0, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn non_surjective_codomain_should_be_ok_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElStructure(tm1, tm2) in self.el_structure.iter_dirty() {
                #[allow(unused_variables)]
                for NonSurjThenMorphism(tm0) in self.non_surj_then_morphism.iter_all() {
                    #[allow(unused_variables)]
                    for Cod(_, _) in self.cod.iter_all_0_1(tm0, tm2) {
                        self.non_surjective_codomain_should_be_ok_7(delta, tm1, tm0, tm2);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn non_surjective_codomain_should_be_ok_6(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Cod(tm0, tm2) in self.cod.iter_dirty() {
                #[allow(unused_variables)]
                for NonSurjThenMorphism(_) in self.non_surj_then_morphism.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for ElStructure(tm1, _) in self.el_structure.iter_all_1(tm2) {
                        self.non_surjective_codomain_should_be_ok_7(delta, tm1, tm0, tm2);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn non_surjective_codomain_should_be_ok_7(
        &self,
        delta: &mut ModelDelta,
        tm1: El,
        tm0: Morphism,
        tm2: Structure,
    ) {
        for _ in [()] {
            let exists_already = self
                .el_should_be_surjective_ok
                .iter_all_0(tm1)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_el_should_be_surjective_ok
                    .push(ElShouldBeSurjectiveOk(tm1));
            }
        }
    }

    #[allow(unused_variables)]
    fn surjective_img_el_is_ok_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.surjective_img_el_is_ok_1(delta);
            self.surjective_img_el_is_ok_2(delta);
            self.surjective_img_el_is_ok_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn surjective_img_el_is_ok_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn surjective_img_el_is_ok_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElShouldBeSurjectiveOk(tm0) in self.el_should_be_surjective_ok.iter_dirty() {
                self.surjective_img_el_is_ok_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn surjective_img_el_is_ok_3(&self, delta: &mut ModelDelta, tm0: El) {
        for _ in [()] {
            self.surjective_img_el_is_ok_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn surjective_img_el_is_ok_4(&self, delta: &mut ModelDelta, tm0: El) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElInImg(tm1, _) in self.el_in_img.iter_all_1(tm0) {
                self.surjective_img_el_is_ok_6(delta, tm1, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn surjective_img_el_is_ok_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElInImg(tm1, tm0) in self.el_in_img.iter_dirty() {
                #[allow(unused_variables)]
                for ElShouldBeSurjectiveOk(_) in self.el_should_be_surjective_ok.iter_all_0(tm0) {
                    self.surjective_img_el_is_ok_6(delta, tm1, tm0);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn surjective_img_el_is_ok_6(&self, delta: &mut ModelDelta, tm1: Morphism, tm0: El) {
        for _ in [()] {
            let exists_already = self.el_is_surjective_ok.iter_all_0(tm0).next().is_some();
            if !exists_already {
                delta.new_el_is_surjective_ok.push(ElIsSurjectiveOk(tm0));
            }
        }
    }

    #[allow(unused_variables)]
    fn surjective_exempted_then_defined_term_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.surjective_exempted_then_defined_term_1(delta);
            self.surjective_exempted_then_defined_term_2(delta);
            self.surjective_exempted_then_defined_term_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn surjective_exempted_then_defined_term_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn surjective_exempted_then_defined_term_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DefinedThenAtomNode(tm0, tm1, tm2) in self.defined_then_atom_node.iter_dirty() {
                self.surjective_exempted_then_defined_term_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn surjective_exempted_then_defined_term_3(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: OptTermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            self.surjective_exempted_then_defined_term_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn surjective_exempted_then_defined_term_4(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: OptTermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(_, tm3, tm4) in self.semantic_el.iter_all_0(tm2) {
                self.surjective_exempted_then_defined_term_6(delta, tm0, tm1, tm2, tm3, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn surjective_exempted_then_defined_term_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(tm2, tm3, tm4) in self.semantic_el.iter_dirty() {
                #[allow(unused_variables)]
                for DefinedThenAtomNode(tm0, tm1, _) in self.defined_then_atom_node.iter_all_2(tm2)
                {
                    self.surjective_exempted_then_defined_term_6(delta, tm0, tm1, tm2, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn surjective_exempted_then_defined_term_6(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: OptTermNode,
        tm2: TermNode,
        tm3: Structure,
        tm4: El,
    ) {
        for _ in [()] {
            let exists_already = self.el_is_surjective_ok.iter_all_0(tm4).next().is_some();
            if !exists_already {
                delta.new_el_is_surjective_ok.push(ElIsSurjectiveOk(tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_should_be_given_by_ctor_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.defined_then_should_be_given_by_ctor_1(delta);
            self.defined_then_should_be_given_by_ctor_2(delta);
            self.defined_then_should_be_given_by_ctor_5(delta);
            self.defined_then_should_be_given_by_ctor_8(delta);
            self.defined_then_should_be_given_by_ctor_9(delta);
            self.defined_then_should_be_given_by_ctor_12(delta);
        }
    }

    #[allow(unused_variables)]
    fn defined_then_should_be_given_by_ctor_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn defined_then_should_be_given_by_ctor_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for DefinedThenAtomNode(tm0, tm1, tm2) in self.defined_then_atom_node.iter_dirty() {
                self.defined_then_should_be_given_by_ctor_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_should_be_given_by_ctor_3(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: OptTermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            self.defined_then_should_be_given_by_ctor_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn defined_then_should_be_given_by_ctor_4(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: OptTermNode,
        tm2: TermNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(_, tm3, tm4) in self.semantic_el.iter_all_0(tm2) {
                self.defined_then_should_be_given_by_ctor_6(delta, tm0, tm1, tm2, tm3, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_should_be_given_by_ctor_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(tm2, tm3, tm4) in self.semantic_el.iter_dirty() {
                #[allow(unused_variables)]
                for DefinedThenAtomNode(tm0, tm1, _) in self.defined_then_atom_node.iter_all_2(tm2)
                {
                    self.defined_then_should_be_given_by_ctor_6(delta, tm0, tm1, tm2, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_should_be_given_by_ctor_6(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: OptTermNode,
        tm2: TermNode,
        tm3: Structure,
        tm4: El,
    ) {
        for _ in [()] {
            self.defined_then_should_be_given_by_ctor_7(delta, tm0, tm1, tm2, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn defined_then_should_be_given_by_ctor_7(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: OptTermNode,
        tm2: TermNode,
        tm3: Structure,
        tm4: El,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElType(_, tm6) in self.el_type.iter_all_0(tm4) {
                #[allow(unused_variables)]
                for SemanticType(tm5, _) in self.semantic_type.iter_all_1(tm6) {
                    self.defined_then_should_be_given_by_ctor_10(
                        delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6,
                    );
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_should_be_given_by_ctor_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElType(tm4, tm6) in self.el_type.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticType(tm5, _) in self.semantic_type.iter_all_1(tm6) {
                    #[allow(unused_variables)]
                    for SemanticEl(tm2, tm3, _) in self.semantic_el.iter_all_2(tm4) {
                        #[allow(unused_variables)]
                        for DefinedThenAtomNode(tm0, tm1, _) in
                            self.defined_then_atom_node.iter_all_2(tm2)
                        {
                            self.defined_then_should_be_given_by_ctor_10(
                                delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6,
                            );
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_should_be_given_by_ctor_9(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticType(tm5, tm6) in self.semantic_type.iter_dirty() {
                #[allow(unused_variables)]
                for ElType(tm4, _) in self.el_type.iter_all_1(tm6) {
                    #[allow(unused_variables)]
                    for SemanticEl(tm2, tm3, _) in self.semantic_el.iter_all_2(tm4) {
                        #[allow(unused_variables)]
                        for DefinedThenAtomNode(tm0, tm1, _) in
                            self.defined_then_atom_node.iter_all_2(tm2)
                        {
                            self.defined_then_should_be_given_by_ctor_10(
                                delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6,
                            );
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_should_be_given_by_ctor_10(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: OptTermNode,
        tm2: TermNode,
        tm3: Structure,
        tm4: El,
        tm5: Ident,
        tm6: Type,
    ) {
        for _ in [()] {
            self.defined_then_should_be_given_by_ctor_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);
        }
    }

    #[allow(unused_variables)]
    fn defined_then_should_be_given_by_ctor_11(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: OptTermNode,
        tm2: TermNode,
        tm3: Structure,
        tm4: El,
        tm5: Ident,
        tm6: Type,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumDecl(tm7, _, tm8) in self.enum_decl.iter_all_1(tm5) {
                self.defined_then_should_be_given_by_ctor_13(
                    delta, tm0, tm1, tm2, tm3, tm4, tm6, tm7, tm5, tm8,
                );
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_should_be_given_by_ctor_12(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumDecl(tm7, tm5, tm8) in self.enum_decl.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticType(_, tm6) in self.semantic_type.iter_all_0(tm5) {
                    #[allow(unused_variables)]
                    for ElType(tm4, _) in self.el_type.iter_all_1(tm6) {
                        #[allow(unused_variables)]
                        for SemanticEl(tm2, tm3, _) in self.semantic_el.iter_all_2(tm4) {
                            #[allow(unused_variables)]
                            for DefinedThenAtomNode(tm0, tm1, _) in
                                self.defined_then_atom_node.iter_all_2(tm2)
                            {
                                self.defined_then_should_be_given_by_ctor_13(
                                    delta, tm0, tm1, tm2, tm3, tm4, tm6, tm7, tm5, tm8,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn defined_then_should_be_given_by_ctor_13(
        &self,
        delta: &mut ModelDelta,
        tm0: ThenAtomNode,
        tm1: OptTermNode,
        tm2: TermNode,
        tm3: Structure,
        tm4: El,
        tm6: Type,
        tm7: EnumDeclNode,
        tm5: Ident,
        tm8: CtorDeclListNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .should_be_obtained_by_ctor
                .iter_all_0_1(tm2, tm7)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_should_be_obtained_by_ctor
                    .push(ShouldBeObtainedByCtor(tm2, tm7));
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_app_is_given_by_ctor_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.ctor_app_is_given_by_ctor_1(delta);
            self.ctor_app_is_given_by_ctor_2(delta);
            self.ctor_app_is_given_by_ctor_5(delta);
            self.ctor_app_is_given_by_ctor_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn ctor_app_is_given_by_ctor_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn ctor_app_is_given_by_ctor_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for AppTermNode(tm0, tm1, tm2) in self.app_term_node.iter_dirty() {
                self.ctor_app_is_given_by_ctor_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_app_is_given_by_ctor_3(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.ctor_app_is_given_by_ctor_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn ctor_app_is_given_by_ctor_4(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorDecl(tm3, _, tm4) in self.ctor_decl.iter_all_1(tm1) {
                self.ctor_app_is_given_by_ctor_6(delta, tm0, tm2, tm3, tm1, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_app_is_given_by_ctor_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorDecl(tm3, tm1, tm4) in self.ctor_decl.iter_dirty() {
                #[allow(unused_variables)]
                for AppTermNode(tm0, _, tm2) in self.app_term_node.iter_all_1(tm1) {
                    self.ctor_app_is_given_by_ctor_6(delta, tm0, tm2, tm3, tm1, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_app_is_given_by_ctor_6(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm2: TermListNode,
        tm3: CtorDeclNode,
        tm1: Ident,
        tm4: ArgDeclListNode,
    ) {
        for _ in [()] {
            self.ctor_app_is_given_by_ctor_7(delta, tm0, tm2, tm3, tm1, tm4);
        }
    }

    #[allow(unused_variables)]
    fn ctor_app_is_given_by_ctor_7(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm2: TermListNode,
        tm3: CtorDeclNode,
        tm1: Ident,
        tm4: ArgDeclListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorEnum(_, tm5) in self.ctor_enum.iter_all_0(tm3) {
                self.ctor_app_is_given_by_ctor_9(delta, tm0, tm2, tm1, tm4, tm3, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_app_is_given_by_ctor_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorEnum(tm3, tm5) in self.ctor_enum.iter_dirty() {
                #[allow(unused_variables)]
                for CtorDecl(_, tm1, tm4) in self.ctor_decl.iter_all_0(tm3) {
                    #[allow(unused_variables)]
                    for AppTermNode(tm0, _, tm2) in self.app_term_node.iter_all_1(tm1) {
                        self.ctor_app_is_given_by_ctor_9(delta, tm0, tm2, tm1, tm4, tm3, tm5);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_app_is_given_by_ctor_9(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm2: TermListNode,
        tm1: Ident,
        tm4: ArgDeclListNode,
        tm3: CtorDeclNode,
        tm5: EnumDeclNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .is_given_by_ctor
                .iter_all_0_1(tm0, tm5)
                .next()
                .is_some();
            if !exists_already {
                delta.new_is_given_by_ctor.push(IsGivenByCtor(tm0, tm5));
            }
        }
    }

    #[allow(unused_variables)]
    fn function_can_be_made_defined_if_codomain_normal_type_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.function_can_be_made_defined_if_codomain_normal_type_1(delta);
            self.function_can_be_made_defined_if_codomain_normal_type_2(delta);
            self.function_can_be_made_defined_if_codomain_normal_type_5(delta);
            self.function_can_be_made_defined_if_codomain_normal_type_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn function_can_be_made_defined_if_codomain_normal_type_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn function_can_be_made_defined_if_codomain_normal_type_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TypeDecl(tm0, tm1) in self.type_decl.iter_dirty() {
                self.function_can_be_made_defined_if_codomain_normal_type_3(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn function_can_be_made_defined_if_codomain_normal_type_3(
        &self,
        delta: &mut ModelDelta,
        tm0: TypeDeclNode,
        tm1: Ident,
    ) {
        for _ in [()] {
            self.function_can_be_made_defined_if_codomain_normal_type_4(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn function_can_be_made_defined_if_codomain_normal_type_4(
        &self,
        delta: &mut ModelDelta,
        tm0: TypeDeclNode,
        tm1: Ident,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticType(_, tm2) in self.semantic_type.iter_all_0(tm1) {
                self.function_can_be_made_defined_if_codomain_normal_type_6(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn function_can_be_made_defined_if_codomain_normal_type_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticType(tm1, tm2) in self.semantic_type.iter_dirty() {
                #[allow(unused_variables)]
                for TypeDecl(tm0, _) in self.type_decl.iter_all_1(tm1) {
                    self.function_can_be_made_defined_if_codomain_normal_type_6(
                        delta, tm0, tm1, tm2,
                    );
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn function_can_be_made_defined_if_codomain_normal_type_6(
        &self,
        delta: &mut ModelDelta,
        tm0: TypeDeclNode,
        tm1: Ident,
        tm2: Type,
    ) {
        for _ in [()] {
            self.function_can_be_made_defined_if_codomain_normal_type_7(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn function_can_be_made_defined_if_codomain_normal_type_7(
        &self,
        delta: &mut ModelDelta,
        tm0: TypeDeclNode,
        tm1: Ident,
        tm2: Type,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Codomain(tm3, _) in self.codomain.iter_all_1(tm2) {
                self.function_can_be_made_defined_if_codomain_normal_type_9(
                    delta, tm0, tm1, tm3, tm2,
                );
            }
        }
    }

    #[allow(unused_variables)]
    fn function_can_be_made_defined_if_codomain_normal_type_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for Codomain(tm3, tm2) in self.codomain.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticType(tm1, _) in self.semantic_type.iter_all_1(tm2) {
                    #[allow(unused_variables)]
                    for TypeDecl(tm0, _) in self.type_decl.iter_all_1(tm1) {
                        self.function_can_be_made_defined_if_codomain_normal_type_9(
                            delta, tm0, tm1, tm3, tm2,
                        );
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn function_can_be_made_defined_if_codomain_normal_type_9(
        &self,
        delta: &mut ModelDelta,
        tm0: TypeDeclNode,
        tm1: Ident,
        tm3: Func,
        tm2: Type,
    ) {
        for _ in [()] {
            let exists_already = self
                .function_can_be_made_defined
                .iter_all_0(tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_function_can_be_made_defined
                    .push(FunctionCanBeMadeDefined(tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn function_can_be_defined_if_constructor_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.function_can_be_defined_if_constructor_1(delta);
            self.function_can_be_defined_if_constructor_2(delta);
            self.function_can_be_defined_if_constructor_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn function_can_be_defined_if_constructor_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn function_can_be_defined_if_constructor_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorDecl(tm0, tm1, tm2) in self.ctor_decl.iter_dirty() {
                self.function_can_be_defined_if_constructor_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn function_can_be_defined_if_constructor_3(
        &self,
        delta: &mut ModelDelta,
        tm0: CtorDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
    ) {
        for _ in [()] {
            self.function_can_be_defined_if_constructor_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn function_can_be_defined_if_constructor_4(
        &self,
        delta: &mut ModelDelta,
        tm0: CtorDeclNode,
        tm1: Ident,
        tm2: ArgDeclListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticFunc(_, tm3) in self.semantic_func.iter_all_0(tm1) {
                self.function_can_be_defined_if_constructor_6(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn function_can_be_defined_if_constructor_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticFunc(tm1, tm3) in self.semantic_func.iter_dirty() {
                #[allow(unused_variables)]
                for CtorDecl(tm0, _, tm2) in self.ctor_decl.iter_all_1(tm1) {
                    self.function_can_be_defined_if_constructor_6(delta, tm0, tm2, tm1, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn function_can_be_defined_if_constructor_6(
        &self,
        delta: &mut ModelDelta,
        tm0: CtorDeclNode,
        tm2: ArgDeclListNode,
        tm1: Ident,
        tm3: Func,
    ) {
        for _ in [()] {
            let exists_already = self
                .function_can_be_made_defined
                .iter_all_0(tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_function_can_be_made_defined
                    .push(FunctionCanBeMadeDefined(tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_is_variable_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.case_pattern_is_variable_defined_1(delta);
            self.case_pattern_is_variable_defined_2(delta);
            self.case_pattern_is_variable_defined_5(delta);
            self.case_pattern_is_variable_defined_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_is_variable_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn case_pattern_is_variable_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchCase(tm0, tm1, tm2) in self.match_case.iter_dirty() {
                self.case_pattern_is_variable_defined_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_is_variable_defined_3(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: TermNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            self.case_pattern_is_variable_defined_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_is_variable_defined_4(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: TermNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for VarTermNode(_, tm3) in self.var_term_node.iter_all_0(tm1) {
                self.case_pattern_is_variable_defined_6(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_is_variable_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for VarTermNode(tm1, tm3) in self.var_term_node.iter_dirty() {
                #[allow(unused_variables)]
                for MatchCase(tm0, _, tm2) in self.match_case.iter_all_1(tm1) {
                    self.case_pattern_is_variable_defined_6(delta, tm0, tm2, tm1, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_is_variable_defined_6(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm2: StmtListNode,
        tm1: TermNode,
        tm3: VirtIdent,
    ) {
        for _ in [()] {
            self.case_pattern_is_variable_defined_7(delta, tm0, tm2, tm1, tm3);
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_is_variable_defined_7(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm2: StmtListNode,
        tm1: TermNode,
        tm3: VirtIdent,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermNodeLoc(_, tm4) in self.term_node_loc.iter_all_0(tm1) {
                self.case_pattern_is_variable_defined_9(delta, tm0, tm2, tm3, tm1, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_is_variable_defined_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermNodeLoc(tm1, tm4) in self.term_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for VarTermNode(_, tm3) in self.var_term_node.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for MatchCase(tm0, _, tm2) in self.match_case.iter_all_1(tm1) {
                        self.case_pattern_is_variable_defined_9(delta, tm0, tm2, tm3, tm1, tm4);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_is_variable_defined_9(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm2: StmtListNode,
        tm3: VirtIdent,
        tm1: TermNode,
        tm4: Loc,
    ) {
        for _ in [()] {
            let exists_already = self
                .case_pattern_is_variable
                .iter_all_0(tm4)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_case_pattern_is_variable
                    .push(CasePatternIsVariable(tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_is_wildcard_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.case_pattern_is_wildcard_defined_1(delta);
            self.case_pattern_is_wildcard_defined_2(delta);
            self.case_pattern_is_wildcard_defined_5(delta);
            self.case_pattern_is_wildcard_defined_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_is_wildcard_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn case_pattern_is_wildcard_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchCase(tm0, tm1, tm2) in self.match_case.iter_dirty() {
                self.case_pattern_is_wildcard_defined_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_is_wildcard_defined_3(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: TermNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            self.case_pattern_is_wildcard_defined_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_is_wildcard_defined_4(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: TermNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for WildcardTermNode(_) in self.wildcard_term_node.iter_all_0(tm1) {
                self.case_pattern_is_wildcard_defined_6(delta, tm0, tm2, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_is_wildcard_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for WildcardTermNode(tm1) in self.wildcard_term_node.iter_dirty() {
                #[allow(unused_variables)]
                for MatchCase(tm0, _, tm2) in self.match_case.iter_all_1(tm1) {
                    self.case_pattern_is_wildcard_defined_6(delta, tm0, tm2, tm1);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_is_wildcard_defined_6(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm2: StmtListNode,
        tm1: TermNode,
    ) {
        for _ in [()] {
            self.case_pattern_is_wildcard_defined_7(delta, tm0, tm2, tm1);
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_is_wildcard_defined_7(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm2: StmtListNode,
        tm1: TermNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermNodeLoc(_, tm3) in self.term_node_loc.iter_all_0(tm1) {
                self.case_pattern_is_wildcard_defined_9(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_is_wildcard_defined_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermNodeLoc(tm1, tm3) in self.term_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for WildcardTermNode(_) in self.wildcard_term_node.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for MatchCase(tm0, _, tm2) in self.match_case.iter_all_1(tm1) {
                        self.case_pattern_is_wildcard_defined_9(delta, tm0, tm2, tm1, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_is_wildcard_defined_9(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm2: StmtListNode,
        tm1: TermNode,
        tm3: Loc,
    ) {
        for _ in [()] {
            let exists_already = self
                .case_pattern_is_wildcard
                .iter_all_0(tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_case_pattern_is_wildcard
                    .push(CasePatternIsWildcard(tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_app_should_be_constructor_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.case_pattern_app_should_be_constructor_1(delta);
            self.case_pattern_app_should_be_constructor_2(delta);
            self.case_pattern_app_should_be_constructor_5(delta);
            self.case_pattern_app_should_be_constructor_8(delta);
            self.case_pattern_app_should_be_constructor_11(delta);
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_app_should_be_constructor_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn case_pattern_app_should_be_constructor_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchCase(tm0, tm1, tm2) in self.match_case.iter_dirty() {
                self.case_pattern_app_should_be_constructor_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_app_should_be_constructor_3(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: TermNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            self.case_pattern_app_should_be_constructor_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_app_should_be_constructor_4(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: TermNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for AppTermNode(_, tm3, tm4) in self.app_term_node.iter_all_0(tm1) {
                self.case_pattern_app_should_be_constructor_6(delta, tm0, tm2, tm1, tm3, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_app_should_be_constructor_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for AppTermNode(tm1, tm3, tm4) in self.app_term_node.iter_dirty() {
                #[allow(unused_variables)]
                for MatchCase(tm0, _, tm2) in self.match_case.iter_all_1(tm1) {
                    self.case_pattern_app_should_be_constructor_6(delta, tm0, tm2, tm1, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_app_should_be_constructor_6(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm2: StmtListNode,
        tm1: TermNode,
        tm3: Ident,
        tm4: TermListNode,
    ) {
        for _ in [()] {
            self.case_pattern_app_should_be_constructor_7(delta, tm0, tm2, tm1, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_app_should_be_constructor_7(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm2: StmtListNode,
        tm1: TermNode,
        tm3: Ident,
        tm4: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermNodeLoc(_, tm5) in self.term_node_loc.iter_all_0(tm1) {
                self.case_pattern_app_should_be_constructor_9(delta, tm0, tm2, tm3, tm4, tm1, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_app_should_be_constructor_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermNodeLoc(tm1, tm5) in self.term_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for MatchCase(tm0, _, tm2) in self.match_case.iter_all_1(tm1) {
                    #[allow(unused_variables)]
                    for AppTermNode(_, tm3, tm4) in self.app_term_node.iter_all_0(tm1) {
                        self.case_pattern_app_should_be_constructor_9(
                            delta, tm0, tm2, tm3, tm4, tm1, tm5,
                        );
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_app_should_be_constructor_9(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm2: StmtListNode,
        tm3: Ident,
        tm4: TermListNode,
        tm1: TermNode,
        tm5: Loc,
    ) {
        for _ in [()] {
            self.case_pattern_app_should_be_constructor_10(delta, tm0, tm2, tm3, tm4, tm1, tm5);
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_app_should_be_constructor_10(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm2: StmtListNode,
        tm3: Ident,
        tm4: TermListNode,
        tm1: TermNode,
        tm5: Loc,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorSymbol(tm6) in self.ctor_symbol.iter_all() {
                self.case_pattern_app_should_be_constructor_12(
                    delta, tm0, tm2, tm3, tm4, tm1, tm5, tm6,
                );
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_app_should_be_constructor_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorSymbol(tm6) in self.ctor_symbol.iter_dirty() {
                #[allow(unused_variables)]
                for TermNodeLoc(tm1, tm5) in self.term_node_loc.iter_all() {
                    #[allow(unused_variables)]
                    for AppTermNode(_, tm3, tm4) in self.app_term_node.iter_all_0(tm1) {
                        #[allow(unused_variables)]
                        for MatchCase(tm0, _, tm2) in self.match_case.iter_all_1(tm1) {
                            self.case_pattern_app_should_be_constructor_12(
                                delta, tm0, tm2, tm3, tm4, tm1, tm5, tm6,
                            );
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn case_pattern_app_should_be_constructor_12(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm2: StmtListNode,
        tm3: Ident,
        tm4: TermListNode,
        tm1: TermNode,
        tm5: Loc,
        tm6: SymbolKind,
    ) {
        for _ in [()] {
            let exists_already = self
                .should_be_symbol
                .iter_all_0_1_2(tm3, tm6, tm5)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_should_be_symbol
                    .push(ShouldBeSymbol(tm3, tm6, tm5));
            }
        }
    }

    #[allow(unused_variables)]
    fn match_case_pattern_ctor_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.match_case_pattern_ctor_defined_1(delta);
            self.match_case_pattern_ctor_defined_2(delta);
            self.match_case_pattern_ctor_defined_5(delta);
            self.match_case_pattern_ctor_defined_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn match_case_pattern_ctor_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn match_case_pattern_ctor_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchCase(tm0, tm1, tm2) in self.match_case.iter_dirty() {
                self.match_case_pattern_ctor_defined_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn match_case_pattern_ctor_defined_3(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: TermNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            self.match_case_pattern_ctor_defined_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn match_case_pattern_ctor_defined_4(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: TermNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for AppTermNode(_, tm3, tm4) in self.app_term_node.iter_all_0(tm1) {
                self.match_case_pattern_ctor_defined_6(delta, tm0, tm2, tm1, tm3, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn match_case_pattern_ctor_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for AppTermNode(tm1, tm3, tm4) in self.app_term_node.iter_dirty() {
                #[allow(unused_variables)]
                for MatchCase(tm0, _, tm2) in self.match_case.iter_all_1(tm1) {
                    self.match_case_pattern_ctor_defined_6(delta, tm0, tm2, tm1, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_case_pattern_ctor_defined_6(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm2: StmtListNode,
        tm1: TermNode,
        tm3: Ident,
        tm4: TermListNode,
    ) {
        for _ in [()] {
            self.match_case_pattern_ctor_defined_7(delta, tm0, tm2, tm1, tm3, tm4);
        }
    }

    #[allow(unused_variables)]
    fn match_case_pattern_ctor_defined_7(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm2: StmtListNode,
        tm1: TermNode,
        tm3: Ident,
        tm4: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorDecl(tm5, _, tm6) in self.ctor_decl.iter_all_1(tm3) {
                self.match_case_pattern_ctor_defined_9(delta, tm0, tm2, tm1, tm4, tm5, tm3, tm6);
            }
        }
    }

    #[allow(unused_variables)]
    fn match_case_pattern_ctor_defined_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorDecl(tm5, tm3, tm6) in self.ctor_decl.iter_dirty() {
                #[allow(unused_variables)]
                for AppTermNode(tm1, _, tm4) in self.app_term_node.iter_all_1(tm3) {
                    #[allow(unused_variables)]
                    for MatchCase(tm0, _, tm2) in self.match_case.iter_all_1(tm1) {
                        self.match_case_pattern_ctor_defined_9(
                            delta, tm0, tm2, tm1, tm4, tm5, tm3, tm6,
                        );
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_case_pattern_ctor_defined_9(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm2: StmtListNode,
        tm1: TermNode,
        tm4: TermListNode,
        tm5: CtorDeclNode,
        tm3: Ident,
        tm6: ArgDeclListNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .match_case_pattern_ctor
                .iter_all_0_1(tm0, tm5)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_match_case_pattern_ctor
                    .push(MatchCasePatternCtor(tm0, tm5));
            }
        }
    }

    #[allow(unused_variables)]
    fn is_pattern_ctor_arg_cons_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.is_pattern_ctor_arg_cons_1(delta);
            self.is_pattern_ctor_arg_cons_2(delta);
            self.is_pattern_ctor_arg_cons_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn is_pattern_ctor_arg_cons_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn is_pattern_ctor_arg_cons_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ArePatternCtorArgs(tm0) in self.are_pattern_ctor_args.iter_dirty() {
                self.is_pattern_ctor_arg_cons_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn is_pattern_ctor_arg_cons_3(&self, delta: &mut ModelDelta, tm0: TermListNode) {
        for _ in [()] {
            self.is_pattern_ctor_arg_cons_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn is_pattern_ctor_arg_cons_4(&self, delta: &mut ModelDelta, tm0: TermListNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsTermListNode(_, tm1, tm2) in self.cons_term_list_node.iter_all_0(tm0) {
                self.is_pattern_ctor_arg_cons_6(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn is_pattern_ctor_arg_cons_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsTermListNode(tm0, tm1, tm2) in self.cons_term_list_node.iter_dirty() {
                #[allow(unused_variables)]
                for ArePatternCtorArgs(_) in self.are_pattern_ctor_args.iter_all_0(tm0) {
                    self.is_pattern_ctor_arg_cons_6(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn is_pattern_ctor_arg_cons_6(
        &self,
        delta: &mut ModelDelta,
        tm0: TermListNode,
        tm1: TermNode,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            let exists_already = self.is_pattern_ctor_arg.iter_all_0(tm1).next().is_some();
            if !exists_already {
                delta.new_is_pattern_ctor_arg.push(IsPatternCtorArg(tm1));
            }

            let exists_already = self.are_pattern_ctor_args.iter_all_0(tm2).next().is_some();
            if !exists_already {
                delta
                    .new_are_pattern_ctor_args
                    .push(ArePatternCtorArgs(tm2));
            }
        }
    }

    #[allow(unused_variables)]
    fn are_pattern_ctor_args_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.are_pattern_ctor_args_defined_1(delta);
            self.are_pattern_ctor_args_defined_2(delta);
            self.are_pattern_ctor_args_defined_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn are_pattern_ctor_args_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn are_pattern_ctor_args_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchCase(tm0, tm1, tm2) in self.match_case.iter_dirty() {
                self.are_pattern_ctor_args_defined_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn are_pattern_ctor_args_defined_3(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: TermNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            self.are_pattern_ctor_args_defined_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn are_pattern_ctor_args_defined_4(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm1: TermNode,
        tm2: StmtListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for AppTermNode(_, tm3, tm4) in self.app_term_node.iter_all_0(tm1) {
                self.are_pattern_ctor_args_defined_6(delta, tm0, tm2, tm1, tm3, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn are_pattern_ctor_args_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for AppTermNode(tm1, tm3, tm4) in self.app_term_node.iter_dirty() {
                #[allow(unused_variables)]
                for MatchCase(tm0, _, tm2) in self.match_case.iter_all_1(tm1) {
                    self.are_pattern_ctor_args_defined_6(delta, tm0, tm2, tm1, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn are_pattern_ctor_args_defined_6(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseNode,
        tm2: StmtListNode,
        tm1: TermNode,
        tm3: Ident,
        tm4: TermListNode,
    ) {
        for _ in [()] {
            let exists_already = self.are_pattern_ctor_args.iter_all_0(tm4).next().is_some();
            if !exists_already {
                delta
                    .new_are_pattern_ctor_args
                    .push(ArePatternCtorArgs(tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_is_app_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.pattern_ctor_arg_is_app_defined_1(delta);
            self.pattern_ctor_arg_is_app_defined_2(delta);
            self.pattern_ctor_arg_is_app_defined_5(delta);
            self.pattern_ctor_arg_is_app_defined_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_is_app_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_is_app_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IsPatternCtorArg(tm0) in self.is_pattern_ctor_arg.iter_dirty() {
                self.pattern_ctor_arg_is_app_defined_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_is_app_defined_3(&self, delta: &mut ModelDelta, tm0: TermNode) {
        for _ in [()] {
            self.pattern_ctor_arg_is_app_defined_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_is_app_defined_4(&self, delta: &mut ModelDelta, tm0: TermNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for AppTermNode(_, tm1, tm2) in self.app_term_node.iter_all_0(tm0) {
                self.pattern_ctor_arg_is_app_defined_6(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_is_app_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for AppTermNode(tm0, tm1, tm2) in self.app_term_node.iter_dirty() {
                #[allow(unused_variables)]
                for IsPatternCtorArg(_) in self.is_pattern_ctor_arg.iter_all_0(tm0) {
                    self.pattern_ctor_arg_is_app_defined_6(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_is_app_defined_6(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            self.pattern_ctor_arg_is_app_defined_7(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_is_app_defined_7(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm2: TermListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermNodeLoc(_, tm3) in self.term_node_loc.iter_all_0(tm0) {
                self.pattern_ctor_arg_is_app_defined_9(delta, tm1, tm2, tm0, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_is_app_defined_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermNodeLoc(tm0, tm3) in self.term_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for IsPatternCtorArg(_) in self.is_pattern_ctor_arg.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for AppTermNode(_, tm1, tm2) in self.app_term_node.iter_all_0(tm0) {
                        self.pattern_ctor_arg_is_app_defined_9(delta, tm1, tm2, tm0, tm3);
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_is_app_defined_9(
        &self,
        delta: &mut ModelDelta,
        tm1: Ident,
        tm2: TermListNode,
        tm0: TermNode,
        tm3: Loc,
    ) {
        for _ in [()] {
            let exists_already = self
                .pattern_ctor_arg_is_app
                .iter_all_0(tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_pattern_ctor_arg_is_app
                    .push(PatternCtorArgIsApp(tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_var_is_not_fresh_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.pattern_ctor_arg_var_is_not_fresh_defined_1(delta);
            self.pattern_ctor_arg_var_is_not_fresh_defined_2(delta);
            self.pattern_ctor_arg_var_is_not_fresh_defined_5(delta);
            self.pattern_ctor_arg_var_is_not_fresh_defined_8(delta);
            self.pattern_ctor_arg_var_is_not_fresh_defined_9(delta);
            self.pattern_ctor_arg_var_is_not_fresh_defined_12(delta);
            self.pattern_ctor_arg_var_is_not_fresh_defined_15(delta);
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_var_is_not_fresh_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_var_is_not_fresh_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for IsPatternCtorArg(tm0) in self.is_pattern_ctor_arg.iter_dirty() {
                self.pattern_ctor_arg_var_is_not_fresh_defined_3(delta, tm0);
            }
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_var_is_not_fresh_defined_3(&self, delta: &mut ModelDelta, tm0: TermNode) {
        for _ in [()] {
            self.pattern_ctor_arg_var_is_not_fresh_defined_4(delta, tm0);
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_var_is_not_fresh_defined_4(&self, delta: &mut ModelDelta, tm0: TermNode) {
        for _ in [()] {
            #[allow(unused_variables)]
            for VarTermNode(_, tm1) in self.var_term_node.iter_all_0(tm0) {
                self.pattern_ctor_arg_var_is_not_fresh_defined_6(delta, tm0, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_var_is_not_fresh_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for VarTermNode(tm0, tm1) in self.var_term_node.iter_dirty() {
                #[allow(unused_variables)]
                for IsPatternCtorArg(_) in self.is_pattern_ctor_arg.iter_all_0(tm0) {
                    self.pattern_ctor_arg_var_is_not_fresh_defined_6(delta, tm0, tm1);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_var_is_not_fresh_defined_6(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: VirtIdent,
    ) {
        for _ in [()] {
            self.pattern_ctor_arg_var_is_not_fresh_defined_7(delta, tm0, tm1);
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_var_is_not_fresh_defined_7(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: VirtIdent,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(_, tm2) in self.rule_descendant_term.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for EntryScope(_, tm3) in self.entry_scope.iter_all_0(tm2) {
                    self.pattern_ctor_arg_var_is_not_fresh_defined_10(delta, tm1, tm0, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_var_is_not_fresh_defined_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for RuleDescendantTerm(tm0, tm2) in self.rule_descendant_term.iter_dirty() {
                #[allow(unused_variables)]
                for IsPatternCtorArg(_) in self.is_pattern_ctor_arg.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for EntryScope(_, tm3) in self.entry_scope.iter_all_0(tm2) {
                        #[allow(unused_variables)]
                        for VarTermNode(_, tm1) in self.var_term_node.iter_all_0(tm0) {
                            self.pattern_ctor_arg_var_is_not_fresh_defined_10(
                                delta, tm1, tm0, tm2, tm3,
                            );
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_var_is_not_fresh_defined_9(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EntryScope(tm2, tm3) in self.entry_scope.iter_dirty() {
                #[allow(unused_variables)]
                for IsPatternCtorArg(tm0) in self.is_pattern_ctor_arg.iter_all() {
                    #[allow(unused_variables)]
                    for RuleDescendantTerm(_, _) in self.rule_descendant_term.iter_all_0_1(tm0, tm2)
                    {
                        #[allow(unused_variables)]
                        for VarTermNode(_, tm1) in self.var_term_node.iter_all_0(tm0) {
                            self.pattern_ctor_arg_var_is_not_fresh_defined_10(
                                delta, tm1, tm0, tm2, tm3,
                            );
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_var_is_not_fresh_defined_10(
        &self,
        delta: &mut ModelDelta,
        tm1: VirtIdent,
        tm0: TermNode,
        tm2: RuleDescendantNode,
        tm3: Scope,
    ) {
        for _ in [()] {
            self.pattern_ctor_arg_var_is_not_fresh_defined_11(delta, tm1, tm0, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_var_is_not_fresh_defined_11(
        &self,
        delta: &mut ModelDelta,
        tm1: VirtIdent,
        tm0: TermNode,
        tm2: RuleDescendantNode,
        tm3: Scope,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for VarInScope(_, _) in self.var_in_scope.iter_all_0_1(tm1, tm3) {
                self.pattern_ctor_arg_var_is_not_fresh_defined_13(delta, tm0, tm2, tm3, tm1);
            }
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_var_is_not_fresh_defined_12(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for VarInScope(tm1, tm3) in self.var_in_scope.iter_dirty() {
                #[allow(unused_variables)]
                for EntryScope(tm2, _) in self.entry_scope.iter_all_1(tm3) {
                    #[allow(unused_variables)]
                    for VarTermNode(tm0, _) in self.var_term_node.iter_all_1(tm1) {
                        #[allow(unused_variables)]
                        for IsPatternCtorArg(_) in self.is_pattern_ctor_arg.iter_all_0(tm0) {
                            #[allow(unused_variables)]
                            for RuleDescendantTerm(_, _) in
                                self.rule_descendant_term.iter_all_0_1(tm0, tm2)
                            {
                                self.pattern_ctor_arg_var_is_not_fresh_defined_13(
                                    delta, tm0, tm2, tm3, tm1,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_var_is_not_fresh_defined_13(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm2: RuleDescendantNode,
        tm3: Scope,
        tm1: VirtIdent,
    ) {
        for _ in [()] {
            self.pattern_ctor_arg_var_is_not_fresh_defined_14(delta, tm0, tm2, tm3, tm1);
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_var_is_not_fresh_defined_14(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm2: RuleDescendantNode,
        tm3: Scope,
        tm1: VirtIdent,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermNodeLoc(_, tm4) in self.term_node_loc.iter_all_0(tm0) {
                self.pattern_ctor_arg_var_is_not_fresh_defined_16(delta, tm2, tm3, tm1, tm0, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_var_is_not_fresh_defined_15(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for TermNodeLoc(tm0, tm4) in self.term_node_loc.iter_dirty() {
                #[allow(unused_variables)]
                for IsPatternCtorArg(_) in self.is_pattern_ctor_arg.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleDescendantTerm(_, tm2) in self.rule_descendant_term.iter_all_0(tm0) {
                        #[allow(unused_variables)]
                        for EntryScope(_, tm3) in self.entry_scope.iter_all_0(tm2) {
                            #[allow(unused_variables)]
                            for VarTermNode(_, tm1) in self.var_term_node.iter_all_0(tm0) {
                                #[allow(unused_variables)]
                                for VarInScope(_, _) in self.var_in_scope.iter_all_0_1(tm1, tm3) {
                                    self.pattern_ctor_arg_var_is_not_fresh_defined_16(
                                        delta, tm2, tm3, tm1, tm0, tm4,
                                    );
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn pattern_ctor_arg_var_is_not_fresh_defined_16(
        &self,
        delta: &mut ModelDelta,
        tm2: RuleDescendantNode,
        tm3: Scope,
        tm1: VirtIdent,
        tm0: TermNode,
        tm4: Loc,
    ) {
        for _ in [()] {
            let exists_already = self
                .pattern_ctor_arg_var_is_not_fresh
                .iter_all_0(tm4)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_pattern_ctor_arg_var_is_not_fresh
                    .push(PatternCtorArgVarIsNotFresh(tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn contains_ctor_case_head_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.contains_ctor_case_head_1(delta);
            self.contains_ctor_case_head_2(delta);
            self.contains_ctor_case_head_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn contains_ctor_case_head_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn contains_ctor_case_head_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsMatchCaseListNode(tm0, tm1, tm2) in self.cons_match_case_list_node.iter_dirty()
            {
                self.contains_ctor_case_head_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn contains_ctor_case_head_3(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: MatchCaseNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            self.contains_ctor_case_head_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn contains_ctor_case_head_4(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: MatchCaseNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchCasePatternCtor(_, tm3) in self.match_case_pattern_ctor.iter_all_0(tm1) {
                self.contains_ctor_case_head_6(delta, tm0, tm2, tm1, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn contains_ctor_case_head_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchCasePatternCtor(tm1, tm3) in self.match_case_pattern_ctor.iter_dirty() {
                #[allow(unused_variables)]
                for ConsMatchCaseListNode(tm0, _, tm2) in
                    self.cons_match_case_list_node.iter_all_1(tm1)
                {
                    self.contains_ctor_case_head_6(delta, tm0, tm2, tm1, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn contains_ctor_case_head_6(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm2: MatchCaseListNode,
        tm1: MatchCaseNode,
        tm3: CtorDeclNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .cases_contain_ctor
                .iter_all_0_1(tm0, tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_cases_contain_ctor
                    .push(CasesContainCtor(tm0, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn contains_ctor_case_tail_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.contains_ctor_case_tail_1(delta);
            self.contains_ctor_case_tail_2(delta);
            self.contains_ctor_case_tail_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn contains_ctor_case_tail_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn contains_ctor_case_tail_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsMatchCaseListNode(tm0, tm1, tm2) in self.cons_match_case_list_node.iter_dirty()
            {
                self.contains_ctor_case_tail_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn contains_ctor_case_tail_3(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: MatchCaseNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            self.contains_ctor_case_tail_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn contains_ctor_case_tail_4(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: MatchCaseNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CasesContainCtor(_, tm3) in self.cases_contain_ctor.iter_all_0(tm2) {
                self.contains_ctor_case_tail_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn contains_ctor_case_tail_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CasesContainCtor(tm2, tm3) in self.cases_contain_ctor.iter_dirty() {
                #[allow(unused_variables)]
                for ConsMatchCaseListNode(tm0, tm1, _) in
                    self.cons_match_case_list_node.iter_all_2(tm2)
                {
                    self.contains_ctor_case_tail_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn contains_ctor_case_tail_6(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: MatchCaseNode,
        tm2: MatchCaseListNode,
        tm3: CtorDeclNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .cases_contain_ctor
                .iter_all_0_1(tm0, tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_cases_contain_ctor
                    .push(CasesContainCtor(tm0, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_contains_ctor_of_enum_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.match_stmt_contains_ctor_of_enum_defined_1(delta);
            self.match_stmt_contains_ctor_of_enum_defined_2(delta);
            self.match_stmt_contains_ctor_of_enum_defined_5(delta);
            self.match_stmt_contains_ctor_of_enum_defined_8(delta);
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_contains_ctor_of_enum_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn match_stmt_contains_ctor_of_enum_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchStmtNode(tm0, tm1, tm2) in self.match_stmt_node.iter_dirty() {
                self.match_stmt_contains_ctor_of_enum_defined_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_contains_ctor_of_enum_defined_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            self.match_stmt_contains_ctor_of_enum_defined_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_contains_ctor_of_enum_defined_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CasesContainCtor(_, tm3) in self.cases_contain_ctor.iter_all_0(tm2) {
                self.match_stmt_contains_ctor_of_enum_defined_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_contains_ctor_of_enum_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CasesContainCtor(tm2, tm3) in self.cases_contain_ctor.iter_dirty() {
                #[allow(unused_variables)]
                for MatchStmtNode(tm0, tm1, _) in self.match_stmt_node.iter_all_2(tm2) {
                    self.match_stmt_contains_ctor_of_enum_defined_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_contains_ctor_of_enum_defined_6(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm3: CtorDeclNode,
    ) {
        for _ in [()] {
            self.match_stmt_contains_ctor_of_enum_defined_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_contains_ctor_of_enum_defined_7(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm3: CtorDeclNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorEnum(_, tm4) in self.ctor_enum.iter_all_0(tm3) {
                self.match_stmt_contains_ctor_of_enum_defined_9(delta, tm0, tm1, tm2, tm3, tm4);
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_contains_ctor_of_enum_defined_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorEnum(tm3, tm4) in self.ctor_enum.iter_dirty() {
                #[allow(unused_variables)]
                for CasesContainCtor(tm2, _) in self.cases_contain_ctor.iter_all_1(tm3) {
                    #[allow(unused_variables)]
                    for MatchStmtNode(tm0, tm1, _) in self.match_stmt_node.iter_all_2(tm2) {
                        self.match_stmt_contains_ctor_of_enum_defined_9(
                            delta, tm0, tm1, tm2, tm3, tm4,
                        );
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_contains_ctor_of_enum_defined_9(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm3: CtorDeclNode,
        tm4: EnumDeclNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .match_stmt_contains_ctor_of_enum
                .iter_all_0_1_2(tm0, tm3, tm4)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_match_stmt_contains_ctor_of_enum
                    .push(MatchStmtContainsCtorOfEnum(tm0, tm3, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_singleton_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.ctor_cases_determine_enum_singleton_1(delta);
            self.ctor_cases_determine_enum_singleton_2(delta);
            self.ctor_cases_determine_enum_singleton_5(delta);
            self.ctor_cases_determine_enum_singleton_8(delta);
            self.ctor_cases_determine_enum_singleton_9(delta);
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_singleton_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_singleton_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsMatchCaseListNode(tm0, tm1, tm2) in self.cons_match_case_list_node.iter_dirty()
            {
                self.ctor_cases_determine_enum_singleton_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_singleton_3(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: MatchCaseNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            self.ctor_cases_determine_enum_singleton_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_singleton_4(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: MatchCaseNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilMatchCaseListNode(_) in self.nil_match_case_list_node.iter_all_0(tm2) {
                self.ctor_cases_determine_enum_singleton_6(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_singleton_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for NilMatchCaseListNode(tm2) in self.nil_match_case_list_node.iter_dirty() {
                #[allow(unused_variables)]
                for ConsMatchCaseListNode(tm0, tm1, _) in
                    self.cons_match_case_list_node.iter_all_2(tm2)
                {
                    self.ctor_cases_determine_enum_singleton_6(delta, tm0, tm1, tm2);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_singleton_6(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: MatchCaseNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            self.ctor_cases_determine_enum_singleton_7(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_singleton_7(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: MatchCaseNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchCasePatternCtor(_, tm3) in self.match_case_pattern_ctor.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for CtorEnum(_, tm4) in self.ctor_enum.iter_all_0(tm3) {
                    self.ctor_cases_determine_enum_singleton_10(delta, tm0, tm2, tm1, tm3, tm4);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_singleton_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorEnum(tm3, tm4) in self.ctor_enum.iter_dirty() {
                #[allow(unused_variables)]
                for NilMatchCaseListNode(tm2) in self.nil_match_case_list_node.iter_all() {
                    #[allow(unused_variables)]
                    for MatchCasePatternCtor(tm1, _) in self.match_case_pattern_ctor.iter_all_1(tm3)
                    {
                        #[allow(unused_variables)]
                        for ConsMatchCaseListNode(tm0, _, _) in
                            self.cons_match_case_list_node.iter_all_1_2(tm1, tm2)
                        {
                            self.ctor_cases_determine_enum_singleton_10(
                                delta, tm0, tm2, tm1, tm3, tm4,
                            );
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_singleton_9(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchCasePatternCtor(tm1, tm3) in self.match_case_pattern_ctor.iter_dirty() {
                #[allow(unused_variables)]
                for NilMatchCaseListNode(tm2) in self.nil_match_case_list_node.iter_all() {
                    #[allow(unused_variables)]
                    for ConsMatchCaseListNode(tm0, _, _) in
                        self.cons_match_case_list_node.iter_all_1_2(tm1, tm2)
                    {
                        #[allow(unused_variables)]
                        for CtorEnum(_, tm4) in self.ctor_enum.iter_all_0(tm3) {
                            self.ctor_cases_determine_enum_singleton_10(
                                delta, tm0, tm2, tm1, tm3, tm4,
                            );
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_singleton_10(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm2: MatchCaseListNode,
        tm1: MatchCaseNode,
        tm3: CtorDeclNode,
        tm4: EnumDeclNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .cases_determined_enum
                .iter_all_0_1(tm0, tm4)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_cases_determined_enum
                    .push(CasesDeterminedEnum(tm0, tm4));
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_cons_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.ctor_cases_determine_enum_cons_1(delta);
            self.ctor_cases_determine_enum_cons_2(delta);
            self.ctor_cases_determine_enum_cons_5(delta);
            self.ctor_cases_determine_enum_cons_8(delta);
            self.ctor_cases_determine_enum_cons_9(delta);
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_cons_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_cons_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ConsMatchCaseListNode(tm0, tm1, tm2) in self.cons_match_case_list_node.iter_dirty()
            {
                self.ctor_cases_determine_enum_cons_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_cons_3(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: MatchCaseNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            self.ctor_cases_determine_enum_cons_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_cons_4(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: MatchCaseNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CasesDeterminedEnum(_, tm3) in self.cases_determined_enum.iter_all_0(tm2) {
                self.ctor_cases_determine_enum_cons_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_cons_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CasesDeterminedEnum(tm2, tm3) in self.cases_determined_enum.iter_dirty() {
                #[allow(unused_variables)]
                for ConsMatchCaseListNode(tm0, tm1, _) in
                    self.cons_match_case_list_node.iter_all_2(tm2)
                {
                    self.ctor_cases_determine_enum_cons_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_cons_6(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: MatchCaseNode,
        tm2: MatchCaseListNode,
        tm3: EnumDeclNode,
    ) {
        for _ in [()] {
            self.ctor_cases_determine_enum_cons_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_cons_7(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm1: MatchCaseNode,
        tm2: MatchCaseListNode,
        tm3: EnumDeclNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchCasePatternCtor(_, tm4) in self.match_case_pattern_ctor.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for CtorEnum(_, _) in self.ctor_enum.iter_all_0_1(tm4, tm3) {
                    self.ctor_cases_determine_enum_cons_10(delta, tm0, tm2, tm1, tm4, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_cons_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorEnum(tm4, tm3) in self.ctor_enum.iter_dirty() {
                #[allow(unused_variables)]
                for CasesDeterminedEnum(tm2, _) in self.cases_determined_enum.iter_all_1(tm3) {
                    #[allow(unused_variables)]
                    for MatchCasePatternCtor(tm1, _) in self.match_case_pattern_ctor.iter_all_1(tm4)
                    {
                        #[allow(unused_variables)]
                        for ConsMatchCaseListNode(tm0, _, _) in
                            self.cons_match_case_list_node.iter_all_1_2(tm1, tm2)
                        {
                            self.ctor_cases_determine_enum_cons_10(delta, tm0, tm2, tm1, tm4, tm3);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_cons_9(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchCasePatternCtor(tm1, tm4) in self.match_case_pattern_ctor.iter_dirty() {
                #[allow(unused_variables)]
                for CtorEnum(_, tm3) in self.ctor_enum.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for CasesDeterminedEnum(tm2, _) in self.cases_determined_enum.iter_all_1(tm3) {
                        #[allow(unused_variables)]
                        for ConsMatchCaseListNode(tm0, _, _) in
                            self.cons_match_case_list_node.iter_all_1_2(tm1, tm2)
                        {
                            self.ctor_cases_determine_enum_cons_10(delta, tm0, tm2, tm1, tm4, tm3);
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn ctor_cases_determine_enum_cons_10(
        &self,
        delta: &mut ModelDelta,
        tm0: MatchCaseListNode,
        tm2: MatchCaseListNode,
        tm1: MatchCaseNode,
        tm4: CtorDeclNode,
        tm3: EnumDeclNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .cases_determined_enum
                .iter_all_0_1(tm0, tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_cases_determined_enum
                    .push(CasesDeterminedEnum(tm0, tm3));
            }
        }
    }

    #[allow(unused_variables)]
    fn match_term_type_if_cases_determine_enum_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.match_term_type_if_cases_determine_enum_1(delta);
            self.match_term_type_if_cases_determine_enum_2(delta);
            self.match_term_type_if_cases_determine_enum_5(delta);
            self.match_term_type_if_cases_determine_enum_8(delta);
            self.match_term_type_if_cases_determine_enum_11(delta);
            self.match_term_type_if_cases_determine_enum_14(delta);
        }
    }

    #[allow(unused_variables)]
    fn match_term_type_if_cases_determine_enum_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn match_term_type_if_cases_determine_enum_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchStmtNode(tm0, tm1, tm2) in self.match_stmt_node.iter_dirty() {
                self.match_term_type_if_cases_determine_enum_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn match_term_type_if_cases_determine_enum_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            self.match_term_type_if_cases_determine_enum_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn match_term_type_if_cases_determine_enum_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CasesDeterminedEnum(_, tm3) in self.cases_determined_enum.iter_all_0(tm2) {
                self.match_term_type_if_cases_determine_enum_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn match_term_type_if_cases_determine_enum_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CasesDeterminedEnum(tm2, tm3) in self.cases_determined_enum.iter_dirty() {
                #[allow(unused_variables)]
                for MatchStmtNode(tm0, tm1, _) in self.match_stmt_node.iter_all_2(tm2) {
                    self.match_term_type_if_cases_determine_enum_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_term_type_if_cases_determine_enum_6(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm3: EnumDeclNode,
    ) {
        for _ in [()] {
            self.match_term_type_if_cases_determine_enum_7(delta, tm0, tm1, tm2, tm3);
        }
    }

    #[allow(unused_variables)]
    fn match_term_type_if_cases_determine_enum_7(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm3: EnumDeclNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumDecl(_, tm4, tm5) in self.enum_decl.iter_all_0(tm3) {
                self.match_term_type_if_cases_determine_enum_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);
            }
        }
    }

    #[allow(unused_variables)]
    fn match_term_type_if_cases_determine_enum_8(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumDecl(tm3, tm4, tm5) in self.enum_decl.iter_dirty() {
                #[allow(unused_variables)]
                for CasesDeterminedEnum(tm2, _) in self.cases_determined_enum.iter_all_1(tm3) {
                    #[allow(unused_variables)]
                    for MatchStmtNode(tm0, tm1, _) in self.match_stmt_node.iter_all_2(tm2) {
                        self.match_term_type_if_cases_determine_enum_9(
                            delta, tm0, tm1, tm2, tm3, tm4, tm5,
                        );
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_term_type_if_cases_determine_enum_9(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm3: EnumDeclNode,
        tm4: Ident,
        tm5: CtorDeclListNode,
    ) {
        for _ in [()] {
            self.match_term_type_if_cases_determine_enum_10(delta, tm0, tm1, tm2, tm3, tm4, tm5);
        }
    }

    #[allow(unused_variables)]
    fn match_term_type_if_cases_determine_enum_10(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm3: EnumDeclNode,
        tm4: Ident,
        tm5: CtorDeclListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticType(_, tm6) in self.semantic_type.iter_all_0(tm4) {
                self.match_term_type_if_cases_determine_enum_12(
                    delta, tm0, tm1, tm2, tm3, tm5, tm4, tm6,
                );
            }
        }
    }

    #[allow(unused_variables)]
    fn match_term_type_if_cases_determine_enum_11(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticType(tm4, tm6) in self.semantic_type.iter_dirty() {
                #[allow(unused_variables)]
                for CasesDeterminedEnum(tm2, tm3) in self.cases_determined_enum.iter_all() {
                    #[allow(unused_variables)]
                    for EnumDecl(_, _, tm5) in self.enum_decl.iter_all_0_1(tm3, tm4) {
                        #[allow(unused_variables)]
                        for MatchStmtNode(tm0, tm1, _) in self.match_stmt_node.iter_all_2(tm2) {
                            self.match_term_type_if_cases_determine_enum_12(
                                delta, tm0, tm1, tm2, tm3, tm5, tm4, tm6,
                            );
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_term_type_if_cases_determine_enum_12(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm3: EnumDeclNode,
        tm5: CtorDeclListNode,
        tm4: Ident,
        tm6: Type,
    ) {
        for _ in [()] {
            self.match_term_type_if_cases_determine_enum_13(
                delta, tm0, tm1, tm2, tm3, tm5, tm4, tm6,
            );
        }
    }

    #[allow(unused_variables)]
    fn match_term_type_if_cases_determine_enum_13(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm3: EnumDeclNode,
        tm5: CtorDeclListNode,
        tm4: Ident,
        tm6: Type,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(_, tm7, tm8) in self.semantic_el.iter_all_0(tm1) {
                self.match_term_type_if_cases_determine_enum_15(
                    delta, tm0, tm2, tm3, tm5, tm4, tm6, tm1, tm7, tm8,
                );
            }
        }
    }

    #[allow(unused_variables)]
    fn match_term_type_if_cases_determine_enum_14(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(tm1, tm7, tm8) in self.semantic_el.iter_dirty() {
                #[allow(unused_variables)]
                for CasesDeterminedEnum(tm2, tm3) in self.cases_determined_enum.iter_all() {
                    #[allow(unused_variables)]
                    for MatchStmtNode(tm0, _, _) in self.match_stmt_node.iter_all_1_2(tm1, tm2) {
                        #[allow(unused_variables)]
                        for EnumDecl(_, tm4, tm5) in self.enum_decl.iter_all_0(tm3) {
                            #[allow(unused_variables)]
                            for SemanticType(_, tm6) in self.semantic_type.iter_all_0(tm4) {
                                self.match_term_type_if_cases_determine_enum_15(
                                    delta, tm0, tm2, tm3, tm5, tm4, tm6, tm1, tm7, tm8,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_term_type_if_cases_determine_enum_15(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm2: MatchCaseListNode,
        tm3: EnumDeclNode,
        tm5: CtorDeclListNode,
        tm4: Ident,
        tm6: Type,
        tm1: TermNode,
        tm7: Structure,
        tm8: El,
    ) {
        for _ in [()] {
            let exists_already = self.el_type.iter_all_0_1(tm8, tm6).next().is_some();
            if !exists_already {
                delta.new_el_type.push(ElType(tm8, tm6));
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_should_contain_ctor_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.match_stmt_should_contain_ctor_defined_1(delta);
            self.match_stmt_should_contain_ctor_defined_2(delta);
            self.match_stmt_should_contain_ctor_defined_5(delta);
            self.match_stmt_should_contain_ctor_defined_6(delta);
            self.match_stmt_should_contain_ctor_defined_9(delta);
            self.match_stmt_should_contain_ctor_defined_12(delta);
            self.match_stmt_should_contain_ctor_defined_15(delta);
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_should_contain_ctor_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn match_stmt_should_contain_ctor_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchStmtNode(tm0, tm1, tm2) in self.match_stmt_node.iter_dirty() {
                self.match_stmt_should_contain_ctor_defined_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_should_contain_ctor_defined_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            self.match_stmt_should_contain_ctor_defined_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_should_contain_ctor_defined_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(_, tm3, tm4) in self.semantic_el.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for ElType(_, tm5) in self.el_type.iter_all_0(tm4) {
                    self.match_stmt_should_contain_ctor_defined_7(
                        delta, tm0, tm2, tm1, tm3, tm4, tm5,
                    );
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_should_contain_ctor_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for ElType(tm4, tm5) in self.el_type.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticEl(tm1, tm3, _) in self.semantic_el.iter_all_2(tm4) {
                    #[allow(unused_variables)]
                    for MatchStmtNode(tm0, _, tm2) in self.match_stmt_node.iter_all_1(tm1) {
                        self.match_stmt_should_contain_ctor_defined_7(
                            delta, tm0, tm2, tm1, tm3, tm4, tm5,
                        );
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_should_contain_ctor_defined_6(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticEl(tm1, tm3, tm4) in self.semantic_el.iter_dirty() {
                #[allow(unused_variables)]
                for ElType(_, tm5) in self.el_type.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for MatchStmtNode(tm0, _, tm2) in self.match_stmt_node.iter_all_1(tm1) {
                        self.match_stmt_should_contain_ctor_defined_7(
                            delta, tm0, tm2, tm1, tm3, tm4, tm5,
                        );
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_should_contain_ctor_defined_7(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm2: MatchCaseListNode,
        tm1: TermNode,
        tm3: Structure,
        tm4: El,
        tm5: Type,
    ) {
        for _ in [()] {
            self.match_stmt_should_contain_ctor_defined_8(delta, tm0, tm2, tm1, tm3, tm4, tm5);
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_should_contain_ctor_defined_8(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm2: MatchCaseListNode,
        tm1: TermNode,
        tm3: Structure,
        tm4: El,
        tm5: Type,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticType(tm6, _) in self.semantic_type.iter_all_1(tm5) {
                self.match_stmt_should_contain_ctor_defined_10(
                    delta, tm0, tm2, tm1, tm3, tm4, tm6, tm5,
                );
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_should_contain_ctor_defined_9(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for SemanticType(tm6, tm5) in self.semantic_type.iter_dirty() {
                #[allow(unused_variables)]
                for ElType(tm4, _) in self.el_type.iter_all_1(tm5) {
                    #[allow(unused_variables)]
                    for SemanticEl(tm1, tm3, _) in self.semantic_el.iter_all_2(tm4) {
                        #[allow(unused_variables)]
                        for MatchStmtNode(tm0, _, tm2) in self.match_stmt_node.iter_all_1(tm1) {
                            self.match_stmt_should_contain_ctor_defined_10(
                                delta, tm0, tm2, tm1, tm3, tm4, tm6, tm5,
                            );
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_should_contain_ctor_defined_10(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm2: MatchCaseListNode,
        tm1: TermNode,
        tm3: Structure,
        tm4: El,
        tm6: Ident,
        tm5: Type,
    ) {
        for _ in [()] {
            self.match_stmt_should_contain_ctor_defined_11(
                delta, tm0, tm2, tm1, tm3, tm4, tm6, tm5,
            );
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_should_contain_ctor_defined_11(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm2: MatchCaseListNode,
        tm1: TermNode,
        tm3: Structure,
        tm4: El,
        tm6: Ident,
        tm5: Type,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumDecl(tm7, _, tm8) in self.enum_decl.iter_all_1(tm6) {
                self.match_stmt_should_contain_ctor_defined_13(
                    delta, tm0, tm2, tm1, tm3, tm4, tm5, tm7, tm6, tm8,
                );
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_should_contain_ctor_defined_12(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for EnumDecl(tm7, tm6, tm8) in self.enum_decl.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticType(_, tm5) in self.semantic_type.iter_all_0(tm6) {
                    #[allow(unused_variables)]
                    for ElType(tm4, _) in self.el_type.iter_all_1(tm5) {
                        #[allow(unused_variables)]
                        for SemanticEl(tm1, tm3, _) in self.semantic_el.iter_all_2(tm4) {
                            #[allow(unused_variables)]
                            for MatchStmtNode(tm0, _, tm2) in self.match_stmt_node.iter_all_1(tm1) {
                                self.match_stmt_should_contain_ctor_defined_13(
                                    delta, tm0, tm2, tm1, tm3, tm4, tm5, tm7, tm6, tm8,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_should_contain_ctor_defined_13(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm2: MatchCaseListNode,
        tm1: TermNode,
        tm3: Structure,
        tm4: El,
        tm5: Type,
        tm7: EnumDeclNode,
        tm6: Ident,
        tm8: CtorDeclListNode,
    ) {
        for _ in [()] {
            self.match_stmt_should_contain_ctor_defined_14(
                delta, tm0, tm2, tm1, tm3, tm4, tm5, tm7, tm6, tm8,
            );
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_should_contain_ctor_defined_14(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm2: MatchCaseListNode,
        tm1: TermNode,
        tm3: Structure,
        tm4: El,
        tm5: Type,
        tm7: EnumDeclNode,
        tm6: Ident,
        tm8: CtorDeclListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorEnum(tm9, _) in self.ctor_enum.iter_all_1(tm7) {
                self.match_stmt_should_contain_ctor_defined_16(
                    delta, tm0, tm2, tm1, tm3, tm4, tm5, tm6, tm8, tm9, tm7,
                );
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_should_contain_ctor_defined_15(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CtorEnum(tm9, tm7) in self.ctor_enum.iter_dirty() {
                #[allow(unused_variables)]
                for SemanticType(tm6, tm5) in self.semantic_type.iter_all() {
                    #[allow(unused_variables)]
                    for EnumDecl(_, _, tm8) in self.enum_decl.iter_all_0_1(tm7, tm6) {
                        #[allow(unused_variables)]
                        for ElType(tm4, _) in self.el_type.iter_all_1(tm5) {
                            #[allow(unused_variables)]
                            for SemanticEl(tm1, tm3, _) in self.semantic_el.iter_all_2(tm4) {
                                #[allow(unused_variables)]
                                for MatchStmtNode(tm0, _, tm2) in
                                    self.match_stmt_node.iter_all_1(tm1)
                                {
                                    self.match_stmt_should_contain_ctor_defined_16(
                                        delta, tm0, tm2, tm1, tm3, tm4, tm5, tm6, tm8, tm9, tm7,
                                    );
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_should_contain_ctor_defined_16(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm2: MatchCaseListNode,
        tm1: TermNode,
        tm3: Structure,
        tm4: El,
        tm5: Type,
        tm6: Ident,
        tm8: CtorDeclListNode,
        tm9: CtorDeclNode,
        tm7: EnumDeclNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .match_stmt_should_contain_ctor
                .iter_all_0_1(tm0, tm9)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_match_stmt_should_contain_ctor
                    .push(MatchStmtShouldContainCtor(tm0, tm9));
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_contains_ctor_defined_0(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            self.match_stmt_contains_ctor_defined_1(delta);
            self.match_stmt_contains_ctor_defined_2(delta);
            self.match_stmt_contains_ctor_defined_5(delta);
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_contains_ctor_defined_1(&self, delta: &mut ModelDelta) {
        for _ in [()] {}
    }

    #[allow(unused_variables)]
    fn match_stmt_contains_ctor_defined_2(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for MatchStmtNode(tm0, tm1, tm2) in self.match_stmt_node.iter_dirty() {
                self.match_stmt_contains_ctor_defined_3(delta, tm0, tm1, tm2);
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_contains_ctor_defined_3(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            self.match_stmt_contains_ctor_defined_4(delta, tm0, tm1, tm2);
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_contains_ctor_defined_4(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
    ) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CasesContainCtor(_, tm3) in self.cases_contain_ctor.iter_all_0(tm2) {
                self.match_stmt_contains_ctor_defined_6(delta, tm0, tm1, tm2, tm3);
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_contains_ctor_defined_5(&self, delta: &mut ModelDelta) {
        for _ in [()] {
            #[allow(unused_variables)]
            for CasesContainCtor(tm2, tm3) in self.cases_contain_ctor.iter_dirty() {
                #[allow(unused_variables)]
                for MatchStmtNode(tm0, tm1, _) in self.match_stmt_node.iter_all_2(tm2) {
                    self.match_stmt_contains_ctor_defined_6(delta, tm0, tm1, tm2, tm3);
                }
            }
        }
    }

    #[allow(unused_variables)]
    fn match_stmt_contains_ctor_defined_6(
        &self,
        delta: &mut ModelDelta,
        tm0: StmtNode,
        tm1: TermNode,
        tm2: MatchCaseListNode,
        tm3: CtorDeclNode,
    ) {
        for _ in [()] {
            let exists_already = self
                .match_stmt_contains_ctor
                .iter_all_0_1(tm0, tm3)
                .next()
                .is_some();
            if !exists_already {
                delta
                    .new_match_stmt_contains_ctor
                    .push(MatchStmtContainsCtor(tm0, tm3));
            }
        }
    }

    fn drop_dirt(&mut self) {
        self.empty_join_is_dirty = false;

        self.absurd.drop_dirt();
        self.type_decl.drop_dirt();
        self.arg_decl_node_name.drop_dirt();
        self.arg_decl_node_type.drop_dirt();
        self.nil_arg_decl_list_node.drop_dirt();
        self.cons_arg_decl_list_node.drop_dirt();
        self.pred_decl.drop_dirt();
        self.func_decl.drop_dirt();
        self.ctor_decl.drop_dirt();
        self.nil_ctor_decl_list_node.drop_dirt();
        self.cons_ctor_decl_list_node.drop_dirt();
        self.enum_decl.drop_dirt();
        self.nil_term_list_node.drop_dirt();
        self.cons_term_list_node.drop_dirt();
        self.none_term_node.drop_dirt();
        self.some_term_node.drop_dirt();
        self.var_term_node.drop_dirt();
        self.wildcard_term_node.drop_dirt();
        self.app_term_node.drop_dirt();
        self.match_case.drop_dirt();
        self.nil_match_case_list_node.drop_dirt();
        self.cons_match_case_list_node.drop_dirt();
        self.equal_if_atom_node.drop_dirt();
        self.defined_if_atom_node.drop_dirt();
        self.pred_if_atom_node.drop_dirt();
        self.var_if_atom_node.drop_dirt();
        self.equal_then_atom_node.drop_dirt();
        self.defined_then_atom_node.drop_dirt();
        self.pred_then_atom_node.drop_dirt();
        self.if_stmt_node.drop_dirt();
        self.then_stmt_node.drop_dirt();
        self.branch_stmt_node.drop_dirt();
        self.match_stmt_node.drop_dirt();
        self.nil_stmt_list_node.drop_dirt();
        self.cons_stmt_list_node.drop_dirt();
        self.nil_stmt_block_list_node.drop_dirt();
        self.cons_stmt_block_list_node.drop_dirt();
        self.rule_decl.drop_dirt();
        self.decl_node_type.drop_dirt();
        self.decl_node_pred.drop_dirt();
        self.decl_node_func.drop_dirt();
        self.decl_node_rule.drop_dirt();
        self.decl_node_enum.drop_dirt();
        self.nil_decl_list_node.drop_dirt();
        self.cons_decl_list_node.drop_dirt();
        self.decls_module_node.drop_dirt();
        self.var_in_scope.drop_dirt();
        self.scope_extension.drop_dirt();
        self.scope_single_child.drop_dirt();
        self.scope_extension_siblings.drop_dirt();
        self.rel_app.drop_dirt();
        self.el_type.drop_dirt();
        self.el_types.drop_dirt();
        self.constrained_el.drop_dirt();
        self.constrained_els.drop_dirt();
        self.in_ker.drop_dirt();
        self.el_in_img.drop_dirt();
        self.rel_tuple_in_img.drop_dirt();
        self.defined_symbol.drop_dirt();
        self.should_be_symbol.drop_dirt();
        self.should_be_symbol_2.drop_dirt();
        self.pred_arg_num_should_match.drop_dirt();
        self.func_arg_num_should_match.drop_dirt();
        self.cfg_edge.drop_dirt();
        self.cfg_edge_stmts_stmt.drop_dirt();
        self.cfg_edge_stmt_stmts.drop_dirt();
        self.cfg_edge_fork.drop_dirt();
        self.cfg_edge_join.drop_dirt();
        self.before_stmt_structure.drop_dirt();
        self.stmt_morphism.drop_dirt();
        self.if_morphism.drop_dirt();
        self.surj_then_morphism.drop_dirt();
        self.non_surj_then_morphism.drop_dirt();
        self.noop_morphism.drop_dirt();
        self.stmt_structure.drop_dirt();
        self.if_atom_structure.drop_dirt();
        self.then_atom_structure.drop_dirt();
        self.term_structure.drop_dirt();
        self.terms_structure.drop_dirt();
        self.opt_term_structure.drop_dirt();
        self.term_should_be_epic_ok.drop_dirt();
        self.terms_should_be_epic_ok.drop_dirt();
        self.el_should_be_surjective_ok.drop_dirt();
        self.el_is_surjective_ok.drop_dirt();
        self.should_be_obtained_by_ctor.drop_dirt();
        self.is_given_by_ctor.drop_dirt();
        self.function_can_be_made_defined.drop_dirt();
        self.case_pattern_is_variable.drop_dirt();
        self.case_pattern_is_wildcard.drop_dirt();
        self.is_pattern_ctor_arg.drop_dirt();
        self.are_pattern_ctor_args.drop_dirt();
        self.pattern_ctor_arg_is_app.drop_dirt();
        self.pattern_ctor_arg_var_is_not_fresh.drop_dirt();
        self.cases_contain_ctor.drop_dirt();
        self.match_stmt_contains_ctor_of_enum.drop_dirt();
        self.match_stmt_should_contain_ctor.drop_dirt();
        self.match_stmt_contains_ctor.drop_dirt();
        self.real_virt_ident.drop_dirt();
        self.virt_real_ident.drop_dirt();
        self.var.drop_dirt();
        self.rule_name.drop_dirt();
        self.type_decl_node_loc.drop_dirt();
        self.arg_decl_node_loc.drop_dirt();
        self.arg_decl_list_node_loc.drop_dirt();
        self.pred_decl_node_loc.drop_dirt();
        self.func_decl_node_loc.drop_dirt();
        self.ctor_decl_node_loc.drop_dirt();
        self.enum_decl_node_loc.drop_dirt();
        self.term_node_loc.drop_dirt();
        self.term_list_node_loc.drop_dirt();
        self.match_case_node_loc.drop_dirt();
        self.opt_term_node_loc.drop_dirt();
        self.if_atom_node_loc.drop_dirt();
        self.then_atom_node_loc.drop_dirt();
        self.stmt_node_loc.drop_dirt();
        self.stmt_list_node_loc.drop_dirt();
        self.rule_decl_node_loc.drop_dirt();
        self.decl_node_loc.drop_dirt();
        self.decl_list_node_loc.drop_dirt();
        self.module_node_loc.drop_dirt();
        self.rule_descendant_rule.drop_dirt();
        self.rule_descendant_term.drop_dirt();
        self.rule_descendant_term_list.drop_dirt();
        self.rule_descendant_opt_term.drop_dirt();
        self.rule_descendant_if_atom.drop_dirt();
        self.rule_descendant_then_atom.drop_dirt();
        self.rule_descendant_match_case.drop_dirt();
        self.rule_descendant_match_case_list.drop_dirt();
        self.rule_descendant_stmt.drop_dirt();
        self.rule_descendant_stmt_list.drop_dirt();
        self.rule_descendant_stmt_block_list.drop_dirt();
        self.entry_scope.drop_dirt();
        self.exit_scope.drop_dirt();
        self.ctor_enum.drop_dirt();
        self.ctors_enum.drop_dirt();
        self.cases_discriminee.drop_dirt();
        self.case_discriminee.drop_dirt();
        self.desugared_case_equality_atom.drop_dirt();
        self.desugared_case_equality_stmt.drop_dirt();
        self.desugared_case_block.drop_dirt();
        self.desugared_case_block_list.drop_dirt();
        self.nil_type_list.drop_dirt();
        self.cons_type_list.drop_dirt();
        self.snoc_type_list.drop_dirt();
        self.semantic_type.drop_dirt();
        self.semantic_arg_types.drop_dirt();
        self.semantic_pred.drop_dirt();
        self.pred_arity.drop_dirt();
        self.semantic_func.drop_dirt();
        self.domain.drop_dirt();
        self.codomain.drop_dirt();
        self.pred_rel.drop_dirt();
        self.func_rel.drop_dirt();
        self.arity.drop_dirt();
        self.dom.drop_dirt();
        self.cod.drop_dirt();
        self.nil_el_list.drop_dirt();
        self.cons_el_list.drop_dirt();
        self.snoc_el_list.drop_dirt();
        self.el_structure.drop_dirt();
        self.els_structure.drop_dirt();
        self.func_app.drop_dirt();
        self.map_el.drop_dirt();
        self.map_els.drop_dirt();
        self.type_symbol.drop_dirt();
        self.pred_symbol.drop_dirt();
        self.func_symbol.drop_dirt();
        self.rule_symbol.drop_dirt();
        self.enum_symbol.drop_dirt();
        self.ctor_symbol.drop_dirt();
        self.zero.drop_dirt();
        self.succ.drop_dirt();
        self.type_list_len.drop_dirt();
        self.term_list_len.drop_dirt();
        self.before_rule_structure.drop_dirt();
        self.if_atom_morphism.drop_dirt();
        self.then_atom_morphism.drop_dirt();
        self.branch_stmt_morphism.drop_dirt();
        self.match_stmt_morphism.drop_dirt();
        self.semantic_name.drop_dirt();
        self.semantic_el.drop_dirt();
        self.semantic_els.drop_dirt();
        self.wildcard_name.drop_dirt();
        self.match_case_pattern_ctor.drop_dirt();
        self.cases_determined_enum.drop_dirt();

        self.ident_dirty.clear();
        self.virt_ident_dirty.clear();
        self.type_decl_node_dirty.clear();
        self.arg_decl_node_dirty.clear();
        self.arg_decl_list_node_dirty.clear();
        self.pred_decl_node_dirty.clear();
        self.func_decl_node_dirty.clear();
        self.ctor_decl_node_dirty.clear();
        self.ctor_decl_list_node_dirty.clear();
        self.enum_decl_node_dirty.clear();
        self.term_node_dirty.clear();
        self.term_list_node_dirty.clear();
        self.opt_term_node_dirty.clear();
        self.match_case_node_dirty.clear();
        self.stmt_list_node_dirty.clear();
        self.match_case_list_node_dirty.clear();
        self.if_atom_node_dirty.clear();
        self.then_atom_node_dirty.clear();
        self.stmt_node_dirty.clear();
        self.stmt_block_list_node_dirty.clear();
        self.rule_decl_node_dirty.clear();
        self.decl_node_dirty.clear();
        self.decl_list_node_dirty.clear();
        self.module_node_dirty.clear();
        self.loc_dirty.clear();
        self.rule_descendant_node_dirty.clear();
        self.scope_dirty.clear();
        self.type_dirty.clear();
        self.type_list_dirty.clear();
        self.pred_dirty.clear();
        self.func_dirty.clear();
        self.rel_dirty.clear();
        self.structure_dirty.clear();
        self.el_dirty.clear();
        self.el_list_dirty.clear();
        self.el_name_dirty.clear();
        self.morphism_dirty.clear();
        self.symbol_kind_dirty.clear();
        self.nat_dirty.clear();
    }
}
impl fmt::Display for Eqlog {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.ident_equalities
            .class_table()
            .with(Header("Ident"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.virt_ident_equalities
            .class_table()
            .with(Header("VirtIdent"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.type_decl_node_equalities
            .class_table()
            .with(Header("TypeDeclNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.arg_decl_node_equalities
            .class_table()
            .with(Header("ArgDeclNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.arg_decl_list_node_equalities
            .class_table()
            .with(Header("ArgDeclListNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.pred_decl_node_equalities
            .class_table()
            .with(Header("PredDeclNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.func_decl_node_equalities
            .class_table()
            .with(Header("FuncDeclNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.ctor_decl_node_equalities
            .class_table()
            .with(Header("CtorDeclNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.ctor_decl_list_node_equalities
            .class_table()
            .with(Header("CtorDeclListNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.enum_decl_node_equalities
            .class_table()
            .with(Header("EnumDeclNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.term_node_equalities
            .class_table()
            .with(Header("TermNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.term_list_node_equalities
            .class_table()
            .with(Header("TermListNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.opt_term_node_equalities
            .class_table()
            .with(Header("OptTermNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.match_case_node_equalities
            .class_table()
            .with(Header("MatchCaseNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.stmt_list_node_equalities
            .class_table()
            .with(Header("StmtListNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.match_case_list_node_equalities
            .class_table()
            .with(Header("MatchCaseListNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.if_atom_node_equalities
            .class_table()
            .with(Header("IfAtomNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.then_atom_node_equalities
            .class_table()
            .with(Header("ThenAtomNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.stmt_node_equalities
            .class_table()
            .with(Header("StmtNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.stmt_block_list_node_equalities
            .class_table()
            .with(Header("StmtBlockListNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.rule_decl_node_equalities
            .class_table()
            .with(Header("RuleDeclNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.decl_node_equalities
            .class_table()
            .with(Header("DeclNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.decl_list_node_equalities
            .class_table()
            .with(Header("DeclListNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.module_node_equalities
            .class_table()
            .with(Header("ModuleNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.loc_equalities
            .class_table()
            .with(Header("Loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.rule_descendant_node_equalities
            .class_table()
            .with(Header("RuleDescendantNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.scope_equalities
            .class_table()
            .with(Header("Scope"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.type_equalities
            .class_table()
            .with(Header("Type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.type_list_equalities
            .class_table()
            .with(Header("TypeList"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.pred_equalities
            .class_table()
            .with(Header("Pred"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.func_equalities
            .class_table()
            .with(Header("Func"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.rel_equalities
            .class_table()
            .with(Header("Rel"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.structure_equalities
            .class_table()
            .with(Header("Structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.el_equalities
            .class_table()
            .with(Header("El"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.el_list_equalities
            .class_table()
            .with(Header("ElList"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.el_name_equalities
            .class_table()
            .with(Header("ElName"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.morphism_equalities
            .class_table()
            .with(Header("Morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.symbol_kind_equalities
            .class_table()
            .with(Header("SymbolKind"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.nat_equalities
            .class_table()
            .with(Header("Nat"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.absurd.fmt(f)?;
        self.type_decl.fmt(f)?;
        self.arg_decl_node_name.fmt(f)?;
        self.arg_decl_node_type.fmt(f)?;
        self.nil_arg_decl_list_node.fmt(f)?;
        self.cons_arg_decl_list_node.fmt(f)?;
        self.pred_decl.fmt(f)?;
        self.func_decl.fmt(f)?;
        self.ctor_decl.fmt(f)?;
        self.nil_ctor_decl_list_node.fmt(f)?;
        self.cons_ctor_decl_list_node.fmt(f)?;
        self.enum_decl.fmt(f)?;
        self.nil_term_list_node.fmt(f)?;
        self.cons_term_list_node.fmt(f)?;
        self.none_term_node.fmt(f)?;
        self.some_term_node.fmt(f)?;
        self.var_term_node.fmt(f)?;
        self.wildcard_term_node.fmt(f)?;
        self.app_term_node.fmt(f)?;
        self.match_case.fmt(f)?;
        self.nil_match_case_list_node.fmt(f)?;
        self.cons_match_case_list_node.fmt(f)?;
        self.equal_if_atom_node.fmt(f)?;
        self.defined_if_atom_node.fmt(f)?;
        self.pred_if_atom_node.fmt(f)?;
        self.var_if_atom_node.fmt(f)?;
        self.equal_then_atom_node.fmt(f)?;
        self.defined_then_atom_node.fmt(f)?;
        self.pred_then_atom_node.fmt(f)?;
        self.if_stmt_node.fmt(f)?;
        self.then_stmt_node.fmt(f)?;
        self.branch_stmt_node.fmt(f)?;
        self.match_stmt_node.fmt(f)?;
        self.nil_stmt_list_node.fmt(f)?;
        self.cons_stmt_list_node.fmt(f)?;
        self.nil_stmt_block_list_node.fmt(f)?;
        self.cons_stmt_block_list_node.fmt(f)?;
        self.rule_decl.fmt(f)?;
        self.decl_node_type.fmt(f)?;
        self.decl_node_pred.fmt(f)?;
        self.decl_node_func.fmt(f)?;
        self.decl_node_rule.fmt(f)?;
        self.decl_node_enum.fmt(f)?;
        self.nil_decl_list_node.fmt(f)?;
        self.cons_decl_list_node.fmt(f)?;
        self.decls_module_node.fmt(f)?;
        self.var_in_scope.fmt(f)?;
        self.scope_extension.fmt(f)?;
        self.scope_single_child.fmt(f)?;
        self.scope_extension_siblings.fmt(f)?;
        self.rel_app.fmt(f)?;
        self.el_type.fmt(f)?;
        self.el_types.fmt(f)?;
        self.constrained_el.fmt(f)?;
        self.constrained_els.fmt(f)?;
        self.in_ker.fmt(f)?;
        self.el_in_img.fmt(f)?;
        self.rel_tuple_in_img.fmt(f)?;
        self.defined_symbol.fmt(f)?;
        self.should_be_symbol.fmt(f)?;
        self.should_be_symbol_2.fmt(f)?;
        self.pred_arg_num_should_match.fmt(f)?;
        self.func_arg_num_should_match.fmt(f)?;
        self.cfg_edge.fmt(f)?;
        self.cfg_edge_stmts_stmt.fmt(f)?;
        self.cfg_edge_stmt_stmts.fmt(f)?;
        self.cfg_edge_fork.fmt(f)?;
        self.cfg_edge_join.fmt(f)?;
        self.before_stmt_structure.fmt(f)?;
        self.stmt_morphism.fmt(f)?;
        self.if_morphism.fmt(f)?;
        self.surj_then_morphism.fmt(f)?;
        self.non_surj_then_morphism.fmt(f)?;
        self.noop_morphism.fmt(f)?;
        self.stmt_structure.fmt(f)?;
        self.if_atom_structure.fmt(f)?;
        self.then_atom_structure.fmt(f)?;
        self.term_structure.fmt(f)?;
        self.terms_structure.fmt(f)?;
        self.opt_term_structure.fmt(f)?;
        self.term_should_be_epic_ok.fmt(f)?;
        self.terms_should_be_epic_ok.fmt(f)?;
        self.el_should_be_surjective_ok.fmt(f)?;
        self.el_is_surjective_ok.fmt(f)?;
        self.should_be_obtained_by_ctor.fmt(f)?;
        self.is_given_by_ctor.fmt(f)?;
        self.function_can_be_made_defined.fmt(f)?;
        self.case_pattern_is_variable.fmt(f)?;
        self.case_pattern_is_wildcard.fmt(f)?;
        self.is_pattern_ctor_arg.fmt(f)?;
        self.are_pattern_ctor_args.fmt(f)?;
        self.pattern_ctor_arg_is_app.fmt(f)?;
        self.pattern_ctor_arg_var_is_not_fresh.fmt(f)?;
        self.cases_contain_ctor.fmt(f)?;
        self.match_stmt_contains_ctor_of_enum.fmt(f)?;
        self.match_stmt_should_contain_ctor.fmt(f)?;
        self.match_stmt_contains_ctor.fmt(f)?;
        self.real_virt_ident.fmt(f)?;
        self.virt_real_ident.fmt(f)?;
        self.var.fmt(f)?;
        self.rule_name.fmt(f)?;
        self.type_decl_node_loc.fmt(f)?;
        self.arg_decl_node_loc.fmt(f)?;
        self.arg_decl_list_node_loc.fmt(f)?;
        self.pred_decl_node_loc.fmt(f)?;
        self.func_decl_node_loc.fmt(f)?;
        self.ctor_decl_node_loc.fmt(f)?;
        self.enum_decl_node_loc.fmt(f)?;
        self.term_node_loc.fmt(f)?;
        self.term_list_node_loc.fmt(f)?;
        self.match_case_node_loc.fmt(f)?;
        self.opt_term_node_loc.fmt(f)?;
        self.if_atom_node_loc.fmt(f)?;
        self.then_atom_node_loc.fmt(f)?;
        self.stmt_node_loc.fmt(f)?;
        self.stmt_list_node_loc.fmt(f)?;
        self.rule_decl_node_loc.fmt(f)?;
        self.decl_node_loc.fmt(f)?;
        self.decl_list_node_loc.fmt(f)?;
        self.module_node_loc.fmt(f)?;
        self.rule_descendant_rule.fmt(f)?;
        self.rule_descendant_term.fmt(f)?;
        self.rule_descendant_term_list.fmt(f)?;
        self.rule_descendant_opt_term.fmt(f)?;
        self.rule_descendant_if_atom.fmt(f)?;
        self.rule_descendant_then_atom.fmt(f)?;
        self.rule_descendant_match_case.fmt(f)?;
        self.rule_descendant_match_case_list.fmt(f)?;
        self.rule_descendant_stmt.fmt(f)?;
        self.rule_descendant_stmt_list.fmt(f)?;
        self.rule_descendant_stmt_block_list.fmt(f)?;
        self.entry_scope.fmt(f)?;
        self.exit_scope.fmt(f)?;
        self.ctor_enum.fmt(f)?;
        self.ctors_enum.fmt(f)?;
        self.cases_discriminee.fmt(f)?;
        self.case_discriminee.fmt(f)?;
        self.desugared_case_equality_atom.fmt(f)?;
        self.desugared_case_equality_stmt.fmt(f)?;
        self.desugared_case_block.fmt(f)?;
        self.desugared_case_block_list.fmt(f)?;
        self.nil_type_list.fmt(f)?;
        self.cons_type_list.fmt(f)?;
        self.snoc_type_list.fmt(f)?;
        self.semantic_type.fmt(f)?;
        self.semantic_arg_types.fmt(f)?;
        self.semantic_pred.fmt(f)?;
        self.pred_arity.fmt(f)?;
        self.semantic_func.fmt(f)?;
        self.domain.fmt(f)?;
        self.codomain.fmt(f)?;
        self.pred_rel.fmt(f)?;
        self.func_rel.fmt(f)?;
        self.arity.fmt(f)?;
        self.dom.fmt(f)?;
        self.cod.fmt(f)?;
        self.nil_el_list.fmt(f)?;
        self.cons_el_list.fmt(f)?;
        self.snoc_el_list.fmt(f)?;
        self.el_structure.fmt(f)?;
        self.els_structure.fmt(f)?;
        self.func_app.fmt(f)?;
        self.map_el.fmt(f)?;
        self.map_els.fmt(f)?;
        self.type_symbol.fmt(f)?;
        self.pred_symbol.fmt(f)?;
        self.func_symbol.fmt(f)?;
        self.rule_symbol.fmt(f)?;
        self.enum_symbol.fmt(f)?;
        self.ctor_symbol.fmt(f)?;
        self.zero.fmt(f)?;
        self.succ.fmt(f)?;
        self.type_list_len.fmt(f)?;
        self.term_list_len.fmt(f)?;
        self.before_rule_structure.fmt(f)?;
        self.if_atom_morphism.fmt(f)?;
        self.then_atom_morphism.fmt(f)?;
        self.branch_stmt_morphism.fmt(f)?;
        self.match_stmt_morphism.fmt(f)?;
        self.semantic_name.fmt(f)?;
        self.semantic_el.fmt(f)?;
        self.semantic_els.fmt(f)?;
        self.wildcard_name.fmt(f)?;
        self.match_case_pattern_ctor.fmt(f)?;
        self.cases_determined_enum.fmt(f)?;
        Ok(())
    }
}
